[
  {
    "file_id": "F1",
    "path": "aspectj-master/weaver/ajsrc/org/aspectj/weaver/BcelApiRules.aj",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC),\n *               2003 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Xerox/PARC      initial implementation\n *     AMC 01.20.2003  extended to support new AspectJ 1.1 options,\n * \t\t\t\t       bugzilla #29769\n * ******************************************************************/\n\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.*;\nimport org.aspectj.weaver.bcel.*;\nimport org.apache.bcel.generic.*;\n\n/**\n * Enforces the correct use of BCEL APIs.\n */\npublic aspect BcelApiRules {\n\n\t/**\n\t * The Utility method needs to be used instead of the BCEL method doue to a bug\n\t * in the implementation of Instruction.copy()\n\t */\n\tdeclare error:\n\t\tcall(* Instruction.copy()) && within(org.aspectj.weaver..*)\n\t\t\t && !withincode(* Utility.copyInstruction(Instruction)):\n\t\t\"use Utility.copyInstruction to work-around bug in Select.copy()\";\n\n\n}\n",
    "size": 1235
  },
  {
    "file_id": "F2",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/IClassFileProvider.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2004 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport java.util.Iterator;\n\nimport org.aspectj.weaver.bcel.UnwovenClassFile;\n\n/**\n * @author colyer\n *\n *         Clients implementing the IClassFileProvider can have a set of class files under their control woven by a weaver, by\n *         calling the weave(IClassFileProvider source) method. The contract is that a call to getRequestor().acceptResult() is\n *         providing a result for the class file most recently returned from the getClassFileIterator().\n */\npublic interface IClassFileProvider {\n\n\t/**\n\t * Answer an iterator that can be used to iterate over a set of UnwovenClassFiles to be woven. During a weave, this method may\n\t * be called multiple times.\n\t *\n\t * @return iterator over UnwovenClassFiles.\n\t */\n\tIterator<UnwovenClassFile> getClassFileIterator();\n\n\t/**\n\t * The client to which the woven results should be returned.\n\t */\n\tIWeaveRequestor getRequestor();\n\n\t/**\n\t * @return true if weaver should only do some internal munging as the one needed for @AspectJ aspectOf methods creation\n\t */\n\tboolean isApplyAtAspectJMungersOnly();\n\n}\n",
    "size": 1637
  },
  {
    "file_id": "F3",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/AnnotationAccessFieldVar.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Andy Clement     initial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.util.List;\n\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.classfile.annotation.ElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.EnumElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.NameValuePair;\nimport org.aspectj.apache.bcel.classfile.annotation.SimpleElementValue;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.UnresolvedType;\n\n/**\n * An AnnotationAccessVar represents access to a particular annotation, whilst an AnnotationAccessFieldVar represents access to a\n * specific field of that annotation.\n *\n * @author Andy Clement\n */\nclass AnnotationAccessFieldVar extends BcelVar {\n\n\tprivate AnnotationAccessVar annoAccessor;\n\tprivate ResolvedType annoFieldOfInterest;\n\tprivate String name;\n\tprivate int elementValueType;\n\n\tpublic AnnotationAccessFieldVar(AnnotationAccessVar aav, ResolvedType annoFieldOfInterest, String name) {\n\t\tsuper(annoFieldOfInterest, 0);\n\t\tthis.annoAccessor = aav;\n\t\tthis.name = name;\n\t\tString sig = annoFieldOfInterest.getSignature();\n\t\tif (sig.length() == 1) {\n\t\t\tswitch (sig.charAt(0)) {\n\t\t\tcase 'I':\n\t\t\t\telementValueType = ElementValue.PRIMITIVE_INT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalStateException(sig);\n\t\t\t}\n\t\t} else if (sig.equals(\"Ljava/lang/String;\")) {\n\t\t\telementValueType = ElementValue.STRING;\n\t\t} else if (annoFieldOfInterest.isEnum()) {\n\t\t\telementValueType = ElementValue.ENUM_CONSTANT;\n\t\t} else {\n\t\t\tthrow new IllegalStateException(sig);\n\t\t}\n\t\tthis.annoFieldOfInterest = annoFieldOfInterest;\n\t}\n\n\t@Override\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\n\t\t// Only possible to do annotation field value extraction at MethodExecution\n\t\tif (annoAccessor.getKind() != Shadow.MethodExecution) {\n\t\t\treturn;\n\t\t}\n\t\tString annotationOfInterestSignature = annoAccessor.getType().getSignature();\n\t\t// So we have an entity that has an annotation on and within it is the value we want\n\t\tMember holder = annoAccessor.getMember();\n\t\tAnnotationAJ[] annos = holder.getAnnotations();\n\t\tfor (AnnotationAJ anno : annos) {\n\t\t\tAnnotationGen annotation = ((BcelAnnotation) anno).getBcelAnnotation();\n\t\t\tboolean foundValueInAnnotationUsage = false;\n\t\t\tif (annotation.getTypeSignature().equals(annotationOfInterestSignature)) {\n\t\t\t\tResolvedMember[] annotationFields = toType.getWorld()\n\t\t\t\t\t\t.resolve(UnresolvedType.forSignature(annotation.getTypeSignature())).getDeclaredMethods();\n\t\t\t\t// Check how many fields there are of the type we are looking for. If >1 then we'll need\n\t\t\t\t// to use the name to choose the right one\n\t\t\t\tint countOfType = 0;\n\t\t\t\tfor (ResolvedMember annotationField : annotationFields) {\n\t\t\t\t\tif (annotationField.getType().equals(annoFieldOfInterest)) {\n\t\t\t\t\t\tcountOfType++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// this block deals with an annotation that has actual values (i.e. not falling back to default values)\n\t\t\t\tList<NameValuePair> nvps = annotation.getValues();\n\t\t\t\tfor (NameValuePair nvp : nvps) {\n\t\t\t\t\t// If multiple of the same type, match by name\n\t\t\t\t\tif (countOfType > 1) {\n\t\t\t\t\t\tif (!nvp.getNameString().equals(name)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tElementValue o = nvp.getValue();\n\t\t\t\t\tif (o.getElementValueType() != elementValueType) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (o instanceof EnumElementValue) {\n\t\t\t\t\t\tEnumElementValue v = (EnumElementValue) o;\n\t\t\t\t\t\tString s = v.getEnumTypeString();\n\t\t\t\t\t\tResolvedType rt = toType.getWorld().resolve(UnresolvedType.forSignature(s));\n\t\t\t\t\t\tif (rt.equals(toType)) {\n\t\t\t\t\t\t\til.append(fact.createGetStatic(rt.getName(), v.getEnumValueString(), Type.getType(rt.getSignature())));\n\t\t\t\t\t\t\tfoundValueInAnnotationUsage = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (o instanceof SimpleElementValue) {\n\t\t\t\t\t\tSimpleElementValue v = (SimpleElementValue) o;\n\t\t\t\t\t\tswitch (v.getElementValueType()) {\n\t\t\t\t\t\tcase ElementValue.PRIMITIVE_INT:\n\t\t\t\t\t\t\til.append(fact.createConstant(v.getValueInt()));\n\t\t\t\t\t\t\tfoundValueInAnnotationUsage = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase ElementValue.STRING:\n\t\t\t\t\t\t\til.append(fact.createConstant(v.getValueString()));\n\t\t\t\t\t\t\tfoundValueInAnnotationUsage = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"NYI: Unsupported annotation value binding for \" + o);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (foundValueInAnnotationUsage) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// this block deals with default values\n\t\t\t\tif (!foundValueInAnnotationUsage) {\n\t\t\t\t\tfor (ResolvedMember annotationField : annotationFields) {\n\t\t\t\t\t\tif (countOfType > 1) {\n\t\t\t\t\t\t\tif (!annotationField.getName().equals(name)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!annotationField.getType().getSignature().equals(annoFieldOfInterest.getSignature())) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (annotationField.getType().getSignature().equals(\"I\")) {\n\t\t\t\t\t\t\tint ivalue = Integer.parseInt(annotationField.getAnnotationDefaultValue());\n\t\t\t\t\t\t\til.append(fact.createConstant(ivalue));\n\t\t\t\t\t\t\tfoundValueInAnnotationUsage = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (annotationField.getType().getSignature().equals(\"Ljava/lang/String;\")) {\n\t\t\t\t\t\t\tString svalue = annotationField.getAnnotationDefaultValue();\n\t\t\t\t\t\t\til.append(fact.createConstant(svalue));\n\t\t\t\t\t\t\tfoundValueInAnnotationUsage = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString dvalue = annotationField.getAnnotationDefaultValue();\n\t\t\t\t\t\t\t// form will be LBLAHBLAHBLAH;X where X is the field within X\n\t\t\t\t\t\t\tString typename = dvalue.substring(0, dvalue.lastIndexOf(';') + 1);\n\t\t\t\t\t\t\tString field = dvalue.substring(dvalue.lastIndexOf(';') + 1);\n\t\t\t\t\t\t\tResolvedType rt = toType.getWorld().resolve(UnresolvedType.forSignature(typename));\n\t\t\t\t\t\t\til.append(fact.createGetStatic(rt.getName(), field, Type.getType(rt.getSignature())));\n\t\t\t\t\t\t\tfoundValueInAnnotationUsage = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (foundValueInAnnotationUsage) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\n\t\t// Only possible to do annotation field value extraction at\n\t\t// MethodExecution\n\t\tif (annoAccessor.getKind() != Shadow.MethodExecution) {\n\t\t\treturn;\n\t\t}\n\t\tappendLoadAndConvert(il, fact, annoFieldOfInterest);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn super.toString();\n\t}\n}\n",
    "size": 7079
  },
  {
    "file_id": "F4",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/AnnotationAccessVar.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005-2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Andy Clement     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.Field;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionBranch;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.Shadow.Kind;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.ast.Var;\n\n/**\n * Represents access to an annotation on an element, relating to some kinded pointcut. Depending on the kind of pointcut the element\n * might be a field or a method and the code generators in here can retrieve the annotation from the element.\n */\npublic class AnnotationAccessVar extends BcelVar {\n\n\tprivate BcelShadow shadow;\n\tprivate Kind kind; // What kind of shadow are we at?\n\tprivate UnresolvedType containingType; // The type upon which we want to ask for 'member'\n\tprivate Member member; // Holds the member that has the annotations (for method/field join points)\n\tprivate boolean isWithin; // implies @within() or @withincode(). If false, that implies @annotation()\n\n\tpublic AnnotationAccessVar(BcelShadow shadow, Kind kind, ResolvedType annotationType, UnresolvedType theTargetIsStoredHere,\n\t\t\tMember sig, boolean isWithin) {\n\t\tsuper(annotationType, 0);\n\t\tthis.shadow = shadow;\n\t\tthis.kind = kind;\n\t\tthis.containingType = theTargetIsStoredHere;\n\t\tthis.member = sig;\n\t\tthis.isWithin = isWithin;\n\t}\n\n\tpublic Kind getKind() {\n\t\treturn kind;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"AnnotationAccessVar(\" + getType() + \")\";\n\t}\n\n\t@Override\n\tpublic Instruction createLoad(InstructionFactory fact) {\n\t\tthrow new IllegalStateException(\"unimplemented\");\n\t}\n\n\t@Override\n\tpublic Instruction createStore(InstructionFactory fact) {\n\t\tthrow new IllegalStateException(\"unimplemented\");\n\t}\n\n\t@Override\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\n\t\tthrow new IllegalStateException(\"unimplemented\");\n\t}\n\n\t@Override\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\n\t\til.append(createLoadInstructions(getType(), fact));\n\t}\n\n\t@Override\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\n\t\til.append(createLoadInstructions(toType, fact));\n\t}\n\n\t@Override\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\n\t\til.insert(createLoadInstructions(getType(), fact));\n\t}\n\n\tprivate InstructionList createLoadInstructions(ResolvedType toType, InstructionFactory fact) {\n\n\t\tInstructionList il = new InstructionList();\n\n\t\tType jlClass = BcelWorld.makeBcelType(UnresolvedType.JL_CLASS);\n\t\tType jlString = BcelWorld.makeBcelType(UnresolvedType.JL_STRING);\n\t\tType jlClassArray = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_CLASS_ARRAY);\n\t\tType jlaAnnotation = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_ANNOTATION);\n\n\t\tInstruction pushConstant = fact.createConstant(new ObjectType(toType.getName()));\n\n\t\tif (kind == Shadow.MethodCall || kind == Shadow.MethodExecution || kind == Shadow.PreInitialization\n\t\t\t\t|| kind == Shadow.Initialization || kind == Shadow.ConstructorCall || kind == Shadow.ConstructorExecution\n\t\t\t\t|| kind == Shadow.AdviceExecution ||\n\t\t\t\t// annotations for fieldset/fieldget when an ITD is involved are stored against a METHOD\n\t\t\t\t((kind == Shadow.FieldGet || kind == Shadow.FieldSet) && member.getKind() == Member.METHOD)) {\n\n\t\t\tType jlrMethod = BcelWorld.makeBcelType(UnresolvedType.forSignature(\"Ljava/lang/reflect/Method;\"));\n\t\t\tType jlAnnotation = BcelWorld.makeBcelType(UnresolvedType.forSignature(\"Ljava/lang/annotation/Annotation;\"));\n\t\t\tType[] paramTypes = BcelWorld.makeBcelTypes(member.getParameterTypes());\n\n\t\t\t// il.append(fact.createConstant(BcelWorld.makeBcelType(containingType)));\n\n\t\t\tif (kind == Shadow.MethodCall\n\t\t\t\t\t|| kind == Shadow.MethodExecution\n\t\t\t\t\t|| kind == Shadow.AdviceExecution\n\t\t\t\t\t||\n\t\t\t\t\t// annotations for fieldset/fieldget when an ITD is involved are stored against a METHOD\n\t\t\t\t\t((kind == Shadow.FieldGet || kind == Shadow.FieldSet) && member.getKind() == Member.METHOD)\n\t\t\t\t\t|| ((kind == Shadow.ConstructorCall || kind == Shadow.ConstructorExecution) && member.getKind() == Member.METHOD)) {\n\n\t\t\t\t// Need to look at the cached annotation before going to fetch it again\n\t\t\t\tField annotationCachingField = shadow.getEnclosingClass().getAnnotationCachingField(shadow, toType, isWithin);\n\n\t\t\t\t// Basic idea here is to check if the cached field is null, if it is then initialize it, otherwise use it\n\t\t\t\til.append(fact.createGetStatic(shadow.getEnclosingClass().getName(), annotationCachingField.getName(), jlAnnotation));\n\t\t\t\til.append(InstructionConstants.DUP);\n\t\t\t\tInstructionBranch ifNonNull = InstructionFactory.createBranchInstruction(Constants.IFNONNULL, null);\n\t\t\t\til.append(ifNonNull);\n\t\t\t\til.append(InstructionConstants.POP);\n\t\t\t\til.append(fact.createConstant(BcelWorld.makeBcelType(containingType)));\n\n\t\t\t\til.append(fact.createConstant(member.getName()));\n\t\t\t\tbuildArray(il, fact, jlClass, paramTypes, 1);\n\t\t\t\t// OPTIMIZE cache result of getDeclaredMethod?\n\t\t\t\til.append(fact.createInvoke(\"java/lang/Class\", \"getDeclaredMethod\", jlrMethod,\n\t\t\t\t\t\tnew Type[] { jlString, jlClassArray }, Constants.INVOKEVIRTUAL));\n\t\t\t\til.append(pushConstant);// fact.createConstant(new ObjectType(toType.getName())));\n\t\t\t\til.append(fact.createInvoke(\"java/lang/reflect/Method\", \"getAnnotation\", jlaAnnotation, new Type[] { jlClass },\n\t\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t\t\til.append(InstructionConstants.DUP);\n\t\t\t\til.append(fact.createPutStatic(shadow.getEnclosingClass().getName(), annotationCachingField.getName(), jlAnnotation));\n\t\t\t\tInstructionHandle ifNullElse = il.append(InstructionConstants.NOP);\n\t\t\t\tifNonNull.setTarget(ifNullElse);\n\n\t\t\t} else { // init/preinit/ctor-call/ctor-exec\n\t\t\t\til.append(fact.createConstant(BcelWorld.makeBcelType(containingType)));\n\t\t\t\tbuildArray(il, fact, jlClass, paramTypes, 1);\n\t\t\t\tType jlrCtor = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_REFLECT_CONSTRUCTOR);\n\t\t\t\t// OPTIMIZE cache result of getDeclaredConstructor and getAnnotation? Might be able to use it again if someone else\n\t\t\t\t// needs the same annotations?\n\t\t\t\til.append(fact.createInvoke(\"java/lang/Class\", \"getDeclaredConstructor\", jlrCtor, new Type[] { jlClassArray },\n\t\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t\t\til.append(pushConstant);\n\t\t\t\til.append(fact.createInvoke(\"java/lang/reflect/Constructor\", \"getAnnotation\", jlaAnnotation,\n\t\t\t\t\t\tnew Type[] { jlClass }, Constants.INVOKEVIRTUAL));\n\t\t\t}\n\t\t} else if (kind == Shadow.FieldSet || kind == Shadow.FieldGet) {\n\t\t\tgenerateBytecodeToAccessAnnotationAtFieldGetSetShadow(toType, fact, il, pushConstant);\n\t\t} else if (kind == Shadow.StaticInitialization || kind == Shadow.ExceptionHandler) {\n\t\t\til.append(fact.createConstant(BcelWorld.makeBcelType(containingType)));\n\t\t\til.append(pushConstant);\n\t\t\til.append(fact.createInvoke(\"java/lang/Class\", \"getAnnotation\", jlaAnnotation, new Type[] { jlClass },\n\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Don't understand this kind \" + kind);\n\t\t}\n\t\til.append(Utility.createConversion(fact, jlaAnnotation, BcelWorld.makeBcelType(toType)));\n\t\treturn il;\n\t}\n\n\t/**\n\t * At a FieldGet or FieldSet shadow, generate the bytecode to access the annotation for that field. The annotation is cached so\n\t * the code checks that cached value before proceeding.\n\t */\n\tprivate void generateBytecodeToAccessAnnotationAtFieldGetSetShadow(ResolvedType toType, InstructionFactory fact,\n\t\t\tInstructionList il, Instruction pushConstantAnnotationType) {\n\t\tType jlClass = BcelWorld.makeBcelType(UnresolvedType.JL_CLASS);\n\t\tType jlString = BcelWorld.makeBcelType(UnresolvedType.JL_STRING);\n\t\tType jlaAnnotation = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_ANNOTATION);\n\t\tType jlrField = BcelWorld.makeBcelType(UnresolvedType.JAVA_LANG_REFLECT_FIELD);\n\n\t\tLazyClassGen shadowEnclosingClass = shadow.getEnclosingClass();\n\n\t\t// The annotation for the field of interest is cached, check cached value before fetching it\n\t\tField annotationCachingField = shadowEnclosingClass.getAnnotationCachingField(shadow, toType, isWithin);\n\t\tString annotationCachingFieldName = annotationCachingField.getName();\n\n\t\t// Basic idea here is to check if the cached field is null, if it is then initialize it, otherwise use it\n\t\til.append(fact.createGetStatic(shadowEnclosingClass.getName(), annotationCachingFieldName, jlaAnnotation));\n\t\til.appendDUP();\n\t\tInstructionBranch ifNonNull = new InstructionBranch(Constants.IFNONNULL, null);\n\t\til.append(ifNonNull);\n\t\til.appendPOP();\n\n\t\t// get the field of interest\n\t\til.append(fact.createConstant(BcelWorld.makeBcelType(containingType)));\n\t\til.append(fact.createConstant(member.getName()));\n\t\til.append(fact.createInvoke(\"java/lang/Class\", \"getDeclaredField\", jlrField, new Type[] { jlString },\n\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\til.append(pushConstantAnnotationType);\n\t\til.append(fact.createInvoke(\"java/lang/reflect/Field\", \"getAnnotation\", jlaAnnotation, new Type[] { jlClass },\n\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\til.appendDUP();\n\t\til.append(fact.createPutStatic(shadowEnclosingClass.getName(), annotationCachingFieldName, jlaAnnotation));\n\t\tInstructionHandle ifNullElse = il.appendNOP();\n\t\tifNonNull.setTarget(ifNullElse);\n\t}\n\n\tprivate void buildArray(InstructionList il, InstructionFactory fact, Type arrayElementType, Type[] arrayEntries, int dim) {\n\t\til.append(fact.createConstant(arrayEntries == null ? 0 : arrayEntries.length));\n\t\til.append(fact.createNewArray(arrayElementType, (short) dim));\n\t\tif (arrayEntries == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < arrayEntries.length; i++) {\n\t\t\til.append(InstructionFactory.createDup(1));\n\t\t\til.append(fact.createConstant(i));\n\t\t\tswitch (arrayEntries[i].getType()) {\n\t\t\tcase Constants.T_ARRAY:\n\t\t\t\til.append(fact.createConstant(new ObjectType(arrayEntries[i].getSignature()))); // FIXME should be getName() and not\n\t\t\t\t// getSignature()?\n\t\t\t\tbreak;\n\t\t\tcase Constants.T_BOOLEAN:\n\t\t\t\til.append(fact.createGetStatic(\"java/lang/Boolean\", \"TYPE\", arrayElementType));\n\t\t\t\tbreak;\n\t\t\tcase Constants.T_BYTE:\n\t\t\t\til.append(fact.createGetStatic(\"java/lang/Byte\", \"TYPE\", arrayElementType));\n\t\t\t\tbreak;\n\t\t\tcase Constants.T_CHAR:\n\t\t\t\til.append(fact.createGetStatic(\"java/lang/Character\", \"TYPE\", arrayElementType));\n\t\t\t\tbreak;\n\t\t\tcase Constants.T_INT:\n\t\t\t\til.append(fact.createGetStatic(\"java/lang/Integer\", \"TYPE\", arrayElementType));\n\t\t\t\tbreak;\n\t\t\tcase Constants.T_LONG:\n\t\t\t\til.append(fact.createGetStatic(\"java/lang/Long\", \"TYPE\", arrayElementType));\n\t\t\t\tbreak;\n\t\t\tcase Constants.T_DOUBLE:\n\t\t\t\til.append(fact.createGetStatic(\"java/lang/Double\", \"TYPE\", arrayElementType));\n\t\t\t\tbreak;\n\t\t\tcase Constants.T_FLOAT:\n\t\t\t\til.append(fact.createGetStatic(\"java/lang/Float\", \"TYPE\", arrayElementType));\n\t\t\t\tbreak;\n\t\t\tcase Constants.T_SHORT:\n\t\t\t\til.append(fact.createGetStatic(\"java/lang/Short\", \"TYPE\", arrayElementType));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\til.append(fact.createConstant(arrayEntries[i]));\n\t\t\t}\n\t\t\til.append(InstructionConstants.AASTORE);\n\t\t}\n\t}\n\n\tpublic Member getMember() {\n\t\treturn member;\n\t}\n\n\t/**\n\t * Return an object that can access a particular value of this annotation.\n\t *\n\t * @param valueType The type from the annotation that is of interest\n\t * @param formalName the formal name expressed in the pointcut, can be used to disambiguate\n\t * @return a variable that represents access to that annotation value\n\t */\n\t@Override\n\tpublic Var getAccessorForValue(ResolvedType valueType, String formalName) {\n\t\treturn new AnnotationAccessFieldVar(this, valueType, formalName);\n\t}\n}\n",
    "size": 12417
  },
  {
    "file_id": "F5",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/AspectInstanceVar.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2011 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Andy Clement - SpringSource/vmware\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.weaver.ResolvedType;\n\n/**\n * Used to represent a variable reference to an aspect instance. This is used to support the if pointcut usage of\n * 'thisAspectInstance'. This variable does not have a slot, instead on requesting a reference we call aspectOf() on the aspect in\n * question to retrieve it. For now it only works with singleton aspects.\n */\npublic class AspectInstanceVar extends BcelVar {\n\n\tpublic AspectInstanceVar(ResolvedType type) {\n\t\tsuper(type, -1);\n\t}\n\n\t// fact is used in the subtypes\n\tpublic Instruction createLoad(InstructionFactory fact) {\n\n\t\tthrow new IllegalStateException();\n\t\t// return InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), slot);\n\t}\n\n\tpublic Instruction createStore(InstructionFactory fact) {\n\t\tthrow new IllegalStateException();\n\t\t// return InstructionFactory.createStore(BcelWorld.makeBcelType(getType()), slot);\n\t}\n\n\tpublic void appendStore(InstructionList il, InstructionFactory fact) {\n\t\tthrow new IllegalStateException();\n\t\t// il.append(createStore(fact));\n\t}\n\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\n\t\tthrow new IllegalStateException();\n\t\t// il.append(createLoad(fact));\n\t}\n\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\n\t\tthrow new IllegalStateException();\n\t\t// il.append(createLoad(fact));\n\t\t// Utility.appendConversion(il, fact, getType(), toType);\n\t}\n\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\n\t\tInstructionList loadInstructions = new InstructionList();\n\t\tloadInstructions.append(fact.createInvoke(getType().getName(), \"aspectOf\", \"()\" + getType().getSignature(),\n\t\t\t\tConstants.INVOKESTATIC));\n\t\til.insert(loadInstructions);\n\t\t// throw new IllegalStateException();\n\t\t// il.insert(createLoad(fact));\n\t}\n\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\n\t\tthrow new IllegalStateException();\n\t\t// InstructionList il = new InstructionList();\n\t\t// il.append(InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), oldSlot));\n\t\t// il.append(createStore(fact));\n\t\t// return il;\n\t}\n\n\t// this is an array var\n\tvoid appendConvertableArrayLoad(InstructionList il, InstructionFactory fact, int index, ResolvedType convertTo) {\n\t\tthrow new IllegalStateException();\n\t\t// ResolvedType convertFromType = getType().getResolvedComponentType();\n\t\t// appendLoad(il, fact);\n\t\t// il.append(Utility.createConstant(fact, index));\n\t\t// il.append(InstructionFactory.createArrayLoad(BcelWorld.makeBcelType(convertFromType)));\n\t\t// Utility.appendConversion(il, fact, convertFromType, convertTo);\n\t}\n\n\tvoid appendConvertableArrayStore(InstructionList il, InstructionFactory fact, int index, BcelVar storee) {\n\t\tthrow new IllegalStateException();\n\t\t// ResolvedType convertToType = getType().getResolvedComponentType();\n\t\t// appendLoad(il, fact);\n\t\t// il.append(Utility.createConstant(fact, index));\n\t\t// storee.appendLoad(il, fact);\n\t\t// Utility.appendConversion(il, fact, storee.getType(), convertToType);\n\t\t// il.append(InstructionFactory.createArrayStore(BcelWorld.makeBcelType(convertToType)));\n\t}\n\n\tInstructionList createConvertableArrayStore(InstructionFactory fact, int index, BcelVar storee) {\n\t\tthrow new IllegalStateException();\n\t\t// InstructionList il = new InstructionList();\n\t\t// appendConvertableArrayStore(il, fact, index, storee);\n\t\t// return il;\n\t}\n\n\tInstructionList createConvertableArrayLoad(InstructionFactory fact, int index, ResolvedType convertTo) {\n\t\tthrow new IllegalStateException();\n\t\t// InstructionList il = new InstructionList();\n\t\t// appendConvertableArrayLoad(il, fact, index, convertTo);\n\t\t// return il;\n\t}\n\n\tpublic int getPositionInAroundState() {\n\t\tthrow new IllegalStateException();\n\t\t// return positionInAroundState;\n\t}\n\n\tpublic void setPositionInAroundState(int positionInAroundState) {\n\t\tthrow new IllegalStateException();\n\t\t// this.positionInAroundState = positionInAroundState;\n\t}\n}\n",
    "size": 4677
  },
  {
    "file_id": "F6",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/AtAjAttributes.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n * initial implementation              Alexandre Vasseur\n *******************************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.Attribute;\nimport org.aspectj.apache.bcel.classfile.Constant;\nimport org.aspectj.apache.bcel.classfile.ConstantUtf8;\nimport org.aspectj.apache.bcel.classfile.Field;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.apache.bcel.classfile.LocalVariable;\nimport org.aspectj.apache.bcel.classfile.LocalVariableTable;\nimport org.aspectj.apache.bcel.classfile.Method;\nimport org.aspectj.apache.bcel.classfile.Unknown;\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.classfile.annotation.ArrayElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.ClassElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.ElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.NameValuePair;\nimport org.aspectj.apache.bcel.classfile.annotation.RuntimeAnnos;\nimport org.aspectj.apache.bcel.classfile.annotation.RuntimeVisAnnos;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.asm.AsmManager;\nimport org.aspectj.asm.IHierarchy;\nimport org.aspectj.asm.IProgramElement;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.bridge.Message;\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjAttribute.WeaverVersionInfo;\nimport org.aspectj.weaver.AjcMemberMaker;\nimport org.aspectj.weaver.BindingScope;\nimport org.aspectj.weaver.ISourceContext;\nimport org.aspectj.weaver.MethodDelegateTypeMunger;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ReferenceTypeDelegate;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedPointcutDefinition;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.VersionedDataInputStream;\nimport org.aspectj.weaver.WeaverMessages;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.patterns.DeclareErrorOrWarning;\nimport org.aspectj.weaver.patterns.DeclareParents;\nimport org.aspectj.weaver.patterns.DeclareParentsMixin;\nimport org.aspectj.weaver.patterns.DeclarePrecedence;\nimport org.aspectj.weaver.patterns.FormalBinding;\nimport org.aspectj.weaver.patterns.IScope;\nimport org.aspectj.weaver.patterns.ParserException;\nimport org.aspectj.weaver.patterns.PatternParser;\nimport org.aspectj.weaver.patterns.PerCflow;\nimport org.aspectj.weaver.patterns.PerClause;\nimport org.aspectj.weaver.patterns.PerFromSuper;\nimport org.aspectj.weaver.patterns.PerObject;\nimport org.aspectj.weaver.patterns.PerSingleton;\nimport org.aspectj.weaver.patterns.PerTypeWithin;\nimport org.aspectj.weaver.patterns.Pointcut;\nimport org.aspectj.weaver.patterns.TypePattern;\n\n/**\n * Annotation defined aspect reader. Reads the Java 5 annotations and turns them into AjAttributes\n *\n * @author Alexandre Vasseur (alex AT gnilux DOT com)\n */\npublic class AtAjAttributes {\n\n\tprivate final static List<AjAttribute> NO_ATTRIBUTES = Collections.emptyList();\n\tprivate final static String[] EMPTY_STRINGS = new String[0];\n\tprivate final static String VALUE = \"value\";\n\tprivate final static String ARGNAMES = \"argNames\";\n\tprivate final static String POINTCUT = \"pointcut\";\n\tprivate final static String THROWING = \"throwing\";\n\tprivate final static String RETURNING = \"returning\";\n\tprivate final static String STRING_DESC = \"Ljava/lang/String;\";\n\tprivate final static String ASPECTJ_ANNOTATION_PACKAGE = \"org.aspectj.lang.annotation\";\n\tprivate final static char PACKAGE_INITIAL_CHAR = ASPECTJ_ANNOTATION_PACKAGE.charAt(0);\n\n\t/**\n\t * A struct that allows to add extra arguments without always breaking the API\n\t */\n\tprivate static class AjAttributeStruct {\n\n\t\t/**\n\t\t * The list of AjAttribute.XXX that we are populating from the @AJ read\n\t\t */\n\t\tList<AjAttribute> ajAttributes = new ArrayList<>();\n\n\t\t/**\n\t\t * The resolved type (class) for which we are reading @AJ for (be it class, method, field annotations)\n\t\t */\n\t\tfinal ResolvedType enclosingType;\n\n\t\tfinal ISourceContext context;\n\t\tfinal IMessageHandler handler;\n\n\t\tpublic AjAttributeStruct(ResolvedType type, ISourceContext sourceContext, IMessageHandler messageHandler) {\n\t\t\tenclosingType = type;\n\t\t\tcontext = sourceContext;\n\t\t\thandler = messageHandler;\n\t\t}\n\t}\n\n\t/**\n\t * A struct when we read @AJ on method\n\t *\n\t * @author <a href=\"mailto:alex AT gnilux DOT com\">Alexandre Vasseur</a>\n\t */\n\tprivate static class AjAttributeMethodStruct extends AjAttributeStruct {\n\n\t\t// argument names used for formal binding\n\t\tprivate String[] m_argumentNamesLazy = null;\n\t\tpublic String unparsedArgumentNames = null; // Set only if discovered as\n\t\t// argNames attribute of\n\t\t// annotation\n\n\t\tfinal Method method;\n\t\tfinal BcelMethod bMethod;\n\n\t\tpublic AjAttributeMethodStruct(Method method, BcelMethod bMethod, ResolvedType type, ISourceContext sourceContext,\n\t\t\t\tIMessageHandler messageHandler) {\n\t\t\tsuper(type, sourceContext, messageHandler);\n\t\t\tthis.method = method;\n\t\t\tthis.bMethod = bMethod;\n\t\t}\n\n\t\tpublic String[] getArgumentNames() {\n\t\t\tif (m_argumentNamesLazy == null) {\n\t\t\t\tm_argumentNamesLazy = getMethodArgumentNames(method, unparsedArgumentNames, this);\n\t\t\t}\n\t\t\treturn m_argumentNamesLazy;\n\t\t}\n\t}\n\n\t/**\n\t * A struct when we read @AJ on field\n\t */\n\tprivate static class AjAttributeFieldStruct extends AjAttributeStruct {\n\n\t\tfinal Field field;\n\n\t\t// final BcelField bField;\n\n\t\tpublic AjAttributeFieldStruct(Field field, BcelField bField, ResolvedType type, ISourceContext sourceContext,\n\t\t\t\tIMessageHandler messageHandler) {\n\t\t\tsuper(type, sourceContext, messageHandler);\n\t\t\tthis.field = field;\n\t\t\t// this.bField = bField;\n\t\t}\n\t}\n\n\t/**\n\t * Annotations are RuntimeVisible only. This allow us to not visit RuntimeInvisible ones.\n\t *\n\t * @param attribute\n\t * @return true if runtime visible annotation\n\t */\n\tpublic static boolean acceptAttribute(Attribute attribute) {\n\t\treturn (attribute instanceof RuntimeVisAnnos);\n\t}\n\n\t/**\n\t * Extract class level annotations and turn them into AjAttributes.\n\t *\n\t * @param javaClass\n\t * @param type\n\t * @param context\n\t * @param msgHandler\n\t * @return list of AjAttributes\n\t */\n\tpublic static List<AjAttribute> readAj5ClassAttributes(AsmManager model, JavaClass javaClass, ReferenceType type,\n\t\t\tISourceContext context, IMessageHandler msgHandler, boolean isCodeStyleAspect) {\n\t\tboolean ignoreThisClass = javaClass.getClassName().charAt(0) == PACKAGE_INITIAL_CHAR\n\t\t\t\t&& javaClass.getClassName().startsWith(ASPECTJ_ANNOTATION_PACKAGE);\n\t\tif (ignoreThisClass) {\n\t\t\treturn NO_ATTRIBUTES;\n\t\t}\n\t\tboolean containsPointcut = false;\n\t\tboolean containsAnnotationClassReference = false;\n\t\tConstant[] cpool = javaClass.getConstantPool().getConstantPool();\n\t\tfor (Constant constant : cpool) {\n\t\t\tif (constant != null && constant.getTag() == Constants.CONSTANT_Utf8) {\n\t\t\t\tString constantValue = ((ConstantUtf8) constant).getValue();\n\t\t\t\tif (constantValue.length() > 28 && constantValue.charAt(1) == PACKAGE_INITIAL_CHAR) {\n\t\t\t\t\tif (constantValue.startsWith(\"Lorg/aspectj/lang/annotation\")) {\n\t\t\t\t\t\tcontainsAnnotationClassReference = true;\n\t\t\t\t\t\tif (\"Lorg/aspectj/lang/annotation/DeclareAnnotation;\".equals(constantValue)) {\n\t\t\t\t\t\t\tmsgHandler.handleMessage(new Message(\n\t\t\t\t\t\t\t\t\t\"Found @DeclareAnnotation while current release does not support it (see '\" + type.getName()\n\t\t\t\t\t\t\t\t\t\t\t+ \"')\", IMessage.WARNING, null, type.getSourceLocation()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\"Lorg/aspectj/lang/annotation/Pointcut;\".equals(constantValue)) {\n\t\t\t\t\t\t\tcontainsPointcut = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!containsAnnotationClassReference) {\n\t\t\treturn NO_ATTRIBUTES;\n\t\t}\n\n\t\tAjAttributeStruct struct = new AjAttributeStruct(type, context, msgHandler);\n\t\tAttribute[] attributes = javaClass.getAttributes();\n\t\tboolean hasAtAspectAnnotation = false;\n\t\tboolean hasAtPrecedenceAnnotation = false;\n\n\t\tWeaverVersionInfo wvinfo = null;\n\t\tfor (Attribute attribute : attributes) {\n\t\t\tif (acceptAttribute(attribute)) {\n\t\t\t\tRuntimeAnnos rvs = (RuntimeAnnos) attribute;\n\t\t\t\t// we don't need to look for several attribute occurrences since\n\t\t\t\t// it cannot happen as per JSR175\n\t\t\t\tif (!isCodeStyleAspect && !javaClass.isInterface()) {\n\t\t\t\t\thasAtAspectAnnotation = handleAspectAnnotation(rvs, struct);\n\t\t\t\t\t// TODO AV - if put outside the if isCodeStyleAspect then we\n\t\t\t\t\t// would enable mix style\n\t\t\t\t\thasAtPrecedenceAnnotation = handlePrecedenceAnnotation(rvs, struct);\n\t\t\t\t}\n\t\t\t\t// there can only be one RuntimeVisible bytecode attribute\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = attributes.length - 1; i >= 0; i--) {\n\t\t\tAttribute attribute = attributes[i];\n\t\t\tif (attribute.getName().equals(WeaverVersionInfo.AttributeName)) {\n\t\t\t\ttry {\n\t\t\t\t\tVersionedDataInputStream s = new VersionedDataInputStream(new ByteArrayInputStream(\n\t\t\t\t\t\t\t((Unknown) attribute).getBytes()), null);\n\t\t\t\t\twvinfo = WeaverVersionInfo.read(s);\n\t\t\t\t\tstruct.ajAttributes.add(0, wvinfo);\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t\tioe.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (wvinfo == null) {\n\t\t\t// If we are in here due to a resetState() call (presumably because of reweavable state processing), the\n\t\t\t// original type delegate will have been set with a version but that version will be missing from\n\t\t\t// the new set of attributes (looks like a bug where the version attribute was not included in the\n\t\t\t// data compressed into the attribute). So rather than 'defaulting' to current, we should use one\n\t\t\t// if it set on the delegate for the type.\n\t\t\tReferenceTypeDelegate delegate = type.getDelegate();\n\t\t\tif (delegate instanceof BcelObjectType) {\n\t\t\t\twvinfo = ((BcelObjectType) delegate).getWeaverVersionAttribute();\n\t\t\t\tif (wvinfo != null) {\n\t\t\t\t\tif (wvinfo.getMajorVersion() != WeaverVersionInfo.WEAVER_VERSION_MAJOR_UNKNOWN) {\n\t\t\t\t\t\t// use this one\n\t\t\t\t\t\tstruct.ajAttributes.add(0, wvinfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twvinfo = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (wvinfo == null) {\n\t\t\t\tstruct.ajAttributes.add(0, wvinfo = new AjAttribute.WeaverVersionInfo());\n\t\t\t}\n\t\t}\n\n\t\t// basic semantic check\n\t\tif (hasAtPrecedenceAnnotation && !hasAtAspectAnnotation) {\n\t\t\tmsgHandler.handleMessage(new Message(\"Found @DeclarePrecedence on a non @Aspect type '\" + type.getName() + \"'\",\n\t\t\t\t\tIMessage.WARNING, null, type.getSourceLocation()));\n\t\t\t// bypass what we have read\n\t\t\treturn NO_ATTRIBUTES;\n\t\t}\n\n\t\t// the following block will not detect @Pointcut in non @Aspect types\n\t\t// for optimization purpose\n\t\tif (!(hasAtAspectAnnotation || isCodeStyleAspect) && !containsPointcut) {\n\t\t\treturn NO_ATTRIBUTES;\n\t\t}\n\n\t\t// FIXME AV - turn on when ajcMightHaveAspect\n\t\t// if (hasAtAspectAnnotation && type.isInterface()) {\n\t\t// msgHandler.handleMessage(\n\t\t// new Message(\n\t\t// \"Found @Aspect on an interface type '\" + type.getName() + \"'\",\n\t\t// IMessage.WARNING,\n\t\t// null,\n\t\t// type.getSourceLocation()\n\t\t// )\n\t\t// );\n\t\t// // bypass what we have read\n\t\t// return EMPTY_LIST;\n\t\t// }\n\n\t\t// semantic check: @Aspect must be public\n\t\t// FIXME AV - do we really want to enforce that?\n\t\t// if (hasAtAspectAnnotation && !javaClass.isPublic()) {\n\t\t// msgHandler.handleMessage(\n\t\t// new Message(\n\t\t// \"Found @Aspect annotation on a non public class '\" +\n\t\t// javaClass.getClassName() + \"'\",\n\t\t// IMessage.ERROR,\n\t\t// null,\n\t\t// type.getSourceLocation()\n\t\t// )\n\t\t// );\n\t\t// return EMPTY_LIST;\n\t\t// }\n\n\t\t// code style pointcuts are class attributes\n\t\t// we need to gather the @AJ pointcut right now and not at method level\n\t\t// annotation extraction time\n\t\t// in order to be able to resolve the pointcut references later on\n\t\t// we don't need to look in super class, the pointcut reference in the\n\t\t// grammar will do it\n\n\t\tfor (int i = 0; i < javaClass.getMethods().length; i++) {\n\t\t\tMethod method = javaClass.getMethods()[i];\n\t\t\tif (method.getName().startsWith(NameMangler.PREFIX)) {\n\t\t\t\tcontinue; // already dealt with by ajc...\n\t\t\t}\n\t\t\t// FIXME alex optimize, this method struct will gets recreated for\n\t\t\t// advice extraction\n\t\t\tAjAttributeMethodStruct mstruct = null;\n\t\t\tboolean processedPointcut = false;\n\t\t\tAttribute[] mattributes = method.getAttributes();\n\t\t\tfor (Attribute mattribute : mattributes) {\n\t\t\t\tif (acceptAttribute(mattribute)) {\n\t\t\t\t\t// TODO speed all this nonsense up rather than looking\n\t\t\t\t\t// through all the annotations every time\n\t\t\t\t\t// same for fields\n\t\t\t\t\tmstruct = new AjAttributeMethodStruct(method, null, type, context, msgHandler);\n\t\t\t\t\tprocessedPointcut = handlePointcutAnnotation((RuntimeAnnos) mattribute, mstruct);\n\t\t\t\t\tif (!processedPointcut) {\n\t\t\t\t\t\tprocessedPointcut = handleDeclareMixinAnnotation((RuntimeAnnos) mattribute, mstruct);\n\t\t\t\t\t}\n\t\t\t\t\t// there can only be one RuntimeVisible bytecode attribute\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (processedPointcut) {\n\t\t\t\tstruct.ajAttributes.addAll(mstruct.ajAttributes);\n\t\t\t}\n\t\t}\n\n\t\t// code style declare error / warning / implements / parents are field\n\t\t// attributes\n\t\tField[] fs = javaClass.getFields();\n\t\tfor (Field field : fs) {\n\t\t\tif (field.getName().startsWith(NameMangler.PREFIX)) {\n\t\t\t\tcontinue; // already dealt with by ajc...\n\t\t\t}\n\t\t\t// FIXME alex optimize, this method struct will gets recreated for\n\t\t\t// advice extraction\n\t\t\tAjAttributeFieldStruct fstruct = new AjAttributeFieldStruct(field, null, type, context, msgHandler);\n\t\t\tAttribute[] fattributes = field.getAttributes();\n\n\t\t\tfor (Attribute fattribute : fattributes) {\n\t\t\t\tif (acceptAttribute(fattribute)) {\n\t\t\t\t\tRuntimeAnnos frvs = (RuntimeAnnos) fattribute;\n\t\t\t\t\tif (handleDeclareErrorOrWarningAnnotation(model, frvs, fstruct)\n\t\t\t\t\t\t\t|| handleDeclareParentsAnnotation(frvs, fstruct)) {\n\t\t\t\t\t\t// semantic check - must be in an @Aspect [remove if\n\t\t\t\t\t\t// previous block bypassed in advance]\n\t\t\t\t\t\tif (!type.isAnnotationStyleAspect() && !isCodeStyleAspect) {\n\t\t\t\t\t\t\tmsgHandler.handleMessage(new Message(\"Found @AspectJ annotations in a non @Aspect type '\"\n\t\t\t\t\t\t\t\t\t+ type.getName() + \"'\", IMessage.WARNING, null, type.getSourceLocation()));\n\t\t\t\t\t\t\t// go ahead\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// there can only be one RuntimeVisible bytecode attribute\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstruct.ajAttributes.addAll(fstruct.ajAttributes);\n\t\t}\n\n\t\treturn struct.ajAttributes;\n\t}\n\n\t/**\n\t * Extract method level annotations and turn them into AjAttributes.\n\t *\n\t * @param method\n\t * @param type\n\t * @param context\n\t * @param msgHandler\n\t * @return list of AjAttributes\n\t */\n\tpublic static List<AjAttribute> readAj5MethodAttributes(Method method, BcelMethod bMethod, ResolvedType type,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut, ISourceContext context, IMessageHandler msgHandler) {\n\t\tif (method.getName().startsWith(NameMangler.PREFIX)) {\n\t\t\treturn Collections.emptyList(); // already dealt with by ajc...\n\t\t}\n\t\tif (method.isBridge()) {\n\t\t\t// This happens for 1.8 compiled code where a bridge method is created for annotation style advice declared\n\t\t\t// in an abstract class\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tAjAttributeMethodStruct struct = new AjAttributeMethodStruct(method, bMethod, type, context, msgHandler);\n\t\tAttribute[] attributes = method.getAttributes();\n\n\t\t// we remember if we found one @AJ annotation for minimal semantic error\n\t\t// reporting\n\t\t// the real reporting beeing done thru AJDT and the compiler mapping @AJ\n\t\t// to AjAtttribute\n\t\t// or thru APT\n\t\t//\n\t\t// Note: we could actually skip the whole thing if type is not itself an\n\t\t// @Aspect\n\t\t// but then we would not see any warning. We do bypass for pointcut but\n\t\t// not for advice since it would\n\t\t// be too silent.\n\t\tboolean hasAtAspectJAnnotation = false;\n\t\tboolean hasAtAspectJAnnotationMustReturnVoid = false;\n\t\tfor (Attribute attribute : attributes) {\n\t\t\ttry {\n\t\t\t\tif (acceptAttribute(attribute)) {\n\t\t\t\t\tRuntimeAnnos rvs = (RuntimeAnnos) attribute;\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\n\t\t\t\t\t\t\t|| handleBeforeAnnotation(rvs, struct, preResolvedPointcut);\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\n\t\t\t\t\t\t\t|| handleAfterAnnotation(rvs, struct, preResolvedPointcut);\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\n\t\t\t\t\t\t\t|| handleAfterReturningAnnotation(rvs, struct, preResolvedPointcut, bMethod);\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\n\t\t\t\t\t\t\t|| handleAfterThrowingAnnotation(rvs, struct, preResolvedPointcut, bMethod);\n\t\t\t\t\thasAtAspectJAnnotation = hasAtAspectJAnnotation || handleAroundAnnotation(rvs, struct, preResolvedPointcut);\n\t\t\t\t\t// there can only be one RuntimeVisible bytecode attribute\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (ReturningFormalNotDeclaredInAdviceSignatureException e) {\n\t\t\t\tmsgHandler.handleMessage(new Message(WeaverMessages.format(WeaverMessages.RETURNING_FORMAL_NOT_DECLARED_IN_ADVICE,\n\t\t\t\t\t\te.getFormalName()), IMessage.ERROR, null, bMethod.getSourceLocation()));\n\t\t\t} catch (ThrownFormalNotDeclaredInAdviceSignatureException e) {\n\t\t\t\tmsgHandler.handleMessage(new Message(WeaverMessages.format(WeaverMessages.THROWN_FORMAL_NOT_DECLARED_IN_ADVICE,\n\t\t\t\t\t\te.getFormalName()), IMessage.ERROR, null, bMethod.getSourceLocation()));\n\t\t\t}\n\t\t}\n\t\thasAtAspectJAnnotation = hasAtAspectJAnnotation || hasAtAspectJAnnotationMustReturnVoid;\n\n\t\t// semantic check - must be in an @Aspect [remove if previous block\n\t\t// bypassed in advance]\n\t\tif (hasAtAspectJAnnotation && !type.isAspect()) { // isAnnotationStyleAspect())\n\t\t\t// {\n\t\t\tmsgHandler.handleMessage(new Message(\"Found @AspectJ annotations in a non @Aspect type '\" + type.getName() + \"'\",\n\t\t\t\t\tIMessage.WARNING, null, type.getSourceLocation()));\n\t\t\t// go ahead\n\t\t}\n\t\t// semantic check - advice must be public\n\t\tif (hasAtAspectJAnnotation && !struct.method.isPublic()) {\n\t\t\tmsgHandler.handleMessage(new Message(\"Found @AspectJ annotation on a non public advice '\"\n\t\t\t\t\t+ methodToString(struct.method) + \"'\", IMessage.ERROR, null, type.getSourceLocation()));\n\t\t\t// go ahead\n\t\t}\n\n\t\t// semantic check - advice must not be static\n\t\tif (hasAtAspectJAnnotation && struct.method.isStatic()) {\n\t\t\tmsgHandler.handleMessage(MessageUtil.error(\"Advice cannot be declared static '\" + methodToString(struct.method) + \"'\",\n\t\t\t\t\ttype.getSourceLocation()));\n\t\t\t// new Message(\n\t\t\t// \"Advice cannot be declared static '\" +\n\t\t\t// methodToString(struct.method) + \"'\",\n\t\t\t// IMessage.ERROR,\n\t\t\t// null,\n\t\t\t// type.getSourceLocation()\n\t\t\t// )\n\t\t\t// );\n\t\t\t// go ahead\n\t\t}\n\n\t\t// semantic check for non around advice must return void\n\t\tif (hasAtAspectJAnnotationMustReturnVoid && !Type.VOID.equals(struct.method.getReturnType())) {\n\t\t\tmsgHandler.handleMessage(new Message(\"Found @AspectJ annotation on a non around advice not returning void '\"\n\t\t\t\t\t+ methodToString(struct.method) + \"'\", IMessage.ERROR, null, type.getSourceLocation()));\n\t\t\t// go ahead\n\t\t}\n\n\t\treturn struct.ajAttributes;\n\t}\n\n\t/**\n\t * Extract field level annotations and turn them into AjAttributes.\n\t *\n\t * @param field\n\t * @param type\n\t * @param context\n\t * @param msgHandler\n\t * @return list of AjAttributes, always empty for now\n\t */\n\tpublic static List<AjAttribute> readAj5FieldAttributes(Field field, BcelField bField, ResolvedType type,\n\t\t\tISourceContext context, IMessageHandler msgHandler) {\n\t\t// Note: field annotation are for ITD and DEOW - processed at class\n\t\t// level directly\n\t\treturn Collections.emptyList();\n\t}\n\n\t/**\n\t * Read @Aspect\n\t *\n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if found\n\t */\n\tprivate static boolean handleAspectAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeStruct struct) {\n\t\tAnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.ASPECT_ANNOTATION);\n\t\tif (aspect != null) {\n\t\t\t// semantic check for inheritance (only one level up)\n\t\t\tboolean extendsAspect = false;\n\t\t\tif (!\"java.lang.Object\".equals(struct.enclosingType.getSuperclass().getName())) {\n\t\t\t\tif (!struct.enclosingType.getSuperclass().isAbstract() && struct.enclosingType.getSuperclass().isAspect()) {\n\t\t\t\t\treportError(\"cannot extend a concrete aspect\", struct);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\textendsAspect = struct.enclosingType.getSuperclass().isAspect();\n\t\t\t}\n\n\t\t\tNameValuePair aspectPerClause = getAnnotationElement(aspect, VALUE);\n\t\t\tfinal PerClause perClause;\n\t\t\tif (aspectPerClause == null) {\n\t\t\t\t// empty value means singleton unless inherited\n\t\t\t\tif (!extendsAspect) {\n\t\t\t\t\tperClause = new PerSingleton();\n\t\t\t\t} else {\n\t\t\t\t\tperClause = new PerFromSuper(struct.enclosingType.getSuperclass().getPerClause().getKind());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString perX = aspectPerClause.getValue().stringifyValue();\n\t\t\t\tif (perX == null || perX.length() <= 0) {\n\t\t\t\t\tperClause = new PerSingleton();\n\t\t\t\t} else {\n\t\t\t\t\tperClause = parsePerClausePointcut(perX, struct);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (perClause == null) {\n\t\t\t\t// could not parse it, ignore the aspect\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tperClause.setLocation(struct.context, -1, -1);// struct.context.getOffset(),\n\t\t\t\t// struct.context.getOffset()+1);//FIXME\n\t\t\t\t// AVASM\n\t\t\t\t// Not setting version here\n\t\t\t\t// struct.ajAttributes.add(new AjAttribute.WeaverVersionInfo());\n\t\t\t\tAjAttribute.Aspect aspectAttribute = new AjAttribute.Aspect(perClause);\n\t\t\t\tstruct.ajAttributes.add(aspectAttribute);\n\t\t\t\tFormalBinding[] bindings = FormalBinding.NONE;\n\t\t\t\tfinal IScope binding;\n\t\t\t\tbinding = new BindingScope(struct.enclosingType, struct.context, bindings);\n\n\t\t\t\t// // we can't resolve here since the perclause typically refers\n\t\t\t\t// to pointcuts\n\t\t\t\t// // defined in the aspect that we haven't told the\n\t\t\t\t// BcelObjectType about yet.\n\t\t\t\t//\n\t\t\t\t// perClause.resolve(binding);\n\n\t\t\t\t// so we prepare to do it later...\n\t\t\t\taspectAttribute.setResolutionScope(binding);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Read a perClause, returns null on failure and issue messages\n\t *\n\t * @param perClauseString like \"pertarget(.....)\"\n\t * @param struct for which we are parsing the per clause\n\t * @return a PerClause instance\n\t */\n\tprivate static PerClause parsePerClausePointcut(String perClauseString, AjAttributeStruct struct) {\n\t\tfinal String pointcutString;\n\t\tPointcut pointcut = null;\n\t\tTypePattern typePattern = null;\n\t\tfinal PerClause perClause;\n\t\tif (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERCFLOW.getName())) {\n\t\t\tpointcutString = PerClause.KindAnnotationPrefix.PERCFLOW.extractPointcut(perClauseString);\n\t\t\tpointcut = parsePointcut(pointcutString, struct, false);\n\t\t\tperClause = new PerCflow(pointcut, false);\n\t\t} else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERCFLOWBELOW.getName())) {\n\t\t\tpointcutString = PerClause.KindAnnotationPrefix.PERCFLOWBELOW.extractPointcut(perClauseString);\n\t\t\tpointcut = parsePointcut(pointcutString, struct, false);\n\t\t\tperClause = new PerCflow(pointcut, true);\n\t\t} else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERTARGET.getName())) {\n\t\t\tpointcutString = PerClause.KindAnnotationPrefix.PERTARGET.extractPointcut(perClauseString);\n\t\t\tpointcut = parsePointcut(pointcutString, struct, false);\n\t\t\tperClause = new PerObject(pointcut, false);\n\t\t} else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERTHIS.getName())) {\n\t\t\tpointcutString = PerClause.KindAnnotationPrefix.PERTHIS.extractPointcut(perClauseString);\n\t\t\tpointcut = parsePointcut(pointcutString, struct, false);\n\t\t\tperClause = new PerObject(pointcut, true);\n\t\t} else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERTYPEWITHIN.getName())) {\n\t\t\tpointcutString = PerClause.KindAnnotationPrefix.PERTYPEWITHIN.extractPointcut(perClauseString);\n\t\t\ttypePattern = parseTypePattern(pointcutString, struct);\n\t\t\tperClause = new PerTypeWithin(typePattern);\n\t\t} else if (perClauseString.equalsIgnoreCase(PerClause.SINGLETON.getName() + \"()\")) {\n\t\t\tperClause = new PerSingleton();\n\t\t} else {\n\t\t\t// could not parse the @AJ perclause - fallback to singleton and\n\t\t\t// issue an error\n\t\t\treportError(\"@Aspect per clause cannot be read '\" + perClauseString + \"'\", struct);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!PerClause.SINGLETON.equals(perClause.getKind()) && !PerClause.PERTYPEWITHIN.equals(perClause.getKind())\n\t\t\t\t&& pointcut == null) {\n\t\t\t// we could not parse the pointcut\n\t\t\treturn null;\n\t\t}\n\t\tif (PerClause.PERTYPEWITHIN.equals(perClause.getKind()) && typePattern == null) {\n\t\t\t// we could not parse the type pattern\n\t\t\treturn null;\n\t\t}\n\t\treturn perClause;\n\t}\n\n\t/**\n\t * Read @DeclarePrecedence\n\t *\n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if found\n\t */\n\tprivate static boolean handlePrecedenceAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeStruct struct) {\n\t\tAnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREPRECEDENCE_ANNOTATION);\n\t\tif (aspect != null) {\n\t\t\tNameValuePair precedence = getAnnotationElement(aspect, VALUE);\n\t\t\tif (precedence != null) {\n\t\t\t\tString precedencePattern = precedence.getValue().stringifyValue();\n\t\t\t\tPatternParser parser = new PatternParser(precedencePattern);\n\t\t\t\tDeclarePrecedence ajPrecedence = parser.parseDominates();\n\t\t\t\tstruct.ajAttributes.add(new AjAttribute.DeclareAttribute(ajPrecedence));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// /**\n\t// * Read @DeclareImplements\n\t// *\n\t// * @param runtimeAnnotations\n\t// * @param struct\n\t// * @return true if found\n\t// */\n\t// private static boolean\n\t// handleDeclareImplementsAnnotation(RuntimeAnnotations runtimeAnnotations,\n\t// AjAttributeFieldStruct\n\t// struct) {//, ResolvedPointcutDefinition preResolvedPointcut) {\n\t// Annotation deci = getAnnotation(runtimeAnnotations,\n\t// AjcMemberMaker.DECLAREIMPLEMENTS_ANNOTATION);\n\t// if (deci != null) {\n\t// ElementNameValuePairGen deciPatternNVP = getAnnotationElement(deci,\n\t// VALUE);\n\t// String deciPattern = deciPatternNVP.getValue().stringifyValue();\n\t// if (deciPattern != null) {\n\t// TypePattern typePattern = parseTypePattern(deciPattern, struct);\n\t// ResolvedType fieldType =\n\t// UnresolvedType.forSignature(struct.field.getSignature()).resolve(struct.enclosingType.getWorld());\n\t// if (fieldType.isPrimitiveType()) {\n\t// return false;\n\t// } else if (fieldType.isInterface()) {\n\t// TypePattern parent = new\n\t// ExactTypePattern(UnresolvedType.forSignature(struct.field.getSignature()),\n\t// false, false);\n\t// parent.resolve(struct.enclosingType.getWorld());\n\t// List parents = new ArrayList(1);\n\t// parents.add(parent);\n\t// //TODO kick ISourceLocation sl = struct.bField.getSourceLocation(); ??\n\t// struct.ajAttributes.add(\n\t// new AjAttribute.DeclareAttribute(\n\t// new DeclareParents(\n\t// typePattern,\n\t// parents,\n\t// false\n\t// )\n\t// )\n\t// );\n\t// return true;\n\t// } else {\n\t// reportError(\"@DeclareImplements: can only be used on field whose type is an interface\",\n\t// struct);\n\t// return false;\n\t// }\n\t// }\n\t// }\n\t// return false;\n\t// }\n\n\tprivate static boolean handleDeclareParentsAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeFieldStruct struct) {\n\t\tAnnotationGen decpAnno = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREPARENTS_ANNOTATION);\n\t\tif (decpAnno != null) {\n\t\t\tNameValuePair decpPatternNameValuePair = getAnnotationElement(decpAnno, VALUE);\n\t\t\tString decpPattern = decpPatternNameValuePair.getValue().stringifyValue();\n\t\t\tif (decpPattern != null) {\n\t\t\t\tTypePattern typePattern = parseTypePattern(decpPattern, struct);\n\t\t\t\tResolvedType fieldType = UnresolvedType.forSignature(struct.field.getSignature()).resolve(\n\t\t\t\t\t\tstruct.enclosingType.getWorld());\n\t\t\t\tif (fieldType.isParameterizedOrRawType()) {\n\t\t\t\t\tfieldType = fieldType.getGenericType();\n\t\t\t\t}\n\t\t\t\tif (fieldType.isInterface()) {\n\t\t\t\t\tTypePattern parent = parseTypePattern(fieldType.getName(), struct);\n\t\t\t\t\tFormalBinding[] bindings = FormalBinding.NONE;\n\t\t\t\t\tIScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);\n\t\t\t\t\t// first add the declare implements like\n\t\t\t\t\tList<TypePattern> parents = new ArrayList<>(1);\n\t\t\t\t\tparents.add(parent);\n\t\t\t\t\tDeclareParents dp = new DeclareParents(typePattern, parents, false);\n\t\t\t\t\tdp.resolve(binding); // resolves the parent and child parts of the decp\n\n\t\t\t\t\t// resolve this so that we can use it for the\n\t\t\t\t\t// MethodDelegateMungers below.\n\t\t\t\t\t// eg. '@Coloured *' will change from a WildTypePattern to\n\t\t\t\t\t// an 'AnyWithAnnotationTypePattern' after this resolution\n\t\t\t\t\ttypePattern = dp.getChild(); // this retrieves the resolved version\n\t\t\t\t\t// TODO kick ISourceLocation sl =\n\t\t\t\t\t// struct.bField.getSourceLocation(); ??\n\t\t\t\t\t// dp.setLocation(dp.getDeclaringType().getSourceContext(),\n\t\t\t\t\t// dp.getDeclaringType().getSourceLocation().getOffset(),\n\t\t\t\t\t// dp.getDeclaringType().getSourceLocation().getOffset());\n\t\t\t\t\tdp.setLocation(struct.context, -1, -1); // not ideal...\n\t\t\t\t\tstruct.ajAttributes.add(new AjAttribute.DeclareAttribute(dp));\n\n\t\t\t\t\t// do we have a defaultImpl=xxx.class (ie implementation)\n\t\t\t\t\tString defaultImplClassName = null;\n\t\t\t\t\tNameValuePair defaultImplNVP = getAnnotationElement(decpAnno, \"defaultImpl\");\n\t\t\t\t\tif (defaultImplNVP != null) {\n\t\t\t\t\t\tClassElementValue defaultImpl = (ClassElementValue) defaultImplNVP.getValue();\n\t\t\t\t\t\tdefaultImplClassName = UnresolvedType.forSignature(defaultImpl.getClassString()).getName();\n\t\t\t\t\t\tif (defaultImplClassName.equals(\"org.aspectj.lang.annotation.DeclareParents\")) {\n\t\t\t\t\t\t\tdefaultImplClassName = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// check public no arg ctor\n\t\t\t\t\t\t\tResolvedType impl = struct.enclosingType.getWorld().resolve(defaultImplClassName, false);\n\t\t\t\t\t\t\tResolvedMember[] mm = impl.getDeclaredMethods();\n\t\t\t\t\t\t\tint implModifiers = impl.getModifiers();\n\t\t\t\t\t\t\tboolean defaultVisibilityImpl = !(Modifier.isPrivate(implModifiers)\n\t\t\t\t\t\t\t\t\t|| Modifier.isProtected(implModifiers) || Modifier.isPublic(implModifiers));\n\t\t\t\t\t\t\tboolean hasNoCtorOrANoArgOne = true;\n\t\t\t\t\t\t\tResolvedMember foundOneOfIncorrectVisibility = null;\n\t\t\t\t\t\t\tfor (ResolvedMember resolvedMember : mm) {\n\t\t\t\t\t\t\t\tif (resolvedMember.getName().equals(\"<init>\")) {\n\t\t\t\t\t\t\t\t\thasNoCtorOrANoArgOne = false;\n\n\t\t\t\t\t\t\t\t\tif (resolvedMember.getParameterTypes().length == 0) {\n\t\t\t\t\t\t\t\t\t\tif (defaultVisibilityImpl) { // default visibility implementation\n\t\t\t\t\t\t\t\t\t\t\tif (resolvedMember.isPublic() || resolvedMember.isDefault()) {\n\t\t\t\t\t\t\t\t\t\t\t\thasNoCtorOrANoArgOne = true;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tfoundOneOfIncorrectVisibility = resolvedMember;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else if (Modifier.isPublic(implModifiers)) { // public\n\t\t\t\t\t\t\t\t\t\t\t// implementation\n\t\t\t\t\t\t\t\t\t\t\tif (resolvedMember.isPublic()) {\n\t\t\t\t\t\t\t\t\t\t\t\thasNoCtorOrANoArgOne = true;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tfoundOneOfIncorrectVisibility = resolvedMember;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (hasNoCtorOrANoArgOne) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!hasNoCtorOrANoArgOne) {\n\t\t\t\t\t\t\t\tif (foundOneOfIncorrectVisibility != null) {\n\t\t\t\t\t\t\t\t\treportError(\n\t\t\t\t\t\t\t\t\t\t\t\"@DeclareParents: defaultImpl=\\\"\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ defaultImplClassName\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"\\\" has a no argument constructor, but it is of incorrect visibility.  It must be at least as visible as the type.\",\n\t\t\t\t\t\t\t\t\t\t\tstruct);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treportError(\"@DeclareParents: defaultImpl=\\\"\" + defaultImplClassName\n\t\t\t\t\t\t\t\t\t\t\t+ \"\\\" has no public no-arg constructor\", struct);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!fieldType.isAssignableFrom(impl)) {\n\t\t\t\t\t\t\t\treportError(\"@DeclareParents: defaultImpl=\\\"\" + defaultImplClassName\n\t\t\t\t\t\t\t\t\t\t+ \"\\\" does not implement the interface '\" + fieldType.toString() + \"'\", struct);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tboolean hasAtLeastOneMethod = false;\n\t\t\t\t\t// then iterate on field interface hierarchy (not object)\n\t\t\t\t\tIterator<ResolvedMember> methodIterator = fieldType.getMethodsIncludingIntertypeDeclarations(false, true);\n\t\t\t\t\twhile (methodIterator.hasNext()) {\n\t\t\t\t\t\tResolvedMember method = methodIterator.next();\n\t\t\t\t\t\tif (method.isAbstract()) {\n\t\t\t\t\t\t\t// moved to be detected at weave time if the target\n\t\t\t\t\t\t\t// doesnt implement the methods\n\t\t\t\t\t\t\t// if (defaultImplClassName == null) {\n\t\t\t\t\t\t\t// // non marker interface with no default impl\n\t\t\t\t\t\t\t// provided\n\t\t\t\t\t\t\t// reportError(\"@DeclareParents: used with a non marker interface and no defaultImpl=\\\"...\\\" provided\",\n\t\t\t\t\t\t\t// struct);\n\t\t\t\t\t\t\t// return false;\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\thasAtLeastOneMethod = true;\n\t\t\t\t\t\t\t// What we are saying here:\n\t\t\t\t\t\t\t// We have this method 'method' and we want to put a\n\t\t\t\t\t\t\t// forwarding method into a type that matches\n\t\t\t\t\t\t\t// typePattern that should delegate to the version\n\t\t\t\t\t\t\t// of the method in 'defaultImplClassName'\n\n\t\t\t\t\t\t\t// Now the method may be from a supertype but the\n\t\t\t\t\t\t\t// declaring type of the method we pass into the\n\t\t\t\t\t\t\t// type\n\t\t\t\t\t\t\t// munger is what is used to determine the type of\n\t\t\t\t\t\t\t// the field that hosts the delegate instance.\n\t\t\t\t\t\t\t// So here we create a modified method with an\n\t\t\t\t\t\t\t// alternative declaring type so that we lookup\n\t\t\t\t\t\t\t// the right field. See pr164016.\n\t\t\t\t\t\t\tMethodDelegateTypeMunger mdtm = new MethodDelegateTypeMunger(method, struct.enclosingType, defaultImplClassName, typePattern);\n\t\t\t\t\t\t\tmdtm.setFieldType(fieldType);\n\t\t\t\t\t\t\tmdtm.setSourceLocation(struct.enclosingType.getSourceLocation());\n\t\t\t\t\t\t\tstruct.ajAttributes.add(new AjAttribute.TypeMunger(mdtm));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// successful so far, we thus need a bcel type munger to have\n\t\t\t\t\t// a field hosting the mixin in the target type\n\t\t\t\t\tif (hasAtLeastOneMethod && defaultImplClassName != null) {\n\t\t\t\t\t\tResolvedMember fieldHost = AjcMemberMaker.itdAtDeclareParentsField(null, fieldType, struct.enclosingType);\n\t\t\t\t\t\tstruct.ajAttributes.add(new AjAttribute.TypeMunger(new MethodDelegateTypeMunger.FieldHostTypeMunger(\n\t\t\t\t\t\t\t\tfieldHost, struct.enclosingType, typePattern)));\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treportError(\"@DeclareParents: can only be used on a field whose type is an interface\", struct);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @return a nicely formatted method string, for example: int X.foo(java.lang.String)\n\t */\n\tpublic static String getMethodForMessage(AjAttributeMethodStruct methodstructure) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"Method '\");\n\t\tsb.append(methodstructure.method.getReturnType().toString());\n\t\tsb.append(\" \").append(methodstructure.enclosingType).append(\".\").append(methodstructure.method.getName());\n\t\tsb.append(\"(\");\n\t\tType[] args = methodstructure.method.getArgumentTypes();\n\t\tif (args != null) {\n\t\t\tfor (int t = 0; t < args.length; t++) {\n\t\t\t\tif (t > 0) {\n\t\t\t\t\tsb.append(\",\");\n\t\t\t\t}\n\t\t\t\tsb.append(args[t].toString());\n\t\t\t}\n\t\t}\n\t\tsb.append(\")'\");\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Process any @DeclareMixin annotation.\n\t *\n\t * Example Declaration <br>\n\t *\n\t * @DeclareMixin(\"Foo+\") public I createImpl(Object o) { return new Impl(o); }\n\t *\n\t * <br>\n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if found\n\t */\n\tprivate static boolean handleDeclareMixinAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct) {\n\t\tAnnotationGen declareMixinAnnotation = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREMIXIN_ANNOTATION);\n\t\tif (declareMixinAnnotation == null) {\n\t\t\t// No annotation found\n\t\t\treturn false;\n\t\t}\n\t\tMethod annotatedMethod = struct.method;\n\t\tWorld world = struct.enclosingType.getWorld();\n\t\tNameValuePair declareMixinPatternNameValuePair = getAnnotationElement(declareMixinAnnotation, VALUE);\n\n\t\t// declareMixinPattern could be of the form \"Bar*\" or \"A || B\" or \"Foo+\"\n\t\tString declareMixinPattern = declareMixinPatternNameValuePair.getValue().stringifyValue();\n\t\tTypePattern targetTypePattern = parseTypePattern(declareMixinPattern, struct);\n\n\t\t// Return value of the annotated method is the interface or class that the mixin delegate should have\n\t\tResolvedType methodReturnType = UnresolvedType.forSignature(annotatedMethod.getReturnType().getSignature()).resolve(world);\n\t\tif (methodReturnType.isParameterizedOrRawType()) {\n\t\t\tmethodReturnType = methodReturnType.getGenericType();\n\t\t}\n\t\tif (methodReturnType.isPrimitiveType()) {\n\t\t\treportError(getMethodForMessage(struct) + \":  factory methods for a mixin cannot return void or a primitive type\",\n\t\t\t\t\tstruct);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (annotatedMethod.getArgumentTypes().length > 1) {\n\t\t\treportError(getMethodForMessage(struct) + \": factory methods for a mixin can take a maximum of one parameter\", struct);\n\t\t\treturn false;\n\t\t}\n\n\t\t// The set of interfaces to be mixed in is either:\n\t\t// supplied as a list in the 'Class[] interfaces' value in the annotation value\n\t\t// supplied as just the interface return value of the annotated method\n\t\t// supplied as just the class return value of the annotated method\n\t\tNameValuePair interfaceListSpecified = getAnnotationElement(declareMixinAnnotation, \"interfaces\");\n\n\t\tList<TypePattern> newParents = new ArrayList<>(1);\n\t\tList<ResolvedType> newInterfaceTypes = new ArrayList<>(1);\n\t\tif (interfaceListSpecified != null) {\n\t\t\tArrayElementValue arrayOfInterfaceTypes = (ArrayElementValue) interfaceListSpecified.getValue();\n\t\t\tint numberOfTypes = arrayOfInterfaceTypes.getElementValuesArraySize();\n\t\t\tElementValue[] theTypes = arrayOfInterfaceTypes.getElementValuesArray();\n\t\t\tfor (int i = 0; i < numberOfTypes; i++) {\n\t\t\t\tClassElementValue interfaceType = (ClassElementValue) theTypes[i];\n\t\t\t\t// Check: needs to be resolvable\n\t\t\t\t// TODO crappy replace required\n\t\t\t\tResolvedType ajInterfaceType = UnresolvedType.forSignature(interfaceType.getClassString().replace(\"/\", \".\"))\n\t\t\t\t\t\t.resolve(world);\n\t\t\t\tif (ajInterfaceType.isMissing() || !ajInterfaceType.isInterface()) {\n\t\t\t\t\treportError(\n\t\t\t\t\t\t\t\"Types listed in the 'interfaces' DeclareMixin annotation value must be valid interfaces. This is invalid: \"\n\t\t\t\t\t\t\t\t\t+ ajInterfaceType.getName(), struct); // TODO better error location, use the method position\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!ajInterfaceType.isAssignableFrom(methodReturnType)) {\n\t\t\t\t\treportError(getMethodForMessage(struct) + \": factory method does not return something that implements '\"\n\t\t\t\t\t\t\t+ ajInterfaceType.getName() + \"'\", struct);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tnewInterfaceTypes.add(ajInterfaceType);\n\t\t\t\t// Checking that it is a superinterface of the methods return value is done at weave time\n\t\t\t\tTypePattern newParent = parseTypePattern(ajInterfaceType.getName(), struct);\n\t\t\t\tnewParents.add(newParent);\n\t\t\t}\n\t\t} else {\n\t\t\tif (methodReturnType.isClass()) {\n\t\t\t\treportError(\n\t\t\t\t\t\tgetMethodForMessage(struct)\n\t\t\t\t\t\t\t\t+ \": factory methods for a mixin must either return an interface type or specify interfaces in the annotation and return a class\",\n\t\t\t\t\t\tstruct);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Use the method return type: this might be a class or an interface\n\t\t\tTypePattern newParent = parseTypePattern(methodReturnType.getName(), struct);\n\t\t\tnewInterfaceTypes.add(methodReturnType);\n\t\t\tnewParents.add(newParent);\n\t\t}\n\t\tif (newParents.size() == 0) {\n\t\t\t// Warning: did they foolishly put @DeclareMixin(value=\"Bar+\",interfaces={})\n\t\t\t// TODO output warning\n\t\t\treturn false;\n\t\t}\n\n\t\t// Create the declare parents that will add the interfaces to matching targets\n\t\tFormalBinding[] bindings = FormalBinding.NONE;\n\t\tIScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);\n\t\t// how do we mark this as a decp due to decmixin?\n\t\tDeclareParents dp = new DeclareParentsMixin(targetTypePattern, newParents);\n\t\tdp.resolve(binding);\n\t\ttargetTypePattern = dp.getChild();\n\n\t\tdp.setLocation(struct.context, -1, -1); // not ideal...\n\t\tstruct.ajAttributes.add(new AjAttribute.DeclareAttribute(dp));\n\n\t\t// The factory method for building the implementation is the\n\t\t// one attached to the annotation:\n\t\t// Method implementationFactory = struct.method;\n\n\t\tboolean hasAtLeastOneMethod = false;\n\n\t\tfor (ResolvedType typeForDelegation : newInterfaceTypes) {\n\t\t\t// TODO check for overlapping interfaces. Eg. A implements I, I extends J - if they specify interfaces={I,J} we dont\n\t\t\t// want to do any methods twice\n\t\t\tResolvedMember[] methods = typeForDelegation.getMethodsWithoutIterator(true, false, false).toArray(\n                    ResolvedMember.NONE);\n\t\t\tfor (ResolvedMember resolvedMember : methods) {\n\t\t\t\tResolvedMember method = resolvedMember;\n\t\t\t\tif (method.isAbstract()) {\n\t\t\t\t\thasAtLeastOneMethod = true;\n\t\t\t\t\tif (method.hasBackingGenericMember()) {\n\t\t\t\t\t\tmethod = method.getBackingGenericMember();\n\t\t\t\t\t}\n\t\t\t\t\tMethodDelegateTypeMunger mdtm = new MethodDelegateTypeMunger(method, struct.enclosingType, \"\",\n\t\t\t\t\t\t\ttargetTypePattern, struct.method.getName(), struct.method.getSignature());\n\t\t\t\t\tmdtm.setFieldType(methodReturnType);\n\t\t\t\t\tmdtm.setSourceLocation(struct.enclosingType.getSourceLocation());\n\t\t\t\t\tstruct.ajAttributes.add(new AjAttribute.TypeMunger(mdtm));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// if any method delegate was created then a field to hold the delegate instance must also be added\n\t\tif (hasAtLeastOneMethod) {\n\t\t\tResolvedMember fieldHost = AjcMemberMaker.itdAtDeclareParentsField(null, methodReturnType, struct.enclosingType);\n\t\t\tstruct.ajAttributes.add(new AjAttribute.TypeMunger(new MethodDelegateTypeMunger.FieldHostTypeMunger(fieldHost,\n\t\t\t\t\tstruct.enclosingType, targetTypePattern)));\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Read @Before\n\t *\n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if found\n\t */\n\tprivate static boolean handleBeforeAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut) {\n\t\tAnnotationGen before = getAnnotation(runtimeAnnotations, AjcMemberMaker.BEFORE_ANNOTATION);\n\t\tif (before != null) {\n\t\t\tNameValuePair beforeAdvice = getAnnotationElement(before, VALUE);\n\t\t\tif (beforeAdvice != null) {\n\t\t\t\t// this/target/args binding\n\t\t\t\tString argumentNames = getArgNamesValue(before);\n\t\t\t\tif (argumentNames != null) {\n\t\t\t\t\tstruct.unparsedArgumentNames = argumentNames;\n\t\t\t\t}\n\t\t\t\tFormalBinding[] bindings = FormalBinding.NONE;\n\t\t\t\ttry {\n\t\t\t\t\tbindings = extractBindings(struct);\n\t\t\t\t} catch (UnreadableDebugInfoException unreadableDebugInfoException) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tIScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);\n\n\t\t\t\t// joinpoint, staticJoinpoint binding\n\t\t\t\tint extraArgument = extractExtraArgument(struct.method);\n\n\t\t\t\tPointcut pc = null;\n\t\t\t\tif (preResolvedPointcut != null) {\n\t\t\t\t\tpc = preResolvedPointcut.getPointcut();\n\t\t\t\t\t// pc.resolve(binding);\n\t\t\t\t} else {\n\t\t\t\t\tpc = parsePointcut(beforeAdvice.getValue().stringifyValue(), struct, false);\n\t\t\t\t\tif (pc == null) {\n\t\t\t\t\t\treturn false;// parse error\n\t\t\t\t\t}\n\t\t\t\t\tpc = pc.resolve(binding);\n\t\t\t\t}\n\t\t\t\tsetIgnoreUnboundBindingNames(pc, bindings);\n\n\t\t\t\tISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(),\n\t\t\t\t\t\tstruct.bMethod.getDeclarationOffset());\n\t\t\t\tstruct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.Before, pc, extraArgument, sl.getOffset(), sl\n\t\t\t\t\t\t.getOffset() + 1,// FIXME AVASM\n\t\t\t\t\t\tstruct.context));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Read @After\n\t *\n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if found\n\t */\n\tprivate static boolean handleAfterAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut) {\n\t\tAnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTER_ANNOTATION);\n\t\tif (after != null) {\n\t\t\tNameValuePair afterAdvice = getAnnotationElement(after, VALUE);\n\t\t\tif (afterAdvice != null) {\n\t\t\t\t// this/target/args binding\n\t\t\t\tFormalBinding[] bindings = FormalBinding.NONE;\n\t\t\t\tString argumentNames = getArgNamesValue(after);\n\t\t\t\tif (argumentNames != null) {\n\t\t\t\t\tstruct.unparsedArgumentNames = argumentNames;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tbindings = extractBindings(struct);\n\t\t\t\t} catch (UnreadableDebugInfoException unreadableDebugInfoException) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tIScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);\n\n\t\t\t\t// joinpoint, staticJoinpoint binding\n\t\t\t\tint extraArgument = extractExtraArgument(struct.method);\n\n\t\t\t\tPointcut pc = null;\n\t\t\t\tif (preResolvedPointcut != null) {\n\t\t\t\t\tpc = preResolvedPointcut.getPointcut();\n\t\t\t\t} else {\n\t\t\t\t\tpc = parsePointcut(afterAdvice.getValue().stringifyValue(), struct, false);\n\t\t\t\t\tif (pc == null) {\n\t\t\t\t\t\treturn false;// parse error\n\t\t\t\t\t}\n\t\t\t\t\tpc.resolve(binding);\n\t\t\t\t}\n\t\t\t\tsetIgnoreUnboundBindingNames(pc, bindings);\n\n\t\t\t\tISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(),\n\t\t\t\t\t\tstruct.bMethod.getDeclarationOffset());\n\t\t\t\tstruct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.After, pc, extraArgument, sl.getOffset(), sl\n\t\t\t\t\t\t.getOffset() + 1,// FIXME AVASM\n\t\t\t\t\t\tstruct.context));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Read @AfterReturning\n\t *\n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if found\n\t */\n\tprivate static boolean handleAfterReturningAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut, BcelMethod owningMethod)\n\t\t\tthrows ReturningFormalNotDeclaredInAdviceSignatureException {\n\t\tAnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTERRETURNING_ANNOTATION);\n\t\tif (after != null) {\n\t\t\tNameValuePair annValue = getAnnotationElement(after, VALUE);\n\t\t\tNameValuePair annPointcut = getAnnotationElement(after, POINTCUT);\n\t\t\tNameValuePair annReturned = getAnnotationElement(after, RETURNING);\n\n\t\t\t// extract the pointcut and returned type/binding - do some checks\n\t\t\tString pointcut = null;\n\t\t\tString returned = null;\n\t\t\tif ((annValue != null && annPointcut != null) || (annValue == null && annPointcut == null)) {\n\t\t\t\treportError(\"@AfterReturning: either 'value' or 'poincut' must be provided, not both\", struct);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (annValue != null) {\n\t\t\t\tpointcut = annValue.getValue().stringifyValue();\n\t\t\t} else {\n\t\t\t\tpointcut = annPointcut.getValue().stringifyValue();\n\t\t\t}\n\t\t\tif (isNullOrEmpty(pointcut)) {\n\t\t\t\treportError(\"@AfterReturning: either 'value' or 'poincut' must be provided, not both\", struct);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (annReturned != null) {\n\t\t\t\treturned = annReturned.getValue().stringifyValue();\n\t\t\t\tif (isNullOrEmpty(returned)) {\n\t\t\t\t\treturned = null;\n\t\t\t\t} else {\n\t\t\t\t\t// check that thrownFormal exists as the last parameter in\n\t\t\t\t\t// the advice\n\t\t\t\t\tString[] pNames = owningMethod.getParameterNames();\n\t\t\t\t\tif (pNames == null || pNames.length == 0 || !Arrays.asList(pNames).contains(returned)) {\n\t\t\t\t\t\tthrow new ReturningFormalNotDeclaredInAdviceSignatureException(returned);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString argumentNames = getArgNamesValue(after);\n\t\t\tif (argumentNames != null) {\n\t\t\t\tstruct.unparsedArgumentNames = argumentNames;\n\t\t\t}\n\t\t\t// this/target/args binding\n\t\t\t// exclude the return binding from the pointcut binding since it is\n\t\t\t// an extraArg binding\n\t\t\tFormalBinding[] bindings = FormalBinding.NONE;\n\t\t\ttry {\n\t\t\t\tbindings = (returned == null ? extractBindings(struct) : extractBindings(struct, returned));\n\t\t\t} catch (UnreadableDebugInfoException unreadableDebugInfoException) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tIScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);\n\n\t\t\t// joinpoint, staticJoinpoint binding\n\t\t\tint extraArgument = extractExtraArgument(struct.method);\n\n\t\t\t// return binding\n\t\t\tif (returned != null) {\n\t\t\t\textraArgument |= Advice.ExtraArgument;\n\t\t\t}\n\n\t\t\tPointcut pc = null;\n\t\t\tif (preResolvedPointcut != null) {\n\t\t\t\tpc = preResolvedPointcut.getPointcut();\n\t\t\t} else {\n\t\t\t\tpc = parsePointcut(pointcut, struct, false);\n\t\t\t\tif (pc == null) {\n\t\t\t\t\treturn false;// parse error\n\t\t\t\t}\n\t\t\t\tpc.resolve(binding);\n\t\t\t}\n\t\t\tsetIgnoreUnboundBindingNames(pc, bindings);\n\n\t\t\tISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(),\n\t\t\t\t\tstruct.bMethod.getDeclarationOffset());\n\t\t\tstruct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.AfterReturning, pc, extraArgument, sl.getOffset(),\n\t\t\t\t\tsl.getOffset() + 1,// FIXME AVASM\n\t\t\t\t\tstruct.context));\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Read @AfterThrowing\n\t *\n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if found\n\t */\n\tprivate static boolean handleAfterThrowingAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut, BcelMethod owningMethod)\n\t\t\tthrows ThrownFormalNotDeclaredInAdviceSignatureException {\n\t\tAnnotationGen after = getAnnotation(runtimeAnnotations, AjcMemberMaker.AFTERTHROWING_ANNOTATION);\n\t\tif (after != null) {\n\t\t\tNameValuePair annValue = getAnnotationElement(after, VALUE);\n\t\t\tNameValuePair annPointcut = getAnnotationElement(after, POINTCUT);\n\t\t\tNameValuePair annThrown = getAnnotationElement(after, THROWING);\n\n\t\t\t// extract the pointcut and throwned type/binding - do some checks\n\t\t\tString pointcut = null;\n\t\t\tString thrownFormal = null;\n\t\t\tif ((annValue != null && annPointcut != null) || (annValue == null && annPointcut == null)) {\n\t\t\t\treportError(\"@AfterThrowing: either 'value' or 'poincut' must be provided, not both\", struct);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (annValue != null) {\n\t\t\t\tpointcut = annValue.getValue().stringifyValue();\n\t\t\t} else {\n\t\t\t\tpointcut = annPointcut.getValue().stringifyValue();\n\t\t\t}\n\t\t\tif (isNullOrEmpty(pointcut)) {\n\t\t\t\treportError(\"@AfterThrowing: either 'value' or 'poincut' must be provided, not both\", struct);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (annThrown != null) {\n\t\t\t\tthrownFormal = annThrown.getValue().stringifyValue();\n\t\t\t\tif (isNullOrEmpty(thrownFormal)) {\n\t\t\t\t\tthrownFormal = null;\n\t\t\t\t} else {\n\t\t\t\t\t// check that thrownFormal exists as the last parameter in\n\t\t\t\t\t// the advice\n\t\t\t\t\tString[] pNames = owningMethod.getParameterNames();\n\t\t\t\t\tif (pNames == null || pNames.length == 0 || !Arrays.asList(pNames).contains(thrownFormal)) {\n\t\t\t\t\t\tthrow new ThrownFormalNotDeclaredInAdviceSignatureException(thrownFormal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString argumentNames = getArgNamesValue(after);\n\t\t\tif (argumentNames != null) {\n\t\t\t\tstruct.unparsedArgumentNames = argumentNames;\n\t\t\t}\n\t\t\t// this/target/args binding\n\t\t\t// exclude the throwned binding from the pointcut binding since it\n\t\t\t// is an extraArg binding\n\t\t\tFormalBinding[] bindings = FormalBinding.NONE;\n\t\t\ttry {\n\t\t\t\tbindings = (thrownFormal == null ? extractBindings(struct) : extractBindings(struct, thrownFormal));\n\t\t\t} catch (UnreadableDebugInfoException unreadableDebugInfoException) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tIScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);\n\n\t\t\t// joinpoint, staticJoinpoint binding\n\t\t\tint extraArgument = extractExtraArgument(struct.method);\n\n\t\t\t// return binding\n\t\t\tif (thrownFormal != null) {\n\t\t\t\textraArgument |= Advice.ExtraArgument;\n\t\t\t}\n\n\t\t\tPointcut pc = null;\n\t\t\tif (preResolvedPointcut != null) {\n\t\t\t\tpc = preResolvedPointcut.getPointcut();\n\t\t\t} else {\n\t\t\t\tpc = parsePointcut(pointcut, struct, false);\n\t\t\t\tif (pc == null) {\n\t\t\t\t\treturn false;// parse error\n\t\t\t\t}\n\t\t\t\tpc.resolve(binding);\n\t\t\t}\n\t\t\tsetIgnoreUnboundBindingNames(pc, bindings);\n\n\t\t\tISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(),\n\t\t\t\t\tstruct.bMethod.getDeclarationOffset());\n\t\t\tstruct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.AfterThrowing, pc, extraArgument, sl.getOffset(), sl\n\t\t\t\t\t.getOffset() + 1, struct.context));\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Read @Around\n\t *\n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if found\n\t */\n\tprivate static boolean handleAroundAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut) {\n\t\tAnnotationGen around = getAnnotation(runtimeAnnotations, AjcMemberMaker.AROUND_ANNOTATION);\n\t\tif (around != null) {\n\t\t\tNameValuePair aroundAdvice = getAnnotationElement(around, VALUE);\n\t\t\tif (aroundAdvice != null) {\n\t\t\t\t// this/target/args binding\n\t\t\t\tString argumentNames = getArgNamesValue(around);\n\t\t\t\tif (argumentNames != null) {\n\t\t\t\t\tstruct.unparsedArgumentNames = argumentNames;\n\t\t\t\t}\n\t\t\t\tFormalBinding[] bindings = FormalBinding.NONE;\n\t\t\t\ttry {\n\t\t\t\t\tbindings = extractBindings(struct);\n\t\t\t\t} catch (UnreadableDebugInfoException unreadableDebugInfoException) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tIScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);\n\n\t\t\t\t// joinpoint, staticJoinpoint binding\n\t\t\t\tint extraArgument = extractExtraArgument(struct.method);\n\n\t\t\t\tPointcut pc = null;\n\t\t\t\tif (preResolvedPointcut != null) {\n\t\t\t\t\tpc = preResolvedPointcut.getPointcut();\n\t\t\t\t} else {\n\t\t\t\t\tpc = parsePointcut(aroundAdvice.getValue().stringifyValue(), struct, false);\n\t\t\t\t\tif (pc == null) {\n\t\t\t\t\t\treturn false;// parse error\n\t\t\t\t\t}\n\t\t\t\t\tpc.resolve(binding);\n\t\t\t\t}\n\t\t\t\tsetIgnoreUnboundBindingNames(pc, bindings);\n\n\t\t\t\tISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(),\n\t\t\t\t\t\tstruct.bMethod.getDeclarationOffset());\n\t\t\t\tstruct.ajAttributes.add(new AjAttribute.AdviceAttribute(AdviceKind.Around, pc, extraArgument, sl.getOffset(), sl\n\t\t\t\t\t\t.getOffset() + 1,// FIXME AVASM\n\t\t\t\t\t\tstruct.context));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Read @Pointcut and handle the resolving in a lazy way to deal with pointcut references\n\t *\n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if a pointcut was handled\n\t */\n\tprivate static boolean handlePointcutAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct) {\n\t\tAnnotationGen pointcut = getAnnotation(runtimeAnnotations, AjcMemberMaker.POINTCUT_ANNOTATION);\n\t\tif (pointcut == null) {\n\t\t\treturn false;\n\t\t}\n\t\tNameValuePair pointcutExpr = getAnnotationElement(pointcut, VALUE);\n\n\t\t// semantic check: the method must return void, or be\n\t\t// \"public static boolean\" for if() support\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\n\t\t\treportWarning(\"Found @Pointcut on a method not returning 'void' or not 'public static boolean'\", struct);\n\t\t\t// no need to stop\n\t\t}\n\n\t\t// semantic check: the method must not throw anything\n\t\tif (struct.method.getExceptionTable() != null) {\n\t\t\treportWarning(\"Found @Pointcut on a method throwing exception\", struct);\n\t\t\t// no need to stop\n\t\t}\n\n\t\tString argumentNames = getArgNamesValue(pointcut);\n\t\tif (argumentNames != null) {\n\t\t\tstruct.unparsedArgumentNames = argumentNames;\n\t\t}\n\t\t// this/target/args binding\n\t\tfinal IScope binding;\n\t\ttry {\n\t\t\tif (struct.method.isAbstract()) {\n\t\t\t\tbinding = null;\n\t\t\t} else {\n\t\t\t\tbinding = new BindingScope(struct.enclosingType, struct.context, extractBindings(struct));\n\t\t\t}\n\t\t} catch (UnreadableDebugInfoException e) {\n\t\t\treturn false;\n\t\t}\n\n\t\tUnresolvedType[] argumentTypes = new UnresolvedType[struct.method.getArgumentTypes().length];\n\t\tfor (int i = 0; i < argumentTypes.length; i++) {\n\t\t\targumentTypes[i] = UnresolvedType.forSignature(struct.method.getArgumentTypes()[i].getSignature());\n\t\t}\n\n\t\tPointcut pc = null;\n\t\tif (struct.method.isAbstract()) {\n\t\t\tif ((pointcutExpr != null && isNullOrEmpty(pointcutExpr.getValue().stringifyValue())) || pointcutExpr == null) {\n\t\t\t\t// abstract pointcut\n\t\t\t\t// leave pc = null\n\t\t\t} else {\n\t\t\t\treportError(\"Found defined @Pointcut on an abstract method\", struct);\n\t\t\t\treturn false;// stop\n\t\t\t}\n\t\t} else {\n\t\t\tif (pointcutExpr == null || isNullOrEmpty(pointcutExpr.getValue().stringifyValue())) {\n\t\t\t\t// the matches nothing pointcut (125475/125480) - perhaps not as\n\t\t\t\t// cleanly supported as it could be.\n\t\t\t} else {\n\t\t\t\t// if (pointcutExpr != null) {\n\t\t\t\t// use a LazyResolvedPointcutDefinition so that the pointcut is\n\t\t\t\t// resolved lazily\n\t\t\t\t// since for it to be resolved, we will need other pointcuts to\n\t\t\t\t// be registered as well\n\t\t\t\tpc = parsePointcut(pointcutExpr.getValue().stringifyValue(), struct, true);\n\t\t\t\tif (pc == null) {\n\t\t\t\t\treturn false;// parse error\n\t\t\t\t}\n\t\t\t\tpc.setLocation(struct.context, -1, -1);// FIXME AVASM !! bMethod\n\t\t\t\t// is null here..\n\t\t\t\t// } else {\n\t\t\t\t// reportError(\"Found undefined @Pointcut on a non-abstract method\",\n\t\t\t\t// struct);\n\t\t\t\t// return false;\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t\t// do not resolve binding now but lazily\n\t\tstruct.ajAttributes.add(new AjAttribute.PointcutDeclarationAttribute(new LazyResolvedPointcutDefinition(\n\t\t\t\tstruct.enclosingType, struct.method.getModifiers(), struct.method.getName(), argumentTypes, UnresolvedType\n\t\t\t\t\t\t.forSignature(struct.method.getReturnType().getSignature()), pc,// can\n\t\t\t\t// be\n\t\t\t\t// null\n\t\t\t\t// for\n\t\t\t\t// abstract\n\t\t\t\t// pointcut\n\t\t\t\tbinding // can be null for abstract pointcut\n\t\t\t\t)));\n\t\treturn true;\n\t}\n\n\t/**\n\t * Read @DeclareError, @DeclareWarning\n\t *\n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if found\n\t */\n\tprivate static boolean handleDeclareErrorOrWarningAnnotation(AsmManager model, RuntimeAnnos runtimeAnnotations,\n\t\t\tAjAttributeFieldStruct struct) {\n\t\tAnnotationGen error = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREERROR_ANNOTATION);\n\t\tboolean hasError = false;\n\t\tif (error != null) {\n\t\t\tNameValuePair declareError = getAnnotationElement(error, VALUE);\n\t\t\tif (declareError != null) {\n\t\t\t\tif (!STRING_DESC.equals(struct.field.getSignature()) || struct.field.getConstantValue() == null) {\n\t\t\t\t\treportError(\"@DeclareError used on a non String constant field\", struct);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tPointcut pc = parsePointcut(declareError.getValue().stringifyValue(), struct, false);\n\t\t\t\tif (pc == null) {\n\t\t\t\t\thasError = false;// cannot parse pointcut\n\t\t\t\t} else {\n\t\t\t\t\tDeclareErrorOrWarning deow = new DeclareErrorOrWarning(true, pc, struct.field.getConstantValue().toString());\n\t\t\t\t\tsetDeclareErrorOrWarningLocation(model, deow, struct);\n\t\t\t\t\tstruct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));\n\t\t\t\t\thasError = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tAnnotationGen warning = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREWARNING_ANNOTATION);\n\t\tboolean hasWarning = false;\n\t\tif (warning != null) {\n\t\t\tNameValuePair declareWarning = getAnnotationElement(warning, VALUE);\n\t\t\tif (declareWarning != null) {\n\t\t\t\tif (!STRING_DESC.equals(struct.field.getSignature()) || struct.field.getConstantValue() == null) {\n\t\t\t\t\treportError(\"@DeclareWarning used on a non String constant field\", struct);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tPointcut pc = parsePointcut(declareWarning.getValue().stringifyValue(), struct, false);\n\t\t\t\tif (pc == null) {\n\t\t\t\t\thasWarning = false;// cannot parse pointcut\n\t\t\t\t} else {\n\t\t\t\t\tDeclareErrorOrWarning deow = new DeclareErrorOrWarning(false, pc, struct.field.getConstantValue().toString());\n\t\t\t\t\tsetDeclareErrorOrWarningLocation(model, deow, struct);\n\t\t\t\t\tstruct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));\n\t\t\t\t\treturn hasWarning = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hasError || hasWarning;\n\t}\n\n\t/**\n\t * Sets the location for the declare error / warning using the corresponding IProgramElement in the structure model. This will\n\t * only fix bug 120356 if compiled with -emacssym, however, it does mean that the cross references view in AJDT will show the\n\t * correct information.\n\t *\n\t * Other possibilities for fix: 1. using the information in ajcDeclareSoft (if this is set correctly) which will fix the problem\n\t * if compiled with ajc but not if compiled with javac. 2. creating an AjAttribute called FieldDeclarationLineNumberAttribute\n\t * (much like MethodDeclarationLineNumberAttribute) which we can ask for the offset. This will again only fix bug 120356 when\n\t * compiled with ajc.\n\t *\n\t * @param deow\n\t * @param struct\n\t */\n\tprivate static void setDeclareErrorOrWarningLocation(AsmManager model, DeclareErrorOrWarning deow, AjAttributeFieldStruct struct) {\n\t\tIHierarchy top = (model == null ? null : model.getHierarchy());\n\t\tif (top != null && top.getRoot() != null) {\n\t\t\tIProgramElement ipe = top.findElementForLabel(top.getRoot(), IProgramElement.Kind.FIELD, struct.field.getName());\n\t\t\tif (ipe != null && ipe.getSourceLocation() != null) {\n\t\t\t\tISourceLocation sourceLocation = ipe.getSourceLocation();\n\t\t\t\tint start = sourceLocation.getOffset();\n\t\t\t\tint end = start + struct.field.getName().length();\n\t\t\t\tdeow.setLocation(struct.context, start, end);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdeow.setLocation(struct.context, -1, -1);\n\t}\n\n\t/**\n\t * Returns a readable representation of a method. Method.toString() is not suitable.\n\t *\n\t * @param method\n\t * @return a readable representation of a method\n\t */\n\tprivate static String methodToString(Method method) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(method.getName());\n\t\tsb.append(method.getSignature());\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Build the bindings for a given method (pointcut / advice)\n\t *\n\t * @param struct\n\t * @return null if no debug info is available\n\t */\n\tprivate static FormalBinding[] extractBindings(AjAttributeMethodStruct struct) throws UnreadableDebugInfoException {\n\t\tMethod method = struct.method;\n\t\tString[] argumentNames = struct.getArgumentNames();\n\n\t\t// assert debug info was here\n\t\tif (argumentNames.length != method.getArgumentTypes().length) {\n\t\t\treportError(\n\t\t\t\t\t\"Cannot read debug info for @Aspect to handle formal binding in pointcuts (please compile with 'javac -g' or '<javac debug='true'.../>' in Ant)\",\n\t\t\t\t\tstruct);\n\t\t\tthrow new UnreadableDebugInfoException();\n\t\t}\n\n\t\tList<FormalBinding> bindings = new ArrayList<>();\n\t\tfor (int i = 0; i < argumentNames.length; i++) {\n\t\t\tString argumentName = argumentNames[i];\n\t\t\tUnresolvedType argumentType = UnresolvedType.forSignature(method.getArgumentTypes()[i].getSignature());\n\n\t\t\t// do not bind JoinPoint / StaticJoinPoint /\n\t\t\t// EnclosingStaticJoinPoint\n\t\t\t// TODO solve me : this means that the JP/SJP/ESJP cannot appear as\n\t\t\t// binding\n\t\t\t// f.e. when applying advice on advice etc\n\t\t\tif ((AjcMemberMaker.TYPEX_JOINPOINT.equals(argumentType)\n\t\t\t\t\t|| AjcMemberMaker.TYPEX_PROCEEDINGJOINPOINT.equals(argumentType)\n\t\t\t\t\t|| AjcMemberMaker.TYPEX_STATICJOINPOINT.equals(argumentType)\n\t\t\t\t\t|| AjcMemberMaker.TYPEX_ENCLOSINGSTATICJOINPOINT.equals(argumentType) || AjcMemberMaker.AROUND_CLOSURE_TYPE\n\t\t\t\t\t\t.equals(argumentType))) {\n\t\t\t\t// continue;// skip\n\t\t\t\tbindings.add(new FormalBinding.ImplicitFormalBinding(argumentType, argumentName, i));\n\t\t\t} else {\n\t\t\t\tbindings.add(new FormalBinding(argumentType, argumentName, i));\n\t\t\t}\n\t\t}\n\n\t\treturn bindings.toArray(FormalBinding.NONE);\n\t}\n\n\t// FIXME alex deal with exclude index\n\tprivate static FormalBinding[] extractBindings(AjAttributeMethodStruct struct, String excludeFormal)\n\t\t\tthrows UnreadableDebugInfoException {\n\t\tFormalBinding[] bindings = extractBindings(struct);\n\t\t// int excludeIndex = -1;\n\t\tfor (int i = 0; i < bindings.length; i++) {\n\t\t\tFormalBinding binding = bindings[i];\n\t\t\tif (binding.getName().equals(excludeFormal)) {\n\t\t\t\t// excludeIndex = i;\n\t\t\t\tbindings[i] = new FormalBinding.ImplicitFormalBinding(binding.getType(), binding.getName(), binding.getIndex());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn bindings;\n\t\t//\n\t\t// if (excludeIndex >= 0) {\n\t\t// FormalBinding[] bindingsFiltered = new\n\t\t// FormalBinding[bindings.length-1];\n\t\t// int k = 0;\n\t\t// for (int i = 0; i < bindings.length; i++) {\n\t\t// if (i == excludeIndex) {\n\t\t// ;\n\t\t// } else {\n\t\t// bindingsFiltered[k] = new FormalBinding(bindings[i].getType(),\n\t\t// bindings[i].getName(), k);\n\t\t// k++;\n\t\t// }\n\t\t// }\n\t\t// return bindingsFiltered;\n\t\t// } else {\n\t\t// return bindings;\n\t\t// }\n\t}\n\n\t/**\n\t * Compute the flag for the xxxJoinPoint extra argument\n\t *\n\t * @param method\n\t * @return extra arg flag\n\t */\n\tprivate static int extractExtraArgument(Method method) {\n\t\tType[] methodArgs = method.getArgumentTypes();\n\t\tString[] sigs = new String[methodArgs.length];\n\t\tfor (int i = 0; i < methodArgs.length; i++) {\n\t\t\tsigs[i] = methodArgs[i].getSignature();\n\t\t}\n\t\treturn extractExtraArgument(sigs);\n\t}\n\n\t/**\n\t * Compute the flag for the xxxJoinPoint extra argument\n\t *\n\t * @param argumentSignatures\n\t * @return extra arg flag\n\t */\n\tpublic static int extractExtraArgument(String[] argumentSignatures) {\n\t\tint extraArgument = 0;\n\t\tfor (String argumentSignature : argumentSignatures) {\n\t\t\tif (AjcMemberMaker.TYPEX_JOINPOINT.getSignature().equals(argumentSignature)) {\n\t\t\t\textraArgument |= Advice.ThisJoinPoint;\n\t\t\t} else if (AjcMemberMaker.TYPEX_PROCEEDINGJOINPOINT.getSignature().equals(argumentSignature)) {\n\t\t\t\textraArgument |= Advice.ThisJoinPoint;\n\t\t\t} else if (AjcMemberMaker.TYPEX_STATICJOINPOINT.getSignature().equals(argumentSignature)) {\n\t\t\t\textraArgument |= Advice.ThisJoinPointStaticPart;\n\t\t\t} else if (AjcMemberMaker.TYPEX_ENCLOSINGSTATICJOINPOINT.getSignature().equals(argumentSignature)) {\n\t\t\t\textraArgument |= Advice.ThisEnclosingJoinPointStaticPart;\n\t\t\t}\n\t\t}\n\t\treturn extraArgument;\n\t}\n\n\t/**\n\t * Returns the runtime (RV/RIV) annotation of type annotationType or null if no such annotation\n\t *\n\t * @param rvs\n\t * @param annotationType\n\t * @return annotation\n\t */\n\tprivate static AnnotationGen getAnnotation(RuntimeAnnos rvs, UnresolvedType annotationType) {\n\t\tfinal String annotationTypeName = annotationType.getName();\n\t\tfor (AnnotationGen rv : rvs.getAnnotations()) {\n\t\t\tif (annotationTypeName.equals(rv.getTypeName())) {\n\t\t\t\treturn rv;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the value of a given element of an annotation or null if not found Caution: Does not handles default value.\n\t *\n\t * @param annotation\n\t * @param elementName\n\t * @return annotation NVP\n\t */\n\tprivate static NameValuePair getAnnotationElement(AnnotationGen annotation, String elementName) {\n\t\tfor (NameValuePair element : annotation.getValues()) {\n\t\t\tif (elementName.equals(element.getNameString())) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Return the argNames set for an annotation or null if it is not specified.\n\t */\n\tprivate static String getArgNamesValue(AnnotationGen anno) {\n\t\tList<NameValuePair> elements = anno.getValues();\n\t\tfor (NameValuePair element : elements) {\n\t\t\tif (ARGNAMES.equals(element.getNameString())) {\n\t\t\t\treturn element.getValue().stringifyValue();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static String lastbit(String fqname) {\n\t\tint i = fqname.lastIndexOf(\".\");\n\t\tif (i == -1) {\n\t\t\treturn fqname;\n\t\t} else {\n\t\t\treturn fqname.substring(i + 1);\n\t\t}\n\t}\n\n\t/**\n\t * Extract the method argument names. First we try the debug info attached to the method (the LocalVariableTable) - if we cannot\n\t * find that we look to use the argNames value that may have been supplied on the associated annotation. If that fails we just\n\t * don't know and return an empty string.\n\t *\n\t * @param method\n\t * @param argNamesFromAnnotation\n\t * @param methodStruct\n\t * @return method argument names\n\t */\n\tprivate static String[] getMethodArgumentNames(Method method, String argNamesFromAnnotation,\n\t\t\tAjAttributeMethodStruct methodStruct) {\n\t\tif (method.getArgumentTypes().length == 0) {\n\t\t\treturn EMPTY_STRINGS;\n\t\t}\n\n\t\tfinal int startAtStackIndex = method.isStatic() ? 0 : 1;\n\t\tfinal List<MethodArgument> arguments = new ArrayList<>();\n\t\tLocalVariableTable lt = method.getLocalVariableTable();\n\t\tif (lt != null) {\n\t\t\tLocalVariable[] lvt = lt.getLocalVariableTable();\n\t\t\tfor (LocalVariable localVariable : lvt) {\n\t\t\t\tif (localVariable != null) { // pr348488\n\t\t\t\t\tif (localVariable.getStartPC() == 0) {\n\t\t\t\t\t\tif (localVariable.getIndex() >= startAtStackIndex) {\n\t\t\t\t\t\t\targuments.add(new MethodArgument(localVariable.getName(), localVariable.getIndex()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tString typename = (methodStruct.enclosingType != null ? methodStruct.enclosingType.getName() : \"\");\n\t\t\t\t\tSystem.err.println(\"AspectJ: 348488 debug: unusual local variable table for method \" + typename + \".\"\n\t\t\t\t\t\t\t+ method.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (arguments.size() == 0) {\n\t\t\t\t// The local variable table is causing us trouble, try the annotation value\n\t\t\t\t// See 539121 for a jacoco variant of the cobertura issue below\n\t\t\t\tif (argNamesFromAnnotation != null) {\n\t\t\t\t\tString[] argNames = extractArgNamesFromAnnotationValue(method, argNamesFromAnnotation, methodStruct);\n\t\t\t\t\tif (argNames.length != 0) {\n\t\t\t\t\t\treturn argNames;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// could be cobertura code where some extra bytecode has been stuffed in at the start of the method\n\t\t\t\t// but the local variable table hasn't been repaired - for example:\n\t\t\t\t// LocalVariable(start_pc = 6, length = 40, index = 0:com.example.ExampleAspect this)\n\t\t\t\t// LocalVariable(start_pc = 6, length = 40, index = 1:org.aspectj.lang.ProceedingJoinPoint pjp)\n\t\t\t\t// LocalVariable(start_pc = 6, length = 40, index = 2:int __cobertura__line__number__)\n\t\t\t\t// LocalVariable(start_pc = 6, length = 40, index = 3:int __cobertura__branch__number__)\n\t\t\t\tif (lvt.length > 0) {\n\t\t\t\t\t// If 0 this may be a bridge synthetic method that was advice annotated in\n\t\t\t\t\t// a parent abstract class. \n\t\t\t\t\tLocalVariable localVariable = lvt[0];\n\t\t\t\t\tif (localVariable != null) { // pr348488\n\t\t\t\t\t\tif (localVariable.getStartPC() != 0) {\n\t\t\t\t\t\t\t// looks suspicious so let's use this information\n\t\t\t\t\t\t\tfor (int j = 0; j < lvt.length && arguments.size() < method.getArgumentTypes().length; j++) {\n\t\t\t\t\t\t\t\tlocalVariable = lvt[j];\n\t\t\t\t\t\t\t\tif (localVariable.getIndex() >= startAtStackIndex) {\n\t\t\t\t\t\t\t\t\targuments.add(new MethodArgument(localVariable.getName(), localVariable.getIndex()));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n//\t\t\t\t} else if (method.isBridge()) {\n//\t\t\t\t\tmethod.\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (argNamesFromAnnotation != null) {\n\t\t\t\tString[] argNames = extractArgNamesFromAnnotationValue(method, argNamesFromAnnotation, methodStruct);\n\t\t\t\tif (argNames != null) {\n\t\t\t\t\treturn argNames;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (arguments.size() != method.getArgumentTypes().length) {\n\t\t\treturn EMPTY_STRINGS;\n\t\t}\n\n\t\t// sort by index\n\t\targuments.sort(new Comparator<MethodArgument>() {\n\t\t\tpublic int compare(MethodArgument mo, MethodArgument mo1) {\n\t\t\t\tif (mo.indexOnStack == mo1.indexOnStack) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} else if (mo.indexOnStack > mo1.indexOnStack) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tString[] argumentNames = new String[arguments.size()];\n\t\tint i = 0;\n\t\tfor (MethodArgument methodArgument : arguments) {\n\t\t\targumentNames[i++] = methodArgument.name;\n\t\t}\n\t\treturn argumentNames;\n\t}\n\n\tprivate static String[] extractArgNamesFromAnnotationValue(Method method, String argNamesFromAnnotation,\n\t\t\tAjAttributeMethodStruct methodStruct) {\n\t\tStringTokenizer st = new StringTokenizer(argNamesFromAnnotation, \" ,\");\n\t\tList<String> args = new ArrayList<>();\n\t\twhile (st.hasMoreTokens()) {\n\t\t\targs.add(st.nextToken());\n\t\t}\n\t\tif (args.size() != method.getArgumentTypes().length) {\n\t\t\tStringBuilder shortString = new StringBuilder().append(lastbit(method.getReturnType().toString())).append(\" \")\n\t\t\t\t\t.append(method.getName());\n\t\t\tif (method.getArgumentTypes().length > 0) {\n\t\t\t\tshortString.append(\"(\");\n\t\t\t\tfor (int i = 0; i < method.getArgumentTypes().length; i++) {\n\t\t\t\t\tshortString.append(lastbit(method.getArgumentTypes()[i].toString()));\n\t\t\t\t\tif ((i + 1) < method.getArgumentTypes().length) {\n\t\t\t\t\t\tshortString.append(\",\");\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tshortString.append(\")\");\n\t\t\t}\n\t\t\treportError(\"argNames annotation value does not specify the right number of argument names for the method '\"\n\t\t\t\t\t+ shortString.toString() + \"'\", methodStruct);\n\t\t\treturn EMPTY_STRINGS;\n\t\t}\n\t\treturn args.toArray(new String[] {});\n\t}\n\n\t/**\n\t * A method argument, used for sorting by indexOnStack (ie order in signature)\n\t *\n\t * @author <a href=\"mailto:alex AT gnilux DOT com\">Alexandre Vasseur</a>\n\t */\n\tprivate static class MethodArgument {\n\t\tString name;\n\t\tint indexOnStack;\n\n\t\tpublic MethodArgument(String name, int indexOnStack) {\n\t\t\tthis.name = name;\n\t\t\tthis.indexOnStack = indexOnStack;\n\t\t}\n\t}\n\n\t/**\n\t * LazyResolvedPointcutDefinition lazyly resolve the pointcut so that we have time to register all pointcut referenced before\n\t * pointcut resolution happens\n\t *\n\t * @author Alexandre Vasseur (alex AT gnilux DOT com)\n\t */\n\tpublic static class LazyResolvedPointcutDefinition extends ResolvedPointcutDefinition {\n\t\tprivate final Pointcut m_pointcutUnresolved; // null for abstract\n\t\t// pointcut\n\t\tprivate final IScope m_binding;\n\n\t\tprivate Pointcut m_lazyPointcut = null;\n\n\t\tpublic LazyResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name,\n\t\t\t\tUnresolvedType[] parameterTypes, UnresolvedType returnType, Pointcut pointcut, IScope binding) {\n\t\t\tsuper(declaringType, modifiers, name, parameterTypes, returnType, Pointcut.makeMatchesNothing(Pointcut.RESOLVED));\n\t\t\tm_pointcutUnresolved = pointcut;\n\t\t\tm_binding = binding;\n\t\t}\n\n\t\t@Override\n\t\tpublic Pointcut getPointcut() {\n\t\t\tif (m_lazyPointcut == null && m_pointcutUnresolved == null) {\n\t\t\t\tm_lazyPointcut = Pointcut.makeMatchesNothing(Pointcut.CONCRETE);\n\t\t\t}\n\t\t\tif (m_lazyPointcut == null && m_pointcutUnresolved != null) {\n\t\t\t\tm_lazyPointcut = m_pointcutUnresolved.resolve(m_binding);\n\t\t\t\tm_lazyPointcut.copyLocationFrom(m_pointcutUnresolved);\n\t\t\t}\n\t\t\treturn m_lazyPointcut;\n\t\t}\n\t}\n\n\t/**\n\t * Helper to test empty strings\n\t *\n\t * @param s\n\t * @return true if empty or null\n\t */\n\tprivate static boolean isNullOrEmpty(String s) {\n\t\treturn (s == null || s.length() <= 0);\n\t}\n\n\t/**\n\t * Set the pointcut bindings for which to ignore unbound issues, so that we can implicitly bind xxxJoinPoint for @AJ advices\n\t *\n\t * @param pointcut\n\t * @param bindings\n\t */\n\tprivate static void setIgnoreUnboundBindingNames(Pointcut pointcut, FormalBinding[] bindings) {\n\t\t// register ImplicitBindings as to be ignored since unbound\n\t\t// TODO is it likely to fail in a bad way if f.e. this(jp) etc ?\n\t\tList<String> ignores = new ArrayList<>();\n\t\tfor (FormalBinding formalBinding : bindings) {\n\t\t\tif (formalBinding instanceof FormalBinding.ImplicitFormalBinding) {\n\t\t\t\tignores.add(formalBinding.getName());\n\t\t\t}\n\t\t}\n\t\tpointcut.m_ignoreUnboundBindingForNames = ignores.toArray(new String[0]);\n\t}\n\n\t/**\n\t * A check exception when we cannot read debug info (needed for formal binding)\n\t */\n\tprivate static class UnreadableDebugInfoException extends Exception {\n\t}\n\n\t/**\n\t * Report an error\n\t *\n\t * @param message\n\t * @param location\n\t */\n\tprivate static void reportError(String message, AjAttributeStruct location) {\n\t\tif (!location.handler.isIgnoring(IMessage.ERROR)) {\n\t\t\tlocation.handler.handleMessage(new Message(message, location.enclosingType.getSourceLocation(), true));\n\t\t}\n\t}\n\n\t// private static void reportError(String message, IMessageHandler handler, ISourceLocation sourceLocation) {\n\t// if (!handler.isIgnoring(IMessage.ERROR)) {\n\t// handler.handleMessage(new Message(message, sourceLocation, true));\n\t// }\n\t// }\n\n\t/**\n\t * Report a warning\n\t *\n\t * @param message\n\t * @param location\n\t */\n\tprivate static void reportWarning(String message, AjAttributeStruct location) {\n\t\tif (!location.handler.isIgnoring(IMessage.WARNING)) {\n\t\t\tlocation.handler.handleMessage(new Message(message, location.enclosingType.getSourceLocation(), false));\n\t\t}\n\t}\n\n\t/**\n\t * Parse the given pointcut, return null on failure and issue an error\n\t *\n\t * @param pointcutString\n\t * @param struct\n\t * @param allowIf\n\t * @return pointcut, unresolved\n\t */\n\tprivate static Pointcut parsePointcut(String pointcutString, AjAttributeStruct struct, boolean allowIf) {\n\t\ttry {\n\t\t\tPatternParser parser = new PatternParser(pointcutString, struct.context);\n\t\t\tPointcut pointcut = parser.parsePointcut();\n\t\t\tparser.checkEof();\n\t\t\tpointcut.check(null, struct.enclosingType.getWorld());\n\t\t\tif (!allowIf && pointcutString.contains(\"if()\") && hasIf(pointcut)) {\n\t\t\t\treportError(\"if() pointcut is not allowed at this pointcut location '\" + pointcutString + \"'\", struct);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpointcut.setLocation(struct.context, -1, -1);// FIXME -1,-1 is not\n\t\t\t// good enough\n\t\t\treturn pointcut;\n\t\t} catch (ParserException e) {\n\t\t\treportError(\"Invalid pointcut '\" + pointcutString + \"': \" + e.toString()\n\t\t\t\t\t+ (e.getLocation() == null ? \"\" : \" at position \" + e.getLocation().getStart()), struct);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static boolean hasIf(Pointcut pointcut) {\n\t\tIfFinder visitor = new IfFinder();\n\t\tpointcut.accept(visitor, null);\n\t\treturn visitor.hasIf;\n\t}\n\n\t/**\n\t * Parse the given type pattern, return null on failure and issue an error\n\t *\n\t * @param patternString\n\t * @param location\n\t * @return type pattern\n\t */\n\tprivate static TypePattern parseTypePattern(String patternString, AjAttributeStruct location) {\n\t\ttry {\n\t\t\tTypePattern typePattern = new PatternParser(patternString).parseTypePattern();\n\t\t\ttypePattern.setLocation(location.context, -1, -1);// FIXME -1,-1 is\n\t\t\t// not good\n\t\t\t// enough\n\t\t\treturn typePattern;\n\t\t} catch (ParserException e) {\n\t\t\treportError(\"Invalid type pattern'\" + patternString + \"' : \" + e.getLocation(), location);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tstatic class ThrownFormalNotDeclaredInAdviceSignatureException extends Exception {\n\n\t\tprivate final String formalName;\n\n\t\tpublic ThrownFormalNotDeclaredInAdviceSignatureException(String formalName) {\n\t\t\tthis.formalName = formalName;\n\t\t}\n\n\t\tpublic String getFormalName() {\n\t\t\treturn formalName;\n\t\t}\n\t}\n\n\tstatic class ReturningFormalNotDeclaredInAdviceSignatureException extends Exception {\n\n\t\tprivate final String formalName;\n\n\t\tpublic ReturningFormalNotDeclaredInAdviceSignatureException(String formalName) {\n\t\t\tthis.formalName = formalName;\n\t\t}\n\n\t\tpublic String getFormalName() {\n\t\t\treturn formalName;\n\t\t}\n\t}\n}\n",
    "size": 77865
  },
  {
    "file_id": "F7",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelAccessForInlineMunger.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Alexandre Vasseur         initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.apache.bcel.generic.FieldInstruction;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.InvokeDynamic;\nimport org.aspectj.apache.bcel.generic.InvokeInstruction;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjcMemberMaker;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.UnresolvedType;\n\n/**\n * Looks for all access to method or field that are not public within the body of the around advices and replace the invocations to\n * a wrapper call so that the around advice can further be inlined.\n * <p>\n * This munger is used for @AJ aspects for which inlining wrapper is not done at compile time.\n * </p>\n * <p>\n * Specific state and logic is kept in the munger ala ITD so that call/get/set pointcuts can still be matched on the wrapped member\n * thanks to the EffectiveSignature attribute.\n * </p>\n *\n * @author Alexandre Vasseur\n * @author Andy Clement\n */\npublic class BcelAccessForInlineMunger extends BcelTypeMunger {\n\n\tprivate Map<String, ResolvedMember> inlineAccessors;\n\n\tprivate LazyClassGen aspectGen;\n\n\t/**\n\t * The wrapper methods representing any created inlineAccessors\n\t */\n\tprivate Set<LazyMethodGen> inlineAccessorMethodGens;\n\n\tpublic BcelAccessForInlineMunger(ResolvedType aspectType) {\n\t\tsuper(null, aspectType);\n\t\tif (aspectType.getWorld().isXnoInline()) {\n\t\t\tthrow new Error(\"This should not happen\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean munge(BcelClassWeaver weaver) {\n\t\taspectGen = weaver.getLazyClassGen();\n\t\tinlineAccessors = new HashMap<>(0);\n\t\tinlineAccessorMethodGens = new HashSet<>();\n\n\t\t// look for all @Around advices\n\t\tfor (LazyMethodGen methodGen : aspectGen.getMethodGens()) {\n\t\t\tif (methodGen.hasAnnotation(UnresolvedType.forName(\"org/aspectj/lang/annotation/Around\"))) {\n\t\t\t\topenAroundAdvice(methodGen);\n\t\t\t}\n\t\t}\n\n\t\t// add the accessors\n\t\tfor (LazyMethodGen lazyMethodGen : inlineAccessorMethodGens) {\n\t\t\taspectGen.addMethodGen(lazyMethodGen);\n\t\t}\n\n\t\t// flush some\n\t\tinlineAccessorMethodGens = null;\n\t\t// we keep m_inlineAccessorsResolvedMembers for shadow matching\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Looks in the wrapper we have added so that we can find their effective signature if needed\n\t */\n\t@Override\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\n    String name = member.getName();\n    String signature = name.startsWith(\"ajc$superDispatch$\")\n      ? member.getSignature()\n      : member.getSignature().replaceFirst(\"\\\\([^;]+;\", \"(\");\n    ResolvedMember rm = inlineAccessors.get(name + signature);\n//\t\tSystem.err.println(\"lookup for \" + member.getName() + \":\" + member.getSignature() + \" = \"\n//\t\t\t\t+ (rm == null ? \"\" : rm.getName()));\n\t\treturn rm;\n\t}\n\n\t@Override\n\tpublic ResolvedMember getSignature() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Match only the aspect for which we act\n\t */\n\t@Override\n\tpublic boolean matches(ResolvedType onType) {\n\t\treturn aspectType.equals(onType);\n\t}\n\n\t/**\n\t * Prepare the around advice, flag it as cannot be inlined if it can't be\n\t */\n\tprivate void openAroundAdvice(LazyMethodGen aroundAdvice) {\n\t\tInstructionHandle curr = aroundAdvice.getBody().getStart();\n\t\tInstructionHandle end = aroundAdvice.getBody().getEnd();\n\t\tConstantPool cpg = aroundAdvice.getEnclosingClass().getConstantPool();\n\t\tInstructionFactory factory = aroundAdvice.getEnclosingClass().getFactory();\n\n\t\tboolean realizedCannotInline = false;\n\t\twhile (curr != end) {\n\t\t\tif (realizedCannotInline) {\n\t\t\t\t// we know we cannot inline this advice so no need for futher handling\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tInstructionHandle next = curr.getNext();\n\t\t\tInstruction inst = curr.getInstruction();\n\n\t\t\t// open-up method call\n\t\t\tif ((inst instanceof InvokeInstruction)) {\n\t\t\t\tInvokeInstruction invoke = (InvokeInstruction) inst;\n\t\t\t\tif (invoke instanceof InvokeDynamic) {\n\t\t\t\t\trealizedCannotInline = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tResolvedType callee = aspectGen.getWorld().resolve(UnresolvedType.forName(invoke.getClassName(cpg)));\n\n\t\t\t\t// look in the whole method list and not just declared for super calls and alike\n\t\t\t\tList<ResolvedMember> methods = callee.getMethodsWithoutIterator(false, true, false);\n\t\t\t\tfor (ResolvedMember resolvedMember : methods) {\n\t\t\t\t\tif (invoke.getName(cpg).equals(resolvedMember.getName())\n\t\t\t\t\t\t\t&& invoke.getSignature(cpg).equals(resolvedMember.getSignature()) && !resolvedMember.isPublic()) {\n\t\t\t\t\t\tif (\"<init>\".equals(invoke.getName(cpg))\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// If ctor invocation, we care about whether it is targeting exactly the same type\n\t\t\t\t\t\t\t// (ignore non public ctors in supertype of the target) (J13 - AbstractStringBuilder has something\n\t\t\t\t\t\t\t// that trips this up in one testcase)\n\t\t\t\t\t\t\tif (invoke.getClassName(cpg).equals(resolvedMember.getDeclaringType().getPackageName()+\n\t\t\t\t\t\t\t\t\t\".\"+resolvedMember.getDeclaringType().getClassName())) {\n\t\t\t\t\t\t\t\t// skipping open up for private constructor\n\t\t\t\t\t\t\t\t// can occur when aspect new a private inner type\n\t\t\t\t\t\t\t\t// too complex to handle new + dup + .. + invokespecial here.\n\t\t\t\t\t\t\t\taroundAdvice.setCanInline(false);\n\t\t\t\t\t\t\t\trealizedCannotInline = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// specific handling for super.foo() calls, where foo is non public\n\t\t\t\t\t\t\tResolvedType memberType = aspectGen.getWorld().resolve(resolvedMember.getDeclaringType());\n\t\t\t\t\t\t\tif (!aspectType.equals(memberType) && memberType.isAssignableFrom(aspectType)) {\n\t\t\t\t\t\t\t\t// old test was...\n\t\t\t\t\t\t\t\t// if (aspectType.getSuperclass() != null\n\t\t\t\t\t\t\t\t// && aspectType.getSuperclass().getName().equals(resolvedMember.getDeclaringType().getName())) {\n\t\t\t\t\t\t\t\tResolvedMember accessor = createOrGetInlineAccessorForSuperDispatch(resolvedMember);\n\t\t\t\t\t\t\t\tInvokeInstruction newInst = factory.createInvoke(aspectType.getName(), accessor.getName(),\n\t\t\t\t\t\t\t\t\t\tBcelWorld.makeBcelType(accessor.getReturnType()),\n\t\t\t\t\t\t\t\t\t\tBcelWorld.makeBcelTypes(accessor.getParameterTypes()), Constants.INVOKEVIRTUAL);\n\t\t\t\t\t\t\t\tcurr.setInstruction(newInst);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tResolvedMember accessor = createOrGetInlineAccessorForMethod(resolvedMember);\n\t\t\t\t\t\t\t\tInvokeInstruction newInst = factory.createInvoke(aspectType.getName(), accessor.getName(),\n\t\t\t\t\t\t\t\t\t\tBcelWorld.makeBcelType(accessor.getReturnType()),\n\t\t\t\t\t\t\t\t\t\tBcelWorld.makeBcelTypes(accessor.getParameterTypes()), Constants.INVOKESTATIC);\n\t\t\t\t\t\t\t\tcurr.setInstruction(newInst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;// ok we found a matching callee member and swapped the instruction with the accessor\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (inst instanceof FieldInstruction) {\n\t\t\t\tFieldInstruction invoke = (FieldInstruction) inst;\n\t\t\t\tResolvedType callee = aspectGen.getWorld().resolve(UnresolvedType.forName(invoke.getClassName(cpg)));\n\t\t\t\tfor (int i = 0; i < callee.getDeclaredJavaFields().length; i++) {\n\t\t\t\t\tResolvedMember resolvedMember = callee.getDeclaredJavaFields()[i];\n\t\t\t\t\tif (invoke.getName(cpg).equals(resolvedMember.getName())\n\t\t\t\t\t\t\t&& invoke.getSignature(cpg).equals(resolvedMember.getSignature()) && !resolvedMember.isPublic()) {\n\t\t\t\t\t\tfinal ResolvedMember accessor;\n\t\t\t\t\t\tif ((inst.opcode == Constants.GETFIELD) || (inst.opcode == Constants.GETSTATIC)) {\n\t\t\t\t\t\t\taccessor = createOrGetInlineAccessorForFieldGet(resolvedMember);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\taccessor = createOrGetInlineAccessorForFieldSet(resolvedMember);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tInvokeInstruction newInst = factory.createInvoke(aspectType.getName(), accessor.getName(),\n\t\t\t\t\t\t\t\tBcelWorld.makeBcelType(accessor.getReturnType()),\n\t\t\t\t\t\t\t\tBcelWorld.makeBcelTypes(accessor.getParameterTypes()), Constants.INVOKESTATIC);\n\t\t\t\t\t\tcurr.setInstruction(newInst);\n\n\t\t\t\t\t\tbreak;// ok we found a matching callee member and swapped the instruction with the accessor\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurr = next;\n\t\t}\n\n\t\t// no reason for not inlining this advice\n\t\t// since it is used for @AJ advice that cannot be inlined by defauilt\n\t\t// make sure we set inline to true since we have done this analysis\n\t\tif (!realizedCannotInline) {\n\t\t\taroundAdvice.setCanInline(true);\n\t\t}\n\t}\n\n\t/**\n\t * Find (or add if not yet created) an inline wrapper for a non public method call\n\t */\n\tprivate ResolvedMember createOrGetInlineAccessorForMethod(ResolvedMember resolvedMember) {\n\t\tString accessorName = NameMangler.inlineAccessMethodForMethod(resolvedMember.getName(), resolvedMember.getDeclaringType(),\n\t\t\t\taspectType);\n\t\tString key = accessorName + resolvedMember.getSignature();\n\t\tResolvedMember inlineAccessor = inlineAccessors.get(key);\n//\t\tSystem.err.println(key + \" accessor=\" + inlineAccessor);\n\t\tif (inlineAccessor == null) {\n\t\t\t// add static method to aspect\n\t\t\tinlineAccessor = AjcMemberMaker.inlineAccessMethodForMethod(aspectType, resolvedMember);\n\n\t\t\t// add new accessor method to aspect bytecode\n\t\t\tInstructionFactory factory = aspectGen.getFactory();\n\t\t\tLazyMethodGen method = makeMethodGen(aspectGen, inlineAccessor);\n\t\t\tmethod.makeSynthetic();\n\t\t\tList<AjAttribute> methodAttributes = new ArrayList<>();\n\t\t\tmethodAttributes.add(new AjAttribute.AjSynthetic());\n\t\t\tmethodAttributes.add(new AjAttribute.EffectiveSignatureAttribute(resolvedMember, Shadow.MethodCall, false));\n\t\t\tmethod.addAttribute(Utility.bcelAttribute(methodAttributes.get(0), aspectGen.getConstantPool()));\n\t\t\t// flag the effective signature, so that we can deobfuscate the signature to apply method call pointcut\n\t\t\tmethod.addAttribute(Utility.bcelAttribute(methodAttributes.get(1), aspectGen.getConstantPool()));\n\n\t\t\tinlineAccessorMethodGens.add(method);\n\n\t\t\tInstructionList il = method.getBody();\n\t\t\tint register = 0;\n\t\t\tfor (int i = 0, max = inlineAccessor.getParameterTypes().length; i < max; i++) {\n\t\t\t\tUnresolvedType ptype = inlineAccessor.getParameterTypes()[i];\n\t\t\t\tType type = BcelWorld.makeBcelType(ptype);\n\t\t\t\til.append(InstructionFactory.createLoad(type, register));\n\t\t\t\tregister += type.getSize();\n\t\t\t}\n\t\t\til.append(Utility.createInvoke(factory, Modifier.isStatic(resolvedMember.getModifiers()) ? Constants.INVOKESTATIC\n\t\t\t\t\t: Constants.INVOKEVIRTUAL, resolvedMember));\n\t\t\til.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(inlineAccessor.getReturnType())));\n\n\t\t\tinlineAccessors.put(key, new BcelMethod(aspectGen.getBcelObjectType(), method.getMethod(), methodAttributes));\n\t\t}\n\t\treturn inlineAccessor;\n\t}\n\n\t/**\n\t * Add an inline wrapper for a non public super.method call\n\t */\n\tprivate ResolvedMember createOrGetInlineAccessorForSuperDispatch(ResolvedMember resolvedMember) {\n\t\tString accessor = NameMangler.superDispatchMethod(aspectType, resolvedMember.getName());\n\n\t\tString key = accessor + resolvedMember.getSignature();\n\t\tResolvedMember inlineAccessor = inlineAccessors.get(key);\n\n\t\tif (inlineAccessor == null) {\n\t\t\t// add super accessor method to class:\n\t\t\tinlineAccessor = AjcMemberMaker.superAccessMethod(aspectType, resolvedMember);\n\n\t\t\t// add new accessor method to aspect bytecode\n\t\t\tInstructionFactory factory = aspectGen.getFactory();\n\t\t\tLazyMethodGen method = makeMethodGen(aspectGen, inlineAccessor);\n\t\t\t// flag it synthetic, AjSynthetic\n\t\t\tmethod.makeSynthetic();\n\t\t\tList<AjAttribute> methodAttributes = new ArrayList<>();\n\t\t\tmethodAttributes.add(new AjAttribute.AjSynthetic());\n\t\t\tmethodAttributes.add(new AjAttribute.EffectiveSignatureAttribute(resolvedMember, Shadow.MethodCall, false));\n\t\t\tmethod.addAttribute(Utility.bcelAttribute(methodAttributes.get(0), aspectGen.getConstantPool()));\n\t\t\t// flag the effective signature, so that we can deobfuscate the signature to apply method call pointcut\n\t\t\tmethod.addAttribute(Utility.bcelAttribute(methodAttributes.get(1), aspectGen.getConstantPool()));\n\n\t\t\tinlineAccessorMethodGens.add(method);\n\n\t\t\tInstructionList il = method.getBody();\n\t\t\til.append(InstructionConstants.ALOAD_0);\n\t\t\tint register = 1;\n\t\t\tfor (int i = 0; i < inlineAccessor.getParameterTypes().length; i++) {\n\t\t\t\tUnresolvedType typeX = inlineAccessor.getParameterTypes()[i];\n\t\t\t\tType type = BcelWorld.makeBcelType(typeX);\n\t\t\t\til.append(InstructionFactory.createLoad(type, register));\n\t\t\t\tregister += type.getSize();\n\t\t\t}\n\t\t\til.append(Utility.createInvoke(factory, Constants.INVOKESPECIAL, resolvedMember));\n\t\t\til.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(inlineAccessor.getReturnType())));\n\n\t\t\tinlineAccessors.put(key, new BcelMethod(aspectGen.getBcelObjectType(), method.getMethod(), methodAttributes));\n\t\t}\n\t\treturn inlineAccessor;\n\t}\n\n\t/**\n\t * Add an inline wrapper for a non public field get\n\t */\n\tprivate ResolvedMember createOrGetInlineAccessorForFieldGet(ResolvedMember resolvedMember) {\n\t\tString accessor = NameMangler.inlineAccessMethodForFieldGet(resolvedMember.getName(), resolvedMember.getDeclaringType(),\n\t\t\t\taspectType);\n\t\tString key = accessor + \"()\" + resolvedMember.getSignature();\n\t\tResolvedMember inlineAccessor = inlineAccessors.get(key);\n\n\t\tif (inlineAccessor == null) {\n\t\t\t// add static method to aspect\n\t\t\tinlineAccessor = AjcMemberMaker.inlineAccessMethodForFieldGet(aspectType, resolvedMember);\n\n\t\t\t// add new accessor method to aspect bytecode\n\t\t\tInstructionFactory factory = aspectGen.getFactory();\n\t\t\tLazyMethodGen method = makeMethodGen(aspectGen, inlineAccessor);\n\t\t\t// flag it synthetic, AjSynthetic\n\t\t\tmethod.makeSynthetic();\n\t\t\tList<AjAttribute> methodAttributes = new ArrayList<>();\n\t\t\tmethodAttributes.add(new AjAttribute.AjSynthetic());\n\t\t\tmethodAttributes.add(new AjAttribute.EffectiveSignatureAttribute(resolvedMember, Shadow.FieldGet, false));\n\t\t\t// flag the effective signature, so that we can deobfuscate the signature to apply method call pointcut\n\t\t\tmethod.addAttribute(Utility.bcelAttribute(methodAttributes.get(0), aspectGen.getConstantPool()));\n\t\t\tmethod.addAttribute(Utility.bcelAttribute(methodAttributes.get(1), aspectGen.getConstantPool()));\n\n\t\t\tinlineAccessorMethodGens.add(method);\n\n\t\t\tInstructionList il = method.getBody();\n\t\t\tif (Modifier.isStatic(resolvedMember.getModifiers())) {\n\t\t\t\t// field accessed is static so no \"this\" as accessor sole parameter\n\t\t\t} else {\n\t\t\t\til.append(InstructionConstants.ALOAD_0);\n\t\t\t}\n\t\t\til.append(Utility.createGet(factory, resolvedMember));\n\t\t\til.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(inlineAccessor.getReturnType())));\n\n\t\t\tinlineAccessors.put(key, new BcelMethod(aspectGen.getBcelObjectType(), method.getMethod(), methodAttributes));\n\t\t}\n\t\treturn inlineAccessor;\n\t}\n\n\t/**\n\t * Add an inline wrapper for a non public field set\n\t */\n\tprivate ResolvedMember createOrGetInlineAccessorForFieldSet(ResolvedMember resolvedMember) {\n\t\tString accessor = NameMangler.inlineAccessMethodForFieldSet(resolvedMember.getName(), resolvedMember.getDeclaringType(),\n\t\t\t\taspectType);\n\t\tString key = accessor + \"(\" + resolvedMember.getSignature() + \")V\";\n\t\tResolvedMember inlineAccessor = inlineAccessors.get(key);\n\n\t\tif (inlineAccessor == null) {\n\t\t\t// add static method to aspect\n\t\t\tinlineAccessor = AjcMemberMaker.inlineAccessMethodForFieldSet(aspectType, resolvedMember);\n\n\t\t\t// add new accessor method to aspect bytecode\n\t\t\tInstructionFactory factory = aspectGen.getFactory();\n\t\t\tLazyMethodGen method = makeMethodGen(aspectGen, inlineAccessor);\n\t\t\t// flag it synthetic, AjSynthetic\n\t\t\tmethod.makeSynthetic();\n\t\t\tList<AjAttribute> methodAttributes = new ArrayList<>();\n\t\t\tmethodAttributes.add(new AjAttribute.AjSynthetic());\n\t\t\tmethodAttributes.add(new AjAttribute.EffectiveSignatureAttribute(resolvedMember, Shadow.FieldSet, false));\n\t\t\tmethod.addAttribute(Utility.bcelAttribute(methodAttributes.get(0), aspectGen.getConstantPool()));\n\t\t\t// flag the effective signature, so that we can deobfuscate the signature to apply method call pointcut\n\t\t\tmethod.addAttribute(Utility.bcelAttribute(methodAttributes.get(1), aspectGen.getConstantPool()));\n\n\t\t\tinlineAccessorMethodGens.add(method);\n\n\t\t\tInstructionList il = method.getBody();\n\t\t\tif (Modifier.isStatic(resolvedMember.getModifiers())) {\n\t\t\t\t// field accessed is static so sole parameter is field value to be set\n\t\t\t\til.append(InstructionFactory.createLoad(BcelWorld.makeBcelType(resolvedMember.getReturnType()), 0));\n\t\t\t} else {\n\t\t\t\til.append(InstructionConstants.ALOAD_0);\n\t\t\t\til.append(InstructionFactory.createLoad(BcelWorld.makeBcelType(resolvedMember.getReturnType()), 1));\n\t\t\t}\n\t\t\til.append(Utility.createSet(factory, resolvedMember));\n\t\t\til.append(InstructionConstants.RETURN);\n\t\t\tinlineAccessors.put(key, new BcelMethod(aspectGen.getBcelObjectType(), method.getMethod(), methodAttributes));\n\t\t}\n\t\treturn inlineAccessor;\n\t}\n}\n",
    "size": 17554
  },
  {
    "file_id": "F8",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelAdvice.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n *     Alexandre Vasseur    support for @AJ aspects\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Map;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.LocalVariable;\nimport org.aspectj.apache.bcel.classfile.LocalVariableTable;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.LineNumberTag;\nimport org.aspectj.apache.bcel.generic.LocalVariableTag;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.bridge.Message;\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.IEclipseSourceContext;\nimport org.aspectj.weaver.ISourceContext;\nimport org.aspectj.weaver.Lint;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ReferenceTypeDelegate;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedMemberImpl;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeaverMessages;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.ast.Literal;\nimport org.aspectj.weaver.ast.Test;\nimport org.aspectj.weaver.patterns.ExactTypePattern;\nimport org.aspectj.weaver.patterns.ExposedState;\nimport org.aspectj.weaver.patterns.PerClause;\nimport org.aspectj.weaver.patterns.Pointcut;\n\n/**\n * Advice implemented for BCEL\n *\n * @author Erik Hilsdale\n * @author Jim Hugunin\n * @author Andy Clement\n */\nclass BcelAdvice extends Advice {\n\n\t/**\n\t * If a match is not entirely statically determinable, this captures the runtime test that must succeed in order for the advice\n\t * to run.\n\t */\n\tprivate Test runtimeTest;\n\tprivate ExposedState exposedState;\n\tprivate int containsInvokedynamic = 0;// 0 = dontknow, 1=no, 2=yes\n\n\tpublic BcelAdvice(AjAttribute.AdviceAttribute attribute, Pointcut pointcut, Member adviceSignature, ResolvedType concreteAspect) {\n\t\tsuper(attribute, pointcut, simplify(attribute.getKind(), adviceSignature));\n\t\tthis.concreteAspect = concreteAspect;\n\t}\n\n\tpublic boolean bindsProceedingJoinPoint() {\n\t\tUnresolvedType[] parameterTypes = signature.getParameterTypes();\n\t\tfor (UnresolvedType parameterType : parameterTypes) {\n\t\t\tif (parameterType.equals(UnresolvedType.PROCEEDING_JOINPOINT)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * A heavyweight BcelMethod object is only required for around advice that will be inlined. For other kinds of advice it is\n\t * possible to save some space.\n\t */\n\tprivate static Member simplify(AdviceKind kind, Member adviceSignature) {\n\t\tif (adviceSignature != null) {\n\t\t\tUnresolvedType adviceDeclaringType = adviceSignature.getDeclaringType();\n\t\t\t// if it isnt around advice or it is but inlining is turned off then shrink it to a ResolvedMemberImpl\n\t\t\tif (kind != AdviceKind.Around\n\t\t\t\t\t|| ((adviceDeclaringType instanceof ResolvedType) && ((ResolvedType) adviceDeclaringType).getWorld()\n\t\t\t\t\t\t\t.isXnoInline())) {\n\t\t\t\tif (adviceSignature instanceof BcelMethod) {\n\t\t\t\t\tBcelMethod bm = (BcelMethod) adviceSignature;\n\t\t\t\t\tif (bm.getMethod() != null && bm.getMethod().getAnnotations() != null) {\n\t\t\t\t\t\treturn adviceSignature;\n\t\t\t\t\t}\n\t\t\t\t\tResolvedMemberImpl simplermember = new ResolvedMemberImpl(bm.getKind(), bm.getDeclaringType(),\n\t\t\t\t\t\t\tbm.getModifiers(), bm.getReturnType(), bm.getName(), bm.getParameterTypes());// ,bm.getExceptions(),bm.getBackingGenericMember()\n\t\t\t\t\t// );\n\t\t\t\t\tsimplermember.setParameterNames(bm.getParameterNames());\n\t\t\t\t\treturn simplermember;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn adviceSignature;\n\t}\n\n\t@Override\n\tpublic ShadowMunger concretize(ResolvedType fromType, World world, PerClause clause) {\n\t\tif (!world.areAllLintIgnored()) {\n\t\t\tsuppressLintWarnings(world);\n\t\t}\n\t\tShadowMunger ret = super.concretize(fromType, world, clause);\n\t\tif (!world.areAllLintIgnored()) {\n\t\t\tclearLintSuppressions(world, this.suppressedLintKinds);\n\t\t}\n\t\tIfFinder ifinder = new IfFinder();\n\t\tret.getPointcut().accept(ifinder, null);\n\t\tboolean hasGuardTest = ifinder.hasIf && getKind() != AdviceKind.Around;\n\t\tboolean isAround = getKind() == AdviceKind.Around;\n\t\tif ((getExtraParameterFlags() & ThisJoinPoint) != 0) {\n\t\t\tif (!isAround && !hasGuardTest && world.getLint().noGuardForLazyTjp.isEnabled()) {\n\t\t\t\t// can't build tjp lazily, no suitable test...\n\t\t\t\t// ... only want to record it once against the advice(bug 133117)\n\t\t\t\tworld.getLint().noGuardForLazyTjp.signal(\"\", getSourceLocation());\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic ShadowMunger parameterizeWith(ResolvedType declaringType, Map<String, UnresolvedType> typeVariableMap) {\n\t\tPointcut pc = getPointcut().parameterizeWith(typeVariableMap, declaringType.getWorld());\n\n\t\tBcelAdvice ret = null;\n\t\tMember adviceSignature = signature;\n\t\t// allows for around advice where the return value is a type variable (see pr115250)\n\t\tif (signature instanceof ResolvedMember && signature.getDeclaringType().isGenericType()) {\n\t\t\tadviceSignature = ((ResolvedMember) signature).parameterizedWith(declaringType.getTypeParameters(), declaringType,\n\t\t\t\t\tdeclaringType.isParameterizedType());\n\t\t}\n\t\tret = new BcelAdvice(this.attribute, pc, adviceSignature, this.concreteAspect);\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic boolean match(Shadow shadow, World world) {\n\t\tif (world.areAllLintIgnored()) {\n\t\t\treturn super.match(shadow, world);\n\t\t} else {\n\t\t\tsuppressLintWarnings(world);\n\t\t\tboolean ret = super.match(shadow, world);\n\t\t\tclearLintSuppressions(world, this.suppressedLintKinds);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void specializeOn(Shadow shadow) {\n\t\tif (getKind() == AdviceKind.Around) {\n\t\t\t((BcelShadow) shadow).initializeForAroundClosure();\n\t\t}\n\n\t\t// XXX this case is just here for supporting lazy test code\n\t\tif (getKind() == null) {\n\t\t\texposedState = new ExposedState(0);\n\t\t\treturn;\n\t\t}\n\t\tif (getKind().isPerEntry()) {\n\t\t\texposedState = new ExposedState(0);\n\t\t} else if (getKind().isCflow()) {\n\t\t\texposedState = new ExposedState(nFreeVars);\n\t\t} else if (getSignature() != null) {\n\t\t\texposedState = new ExposedState(getSignature());\n\t\t} else {\n\t\t\texposedState = new ExposedState(0);\n\t\t\treturn; // XXX this case is just here for supporting lazy test code\n\t\t}\n\n\t\tWorld world = shadow.getIWorld();\n\t\tif (!world.areAllLintIgnored()) {\n\t\t\tsuppressLintWarnings(world);\n\t\t}\n\t\texposedState.setConcreteAspect(concreteAspect);\n\t\truntimeTest = getPointcut().findResidue(shadow, exposedState);\n\t\tif (!world.areAllLintIgnored()) {\n\t\t\tclearLintSuppressions(world, this.suppressedLintKinds);\n\t\t}\n\n\t\t// these initializations won't be performed by findResidue, but need to be\n\t\t// so that the joinpoint is primed for weaving\n\t\tif (getKind() == AdviceKind.PerThisEntry) {\n\t\t\tshadow.getThisVar();\n\t\t} else if (getKind() == AdviceKind.PerTargetEntry) {\n\t\t\tshadow.getTargetVar();\n\t\t}\n\n\t\t// make sure thisJoinPoint parameters are initialized\n\t\tif ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {\n\t\t\t((BcelShadow) shadow).getThisJoinPointStaticPartVar();\n\t\t\t((BcelShadow) shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow, getSourceLocation());\n\t\t}\n\n\t\tif ((getExtraParameterFlags() & ThisJoinPoint) != 0) {\n\t\t\tboolean hasGuardTest = runtimeTest != Literal.TRUE && getKind() != AdviceKind.Around;\n\t\t\tboolean isAround = getKind() == AdviceKind.Around;\n\t\t\t((BcelShadow) shadow).requireThisJoinPoint(hasGuardTest, isAround);\n\t\t\t((BcelShadow) shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow, getSourceLocation());\n\t\t\tif (!hasGuardTest && world.getLint().multipleAdviceStoppingLazyTjp.isEnabled()) {\n\t\t\t\t// collect up the problematic advice\n\t\t\t\t((BcelShadow) shadow).addAdvicePreventingLazyTjp(this);\n\t\t\t}\n\t\t}\n\n\t\tif ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {\n\t\t\t((BcelShadow) shadow).getThisEnclosingJoinPointStaticPartVar();\n\t\t\t((BcelShadow) shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow, getSourceLocation());\n\t\t}\n\t}\n\n\tprivate boolean canInline(Shadow s) {\n\t\tif (attribute.isProceedInInners()) {\n\t\t\treturn false;\n\t\t}\n\t\t// XXX this guard seems to only be needed for bad test cases\n\t\tif (concreteAspect == null || concreteAspect.isMissing()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (concreteAspect.getWorld().isXnoInline()) {\n\t\t\treturn false;\n\t\t}\n\t\t// System.err.println(\"isWoven? \" + ((BcelObjectType)concreteAspect).getLazyClassGen().getWeaverState());\n\t\tBcelObjectType boType = BcelWorld.getBcelObjectType(concreteAspect);\n\t\tif (boType == null) {\n\t\t\t// Could be a symptom that the aspect failed to build last build... return the default answer of false\n\t\t\treturn false;\n\t\t}\n\t\t// Need isJava8 check\n\t\t// Does the advice contain invokedynamic...\n\t\tif (boType.javaClass.getMajor() >= Constants.MAJOR_1_8) {\n\t\t\tif (containsInvokedynamic == 0) {\n\t\t\t\tcontainsInvokedynamic = 1;\n\t\t\t\tLazyMethodGen lmg = boType.getLazyClassGen().getLazyMethodGen(this.signature.getName(), this.signature.getSignature(), true);\n\t\t\t\t// Check Java8 supertypes\n\t\t\t\tResolvedType searchType = concreteAspect;\n\t\t\t\twhile (lmg == null) {\n\t\t\t\t\tsearchType = searchType.getSuperclass();\n\t\t\t\t\tif (searchType == null) break;\n\t\t\t\t\tReferenceTypeDelegate rtd = ((ReferenceType)searchType).getDelegate();\n\t\t\t\t\tif (rtd instanceof BcelObjectType) {\n\t\t\t\t\t\tBcelObjectType bot = (BcelObjectType)rtd;\n\t\t\t\t\t\tif (bot.javaClass.getMajor() < Constants.MAJOR_1_8) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlmg = bot.getLazyClassGen().getLazyMethodGen(this.signature.getName(), this.signature.getSignature(), true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lmg != null) {\n\t\t\t\t\tInstructionList ilist = lmg.getBody();\n\t\t\t\t\tfor (InstructionHandle src = ilist.getStart(); src != null; src = src.getNext()) {\n\t\t\t\t\t\tif (src.getInstruction().opcode == Constants.INVOKEDYNAMIC) {\n\t\t\t\t\t\t\tcontainsInvokedynamic = 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (containsInvokedynamic == 2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn boType.getLazyClassGen().isWoven();\n\t}\n\n\tprivate boolean aspectIsBroken() {\n\t\tif (concreteAspect instanceof ReferenceType) {\n\t\t\tReferenceTypeDelegate rtDelegate = ((ReferenceType) concreteAspect).getDelegate();\n\t\t\tif (!(rtDelegate instanceof BcelObjectType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean implementOn(Shadow s) {\n\t\thasMatchedAtLeastOnce = true;\n\n\t\t// pr263323 - if the aspect is broken then the delegate will not be usable for weaving\n\t\tif (aspectIsBroken()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tBcelShadow shadow = (BcelShadow) s;\n\n\t\t// remove any unnecessary exceptions if the compiler option is set to\n\t\t// error or warning and if this piece of advice throws exceptions\n\t\t// (bug 129282). This may be expanded to include other compiler warnings\n\t\t// at the moment it only deals with 'declared exception is not thrown'\n\t\tif (!shadow.getWorld().isIgnoringUnusedDeclaredThrownException() && !getThrownExceptions().isEmpty()) {\n\t\t\tMember member = shadow.getSignature();\n\t\t\tif (member instanceof BcelMethod) {\n\t\t\t\tremoveUnnecessaryProblems((BcelMethod) member, ((BcelMethod) member).getDeclarationLineNumber());\n\t\t\t} else {\n\t\t\t\t// we're in a call shadow therefore need the line number of the\n\t\t\t\t// declared method (which may be in a different type). However,\n\t\t\t\t// we want to remove the problems from the CompilationResult\n\t\t\t\t// held within the current type's EclipseSourceContext so need\n\t\t\t\t// the enclosing shadow too\n\t\t\t\tResolvedMember resolvedMember = shadow.getSignature().resolve(shadow.getWorld());\n\t\t\t\tif (resolvedMember instanceof BcelMethod && shadow.getEnclosingShadow() instanceof BcelShadow) {\n\t\t\t\t\tMember enclosingMember = shadow.getEnclosingShadow().getSignature();\n\t\t\t\t\tif (enclosingMember instanceof BcelMethod) {\n\t\t\t\t\t\tremoveUnnecessaryProblems((BcelMethod) enclosingMember,\n\t\t\t\t\t\t\t\t((BcelMethod) resolvedMember).getDeclarationLineNumber());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (shadow.getIWorld().isJoinpointSynchronizationEnabled() && shadow.getKind() == Shadow.MethodExecution\n\t\t\t\t&& (s.getSignature().getModifiers() & Modifier.SYNCHRONIZED) != 0) {\n\t\t\tshadow.getIWorld().getLint().advisingSynchronizedMethods.signal(new String[] { shadow.toString() },\n\t\t\t\t\tshadow.getSourceLocation(), new ISourceLocation[] { getSourceLocation() });\n\t\t}\n\n\t\t// FIXME AV - see #75442, this logic is not enough so for now comment it out until we fix the bug\n\t\t// // callback for perObject AJC MightHaveAspect postMunge (#75442)\n\t\t// if (getConcreteAspect() != null\n\t\t// && getConcreteAspect().getPerClause() != null\n\t\t// && PerClause.PEROBJECT.equals(getConcreteAspect().getPerClause().getKind())) {\n\t\t// final PerObject clause;\n\t\t// if (getConcreteAspect().getPerClause() instanceof PerFromSuper) {\n\t\t// clause = (PerObject)((PerFromSuper) getConcreteAspect().getPerClause()).lookupConcretePerClause(getConcreteAspect());\n\t\t// } else {\n\t\t// clause = (PerObject) getConcreteAspect().getPerClause();\n\t\t// }\n\t\t// if (clause.isThis()) {\n\t\t// PerObjectInterfaceTypeMunger.registerAsAdvisedBy(s.getThisVar().getType(), getConcreteAspect());\n\t\t// } else {\n\t\t// PerObjectInterfaceTypeMunger.registerAsAdvisedBy(s.getTargetVar().getType(), getConcreteAspect());\n\t\t// }\n\t\t// }\n\t\tif (runtimeTest == Literal.FALSE) { // not usually allowed, except in one case (260384)\n\t\t\tMember sig = shadow.getSignature();\n\t\t\tif (sig.getArity() == 0 && shadow.getKind() == Shadow.MethodCall && sig.getName().charAt(0) == 'c'\n\t\t\t\t\t&& sig.getReturnType().equals(ResolvedType.OBJECT) && sig.getName().equals(\"clone\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (getKind() == AdviceKind.Before) {\n\t\t\tshadow.weaveBefore(this);\n\t\t} else if (getKind() == AdviceKind.AfterReturning) {\n\t\t\tshadow.weaveAfterReturning(this);\n\t\t} else if (getKind() == AdviceKind.AfterThrowing) {\n\t\t\tUnresolvedType catchType = hasExtraParameter() ? getExtraParameterType() : UnresolvedType.THROWABLE;\n\t\t\tshadow.weaveAfterThrowing(this, catchType);\n\t\t} else if (getKind() == AdviceKind.After) {\n\t\t\tshadow.weaveAfter(this);\n\t\t} else if (getKind() == AdviceKind.Around) {\n\t\t\t// Note: under regular LTW the aspect is usually loaded after the first use of any class affected by it.\n\t\t\t// This means that as long as the aspect has not been thru the LTW, it's woven state is unknown\n\t\t\t// and thus canInline(s) will return false.\n\t\t\t// To force inlining (test), ones can do Class aspect = FQNAspect.class in the clinit of the target class\n\t\t\t// FIXME AV : for AJC compiled @AJ aspect (or any code style aspect), the woven state can never be known\n\t\t\t// if the aspect belongs to a parent classloader. In that case the aspect will never be inlined.\n\t\t\t// It might be dangerous to change that especially for @AJ aspect non compiled with AJC since if those\n\t\t\t// are not weaved (f.e. use of some limited LTW etc) then they cannot be prepared for inlining.\n\t\t\t// One solution would be to flag @AJ aspect with an annotation as \"prepared\" and query that one.\n\t\t\tLazyClassGen enclosingClass = shadow.getEnclosingClass();\n\t\t\tif (enclosingClass != null && enclosingClass.isInterface() && shadow.getEnclosingMethod().getName().charAt(0) == '<') {\n\t\t\t\t// Do not add methods with bodies to an interface (252198, 163005)\n\t\t\t\tshadow.getWorld().getLint().cannotAdviseJoinpointInInterfaceWithAroundAdvice.signal(shadow.toString(),\n\t\t\t\t\t\tshadow.getSourceLocation());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!canInline(s)) {\n\t\t\t\tshadow.weaveAroundClosure(this, hasDynamicTests());\n\t\t\t} else {\n\t\t\t\tshadow.weaveAroundInline(this, hasDynamicTests());\n\t\t\t}\n\t\t} else if (getKind() == AdviceKind.InterInitializer) {\n\t\t\tshadow.weaveAfterReturning(this);\n\t\t} else if (getKind().isCflow()) {\n\t\t\tshadow.weaveCflowEntry(this, getSignature());\n\t\t} else if (getKind() == AdviceKind.PerThisEntry) {\n\t\t\tshadow.weavePerObjectEntry(this, (BcelVar) shadow.getThisVar());\n\t\t} else if (getKind() == AdviceKind.PerTargetEntry) {\n\t\t\tshadow.weavePerObjectEntry(this, (BcelVar) shadow.getTargetVar());\n\t\t} else if (getKind() == AdviceKind.Softener) {\n\t\t\tshadow.weaveSoftener(this, ((ExactTypePattern) exceptionType).getType());\n\t\t} else if (getKind() == AdviceKind.PerTypeWithinEntry) {\n\t\t\t// PTWIMPL Entry to ptw is the static initialization of a type that matched the ptw type pattern\n\t\t\tshadow.weavePerTypeWithinAspectInitialization(this, shadow.getEnclosingType());\n\t\t} else {\n\t\t\tthrow new BCException(\"unimplemented kind: \" + getKind());\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void removeUnnecessaryProblems(BcelMethod method, int problemLineNumber) {\n\t\tISourceContext sourceContext = method.getSourceContext();\n\t\tif (sourceContext instanceof IEclipseSourceContext) {\n\t\t\t((IEclipseSourceContext) sourceContext).removeUnnecessaryProblems(method, problemLineNumber);\n\t\t}\n\t}\n\n\t// ---- implementations\n\n\tprivate Collection<ResolvedType> collectCheckedExceptions(UnresolvedType[] excs) {\n\t\tif (excs == null || excs.length == 0) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tCollection<ResolvedType> ret = new ArrayList<>();\n\t\tWorld world = concreteAspect.getWorld();\n\t\tResolvedType runtimeException = world.getCoreType(UnresolvedType.RUNTIME_EXCEPTION);\n\t\tResolvedType error = world.getCoreType(UnresolvedType.ERROR);\n\n\t\tfor (UnresolvedType exc : excs) {\n\t\t\tResolvedType t = world.resolve(exc, true);\n\t\t\tif (t.isMissing()) {\n\t\t\t\tworld.getLint().cantFindType\n\t\t\t\t\t\t.signal(WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_EXCEPTION_TYPE, exc.getName()),\n\t\t\t\t\t\t\t\tgetSourceLocation());\n\t\t\t\t// IMessage msg = new Message(\n\t\t\t\t// WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_EXCEPTION_TYPE,excs[i].getName()),\n\t\t\t\t// \"\",IMessage.ERROR,getSourceLocation(),null,null);\n\t\t\t\t// world.getMessageHandler().handleMessage(msg);\n\t\t\t}\n\t\t\tif (!(runtimeException.isAssignableFrom(t) || error.isAssignableFrom(t))) {\n\t\t\t\tret.add(t);\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tprivate Collection<ResolvedType> thrownExceptions = null;\n\n\t@Override\n\tpublic Collection<ResolvedType> getThrownExceptions() {\n\t\tif (thrownExceptions == null) {\n\t\t\t// ??? can we really lump in Around here, how does this interact with Throwable\n\t\t\tif (concreteAspect != null && concreteAspect.getWorld() != null && // null tests for test harness\n\t\t\t\t\t(getKind().isAfter() || getKind() == AdviceKind.Before || getKind() == AdviceKind.Around)) {\n\t\t\t\tWorld world = concreteAspect.getWorld();\n\t\t\t\tResolvedMember m = world.resolve(signature);\n\t\t\t\tif (m == null) {\n\t\t\t\t\tthrownExceptions = Collections.emptyList();\n\t\t\t\t} else {\n\t\t\t\t\tthrownExceptions = collectCheckedExceptions(m.getExceptions());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrownExceptions = Collections.emptyList();\n\t\t\t}\n\t\t}\n\t\treturn thrownExceptions;\n\t}\n\n\t/**\n\t * The munger must not check for the advice exceptions to be declared by the shadow in the case of @AJ aspects so that around\n\t * can throws Throwable\n\t *\n\t * @return\n\t */\n\t@Override\n\tpublic boolean mustCheckExceptions() {\n\t\tif (getConcreteAspect() == null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn !getConcreteAspect().isAnnotationStyleAspect();\n\t}\n\n\t// only call me after prepare has been called\n\t@Override\n\tpublic boolean hasDynamicTests() {\n\t\t// if (hasExtraParameter() && getKind() == AdviceKind.AfterReturning) {\n\t\t// UnresolvedType extraParameterType = getExtraParameterType();\n\t\t// if (! extraParameterType.equals(UnresolvedType.OBJECT)\n\t\t// && ! extraParameterType.isPrimitive())\n\t\t// return true;\n\t\t// }\n\n\t\treturn runtimeTest != null && !(runtimeTest == Literal.TRUE);// || pointcutTest == Literal.NO_TEST);\n\t}\n\n\t/**\n\t * get the instruction list for the really simple version of this advice. Is broken apart for other advice, but if you want it\n\t * in one block, this is the method to call.\n\t *\n\t * @param s The shadow around which these instructions will eventually live.\n\t * @param extraArgVar The var that will hold the return value or thrown exception for afterX advice\n\t * @param ifNoAdvice The instructionHandle to jump to if the dynamic tests for this munger fails.\n\t */\n\tInstructionList getAdviceInstructions(BcelShadow s, BcelVar extraArgVar, InstructionHandle ifNoAdvice) {\n\t\tBcelShadow shadow = s;\n\t\tInstructionFactory fact = shadow.getFactory();\n\t\tBcelWorld world = shadow.getWorld();\n\n\t\tInstructionList il = new InstructionList();\n\n\t\t// we test to see if we have the right kind of thing...\n\t\t// after throwing does this just by the exception mechanism.\n\t\tif (hasExtraParameter() && getKind() == AdviceKind.AfterReturning) {\n\t\t\tUnresolvedType extraParameterType = getExtraParameterType();\n\t\t\tif (!extraParameterType.equals(UnresolvedType.OBJECT) && !extraParameterType.isPrimitiveType()) {\n\t\t\t\til.append(BcelRenderer.renderTest(fact, world,\n\t\t\t\t\t\tTest.makeInstanceof(extraArgVar, getExtraParameterType().resolve(world)), null, ifNoAdvice, null));\n\t\t\t}\n\t\t}\n\t\til.append(getAdviceArgSetup(shadow, extraArgVar, null));\n\t\til.append(getNonTestAdviceInstructions(shadow));\n\n\t\tInstructionHandle ifYesAdvice = il.getStart();\n\t\til.insert(getTestInstructions(shadow, ifYesAdvice, ifNoAdvice, ifYesAdvice));\n\n\t\t// If inserting instructions at the start of a method, we need a nice line number for this entry\n\t\t// in the stack trace\n\t\tif (shadow.getKind() == Shadow.MethodExecution && getKind() == AdviceKind.Before) {\n\t\t\tint lineNumber = 0;\n\t\t\t// Uncomment this code if you think we should use the method decl line number when it exists...\n\t\t\t// // If the advised join point is in a class built by AspectJ, we can use the declaration line number\n\t\t\t// boolean b = shadow.getEnclosingMethod().getMemberView().hasDeclarationLineNumberInfo();\n\t\t\t// if (b) {\n\t\t\t// lineNumber = shadow.getEnclosingMethod().getMemberView().getDeclarationLineNumber();\n\t\t\t// } else { // If it wasn't, the best we can do is the line number of the first instruction in the method\n\t\t\tlineNumber = shadow.getEnclosingMethod().getMemberView().getLineNumberOfFirstInstruction();\n\t\t\t// }\n\t\t\tInstructionHandle start = il.getStart();\n\t\t\tif (lineNumber > 0) {\n\t\t\t\tstart.addTargeter(new LineNumberTag(lineNumber));\n\t\t\t}\n\t\t\t// Fix up the local variables: find any that have a startPC of 0 and ensure they target the new start of the method\n\t\t\tLocalVariableTable lvt = shadow.getEnclosingMethod().getMemberView().getMethod().getLocalVariableTable();\n\t\t\tif (lvt != null) {\n\t\t\t\tLocalVariable[] lvTable = lvt.getLocalVariableTable();\n\t\t\t\tfor (LocalVariable lv : lvTable) {\n\t\t\t\t\tif (lv.getStartPC() == 0) {\n\t\t\t\t\t\tstart.addTargeter(new LocalVariableTag(lv.getSignature(), lv.getName(), lv.getIndex(), 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn il;\n\t}\n\n\tpublic InstructionList getAdviceArgSetup(BcelShadow shadow, BcelVar extraVar, InstructionList closureInstantiation) {\n\t\tInstructionFactory fact = shadow.getFactory();\n\t\tBcelWorld world = shadow.getWorld();\n\t\tInstructionList il = new InstructionList();\n\n\t\t// if (targetAspectField != null) {\n\t\t// il.append(fact.createFieldAccess(\n\t\t// targetAspectField.getDeclaringType().getName(),\n\t\t// targetAspectField.getName(),\n\t\t// BcelWorld.makeBcelType(targetAspectField.getType()),\n\t\t// Constants.GETSTATIC));\n\t\t// }\n\t\t//\n\t\t// System.err.println(\"BcelAdvice: \" + exposedState);\n\n\t\tif (exposedState.getAspectInstance() != null) {\n\t\t\til.append(BcelRenderer.renderExpr(fact, world, exposedState.getAspectInstance()));\n\t\t}\n\t\t// pr121385\n\t\tboolean x = this.getDeclaringAspect().resolve(world).isAnnotationStyleAspect();\n\t\tfinal boolean isAnnotationStyleAspect = getConcreteAspect() != null && getConcreteAspect().isAnnotationStyleAspect() && x;\n\t\tboolean previousIsClosure = false;\n\t\tfor (int i = 0, len = exposedState.size(); i < len; i++) {\n\t\t\tif (exposedState.isErroneousVar(i)) {\n\t\t\t\tcontinue; // Erroneous vars have already had error msgs reported!\n\t\t\t}\n\t\t\tBcelVar v = (BcelVar) exposedState.get(i);\n\n\t\t\tif (v == null) {\n\t\t\t\t// if not @AJ aspect, go on with the regular binding handling\n\t\t\t\tif (!isAnnotationStyleAspect) {\n\n\t\t\t\t} else {\n\t\t\t\t\t// ATAJ: for @AJ aspects, handle implicit binding of xxJoinPoint\n\t\t\t\t\t// if (getKind() == AdviceKind.Around) {\n\t\t\t\t\t// previousIsClosure = true;\n\t\t\t\t\t// il.append(closureInstantiation);\n\t\t\t\t\tif (\"Lorg/aspectj/lang/ProceedingJoinPoint;\".equals(getSignature().getParameterTypes()[i].getSignature())) {\n\t\t\t\t\t\t// make sure we are in an around, since we deal with the closure, not the arg here\n\t\t\t\t\t\tif (getKind() != AdviceKind.Around) {\n\t\t\t\t\t\t\tpreviousIsClosure = false;\n\t\t\t\t\t\t\tgetConcreteAspect()\n\t\t\t\t\t\t\t\t\t.getWorld()\n\t\t\t\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\t\t\t\tnew Message(\"use of ProceedingJoinPoint is allowed only on around advice (\" + \"arg \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ i + \" in \" + toString() + \")\", this.getSourceLocation(), true));\n\t\t\t\t\t\t\t// try to avoid verify error and pass in null\n\t\t\t\t\t\t\til.append(InstructionConstants.ACONST_NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (previousIsClosure) {\n\t\t\t\t\t\t\t\til.append(InstructionConstants.DUP);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpreviousIsClosure = true;\n\t\t\t\t\t\t\t\til.append(closureInstantiation.copy());\n\t\t\t\t\t\t\t\tshadow.closureVarInitialized = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (\"Lorg/aspectj/lang/JoinPoint$StaticPart;\".equals(getSignature().getParameterTypes()[i]\n\t\t\t\t\t\t\t.getSignature())) {\n\t\t\t\t\t\tpreviousIsClosure = false;\n\t\t\t\t\t\tif ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {\n\t\t\t\t\t\t\tshadow.getThisJoinPointStaticPartBcelVar().appendLoad(il, fact);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (\"Lorg/aspectj/lang/JoinPoint;\".equals(getSignature().getParameterTypes()[i].getSignature())) {\n\t\t\t\t\t\tpreviousIsClosure = false;\n\t\t\t\t\t\tif ((getExtraParameterFlags() & ThisJoinPoint) != 0) {\n\t\t\t\t\t\t\til.append(shadow.loadThisJoinPoint());\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (\"Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;\".equals(getSignature().getParameterTypes()[i]\n\t\t\t\t\t\t\t.getSignature())) {\n\t\t\t\t\t\tpreviousIsClosure = false;\n\t\t\t\t\t\tif ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {\n\t\t\t\t\t\t\tshadow.getThisEnclosingJoinPointStaticPartBcelVar().appendLoad(il, fact);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (hasExtraParameter()) {\n\t\t\t\t\t\tpreviousIsClosure = false;\n\t\t\t\t\t\textraVar.appendLoadAndConvert(il, fact, getExtraParameterType().resolve(world));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpreviousIsClosure = false;\n\t\t\t\t\t\tgetConcreteAspect()\n\t\t\t\t\t\t\t\t.getWorld()\n\t\t\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\t\t\tnew Message(\"use of ProceedingJoinPoint is allowed only on around advice (\" + \"arg \" + i\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" in \" + toString() + \")\", this.getSourceLocation(), true));\n\t\t\t\t\t\t// try to avoid verify error and pass in null\n\t\t\t\t\t\til.append(InstructionConstants.ACONST_NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tUnresolvedType desiredTy = getBindingParameterTypes()[i];\n\t\t\t\tv.appendLoadAndConvert(il, fact, desiredTy.resolve(world));\n\t\t\t}\n\t\t}\n\n\t\t// ATAJ: for code style aspect, handles the extraFlag as usual ie not\n\t\t// in the middle of the formal bindings but at the end, in a rock solid ordering\n\t\tif (!isAnnotationStyleAspect) {\n\t\t\tif (getKind() == AdviceKind.Around) {\n\t\t\t\til.append(closureInstantiation);\n\t\t\t} else if (hasExtraParameter()) {\n\t\t\t\textraVar.appendLoadAndConvert(il, fact, getExtraParameterType().resolve(world));\n\t\t\t}\n\n\t\t\t// handle thisJoinPoint parameters\n\t\t\t// these need to be in that same order as parameters in\n\t\t\t// org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration\n\t\t\tif ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {\n\t\t\t\tshadow.getThisJoinPointStaticPartBcelVar().appendLoad(il, fact);\n\t\t\t}\n\n\t\t\tif ((getExtraParameterFlags() & ThisJoinPoint) != 0) {\n\t\t\t\til.append(shadow.loadThisJoinPoint());\n\t\t\t}\n\n\t\t\tif ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {\n\t\t\t\tshadow.getThisEnclosingJoinPointStaticPartBcelVar().appendLoad(il, fact);\n\t\t\t}\n\t\t}\n\n\t\treturn il;\n\t}\n\n\tpublic InstructionList getNonTestAdviceInstructions(BcelShadow shadow) {\n\t\treturn new InstructionList(Utility.createInvoke(shadow.getFactory(), shadow.getWorld(), getOriginalSignature()));\n\t}\n\n\t@Override\n\tpublic Member getOriginalSignature() {\n\t\tMember sig = getSignature();\n\t\tif (sig instanceof ResolvedMember) {\n\t\t\tResolvedMember rsig = (ResolvedMember) sig;\n\t\t\tif (rsig.hasBackingGenericMember()) {\n\t\t\t\treturn rsig.getBackingGenericMember();\n\t\t\t}\n\t\t}\n\t\treturn sig;\n\t}\n\n\tpublic InstructionList getTestInstructions(BcelShadow shadow, InstructionHandle sk, InstructionHandle fk, InstructionHandle next) {\n\t\t// System.err.println(\"test: \" + pointcutTest);\n\t\treturn BcelRenderer.renderTest(shadow.getFactory(), shadow.getWorld(), runtimeTest, sk, fk, next);\n\t}\n\n\tpublic int compareTo(Object other) {\n\t\tif (!(other instanceof BcelAdvice)) {\n\t\t\treturn 0;\n\t\t}\n\t\tBcelAdvice o = (BcelAdvice) other;\n\n\t\t// System.err.println(\"compareTo: \" + this + \", \" + o);\n\t\tif (kind.getPrecedence() != o.kind.getPrecedence()) {\n\t\t\tif (kind.getPrecedence() > o.kind.getPrecedence()) {\n\t\t\t\treturn +1;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (kind.isCflow()) {\n\t\t\t// System.err.println(\"sort: \" + this + \" innerCflowEntries \" + innerCflowEntries);\n\t\t\t// System.err.println(\"      \" + o + \" innerCflowEntries \" + o.innerCflowEntries);\n\t\t\tboolean isBelow = (kind == AdviceKind.CflowBelowEntry);\n\n\t\t\tif (this.innerCflowEntries.contains(o)) {\n\t\t\t\treturn isBelow ? +1 : -1;\n\t\t\t} else if (o.innerCflowEntries.contains(this)) {\n\t\t\t\treturn isBelow ? -1 : +1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif (kind.isPerEntry() || kind == AdviceKind.Softener) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// System.out.println(\"compare: \" + this + \" with \" + other);\n\t\tWorld world = concreteAspect.getWorld();\n\n\t\tint ret = concreteAspect.getWorld().compareByPrecedence(concreteAspect, o.concreteAspect);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tResolvedType declaringAspect = getDeclaringAspect().resolve(world);\n\t\tResolvedType o_declaringAspect = o.getDeclaringAspect().resolve(world);\n\n\t\tif (declaringAspect == o_declaringAspect) {\n\t\t\tif (kind.isAfter() || o.kind.isAfter()) {\n\t\t\t\treturn this.getStart() < o.getStart() ? -1 : +1;\n\t\t\t} else {\n\t\t\t\treturn this.getStart() < o.getStart() ? +1 : -1;\n\t\t\t}\n\t\t} else if (declaringAspect.isAssignableFrom(o_declaringAspect)) {\n\t\t\treturn -1;\n\t\t} else if (o_declaringAspect.isAssignableFrom(declaringAspect)) {\n\t\t\treturn +1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic BcelVar[] getExposedStateAsBcelVars(boolean isAround) {\n\t\t// ATAJ aspect\n\t\tif (isAround) {\n\t\t\t// the closure instantiation has the same mapping as the extracted method from wich it is called\n\t\t\tif (getConcreteAspect() != null && getConcreteAspect().isAnnotationStyleAspect()) {\n\t\t\t\treturn BcelVar.NONE;\n\t\t\t}\n\t\t}\n\n\t\t// System.out.println(\"vars: \" + Arrays.asList(exposedState.vars));\n\t\tif (exposedState == null) {\n\t\t\treturn BcelVar.NONE;\n\t\t}\n\t\tint len = exposedState.vars.length;\n\t\tBcelVar[] ret = new BcelVar[len];\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tret[i] = (BcelVar) exposedState.vars[i];\n\t\t}\n\t\treturn ret; // (BcelVar[]) exposedState.vars;\n\t}\n\n\tprotected void suppressLintWarnings(World inWorld) {\n\t\tif (suppressedLintKinds == null) {\n\t\t\tif (signature instanceof BcelMethod) {\n\t\t\t\tthis.suppressedLintKinds = Utility.getSuppressedWarnings(signature.getAnnotations(), inWorld.getLint());\n\t\t\t} else {\n\t\t\t\tthis.suppressedLintKinds = Collections.emptyList();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tinWorld.getLint().suppressKinds(suppressedLintKinds);\n\t}\n\n\tprotected void clearLintSuppressions(World inWorld, Collection<Lint.Kind> toClear) {\n\t\tinWorld.getLint().clearSuppressions(toClear);\n\t}\n\n\t/**\n\t * For testing only\n\t */\n\tpublic BcelAdvice(AdviceKind kind, Pointcut pointcut, Member signature, int extraArgumentFlags, int start, int end,\n\t\t\tISourceContext sourceContext, ResolvedType concreteAspect) {\n\t\tthis(new AjAttribute.AdviceAttribute(kind, pointcut, extraArgumentFlags, start, end, sourceContext), pointcut, signature,\n\t\t\t\tconcreteAspect);\n\t\tthrownExceptions = Collections.emptyList(); // !!! interaction with unit tests\n\t}\n\n}\n",
    "size": 32252
  },
  {
    "file_id": "F9",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelAnnotation.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.classfile.annotation.ArrayElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.ElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.EnumElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.NameValuePair;\nimport org.aspectj.weaver.AbstractAnnotationAJ;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\n\n/**\n * Wraps a Bcel Annotation object and uses it to answer AnnotationAJ method calls. This is cheaper than translating all Bcel\n * annotations into AnnotationAJ objects.\n *\n * @author AndyClement\n */\npublic class BcelAnnotation extends AbstractAnnotationAJ {\n\n\tprivate final AnnotationGen bcelAnnotation;\n\n\tpublic BcelAnnotation(AnnotationGen theBcelAnnotation, World world) {\n\t\tsuper(UnresolvedType.forSignature(theBcelAnnotation.getTypeSignature()).resolve(world));\n\t\tthis.bcelAnnotation = theBcelAnnotation;\n\t}\n\n\tpublic BcelAnnotation(AnnotationGen theBcelAnnotation, ResolvedType resolvedAnnotationType) {\n\t\tsuper(resolvedAnnotationType);\n\t\tthis.bcelAnnotation = theBcelAnnotation;\n\t}\n\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tList<NameValuePair> nvPairs = bcelAnnotation.getValues();\n\t\tsb.append(\"Anno[\" + getTypeSignature() + \" \" + (isRuntimeVisible() ? \"rVis\" : \"rInvis\"));\n\t\tif (nvPairs.size() > 0) {\n\t\t\tsb.append(\" \");\n\t\t\tint i = 0;\n\t\t\tfor (NameValuePair element : nvPairs) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(',');\n\t\t\t\t}\n\t\t\t\tsb.append(element.getNameString()).append(\"=\").append(element.getValue().toString());\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tsb.append(\"]\");\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic Set<String> getTargets() {\n\t\tif (!type.equals(UnresolvedType.AT_TARGET)) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tList<NameValuePair> values = bcelAnnotation.getValues();\n\t\tNameValuePair envp = values.get(0);\n\t\tArrayElementValue aev = (ArrayElementValue) envp.getValue();\n\t\tElementValue[] evs = aev.getElementValuesArray();\n\t\tSet<String> targets = new HashSet<>();\n\t\tfor (ElementValue elementValue : evs) {\n\t\t\tEnumElementValue ev = (EnumElementValue) elementValue;\n\t\t\ttargets.add(ev.getEnumValueString());\n\t\t}\n\t\treturn targets;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic boolean hasNameValuePair(String name, String value) {\n\t\treturn bcelAnnotation.hasNameValuePair(name, value);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic boolean hasNamedValue(String name) {\n\t\treturn bcelAnnotation.hasNamedValue(name);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String stringify() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"@\").append(type.getClassName());\n\t\tList<NameValuePair> values = bcelAnnotation.getValues();\n\t\tif (values != null && values.size() != 0) {\n\t\t\tsb.append(\"(\");\n\t\t\tfor (NameValuePair nvPair : values) {\n\t\t\t\tsb.append(nvPair.getNameString()).append(\"=\").append(nvPair.getValue().stringifyValue());\n\t\t\t}\n\t\t\tsb.append(\")\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic boolean isRuntimeVisible() {\n\t\treturn this.bcelAnnotation.isRuntimeVisible();\n\t}\n\n\t/**\n\t * @return return the real bcel annotation being wrapped\n\t */\n\tpublic AnnotationGen getBcelAnnotation() {\n\t\treturn bcelAnnotation;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic String getStringFormOfValue(String name) {\n\t\tList<NameValuePair> annotationValues = this.bcelAnnotation.getValues();\n\t\tif (annotationValues == null || annotationValues.size() == 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tfor (NameValuePair nvPair : annotationValues) {\n\t\t\t\tif (nvPair.getNameString().equals(name)) {\n\t\t\t\t\treturn nvPair.getValue().stringifyValue();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n}\n",
    "size": 4343
  },
  {
    "file_id": "F10",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelCflowAccessVar.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.ResolvedType;\n\n/**\n * XXX Erik and I need to discuss this hierarchy. Having FieldRef extend Var is convenient, but hopefully there's a better design.\n *\n * This is always a static reference.\n */\npublic class BcelCflowAccessVar extends BcelVar {\n\n\tprivate Member stackField;\n\tprivate int index;\n\n\t/**\n\t * @param type The type to convert to from Object\n\t * @param stackField the member containing the CFLOW_STACK_TYPE\n\t * @param index yeah yeah\n\t */\n\tpublic BcelCflowAccessVar(ResolvedType type, Member stackField, int index) {\n\t\tsuper(type, 0);\n\t\tthis.stackField = stackField;\n\t\tthis.index = index;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"BcelCflowAccessVar(\" + getType() + \" \" + stackField + \".\" + index + \")\";\n\t}\n\n\tpublic Instruction createLoad(InstructionFactory fact) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic Instruction createStore(InstructionFactory fact) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\n\t\til.append(createLoadInstructions(getType(), fact));\n\t}\n\n\tpublic InstructionList createLoadInstructions(ResolvedType toType, InstructionFactory fact) {\n\t\tInstructionList il = new InstructionList();\n\n\t\til.append(Utility.createGet(fact, stackField));\n\t\til.append(Utility.createConstant(fact, index));\n\t\til.append(fact.createInvoke(NameMangler.CFLOW_STACK_TYPE, \"get\", Type.OBJECT, new Type[] { Type.INT },\n\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\til.append(Utility.createConversion(fact, Type.OBJECT, BcelWorld.makeBcelType(toType)));\n\n\t\treturn il;\n\n\t}\n\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\n\t\til.append(createLoadInstructions(toType, fact));\n\n\t}\n\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\n\t\til.insert(createLoadInstructions(getType(), fact));\n\t}\n\n}\n",
    "size": 2895
  },
  {
    "file_id": "F11",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelCflowCounterFieldAdder.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2004 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *      (Andy Clement)\n *******************************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.FieldGen;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\n\n/**\n * This type munger will modify a given class (see the munge() method) to include a field representing a CflowCounter object.\n */\npublic class BcelCflowCounterFieldAdder extends BcelTypeMunger {\n\tprivate ResolvedMember cflowCounterField;\n\n\tpublic BcelCflowCounterFieldAdder(ResolvedMember cflowCounterField) {\n\t\tsuper(null, (ResolvedType) cflowCounterField.getDeclaringType());\n\t\tthis.cflowCounterField = cflowCounterField;\n\t}\n\n\tpublic boolean munge(BcelClassWeaver weaver) {\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\n\t\t// Only munge one type!\n\t\tif (!gen.getType().equals(cflowCounterField.getDeclaringType()))\n\t\t\treturn false;\n\n\t\t// Create the field declaration.\n\t\t// Something like: \"public static final CflowCounter ajc$cflowCounter$0;\"\n\t\tFieldGen f = new FieldGen(cflowCounterField.getModifiers(), BcelWorld.makeBcelType(cflowCounterField.getReturnType()),\n\t\t\t\tcflowCounterField.getName(), gen.getConstantPool());\n\n\t\tgen.addField(f, getSourceLocation());\n\n\t\t// Modify the ajc$preClinit() method to initialize it.\n\t\t// Something like: \"ajc$cflowCounter$0 = new CflowCounter();\"\n\t\tLazyMethodGen clinit = gen.getAjcPreClinit(); // StaticInitializer();\n\t\tInstructionList setup = new InstructionList();\n\t\tInstructionFactory fact = gen.getFactory();\n\n\t\tsetup.append(fact.createNew(new ObjectType(NameMangler.CFLOW_COUNTER_TYPE)));\n\t\tsetup.append(InstructionFactory.createDup(1));\n\t\tsetup.append(fact.createInvoke(NameMangler.CFLOW_COUNTER_TYPE, \"<init>\", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));\n\n\t\tsetup.append(Utility.createSet(fact, cflowCounterField));\n\t\tclinit.getBody().insert(setup);\n\n\t\treturn true;\n\t}\n\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\n\t\treturn null;\n\t}\n\n\tpublic ResolvedMember getSignature() {\n\t\treturn cflowCounterField;\n\t}\n\n\tpublic boolean matches(ResolvedType onType) {\n\t\treturn onType.equals(cflowCounterField.getDeclaringType());\n\t}\n\n\tpublic boolean existsToSupportShadowMunging() {\n\t\treturn true;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(BcelTypeMunger: CflowField \" + cflowCounterField.getDeclaringType().getName() + \" \" + cflowCounterField.getName()\n\t\t\t\t+ \")\";\n\t}\n\n}\n",
    "size": 3207
  },
  {
    "file_id": "F12",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.FieldGen;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\n\npublic class BcelCflowStackFieldAdder extends BcelTypeMunger {\n\tprivate ResolvedMember cflowStackField;\n\n\tpublic BcelCflowStackFieldAdder(ResolvedMember cflowStackField) {\n\t\tsuper(null, (ResolvedType) cflowStackField.getDeclaringType());\n\t\tthis.cflowStackField = cflowStackField;\n\t}\n\n\t@Override\n\tpublic boolean munge(BcelClassWeaver weaver) {\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\t\tif (!gen.getType().equals(cflowStackField.getDeclaringType())) {\n\t\t\treturn false;\n\t\t}\n\t\tFieldGen f = new FieldGen(cflowStackField.getModifiers(), BcelWorld.makeBcelType(cflowStackField.getReturnType()),\n\t\t\t\tcflowStackField.getName(), gen.getConstantPool());\n\t\tgen.addField(f, getSourceLocation());\n\n\t\tLazyMethodGen clinit = gen.getAjcPreClinit(); // StaticInitializer();\n\t\tInstructionList setup = new InstructionList();\n\t\tInstructionFactory fact = gen.getFactory();\n\n\t\tsetup.append(fact.createNew(NameMangler.CFLOW_STACK_TYPE));\n\t\tsetup.append(InstructionFactory.createDup(1));\n\t\tsetup.append(fact.createInvoke(NameMangler.CFLOW_STACK_TYPE, \"<init>\", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));\n\n\t\tsetup.append(Utility.createSet(fact, cflowStackField));\n\t\tclinit.getBody().insert(setup);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic ResolvedMember getSignature() {\n\t\treturn cflowStackField;\n\t}\n\n\t@Override\n\tpublic boolean matches(ResolvedType onType) {\n\t\treturn onType.equals(cflowStackField.getDeclaringType());\n\t}\n\n\t@Override\n\tpublic boolean existsToSupportShadowMunging() {\n\t\treturn true;\n\t}\n\n}\n",
    "size": 2567
  },
  {
    "file_id": "F13",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelClassWeaver.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.BootstrapMethods;\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.apache.bcel.classfile.Method;\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.generic.FieldGen;\nimport org.aspectj.apache.bcel.generic.FieldInstruction;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionBranch;\nimport org.aspectj.apache.bcel.generic.InstructionCP;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionLV;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.InstructionSelect;\nimport org.aspectj.apache.bcel.generic.InstructionTargeter;\nimport org.aspectj.apache.bcel.generic.InvokeInstruction;\nimport org.aspectj.apache.bcel.generic.LineNumberTag;\nimport org.aspectj.apache.bcel.generic.LocalVariableTag;\nimport org.aspectj.apache.bcel.generic.MULTIANEWARRAY;\nimport org.aspectj.apache.bcel.generic.MethodGen;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.RET;\nimport org.aspectj.apache.bcel.generic.Tag;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.asm.AsmManager;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.bridge.Message;\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.bridge.WeaveMessage;\nimport org.aspectj.bridge.context.CompilationAndWeavingContext;\nimport org.aspectj.bridge.context.ContextToken;\nimport org.aspectj.util.PartialOrder;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjcMemberMaker;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.ConcreteTypeMunger;\nimport org.aspectj.weaver.IClassWeaver;\nimport org.aspectj.weaver.IntMap;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.MissingResolvedTypeWithKnownSignature;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.NewConstructorTypeMunger;\nimport org.aspectj.weaver.NewFieldTypeMunger;\nimport org.aspectj.weaver.NewMethodTypeMunger;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedMemberImpl;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ResolvedTypeMunger;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.UnresolvedTypeVariableReferenceType;\nimport org.aspectj.weaver.WeaverStateInfo;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.model.AsmRelationshipProvider;\nimport org.aspectj.weaver.patterns.DeclareAnnotation;\nimport org.aspectj.weaver.patterns.ExactTypePattern;\nimport org.aspectj.weaver.tools.Trace;\nimport org.aspectj.weaver.tools.TraceFactory;\n\nclass BcelClassWeaver implements IClassWeaver {\n\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelClassWeaver.class);\n\n\t// Name of helper method generated by JDT compiler. Javac uses a separate inner class.\n\tprivate static final String SWITCH_TABLE_SYNTHETIC_METHOD_PREFIX = \"$SWITCH_TABLE$\";\n\n\tpublic static boolean weave(BcelWorld world, LazyClassGen clazz, List<ShadowMunger> shadowMungers,\n\t\t\tList<ConcreteTypeMunger> typeMungers, List<ConcreteTypeMunger> lateTypeMungers, boolean inReweavableMode) {\n\t\tBcelClassWeaver classWeaver = new BcelClassWeaver(world, clazz, shadowMungers, typeMungers, lateTypeMungers);\n\t\tclassWeaver.setReweavableMode(inReweavableMode);\n\t\tboolean b = classWeaver.weave();\n\t\treturn b;\n\t}\n\n\t// --------------------------------------------\n\n\tprivate final LazyClassGen clazz;\n\tprivate final List<ShadowMunger> shadowMungers;\n\tprivate final List<ConcreteTypeMunger> typeMungers;\n\tprivate final List<ConcreteTypeMunger> lateTypeMungers;\n\n\tprivate List<ShadowMunger>[] indexedShadowMungers;\n\tprivate boolean canMatchBodyShadows = false;\n\n\tprivate final BcelObjectType ty; // alias of clazz.getType()\n\tprivate final BcelWorld world; // alias of ty.getWorld()\n\tprivate final ConstantPool cpg; // alias of clazz.getConstantPoolGen()\n\tprivate final InstructionFactory fact; // alias of clazz.getFactory();\n\n\tprivate final List<LazyMethodGen> addedLazyMethodGens = new ArrayList<>();\n\tprivate final Set<ResolvedMember> addedDispatchTargets = new HashSet<>();\n\n\tprivate boolean inReweavableMode = false;\n\n\tprivate List<IfaceInitList> addedSuperInitializersAsList = null;\n\tprivate final Map<ResolvedType, IfaceInitList> addedSuperInitializers = new HashMap<>();\n\tprivate final List<ConcreteTypeMunger> addedThisInitializers = new ArrayList<>();\n\tprivate final List<ConcreteTypeMunger> addedClassInitializers = new ArrayList<>();\n\n\tprivate final Map<ResolvedMember, ResolvedMember> mapToAnnotationHolder = new HashMap<>();\n\n\t// private BcelShadow clinitShadow = null;\n\n\t/**\n\t * This holds the initialization and pre-initialization shadows for this class that were actually matched by mungers (if no\n\t * match, then we don't even create the shadows really).\n\t */\n\tprivate final List<BcelShadow> initializationShadows = new ArrayList<>();\n\n\tprivate BcelClassWeaver(BcelWorld world, LazyClassGen clazz, List<ShadowMunger> shadowMungers,\n\t\t\tList<ConcreteTypeMunger> typeMungers, List<ConcreteTypeMunger> lateTypeMungers) {\n\t\tsuper();\n\t\tthis.world = world;\n\t\tthis.clazz = clazz;\n\t\tthis.shadowMungers = shadowMungers;\n\t\tthis.typeMungers = typeMungers;\n\t\tthis.lateTypeMungers = lateTypeMungers;\n\t\tthis.ty = clazz.getBcelObjectType();\n\t\tthis.cpg = clazz.getConstantPool();\n\t\tthis.fact = clazz.getFactory();\n\n\t\tindexShadowMungers();\n\n\t\tinitializeSuperInitializerMap(ty.getResolvedTypeX());\n\t\tif (!checkedXsetForLowLevelContextCapturing) {\n\t\t\tProperties p = world.getExtraConfiguration();\n\t\t\tif (p != null) {\n\t\t\t\tString s = p.getProperty(World.xsetCAPTURE_ALL_CONTEXT, \"false\");\n\t\t\t\tcaptureLowLevelContext = s.equalsIgnoreCase(\"true\");\n\t\t\t\tif (captureLowLevelContext) {\n\t\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\t\tMessageUtil.info(\"[\" + World.xsetCAPTURE_ALL_CONTEXT\n\t\t\t\t\t\t\t\t\t+ \"=true] Enabling collection of low level context for debug/crash messages\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckedXsetForLowLevelContextCapturing = true;\n\t\t}\n\t}\n\n\tprivate boolean canMatch(Shadow.Kind kind) {\n\t\treturn indexedShadowMungers[kind.getKey()] != null;\n\t}\n\n\t// private void fastMatchShadowMungers(List shadowMungers, ArrayList\n\t// mungers, Kind kind) {\n\t// FastMatchInfo info = new FastMatchInfo(clazz.getType(), kind);\n\t// for (Iterator i = shadowMungers.iterator(); i.hasNext();) {\n\t// ShadowMunger munger = (ShadowMunger) i.next();\n\t// FuzzyBoolean fb = munger.getPointcut().fastMatch(info);\n\t// WeaverMetrics.recordFastMatchResult(fb);// Could pass:\n\t// munger.getPointcut().toString()\n\t// if (fb.maybeTrue()) mungers.add(munger);\n\t// }\n\t// }\n\n\tprivate void initializeSuperInitializerMap(ResolvedType child) {\n\t\tResolvedType[] superInterfaces = child.getDeclaredInterfaces();\n\t\tfor (ResolvedType superInterface : superInterfaces) {\n\t\t\tif (ty.getResolvedTypeX().isTopmostImplementor(superInterface)) {\n\t\t\t\tif (addSuperInitializer(superInterface)) {\n\t\t\t\t\tinitializeSuperInitializerMap(superInterface);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Process the shadow mungers into array 'buckets', each bucket represents a shadow kind and contains a list of shadowmungers\n\t * that could potentially apply at that shadow kind.\n\t */\n\tprivate void indexShadowMungers() {\n\t\t// beware the annoying property that SHADOW_KINDS[i].getKey == (i+1) !\n\t\tindexedShadowMungers = new List[Shadow.MAX_SHADOW_KIND + 1];\n\t\tfor (ShadowMunger shadowMunger : shadowMungers) {\n\t\t\tint couldMatchKinds = shadowMunger.getPointcut().couldMatchKinds();\n\t\t\tfor (Shadow.Kind kind : Shadow.SHADOW_KINDS) {\n\t\t\t\tif (kind.isSet(couldMatchKinds)) {\n\t\t\t\t\tbyte k = kind.getKey();\n\t\t\t\t\tif (indexedShadowMungers[k] == null) {\n\t\t\t\t\t\tindexedShadowMungers[k] = new ArrayList<>();\n\t\t\t\t\t\tif (!kind.isEnclosingKind()) {\n\t\t\t\t\t\t\tcanMatchBodyShadows = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tindexedShadowMungers[k].add(shadowMunger);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean addSuperInitializer(ResolvedType onType) {\n\t\tif (onType.isRawType() || onType.isParameterizedType()) {\n\t\t\tonType = onType.getGenericType();\n\t\t}\n\t\tIfaceInitList l = addedSuperInitializers.get(onType);\n\t\tif (l != null) {\n\t\t\treturn false;\n\t\t}\n\t\tl = new IfaceInitList(onType);\n\t\taddedSuperInitializers.put(onType, l);\n\t\treturn true;\n\t}\n\n\tpublic void addInitializer(ConcreteTypeMunger cm) {\n\t\tNewFieldTypeMunger m = (NewFieldTypeMunger) cm.getMunger();\n\t\tResolvedType onType = m.getSignature().getDeclaringType().resolve(world);\n\t\tif (onType.isRawType()) {\n\t\t\tonType = onType.getGenericType();\n\t\t}\n\n\t\tif (Modifier.isStatic(m.getSignature().getModifiers())) {\n\t\t\taddedClassInitializers.add(cm);\n\t\t} else {\n\t\t\tif (onType == ty.getResolvedTypeX()) {\n\t\t\t\taddedThisInitializers.add(cm);\n\t\t\t} else {\n\t\t\t\tIfaceInitList l = addedSuperInitializers.get(onType);\n\t\t\t\tl.list.add(cm);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class IfaceInitList implements PartialOrder.PartialComparable {\n\t\tfinal ResolvedType onType;\n\t\tList<ConcreteTypeMunger> list = new ArrayList<>();\n\n\t\tIfaceInitList(ResolvedType onType) {\n\t\t\tthis.onType = onType;\n\t\t}\n\n\t\tpublic int compareTo(Object other) {\n\t\t\tIfaceInitList o = (IfaceInitList) other;\n\t\t\tif (onType.isAssignableFrom(o.onType)) {\n\t\t\t\treturn +1;\n\t\t\t} else if (o.onType.isAssignableFrom(onType)) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic int fallbackCompareTo(Object other) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t// XXX this is being called, but the result doesn't seem to be being used\n\tpublic boolean addDispatchTarget(ResolvedMember m) {\n\t\treturn addedDispatchTargets.add(m);\n\t}\n\n\tpublic void addLazyMethodGen(LazyMethodGen gen) {\n\t\taddedLazyMethodGens.add(gen);\n\t}\n\n\tpublic void addOrReplaceLazyMethodGen(LazyMethodGen mg) {\n\t\tif (alreadyDefined(clazz, mg)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Iterator<LazyMethodGen> i = addedLazyMethodGens.iterator(); i.hasNext();) {\n\t\t\tLazyMethodGen existing = i.next();\n\t\t\tif (signaturesMatch(mg, existing)) {\n\t\t\t\tif (existing.definingType == null) {\n\t\t\t\t\t// this means existing was introduced on the class itself\n\t\t\t\t\treturn;\n\t\t\t\t} else if (mg.definingType.isAssignableFrom(existing.definingType)) {\n\t\t\t\t\t// existing is mg's subtype and dominates mg\n\t\t\t\t\treturn;\n\t\t\t\t} else if (existing.definingType.isAssignableFrom(mg.definingType)) {\n\t\t\t\t\t// mg is existing's subtype and dominates existing\n\t\t\t\t\ti.remove();\n\t\t\t\t\taddedLazyMethodGens.add(mg);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new BCException(\"conflict between: \" + mg + \" and \" + existing);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\taddedLazyMethodGens.add(mg);\n\t}\n\n\tprivate boolean alreadyDefined(LazyClassGen clazz, LazyMethodGen mg) {\n\t\tfor (Iterator<LazyMethodGen> i = clazz.getMethodGens().iterator(); i.hasNext();) {\n\t\t\tLazyMethodGen existing = i.next();\n\t\t\tif (signaturesMatch(mg, existing)) {\n\t\t\t\tif (!mg.isAbstract() && existing.isAbstract()) {\n\t\t\t\t\ti.remove();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean signaturesMatch(LazyMethodGen mg, LazyMethodGen existing) {\n\t\treturn mg.getName().equals(existing.getName()) && mg.getSignature().equals(existing.getSignature());\n\t}\n\n\tprotected static LazyMethodGen makeBridgeMethod(LazyClassGen gen, ResolvedMember member) {\n\n\t\t// remove abstract modifier\n\t\tint mods = member.getModifiers();\n\t\tif (Modifier.isAbstract(mods)) {\n\t\t\tmods = mods - Modifier.ABSTRACT;\n\t\t}\n\n\t\tLazyMethodGen ret = new LazyMethodGen(mods, BcelWorld.makeBcelType(member.getReturnType()), member.getName(),\n\t\t\t\tBcelWorld.makeBcelTypes(member.getParameterTypes()), UnresolvedType.getNames(member.getExceptions()), gen);\n\n\t\t// 43972 : Static crosscutting makes interfaces unusable for javac\n\t\t// ret.makeSynthetic();\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Create a single bridge method called 'theBridgeMethod' that bridges to 'whatToBridgeTo'\n\t */\n\tprivate static void createBridgeMethod(BcelWorld world, LazyMethodGen whatToBridgeToMethodGen, LazyClassGen clazz, ResolvedMember theBridgeMethod) {\n\t\tInstructionList body;\n\t\tInstructionFactory fact;\n\t\tint pos = 0;\n\n\t\tResolvedMember whatToBridgeTo = whatToBridgeToMethodGen.getMemberView();\n\n\t\tif (whatToBridgeTo == null) {\n\t\t\twhatToBridgeTo = new ResolvedMemberImpl(Member.METHOD, whatToBridgeToMethodGen.getEnclosingClass().getType(),\n\t\t\t\t\twhatToBridgeToMethodGen.getAccessFlags(), whatToBridgeToMethodGen.getName(),\n\t\t\t\t\twhatToBridgeToMethodGen.getSignature());\n\t\t}\n\t\t// The bridge method in this type will have the same signature as the one in the supertype\n\t\tLazyMethodGen bridgeMethod = makeBridgeMethod(clazz, theBridgeMethod);\n\t\tint newflags = bridgeMethod.getAccessFlags() | Constants.ACC_BRIDGE | Constants.ACC_SYNTHETIC ;// BRIDGE = 0x00000040\n\n\t\tif ((newflags & 0x00000100) != 0) {\n\t\t\tnewflags = newflags - 0x100;// NATIVE = 0x00000100 - need to clear it\n\t\t}\n\n\t\tbridgeMethod.setAccessFlags(newflags);\n\t\tType returnType = BcelWorld.makeBcelType(theBridgeMethod.getReturnType());\n\t\tType[] paramTypes = BcelWorld.makeBcelTypes(theBridgeMethod.getParameterTypes());\n\t\tType[] newParamTypes = whatToBridgeToMethodGen.getArgumentTypes();\n\t\tbody = bridgeMethod.getBody();\n\t\tfact = clazz.getFactory();\n\n\t\tif (!whatToBridgeToMethodGen.isStatic()) {\n\t\t\tbody.append(InstructionFactory.createThis());\n\t\t\tpos++;\n\t\t}\n\t\tfor (int i = 0, len = paramTypes.length; i < len; i++) {\n\t\t\tType paramType = paramTypes[i];\n\t\t\tbody.append(InstructionFactory.createLoad(paramType, pos));\n\t\t\tif (!newParamTypes[i].equals(paramTypes[i])) {\n\t\t\t\tif (world.forDEBUG_bridgingCode) {\n\t\t\t\t\tSystem.err.println(\"Bridging: Cast \" + newParamTypes[i] + \" from \" + paramTypes[i]);\n\t\t\t\t}\n\t\t\t\tbody.append(fact.createCast(paramTypes[i], newParamTypes[i]));\n\t\t\t}\n\t\t\tpos += paramType.getSize();\n\t\t}\n\n\t\tbody.append(Utility.createInvoke(fact, world, whatToBridgeTo));\n\t\tbody.append(InstructionFactory.createReturn(returnType));\n\t\tclazz.addMethodGen(bridgeMethod);\n\t}\n\n\t/**\n\t * Weave a class and indicate through the return value whether the class was modified.\n\t *\n\t * @return true if the class was modified\n\t */\n\tpublic boolean weave() {\n\t\tif (clazz.isWoven() && !clazz.isReweavable()) {\n\t\t\tif (world.getLint().nonReweavableTypeEncountered.isEnabled()) {\n\t\t\t\tworld.getLint().nonReweavableTypeEncountered.signal(clazz.getType().getName(), ty.getSourceLocation());\n\t\t\t}\n\t\t\t// Integer uniqueID = new Integer(rm.hashCode() * deca.hashCode());\n\t\t\t// if (!reportedProblems.contains(uniqueID)) {\n\t\t\t// reportedProblems.add(uniqueID);\n\t\t\t// world.getLint().elementAlreadyAnnotated.signal(new String[] { rm.toString(),\n\t\t\t// world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.ALREADY_WOVEN, clazz.getType().getName()),\n\t\t\t// ty.getSourceLocation(), null);\n\t\t\treturn false;\n\t\t}\n\n\t\tSet<String> aspectsAffectingType = null;\n\t\tif (inReweavableMode || clazz.getType().isAspect()) {\n\t\t\taspectsAffectingType = new HashSet<>();\n\t\t}\n\n\t\tboolean isChanged = false;\n\n\t\t// we want to \"touch\" all aspects\n\t\tif (clazz.getType().isAspect()) {\n\t\t\tisChanged = true;\n\t\t}\n\n\t\tWeaverStateInfo typeWeaverState = (world.isOverWeaving() ? getLazyClassGen().getType().getWeaverState() : null);\n\t\t// start by munging all typeMungers\n\t\tfor (ConcreteTypeMunger o : typeMungers) {\n\t\t\tif (!(o instanceof BcelTypeMunger)) {\n\t\t\t\t// ???System.err.println(\"surprising: \" + o);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tBcelTypeMunger munger = (BcelTypeMunger) o;\n\n\t\t\tif (typeWeaverState != null && typeWeaverState.isAspectAlreadyApplied(munger.getAspectType())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean typeMungerAffectedType = munger.munge(this);\n\t\t\tif (typeMungerAffectedType) {\n\t\t\t\tisChanged = true;\n\t\t\t\tif (inReweavableMode || clazz.getType().isAspect()) {\n\t\t\t\t\taspectsAffectingType.add(munger.getAspectType().getSignature());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Weave special half type/half shadow mungers...\n\t\tisChanged = weaveDeclareAtMethodCtor(clazz) || isChanged;\n\t\tisChanged = weaveDeclareAtField(clazz) || isChanged;\n\n\t\t// XXX do major sort of stuff\n\t\t// sort according to: Major: type hierarchy\n\t\t// within each list: dominates\n\t\t// don't forget to sort addedThisInitialiers according to dominates\n\t\taddedSuperInitializersAsList = new ArrayList<>(addedSuperInitializers.values());\n\t\taddedSuperInitializersAsList = PartialOrder.sort(addedSuperInitializersAsList);\n\t\tif (addedSuperInitializersAsList == null) {\n\t\t\tthrow new BCException(\"circularity in inter-types\");\n\t\t}\n\n\t\t// this will create a static initializer if there isn't one\n\t\t// this is in just as bad taste as NOPs\n\t\tLazyMethodGen staticInit = clazz.getStaticInitializer();\n\t\tstaticInit.getBody().insert(genInitInstructions(addedClassInitializers, true));\n\n\t\t// now go through each method, and match against each method. This\n\t\t// sets up each method's {@link LazyMethodGen#matchedShadows} field,\n\t\t// and it also possibly adds to {@link #initializationShadows}.\n\t\tList<LazyMethodGen> methodGens = new ArrayList<>(clazz.getMethodGens());\n\t\tfor (LazyMethodGen member : methodGens) {\n\t\t\tif (!member.hasBody()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (world.isJoinpointSynchronizationEnabled() && world.areSynchronizationPointcutsInUse()\n\t\t\t\t\t&& member.getMethod().isSynchronized()) {\n\t\t\t\ttransformSynchronizedMethod(member);\n\t\t\t}\n\t\t\tboolean shadowMungerMatched = match(member);\n\t\t\tif (shadowMungerMatched) {\n\t\t\t\t// For matching mungers, add their declaring aspects to the list\n\t\t\t\t// that affected this type\n\t\t\t\tif (inReweavableMode || clazz.getType().isAspect()) {\n\t\t\t\t\taspectsAffectingType.addAll(findAspectsForMungers(member));\n\t\t\t\t}\n\t\t\t\tisChanged = true;\n\t\t\t}\n\t\t}\n\n\t\t// now we weave all but the initialization shadows\n\t\tfor (LazyMethodGen methodGen : methodGens) {\n\t\t\tif (!methodGen.hasBody()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\timplement(methodGen);\n\t\t}\n\n\t\t// if we matched any initialization shadows, we inline and weave\n\t\tif (!initializationShadows.isEmpty()) {\n\t\t\t// Repeat next step until nothing left to inline...cant go on\n\t\t\t// infinetly as compiler will have detected and reported\n\t\t\t// \"Recursive constructor invocation\"\n\t\t\tList<LazyMethodGen> recursiveCtors = new ArrayList<>();\n\t\t\twhile (inlineSelfConstructors(methodGens, recursiveCtors)) {\n\t\t\t}\n\t\t\tpositionAndImplement(initializationShadows);\n\t\t}\n\n\t\t// now proceed with late type mungers\n\t\tif (lateTypeMungers != null) {\n\t\t\tfor (ConcreteTypeMunger lateTypeMunger : lateTypeMungers) {\n\t\t\t\tBcelTypeMunger munger = (BcelTypeMunger) lateTypeMunger;\n\t\t\t\tif (munger.matches(clazz.getType())) {\n\t\t\t\t\tboolean typeMungerAffectedType = munger.munge(this);\n\t\t\t\t\tif (typeMungerAffectedType) {\n\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\tif (inReweavableMode || clazz.getType().isAspect()) {\n\t\t\t\t\t\t\taspectsAffectingType.add(munger.getAspectType().getSignature());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// FIXME AV - see #75442, for now this is not enough to fix the bug,\n\t\t// comment that out until we really fix it\n\t\t// // flush to save some memory\n\t\t// PerObjectInterfaceTypeMunger.unregisterFromAsAdvisedBy(clazz.getType()\n\t\t// );\n\n\t\t// finally, if we changed, we add in the introduced methods.\n\t\tif (isChanged) {\n\t\t\tclazz.getOrCreateWeaverStateInfo(inReweavableMode);\n\t\t\tweaveInAddedMethods();\n\t\t}\n\n\t\tif (inReweavableMode) {\n\t\t\tWeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo(true);\n\t\t\twsi.addAspectsAffectingType(aspectsAffectingType);\n\t\t\tif (!world.isOverWeaving()) {\n\t\t\t\twsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());\n\t\t\t\twsi.setReweavable(true);\n\t\t\t} else {\n\t\t\t\twsi.markOverweavingInUse();\n\t\t\t}\n\t\t} else {\n\t\t\tclazz.getOrCreateWeaverStateInfo(false).setReweavable(false);\n\t\t}\n\n\t\t// tidyup, reduce ongoing memory usage of BcelMethods that hang around\n\t\tfor (LazyMethodGen mg : methodGens) {\n\t\t\tBcelMethod method = mg.getMemberView();\n\t\t\tif (method != null) {\n\t\t\t\tmethod.wipeJoinpointSignatures();\n\t\t\t}\n\t\t}\n\n\t\treturn isChanged;\n\t}\n\n\t// **************************** start of bridge method creation code\n\t// *****************\n\n\t// FIXASC tidy this lot up !!\n\t// FIXASC refactor into ResolvedType or even ResolvedMember?\n\t/**\n\t * Check if a particular method is overriding another - refactored into this helper so it can be used from multiple places.\n\t * @return method that is overriding if it\n\t */\n\tprivate static ResolvedMember isOverriding(ResolvedType typeToCheck, ResolvedMember methodThatMightBeGettingOverridden,\n\t\t\tString mname, String mrettype, int mmods, boolean inSamePackage, UnresolvedType[] methodParamsArray) {\n\t\t// Check if we can be an override...\n\t\tif (Modifier.isStatic(methodThatMightBeGettingOverridden.getModifiers())) {\n\t\t\t// we can't be overriding a static method\n\t\t\treturn null;\n\t\t}\n\t\tif (Modifier.isPrivate(methodThatMightBeGettingOverridden.getModifiers())) {\n\t\t\t// we can't be overriding a private method\n\t\t\treturn null;\n\t\t}\n\t\tif (!methodThatMightBeGettingOverridden.getName().equals(mname)) {\n\t\t\t// names do not match (this will also skip <init> and <clinit>)\n\t\t\treturn null;\n\t\t}\n\t\tif (methodThatMightBeGettingOverridden.getParameterTypes().length != methodParamsArray.length) {\n\t\t\t// not the same number of parameters\n\t\t\treturn null;\n\t\t}\n\t\tif (!isVisibilityOverride(mmods, methodThatMightBeGettingOverridden, inSamePackage)) {\n\t\t\t// not override from visibility point of view\n\t\t\treturn null;\n\t\t}\n\n\t\tif (typeToCheck.getWorld().forDEBUG_bridgingCode) {\n\t\t\tSystem.err.println(\"  Bridging:seriously considering this might be getting overridden '\"\n\t\t\t\t\t+ methodThatMightBeGettingOverridden + \"'\");\n\t\t}\n\n\t\tWorld w = typeToCheck.getWorld();\n\n\t\t// Look at erasures of parameters (List<String> erased is List)\n\t\tboolean sameParams = true;\n\t\tfor (int p = 0, max = methodThatMightBeGettingOverridden.getParameterTypes().length; p < max; p++) {\n\n\t\t\tUnresolvedType mtmbgoParameter = methodThatMightBeGettingOverridden.getParameterTypes()[p];\n\t\t\tUnresolvedType ptype = methodParamsArray[p];\n\n\t\t\tif (mtmbgoParameter.isTypeVariableReference()) {\n\t\t\t\tif (!mtmbgoParameter.resolve(w).isAssignableFrom(ptype.resolve(w))) {\n\t\t\t\t\tsameParams = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// old condition:\n\t\t\t\tboolean b = !methodThatMightBeGettingOverridden.getParameterTypes()[p].getErasureSignature().equals(\n\t\t\t\t\t\tmethodParamsArray[p].getErasureSignature());\n\n\t\t\t\tUnresolvedType parameterType = methodThatMightBeGettingOverridden.getParameterTypes()[p];\n\n\t\t\t\t// Collapse to first bound (isn't that the same as erasure!\n\t\t\t\tif (parameterType instanceof UnresolvedTypeVariableReferenceType) {\n\t\t\t\t\tparameterType = ((UnresolvedTypeVariableReferenceType) parameterType).getTypeVariable().getFirstBound();\n\t\t\t\t}\n\n\t\t\t\tif (b) { // !parameterType.resolve(w).equals(parameterType2.resolve(w))) {\n\t\t\t\t\tsameParams = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\t// if (!ut.getErasureSignature().equals(ut2.getErasureSignature()))\n\t\t\t// sameParams = false;\n\t\t}\n\n\t\t// If the 'typeToCheck' represents a parameterized type then the method\n\t\t// will be the parameterized form of the\n\t\t// generic method in the generic type. So if the method was 'void\n\t\t// m(List<T> lt, T t)' and the parameterized type here\n\t\t// is I<String> then the method we are looking at will be 'void\n\t\t// m(List<String> lt, String t)' which when erased\n\t\t// is 'void m(List lt,String t)' - so if the parameters *do* match then\n\t\t// there is a generic method we are\n\t\t// overriding\n\n\t\t// FIXASC Why bother with the return type? If it is incompatible then the code has other problems!\n\t\tif (sameParams) {\n\t\t\tif (typeToCheck.isParameterizedType()) {\n\t\t\t\treturn methodThatMightBeGettingOverridden.getBackingGenericMember();\n\t\t\t} else if (!methodThatMightBeGettingOverridden.getReturnType().getErasureSignature().equals(mrettype)) {\n\t\t\t\t// addressing the wierd situation from bug 147801\n\t\t\t\t// just check whether these things are in the right relationship\n\t\t\t\t// for covariance...\n\t\t\t\tResolvedType superReturn = typeToCheck.getWorld().resolve(\n\t\t\t\t\t\tUnresolvedType.forSignature(methodThatMightBeGettingOverridden.getReturnType().getErasureSignature()));\n\t\t\t\tResolvedType subReturn = typeToCheck.getWorld().resolve(UnresolvedType.forSignature(mrettype));\n\t\t\t\tif (superReturn.isAssignableFrom(subReturn)) {\n\t\t\t\t\treturn methodThatMightBeGettingOverridden;\n\t\t\t\t}\n\t\t\t\t// } else if (typeToCheck.isParameterizedType()) {\n\t\t\t\t// return methodThatMightBeGettingOverridden.getBackingGenericMember();\n\t\t\t} else {\n\t\t\t\treturn methodThatMightBeGettingOverridden;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Looks at the visibility modifiers between two methods, and knows whether they are from classes in the same package, and\n\t * decides whether one overrides the other.\n\t *\n\t * @return true if there is an overrides rather than a 'hides' relationship\n\t */\n\tstatic boolean isVisibilityOverride(int methodMods, ResolvedMember inheritedMethod, boolean inSamePackage) {\n\t\tint inheritedModifiers = inheritedMethod.getModifiers();\n\t\tif (Modifier.isStatic(inheritedModifiers)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (methodMods == inheritedModifiers) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (Modifier.isPrivate(inheritedModifiers)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean isPackageVisible = !Modifier.isPrivate(inheritedModifiers) && !Modifier.isProtected(inheritedModifiers)\n\t\t\t\t&& !Modifier.isPublic(inheritedModifiers);\n\t\tif (isPackageVisible && !inSamePackage) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * This method recurses up a specified type looking for a method that overrides the one passed in.\n\t *\n\t * @return the method being overridden or null if none is found\n\t */\n\tpublic static void checkForOverride(ResolvedType typeToCheck, String mname, String mparams, String mrettype,\n\t\t\tint mmods, String mpkg, UnresolvedType[] methodParamsArray, List<ResolvedMember> overriddenMethodsCollector) {\n\n\t\tif (typeToCheck == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (typeToCheck instanceof MissingResolvedTypeWithKnownSignature) {\n\t\t\treturn; // we just can't tell !\n\t\t}\n\n\n\t\tif (typeToCheck.getWorld().forDEBUG_bridgingCode) {\n\t\t\tSystem.err.println(\"  Bridging:checking for override of \" + mname + \" in \" + typeToCheck);\n\t\t}\n\n\t\tString packageName = typeToCheck.getPackageName();\n\t\tif (packageName == null) {\n\t\t\tpackageName = \"\";\n\t\t}\n\t\t// used when looking at visibility rules\n\t\tboolean inSamePackage = packageName.equals(mpkg);\n\n\t\tResolvedMember[] methods = typeToCheck.getDeclaredMethods();\n\t\tfor (ResolvedMember methodThatMightBeGettingOverridden : methods) {\n\t\t\t// the method we are going to check\n\t\t\tResolvedMember isOverriding = isOverriding(typeToCheck, methodThatMightBeGettingOverridden, mname, mrettype, mmods,\n\t\t\t\t\tinSamePackage, methodParamsArray);\n\t\t\tif (isOverriding != null) {\n\t\t\t\toverriddenMethodsCollector.add(isOverriding);\n\t\t\t}\n\t\t}\n\t\t// was: List l = typeToCheck.getInterTypeMungers();\n\t\tList<ConcreteTypeMunger> l = (typeToCheck.isRawType() ? typeToCheck.getGenericType().getInterTypeMungers() : typeToCheck\n\t\t\t\t.getInterTypeMungers());\n\t\tfor (ConcreteTypeMunger o : l) {\n\t\t\t// FIXME asc if its not a BcelTypeMunger then its an\n\t\t\t// EclipseTypeMunger ... do I need to worry about that?\n\t\t\tif (o instanceof BcelTypeMunger) {\n\t\t\t\tBcelTypeMunger element = (BcelTypeMunger) o;\n\t\t\t\tif (element.getMunger() instanceof NewMethodTypeMunger) {\n\t\t\t\t\tif (typeToCheck.getWorld().forDEBUG_bridgingCode) {\n\t\t\t\t\t\tSystem.err.println(\"Possible ITD candidate \" + element);\n\t\t\t\t\t}\n\t\t\t\t\tResolvedMember aMethod = element.getSignature();\n\t\t\t\t\tResolvedMember isOverriding = isOverriding(typeToCheck, aMethod, mname, mrettype, mmods, inSamePackage,\n\t\t\t\t\t\t\tmethodParamsArray);\n\t\t\t\t\tif (isOverriding != null) {\n\t\t\t\t\t\toverriddenMethodsCollector.add(isOverriding);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeToCheck.equals(UnresolvedType.OBJECT)) {\n\t\t\treturn;\n\t\t}\n\n\t\tResolvedType superclass = typeToCheck.getSuperclass();\n\t\tcheckForOverride(superclass, mname, mparams, mrettype, mmods, mpkg, methodParamsArray,overriddenMethodsCollector);\n\n\t\tResolvedType[] interfaces = typeToCheck.getDeclaredInterfaces();\n\t\tfor (ResolvedType anInterface : interfaces) {\n\t\t\tcheckForOverride(anInterface, mname, mparams, mrettype, mmods, mpkg, methodParamsArray, overriddenMethodsCollector);\n\t\t}\n\t}\n\n\t/**\n\t * We need to determine if any methods in this type require bridge methods - this method should only be called if necessary to\n\t * do this calculation, i.e. we are on a 1.5 VM (where covariance/generics exist) and the type hierarchy for the specified class\n\t * has changed (via decp/itd).\n\t *\n\t * See pr108101\n\t */\n\tpublic static boolean calculateAnyRequiredBridgeMethods(BcelWorld world, LazyClassGen clazz) {\n\t\tworld.ensureAdvancedConfigurationProcessed();\n\n\t\tif (!world.isInJava5Mode()) {\n\t\t\treturn false; // just double check... the caller should have already\n\t\t}\n\t\tif (clazz.isInterface()) {\n\t\t\treturn false; // dont bother if we are an interface\n\t\t}\n\n\t\t// So what methods do we have right now in this class?\n\t\tList<LazyMethodGen> methods = clazz.getMethodGens();\n\n\t\t// Keep a set of all methods from this type - it'll help us to check if bridge methods\n\t\t// have already been created, we don't want to do it twice!\n\t\tSet<String> methodsSet = new HashSet<>();\n\t\tfor (LazyMethodGen aMethod : methods) {\n\t\t\tStringBuilder sb = new StringBuilder(aMethod.getName());\n\t\t\tsb.append(aMethod.getSignature());\n\t\t\tmethodsSet.add(sb.toString()); // e.g. \"foo(Ljava/lang/String;)V\"\n\t\t}\n\n\t\tList<BridgeMethodDescriptor> bridges = null;\n\t\t// Now go through all the methods in this type\n\t\tfor (LazyMethodGen bridgeToCandidate : methods) {\n\t\t\t// This is the local method that we *might* have to bridge to\n\t\t\tif (bridgeToCandidate.isBridgeMethod()) {\n\t\t\t\tcontinue; // Doh!\n\t\t\t}\n\t\t\tString name = bridgeToCandidate.getName();\n\t\t\tString psig = bridgeToCandidate.getParameterSignature();\n\t\t\tString rsig = bridgeToCandidate.getReturnType().getSignature();\n\n\t\t\t// if (bridgeToCandidate.isAbstract()) continue;\n\t\t\tif (bridgeToCandidate.isStatic()) {\n\t\t\t\tcontinue; // ignore static methods\n\t\t\t}\n\t\t\tif (name.endsWith(\"init>\")) {\n\t\t\t\tcontinue; // Skip constructors and static initializers\n\t\t\t}\n\n\t\t\tif (world.forDEBUG_bridgingCode) {\n\t\t\t\tSystem.err.println(\"Bridging: Determining if we have to bridge to \" + clazz.getName() + \".\" + name + \"\" + bridgeToCandidate.getSignature());\n\t\t\t}\n\n\t\t\t// Let's take a look at the superclass\n\t\t\tResolvedType theSuperclass = clazz.getSuperClass();\n\t\t\tif (world.forDEBUG_bridgingCode) {\n\t\t\t\tSystem.err.println(\"Bridging: Checking supertype \" + theSuperclass);\n\t\t\t}\n\t\t\tString pkgName = clazz.getPackageName();\n\t\t\tUnresolvedType[] bm = BcelWorld.fromBcel(bridgeToCandidate.getArgumentTypes());\n\t\t\tList<ResolvedMember> overriddenMethodsCollector = new ArrayList<>();\n\t\t\tcheckForOverride(theSuperclass, name, psig, rsig, bridgeToCandidate.getAccessFlags(), pkgName, bm, overriddenMethodsCollector);\n\t\t\tif (overriddenMethodsCollector.size() != 0) {\n\t\t\t\tfor (ResolvedMember overriddenMethod : overriddenMethodsCollector) {\n\t\t\t\t\tString key = new StringBuilder(overriddenMethod.getName()).append(overriddenMethod.getSignatureErased()).toString(); // pr237419\n\t\t\t\t\tboolean alreadyHaveABridgeMethod = methodsSet.contains(key);\n\t\t\t\t\tif (!alreadyHaveABridgeMethod) {\n\t\t\t\t\t\tif (world.forDEBUG_bridgingCode) {\n\t\t\t\t\t\t\tSystem.err.println(\"Bridging:bridging to '\" + overriddenMethod + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (bridges== null) {\n\t\t\t\t\t\t\tbridges = new ArrayList<>();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbridges.add(new BridgeMethodDescriptor(bridgeToCandidate, overriddenMethod));\n\t\t\t\t\t\t//createBridgeMethod(world, bridgeToCandidate, clazz, overriddenMethod);\n\t\t\t\t\t\tmethodsSet.add(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check superinterfaces\n\t\t\tString[] interfaces = clazz.getInterfaceNames();\n\t\t\tfor (String anInterface : interfaces) {\n\t\t\t\tif (world.forDEBUG_bridgingCode) {\n\t\t\t\t\tSystem.err.println(\"Bridging:checking superinterface \" + anInterface);\n\t\t\t\t}\n\t\t\t\tResolvedType interfaceType = world.resolve(anInterface);\n\t\t\t\toverriddenMethodsCollector.clear();\n\t\t\t\tcheckForOverride(interfaceType, name, psig, rsig, bridgeToCandidate.getAccessFlags(),\n\t\t\t\t\t\tclazz.getPackageName(), bm, overriddenMethodsCollector);\n\t\t\t\tfor (ResolvedMember overriddenMethod : overriddenMethodsCollector) {\n\t\t\t\t\tString key = new StringBuilder().append(overriddenMethod.getName()).append(overriddenMethod.getSignatureErased()).toString(); // pr237419\n\t\t\t\t\tboolean alreadyHaveABridgeMethod = methodsSet.contains(key);\n\t\t\t\t\tif (!alreadyHaveABridgeMethod) {\n\t\t\t\t\t\tif (bridges== null) {\n\t\t\t\t\t\t\tbridges = new ArrayList<>();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbridges.add(new BridgeMethodDescriptor(bridgeToCandidate, overriddenMethod));\n\t\t\t\t\t\t// createBridgeMethod(world, bridgeToCandidate, clazz, overriddenMethod);\n\t\t\t\t\t\tmethodsSet.add(key);\n\t\t\t\t\t\tif (world.forDEBUG_bridgingCode) {\n\t\t\t\t\t\t\tSystem.err.println(\"Bridging:bridging to \" + overriddenMethod);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (bridges != null) {\n\t\t\tfor (BridgeMethodDescriptor bmDescriptor: bridges) {\n\t\t\t\tcreateBridgeMethod(world, bmDescriptor.bridgeToCandidate, clazz, bmDescriptor.overriddenMethod);\n\t\t\t}\n\t\t}\n\n\t\treturn bridges!=null && !bridges.isEmpty();\n\t}\n\n\tstatic class BridgeMethodDescriptor {\n\n\t\tfinal LazyMethodGen bridgeToCandidate;\n\t\tfinal ResolvedMember overriddenMethod;\n\n\t\tpublic BridgeMethodDescriptor(LazyMethodGen bridgeToCandidate, ResolvedMember overriddenMethod) {\n\t\t\tthis.bridgeToCandidate = bridgeToCandidate;\n\t\t\tthis.overriddenMethod = overriddenMethod;\n\t\t}\n\n\t}\n\n\t// **************************** end of bridge method creation code *****************\n\n\t/**\n\t * Weave any declare @method/@ctor statements into the members of the supplied class\n\t */\n\tprivate boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {\n\t\tList<Integer> reportedProblems = new ArrayList<>();\n\n\t\tList<DeclareAnnotation> allDecams = world.getDeclareAnnotationOnMethods();\n\t\tif (allDecams.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean isChanged = false;\n\n\t\t// deal with ITDs\n\t\tList<ConcreteTypeMunger> itdMethodsCtors = getITDSubset(clazz, ResolvedTypeMunger.Method);\n\t\titdMethodsCtors.addAll(getITDSubset(clazz, ResolvedTypeMunger.Constructor));\n\t\tif (!itdMethodsCtors.isEmpty()) {\n\t\t\t// Can't use the subset called 'decaMs' as it won't be right for\n\t\t\t// ITDs...\n\t\t\tisChanged = weaveAtMethodOnITDSRepeatedly(allDecams, itdMethodsCtors, reportedProblems);\n\t\t}\n\n\t\tList<DeclareAnnotation> decaMs = getMatchingSubset(allDecams, clazz.getType());\n\t\tif (decaMs.isEmpty()) {\n\t\t\treturn false; // nothing to do\n\t\t}\n\n\t\tSet<DeclareAnnotation> unusedDecams = new HashSet<>(decaMs);\n\n\t\t// These methods may have been targeted with declare annotation.  Example: ITD on an interface\n\t\t// where the top most implementor gets a real method.  The top most implementor method\n\t\t// is an 'addedLazyMethodGen'\n\t\tif (addedLazyMethodGens!=null) {\n\t\t\tfor (LazyMethodGen method: addedLazyMethodGens) {\n\t\t\t\t// They have no resolvedmember of their own, conjure one up for matching purposes\n\t\t\t\tResolvedMember resolvedmember =\n\t\t\t\t\t\tnew ResolvedMemberImpl(ResolvedMember.METHOD,method.getEnclosingClass().getType(),method.getAccessFlags(),\n\t\t\t\t\t\t\t\tBcelWorld.fromBcel(method.getReturnType()),method.getName(),\n\t\t\t\t\t\t\t\tBcelWorld.fromBcel(method.getArgumentTypes()),UnresolvedType.forNames(method.getDeclaredExceptions()));\n\t\t\t\tresolvedmember.setAnnotationTypes(method.getAnnotationTypes());\n\t\t\t\tresolvedmember.setAnnotations(method.getAnnotations());\n\n\t\t\t\tList<DeclareAnnotation> worthRetrying = new ArrayList<>();\n\t\t\t\tboolean modificationOccured = false;\n\t\t\t\tfor (DeclareAnnotation decam: decaMs) {\n\t\t\t\t\tif (decam.matches(resolvedmember, world)) {\n\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(resolvedmember, decam, reportedProblems,false)) {\n\t\t\t\t\t\t\t// remove the declare @method since don't want an error when the annotation is already there\n\t\t\t\t\t\t\tunusedDecams.remove(decam);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAnnotationGen a = ((BcelAnnotation) decam.getAnnotation()).getBcelAnnotation();\n\t\t\t\t\t\t// create copy to get the annotation type into the right constant pool\n\t\t\t\t\t\tAnnotationAJ aj = new BcelAnnotation(new AnnotationGen(a, clazz.getConstantPool(), true),world);\n\t\t\t\t\t\tmethod.addAnnotation(aj);\n\t\t\t\t\t\tresolvedmember.addAnnotation(decam.getAnnotation());\n\n\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationMethodRelationship(decam.getSourceLocation(),\n\t\t\t\t\t\t\t\tclazz.getName(), resolvedmember, world.getModelAsAsmManager());\n\t\t\t\t\t\treportMethodCtorWeavingMessage(clazz, resolvedmember, decam, method.getDeclarationLineNumber());\n\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\tmodificationOccured = true;\n\t\t\t\t\t\tunusedDecams.remove(decam);\n\t\t\t\t\t} else if (!decam.isStarredAnnotationPattern()) {\n\t\t\t\t\t\t// an annotation is specified that might be put on by a subsequent decaf\n\t\t\t\t\t\tworthRetrying.add(decam);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Multiple secondary passes\n\t\t\t\twhile (!worthRetrying.isEmpty() && modificationOccured) {\n\t\t\t\t\tmodificationOccured = false;\n\t\t\t\t\t// lets have another go\n\t\t\t\t\tList<DeclareAnnotation> forRemoval = new ArrayList<>();\n\t\t\t\t\tfor (DeclareAnnotation decam : worthRetrying) {\n\t\t\t\t\t\tif (decam.matches(resolvedmember, world)) {\n\t\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(resolvedmember, decam, reportedProblems,false)) {\n\t\t\t\t\t\t\t\t// remove the declare @method since don't\n\t\t\t\t\t\t\t\t// want an error when\n\t\t\t\t\t\t\t\t// the annotation is already there\n\t\t\t\t\t\t\t\tunusedDecams.remove(decam);\n\t\t\t\t\t\t\t\tcontinue; // skip this one...\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAnnotationGen a = ((BcelAnnotation) decam.getAnnotation()).getBcelAnnotation();\n\t\t\t\t\t\t\t// create copy to get the annotation type into the right constant pool\n\t\t\t\t\t\t\tAnnotationAJ aj = new BcelAnnotation(new AnnotationGen(a, clazz.getConstantPool(), true),world);\n\t\t\t\t\t\t\tmethod.addAnnotation(aj);\n\t\t\t\t\t\t\tresolvedmember.addAnnotation(decam.getAnnotation());\n\t\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationMethodRelationship(decam.getSourceLocation(),\n\t\t\t\t\t\t\t\t\tclazz.getName(), resolvedmember, world.getModelAsAsmManager());// getMethod());\n\t\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\t\tmodificationOccured = true;\n\t\t\t\t\t\t\tforRemoval.add(decam);\n\t\t\t\t\t\t\tunusedDecams.remove(decam);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tworthRetrying.removeAll(forRemoval);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t// deal with all the other methods...\n\t\tList<LazyMethodGen> members = clazz.getMethodGens();\n\t\tif (!members.isEmpty()) {\n\t\t\tfor (int memberCounter = 0; memberCounter < members.size(); memberCounter++) {\n\t\t\t\tLazyMethodGen mg = members.get(memberCounter);\n\t\t\t\tif (!mg.getName().startsWith(NameMangler.PREFIX)) {\n\n\t\t\t\t\t// Single first pass\n\t\t\t\t\tList<DeclareAnnotation> worthRetrying = new ArrayList<>();\n\t\t\t\t\tboolean modificationOccured = false;\n\t\t\t\t\tList<AnnotationGen> annotationsToAdd = null;\n\t\t\t\t\tfor (DeclareAnnotation decaM : decaMs) {\n\n\t\t\t\t\t\tif (decaM.matches(mg.getMemberView(), world)) {\n\t\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(mg.getMemberView(), decaM, reportedProblems,true)) {\n\t\t\t\t\t\t\t\t// remove the declare @method since don't want\n\t\t\t\t\t\t\t\t// an error when the annotation is already there\n\t\t\t\t\t\t\t\tunusedDecams.remove(decaM);\n\t\t\t\t\t\t\t\tcontinue; // skip this one...\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (annotationsToAdd == null) {\n\t\t\t\t\t\t\t\tannotationsToAdd = new ArrayList<>();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tBcelAnnotation decaMAnnotation = (BcelAnnotation) decaM.getAnnotation();\n\t\t\t\t\t\t\tif (decaMAnnotation == null) {\n\t\t\t\t\t\t\t\tunusedDecams.remove(decaM);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAnnotationGen a = decaMAnnotation.getBcelAnnotation();\n\t\t\t\t\t\t\tAnnotationGen ag = new AnnotationGen(a, clazz.getConstantPool(), true);\n\t\t\t\t\t\t\tannotationsToAdd.add(ag);\n\t\t\t\t\t\t\tmg.addAnnotation(decaM.getAnnotation());\n\n\t\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationMethodRelationship(decaM.getSourceLocation(),\n\t\t\t\t\t\t\t\t\tclazz.getName(), mg.getMemberView(), world.getModelAsAsmManager());// getMethod());\n\t\t\t\t\t\t\treportMethodCtorWeavingMessage(clazz, mg.getMemberView(), decaM, mg.getDeclarationLineNumber());\n\t\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\t\tmodificationOccured = true;\n\t\t\t\t\t\t\t// remove the declare @method since have matched\n\t\t\t\t\t\t\t// against it\n\t\t\t\t\t\t\tunusedDecams.remove(decaM);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!decaM.isStarredAnnotationPattern()) {\n\t\t\t\t\t\t\t\tworthRetrying.add(decaM); // an annotation is\n\t\t\t\t\t\t\t\t// specified that\n\t\t\t\t\t\t\t\t// might be put on\n\t\t\t\t\t\t\t\t// by a subsequent\n\t\t\t\t\t\t\t\t// decaf\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Multiple secondary passes\n\t\t\t\t\twhile (!worthRetrying.isEmpty() && modificationOccured) {\n\t\t\t\t\t\tmodificationOccured = false;\n\t\t\t\t\t\t// lets have another go\n\t\t\t\t\t\tList<DeclareAnnotation> forRemoval = new ArrayList<>();\n\t\t\t\t\t\tfor (DeclareAnnotation decaM : worthRetrying) {\n\t\t\t\t\t\t\tif (decaM.matches(mg.getMemberView(), world)) {\n\t\t\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(mg.getMemberView(), decaM, reportedProblems,true)) {\n\t\t\t\t\t\t\t\t\t// remove the declare @method since don't\n\t\t\t\t\t\t\t\t\t// want an error when\n\t\t\t\t\t\t\t\t\t// the annotation is already there\n\t\t\t\t\t\t\t\t\tunusedDecams.remove(decaM);\n\t\t\t\t\t\t\t\t\tcontinue; // skip this one...\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (annotationsToAdd == null) {\n\t\t\t\t\t\t\t\t\tannotationsToAdd = new ArrayList<>();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tAnnotationGen a = ((BcelAnnotation) decaM.getAnnotation()).getBcelAnnotation();\n\t\t\t\t\t\t\t\t// create copy to get the annotation type into the right constant pool\n\t\t\t\t\t\t\t\tAnnotationGen ag = new AnnotationGen(a, clazz.getConstantPool(), true);\n\t\t\t\t\t\t\t\tannotationsToAdd.add(ag);\n\t\t\t\t\t\t\t\tmg.addAnnotation(decaM.getAnnotation());\n\t\t\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationMethodRelationship(decaM.getSourceLocation(),\n\t\t\t\t\t\t\t\t\t\tclazz.getName(), mg.getMemberView(), world.getModelAsAsmManager());// getMethod());\n\t\t\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\t\t\tmodificationOccured = true;\n\t\t\t\t\t\t\t\tforRemoval.add(decaM);\n\t\t\t\t\t\t\t\t// remove the declare @method since have matched\n\t\t\t\t\t\t\t\t// against it\n\t\t\t\t\t\t\t\tunusedDecams.remove(decaM);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tworthRetrying.removeAll(forRemoval);\n\t\t\t\t\t}\n\t\t\t\t\tif (annotationsToAdd != null) {\n\t\t\t\t\t\tMethod oldMethod = mg.getMethod();\n\t\t\t\t\t\tMethodGen myGen = new MethodGen(oldMethod, clazz.getClassName(), clazz.getConstantPool(), false);\n\t\t\t\t\t\tfor (AnnotationGen a : annotationsToAdd) {\n\t\t\t\t\t\t\tmyGen.addAnnotation(a);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMethod newMethod = myGen.getMethod();\n\t\t\t\t\t\tmembers.set(memberCounter, new LazyMethodGen(newMethod, clazz));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckUnusedDeclareAts(unusedDecams, false);\n\t\t}\n\t\treturn isChanged;\n\t}\n\n\t// TAG: WeavingMessage\n\tprivate void reportMethodCtorWeavingMessage(LazyClassGen clazz, ResolvedMember member, DeclareAnnotation decaM,\n\t\t\tint memberLineNumber) {\n\t\tif (!getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {\n\t\t\tStringBuilder parmString = new StringBuilder(\"(\");\n\t\t\tUnresolvedType[] paramTypes = member.getParameterTypes();\n\t\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\t\tUnresolvedType type = paramTypes[i];\n\t\t\t\tString s = org.aspectj.apache.bcel.classfile.Utility.signatureToString(type.getSignature());\n\t\t\t\tif (s.lastIndexOf('.') != -1) {\n\t\t\t\t\ts = s.substring(s.lastIndexOf('.') + 1);\n\t\t\t\t}\n\t\t\t\tparmString.append(s);\n\t\t\t\tif ((i + 1) < paramTypes.length) {\n\t\t\t\t\tparmString.append(\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tparmString.append(\")\");\n\t\t\tString methodName = member.getName();\n\t\t\tStringBuilder sig = new StringBuilder();\n\t\t\tsig.append(org.aspectj.apache.bcel.classfile.Utility.accessToString(member.getModifiers()));\n\t\t\tsig.append(\" \");\n\t\t\tsig.append(member.getReturnType().toString());\n\t\t\tsig.append(\" \");\n\t\t\tsig.append(member.getDeclaringType().toString());\n\t\t\tsig.append(\".\");\n\t\t\tsig.append(methodName.equals(\"<init>\") ? \"new\" : methodName);\n\t\t\tsig.append(parmString);\n\n\t\t\tStringBuilder loc = new StringBuilder();\n\t\t\tif (clazz.getFileName() == null) {\n\t\t\t\tloc.append(\"no debug info available\");\n\t\t\t} else {\n\t\t\t\tloc.append(clazz.getFileName());\n\t\t\t\tif (memberLineNumber != -1) {\n\t\t\t\t\tloc.append(\":\" + memberLineNumber);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetWorld().getMessageHandler().handleMessage(\n\t\t\t\t\tWeaveMessage.constructWeavingMessage(\n\t\t\t\t\t\t\tWeaveMessage.WEAVEMESSAGE_ANNOTATES,\n\t\t\t\t\t\t\tnew String[] { sig.toString(), loc.toString(), decaM.getAnnotationString(),\n\t\t\t\t\t\t\t\t\tmethodName.startsWith(\"<init>\") ? \"constructor\" : \"method\", decaM.getAspect().toString(),\n\t\t\t\t\t\t\t\t\t\t\tUtility.beautifyLocation(decaM.getSourceLocation()) }));\n\t\t}\n\t}\n\n\t/**\n\t * Looks through a list of declare annotation statements and only returns those that could possibly match on a field/method/ctor\n\t * in type.\n\t */\n\tprivate List<DeclareAnnotation> getMatchingSubset(List<DeclareAnnotation> declareAnnotations, ResolvedType type) {\n\t\tList<DeclareAnnotation> subset = new ArrayList<>();\n\t\tfor (DeclareAnnotation da : declareAnnotations) {\n\t\t\tif (da.couldEverMatch(type)) {\n\t\t\t\tsubset.add(da);\n\t\t\t}\n\t\t}\n\t\treturn subset;\n\t}\n\n\t/**\n\t * Get a subset of all the type mungers defined on this aspect\n\t */\n\tprivate List<ConcreteTypeMunger> getITDSubset(LazyClassGen clazz, ResolvedTypeMunger.Kind wantedKind) {\n\t\tList<ConcreteTypeMunger> subset = new ArrayList<>();\n\t\tfor (ConcreteTypeMunger typeMunger : clazz.getBcelObjectType().getTypeMungers()) {\n\t\t\tif (typeMunger.getMunger().getKind() == wantedKind) {\n\t\t\t\tsubset.add(typeMunger);\n\t\t\t}\n\t\t}\n\t\treturn subset;\n\t}\n\n\tpublic LazyMethodGen locateAnnotationHolderForFieldMunger(LazyClassGen clazz, ConcreteTypeMunger fieldMunger) {\n\t\tNewFieldTypeMunger newFieldMunger = (NewFieldTypeMunger) fieldMunger.getMunger();\n\t\tResolvedMember lookingFor = AjcMemberMaker.interFieldInitializer(newFieldMunger.getSignature(), clazz.getType());\n\t\tfor (LazyMethodGen method : clazz.getMethodGens()) {\n\t\t\tif (method.getName().equals(lookingFor.getName())) {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t// FIXME asc refactor this to neaten it up\n\tpublic LazyMethodGen locateAnnotationHolderForMethodCtorMunger(LazyClassGen clazz, ConcreteTypeMunger methodCtorMunger) {\n\t\tResolvedTypeMunger rtMunger = methodCtorMunger.getMunger();\n\t\tResolvedMember lookingFor = null;\n\t\tif (rtMunger instanceof NewMethodTypeMunger) {\n\t\t\tNewMethodTypeMunger nftm = (NewMethodTypeMunger) rtMunger;\n\t\t\tlookingFor = AjcMemberMaker.interMethodDispatcher(nftm.getSignature(), methodCtorMunger.getAspectType());\n\t\t} else if (rtMunger instanceof NewConstructorTypeMunger) {\n\t\t\tNewConstructorTypeMunger nftm = (NewConstructorTypeMunger) rtMunger;\n\t\t\tlookingFor = AjcMemberMaker.postIntroducedConstructor(methodCtorMunger.getAspectType(), nftm.getSignature()\n\t\t\t\t\t.getDeclaringType(), nftm.getSignature().getParameterTypes());\n\t\t} else {\n\t\t\tthrow new BCException(\"Not sure what this is: \" + methodCtorMunger);\n\t\t}\n\t\tString name = lookingFor.getName();\n\t\tString paramSignature = lookingFor.getParameterSignature();\n\t\tfor (LazyMethodGen member : clazz.getMethodGens()) {\n\t\t\tif (member.getName().equals(name) && member.getParameterSignature().equals(paramSignature)) {\n\t\t\t\treturn member;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Applies some set of declare @field constructs (List<DeclareAnnotation>) to some bunch of ITDfields (List<BcelTypeMunger>. It\n\t * will iterate over the fields repeatedly until everything has been applied.\n\t *\n\t */\n\tprivate boolean weaveAtFieldRepeatedly(List<DeclareAnnotation> decaFs, List<ConcreteTypeMunger> itdFields,\n\t\t\tList<Integer> reportedErrors) {\n\t\tboolean isChanged = false;\n\t\tfor (ConcreteTypeMunger itdField : itdFields) {\n\t\t\tBcelTypeMunger fieldMunger = (BcelTypeMunger) itdField;\n\t\t\tResolvedMember itdIsActually = fieldMunger.getSignature();\n\t\t\tSet<DeclareAnnotation> worthRetrying = new LinkedHashSet<>();\n\t\t\tboolean modificationOccured = false;\n\n\t\t\tfor (DeclareAnnotation decaF : decaFs) {\n\t\t\t\tif (decaF.matches(itdIsActually, world)) {\n\t\t\t\t\tif (decaF.isRemover()) {\n\t\t\t\t\t\tLazyMethodGen annotationHolder = locateAnnotationHolderForFieldMunger(clazz, fieldMunger);\n\t\t\t\t\t\tif (annotationHolder.hasAnnotation(decaF.getAnnotationType())) {\n\t\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\t\t// something to remove\n\t\t\t\t\t\t\tannotationHolder.removeAnnotation(decaF.getAnnotationType());\n\t\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationRelationship(world.getModelAsAsmManager(),\n\t\t\t\t\t\t\t\t\tdecaF.getSourceLocation(), itdIsActually.getSourceLocation(), true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tworthRetrying.add(decaF);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tLazyMethodGen annotationHolder = locateAnnotationHolderForFieldMunger(clazz, fieldMunger);\n\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(annotationHolder, itdIsActually, decaF, reportedErrors)) {\n\t\t\t\t\t\t\tcontinue; // skip this one...\n\t\t\t\t\t\t}\n\t\t\t\t\t\tannotationHolder.addAnnotation(decaF.getAnnotation());\n\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationRelationship(world.getModelAsAsmManager(),\n\t\t\t\t\t\t\t\tdecaF.getSourceLocation(), itdIsActually.getSourceLocation(), false);\n\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\tmodificationOccured = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!decaF.isStarredAnnotationPattern()) {\n\t\t\t\t\t\tworthRetrying.add(decaF); // an annotation is specified\n\t\t\t\t\t\t// that might be put on by a\n\t\t\t\t\t\t// subsequent decaf\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (!worthRetrying.isEmpty() && modificationOccured) {\n\t\t\t\tmodificationOccured = false;\n\t\t\t\tList<DeclareAnnotation> forRemoval = new ArrayList<>();\n\t\t\t\tfor (DeclareAnnotation decaF : worthRetrying) {\n\t\t\t\t\tif (decaF.matches(itdIsActually, world)) {\n\t\t\t\t\t\tif (decaF.isRemover()) {\n\t\t\t\t\t\t\tLazyMethodGen annotationHolder = locateAnnotationHolderForFieldMunger(clazz, fieldMunger);\n\t\t\t\t\t\t\tif (annotationHolder.hasAnnotation(decaF.getAnnotationType())) {\n\t\t\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\t\t\t// something to remove\n\t\t\t\t\t\t\t\tannotationHolder.removeAnnotation(decaF.getAnnotationType());\n\t\t\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationRelationship(world.getModelAsAsmManager(),\n\t\t\t\t\t\t\t\t\t\tdecaF.getSourceLocation(), itdIsActually.getSourceLocation(), true);\n\t\t\t\t\t\t\t\tforRemoval.add(decaF);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLazyMethodGen annotationHolder = locateAnnotationHolderForFieldMunger(clazz, fieldMunger);\n\t\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(annotationHolder, itdIsActually, decaF, reportedErrors)) {\n\t\t\t\t\t\t\t\tcontinue; // skip this one...\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tannotationHolder.addAnnotation(decaF.getAnnotation());\n\t\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationRelationship(world.getModelAsAsmManager(),\n\t\t\t\t\t\t\t\t\tdecaF.getSourceLocation(), itdIsActually.getSourceLocation(), false);\n\t\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\t\tmodificationOccured = true;\n\t\t\t\t\t\t\tforRemoval.add(decaF);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworthRetrying.removeAll(forRemoval);\n\t\t\t}\n\t\t}\n\t\treturn isChanged;\n\t}\n\n\t/**\n\t * Applies some set of declare @method/@ctor constructs (List<DeclareAnnotation>) to some bunch of ITDmembers\n\t * (List<BcelTypeMunger>. It will iterate over the fields repeatedly until everything has been applied.\n\t */\n\tprivate boolean weaveAtMethodOnITDSRepeatedly(List<DeclareAnnotation> decaMCs,\n\t\t\tList<ConcreteTypeMunger> itdsForMethodAndConstructor, List<Integer> reportedErrors) {\n\t\tboolean isChanged = false;\n\t\tAsmManager asmManager = world.getModelAsAsmManager();\n\t\tfor (ConcreteTypeMunger methodctorMunger : itdsForMethodAndConstructor) {\n\t\t\t// for (Iterator iter = itdsForMethodAndConstructor.iterator(); iter.hasNext();) {\n\t\t\t// BcelTypeMunger methodctorMunger = (BcelTypeMunger) iter.next();\n\t\t\tResolvedMember unMangledInterMethod = methodctorMunger.getSignature();\n\t\t\tList<DeclareAnnotation> worthRetrying = new ArrayList<>();\n\t\t\tboolean modificationOccured = false;\n\n\t\t\tfor (DeclareAnnotation decaMC : decaMCs) {\n\t\t\t\tif (decaMC.matches(unMangledInterMethod, world)) {\n\t\t\t\t\tLazyMethodGen annotationHolder = locateAnnotationHolderForMethodCtorMunger(clazz, methodctorMunger);\n\t\t\t\t\tif (annotationHolder == null\n\t\t\t\t\t\t\t|| doesAlreadyHaveAnnotation(annotationHolder, unMangledInterMethod, decaMC, reportedErrors)) {\n\t\t\t\t\t\tcontinue; // skip this one...\n\t\t\t\t\t}\n\t\t\t\t\tannotationHolder.addAnnotation(decaMC.getAnnotation());\n\t\t\t\t\tisChanged = true;\n\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationRelationship(asmManager, decaMC.getSourceLocation(),\n\t\t\t\t\t\t\tunMangledInterMethod.getSourceLocation(), false);\n\t\t\t\t\treportMethodCtorWeavingMessage(clazz, unMangledInterMethod, decaMC, -1);\n\t\t\t\t\tmodificationOccured = true;\n\t\t\t\t} else {\n\t\t\t\t\t// If an annotation is specified, it might be added by one of the other declare annotation statements\n\t\t\t\t\tif (!decaMC.isStarredAnnotationPattern()) {\n\t\t\t\t\t\tworthRetrying.add(decaMC);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (!worthRetrying.isEmpty() && modificationOccured) {\n\t\t\t\tmodificationOccured = false;\n\t\t\t\tList<DeclareAnnotation> forRemoval = new ArrayList<>();\n\t\t\t\tfor (DeclareAnnotation decaMC : worthRetrying) {\n\t\t\t\t\tif (decaMC.matches(unMangledInterMethod, world)) {\n\t\t\t\t\t\tLazyMethodGen annotationHolder = locateAnnotationHolderForFieldMunger(clazz, methodctorMunger);\n\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(annotationHolder, unMangledInterMethod, decaMC, reportedErrors)) {\n\t\t\t\t\t\t\tcontinue; // skip this one...\n\t\t\t\t\t\t}\n\t\t\t\t\t\tannotationHolder.addAnnotation(decaMC.getAnnotation());\n\t\t\t\t\t\tunMangledInterMethod.addAnnotation(decaMC.getAnnotation());\n\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationRelationship(asmManager, decaMC.getSourceLocation(),\n\t\t\t\t\t\t\t\tunMangledInterMethod.getSourceLocation(), false);\n\t\t\t\t\t\tisChanged = true;\n\t\t\t\t\t\tmodificationOccured = true;\n\t\t\t\t\t\tforRemoval.add(decaMC);\n\t\t\t\t\t}\n\t\t\t\t\tworthRetrying.removeAll(forRemoval);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn isChanged;\n\t}\n\n\tprivate boolean dontAddTwice(DeclareAnnotation decaF, AnnotationAJ[] dontAddMeTwice) {\n\t\tfor (AnnotationAJ ann : dontAddMeTwice) {\n\t\t\tif (ann != null && decaF.getAnnotation().getTypeName().equals(ann.getTypeName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Remove an annotation from the supplied array, if it is in there.\n\t */\n\tprivate AnnotationAJ[] removeFromAnnotationsArray(AnnotationAJ[] annotations,AnnotationAJ annotation) {\n\t\tfor (int i=0;i<annotations.length;i++) {\n\t\t\tif (annotations[i] != null && annotation.getTypeName().equals(annotations[i].getTypeName())) {\n\t\t\t\t// Remove it!\n\t\t\t\tAnnotationAJ[] newArray = new AnnotationAJ[annotations.length-1];\n\t\t\t\tint index=0;\n\t\t\t\tfor (int j=0;j<annotations.length;j++) {\n\t\t\t\t\tif (j!=i) {\n\t\t\t\t\t\tnewArray[index++]=annotations[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn newArray;\n\t\t\t}\n\t\t}\n\t\treturn annotations;\n\t}\n\n\t// BUGWARNING not getting enough warnings out on declare @field ? There is a potential problem here with warnings not\n\t// coming out - this will occur if they are created on the second iteration round this loop.\n\t// We currently deactivate error reporting for the second time round. A possible solution is to record what annotations\n\t// were added by what decafs and check that to see if an error needs to be reported - this would be expensive so lets\n\t// skip it for now\n\t/**\n\t * Weave any declare @field statements into the fields of the supplied class. This will attempt to apply them to the ITDs too.\n\t *\n\t * Interesting case relating to public ITDd fields. The annotations are really stored against the interfieldinit method in the\n\t * aspect, but the public field is placed in the target type and then is processed in the 2nd pass over fields that occurs. I\n\t * think it would be more expensive to avoid putting the annotation on that inserted public field than just to have it put there\n\t * as well as on the interfieldinit method.\n\t */\n\tprivate boolean weaveDeclareAtField(LazyClassGen clazz) {\n\t\tList<Integer> reportedProblems = new ArrayList<>();\n\t\tList<DeclareAnnotation> allDecafs = world.getDeclareAnnotationOnFields();\n\t\tif (allDecafs.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tboolean typeIsChanged = false;\n\t\tList<ConcreteTypeMunger> relevantItdFields = getITDSubset(clazz, ResolvedTypeMunger.Field);\n\t\tif (relevantItdFields != null) {\n\t\t\ttypeIsChanged = weaveAtFieldRepeatedly(allDecafs, relevantItdFields, reportedProblems);\n\t\t}\n\n\t\tList<DeclareAnnotation> decafs = getMatchingSubset(allDecafs, clazz.getType());\n\t\tif (decafs.isEmpty()) {\n\t\t\treturn typeIsChanged;\n\t\t}\n\n\t\tList<BcelField> fields = clazz.getFieldGens();\n\t\tif (fields != null) {\n\t\t\tSet<DeclareAnnotation> unusedDecafs = new HashSet<>(decafs);\n\t\t\tfor (BcelField field : fields) {\n\t\t\t\tif (!field.getName().startsWith(NameMangler.PREFIX)) {\n\t\t\t\t\t// Single first pass\n\t\t\t\t\tSet<DeclareAnnotation> worthRetrying = new LinkedHashSet<>();\n\t\t\t\t\tboolean modificationOccured = false;\n\t\t\t\t\tAnnotationAJ[] dontAddMeTwice = field.getAnnotations();\n\n\t\t\t\t\t// go through all the declare @field statements\n\t\t\t\t\tfor (DeclareAnnotation decaf : decafs) {\n\t\t\t\t\t\tif (decaf.getAnnotation() == null) {\n\t\t\t\t\t\t\tunusedDecafs.remove(decaf);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (decaf.matches(field, world)) {\n\t\t\t\t\t\t\tif (decaf.isRemover()) {\n\t\t\t\t\t\t\t\tAnnotationAJ annotation = decaf.getAnnotation();\n\t\t\t\t\t\t\t\tif (field.hasAnnotation(annotation.getType())) {\n\t\t\t\t\t\t\t\t\t// something to remove\n\t\t\t\t\t\t\t\t\ttypeIsChanged = true;\n\t\t\t\t\t\t\t\t\tfield.removeAnnotation(annotation);\n\t\t\t\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationFieldRelationship(world.getModelAsAsmManager(),\n\t\t\t\t\t\t\t\t\t\t\tdecaf.getSourceLocation(), clazz.getName(), field, true);\n\t\t\t\t\t\t\t\t\treportFieldAnnotationWeavingMessage(clazz, field, decaf, true);\n\t\t\t\t\t\t\t\t\tdontAddMeTwice = removeFromAnnotationsArray(dontAddMeTwice, annotation);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tworthRetrying.add(decaf);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tunusedDecafs.remove(decaf);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!dontAddTwice(decaf, dontAddMeTwice)) {\n\t\t\t\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(field, decaf, reportedProblems,true )) {\n\t\t\t\t\t\t\t\t\t\t// remove the declare @field since don't want an error when the annotation is already there\n\t\t\t\t\t\t\t\t\t\tunusedDecafs.remove(decaf);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfield.addAnnotation(decaf.getAnnotation());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationFieldRelationship(world.getModelAsAsmManager(),\n\t\t\t\t\t\t\t\t\t\tdecaf.getSourceLocation(), clazz.getName(), field, false);\n\t\t\t\t\t\t\t\treportFieldAnnotationWeavingMessage(clazz, field, decaf, false);\n\t\t\t\t\t\t\t\ttypeIsChanged = true;\n\t\t\t\t\t\t\t\tmodificationOccured = true;\n\t\t\t\t\t\t\t\tunusedDecafs.remove(decaf);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!decaf.isStarredAnnotationPattern() || decaf.isRemover()) {\n\t\t\t\t\t\t\tworthRetrying.add(decaf); // an annotation is specified that might be put on by a subsequent decaf\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Multiple secondary passes\n\t\t\t\t\twhile (!worthRetrying.isEmpty() && modificationOccured) {\n\t\t\t\t\t\tmodificationOccured = false;\n\t\t\t\t\t\t// lets have another go with any remaining ones\n\t\t\t\t\t\tList<DeclareAnnotation> forRemoval = new ArrayList<>();\n\t\t\t\t\t\tfor (DeclareAnnotation decaF : worthRetrying) {\n\t\t\t\t\t\t\tif (decaF.matches(field, world)) {\n\t\t\t\t\t\t\t\tif (decaF.isRemover()) {\n\t\t\t\t\t\t\t\t\tAnnotationAJ annotation = decaF.getAnnotation();\n\t\t\t\t\t\t\t\t\tif (field.hasAnnotation(annotation.getType())) {\n\t\t\t\t\t\t\t\t\t\t// something to remove\n\t\t\t\t\t\t\t\t\t\ttypeIsChanged = modificationOccured = true;\n\t\t\t\t\t\t\t\t\t\tforRemoval.add(decaF);\n\t\t\t\t\t\t\t\t\t\tfield.removeAnnotation(annotation);\n\t\t\t\t\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationFieldRelationship(world.getModelAsAsmManager(),\n\t\t\t\t\t\t\t\t\t\t\t\tdecaF.getSourceLocation(), clazz.getName(), field, true);\n\t\t\t\t\t\t\t\t\t\treportFieldAnnotationWeavingMessage(clazz, field, decaF, true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// below code is for recursive things\n\t\t\t\t\t\t\t\t\tunusedDecafs.remove(decaF);\n\t\t\t\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(field, decaF, reportedProblems, true)) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfield.addAnnotation(decaF.getAnnotation());\n\t\t\t\t\t\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationFieldRelationship(world.getModelAsAsmManager(),\n\t\t\t\t\t\t\t\t\t\t\tdecaF.getSourceLocation(), clazz.getName(), field, false);\n\t\t\t\t\t\t\t\t\ttypeIsChanged = modificationOccured = true;\n\t\t\t\t\t\t\t\t\tforRemoval.add(decaF);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tworthRetrying.removeAll(forRemoval);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckUnusedDeclareAts(unusedDecafs, true);\n\t\t}\n\t\treturn typeIsChanged;\n\t}\n\n\t// bug 99191 - put out an error message if the type doesn't exist\n\t/**\n\t * Report an error if the reason a \"declare @method/ctor/field\" was not used was because the member specified does not exist.\n\t * This method is passed some set of declare statements that didn't match and a flag indicating whether the set contains declare @field\n\t * or declare @method/ctor entries.\n\t */\n\tprivate void checkUnusedDeclareAts(Set<DeclareAnnotation> unusedDecaTs, boolean isDeclareAtField) {\n\t\tfor (DeclareAnnotation declA : unusedDecaTs) {\n\n\t\t\t// Error if an exact type pattern was specified\n\t\t\tboolean shouldCheck = declA.isExactPattern() || declA.getSignaturePattern().getExactDeclaringTypes().size() != 0;\n\n\t\t\tif (shouldCheck && declA.getKind() != DeclareAnnotation.AT_CONSTRUCTOR) {\n\t\t\t\tif (declA.getSignaturePattern().isMatchOnAnyName()) {\n\t\t\t\t\tshouldCheck = false;\n\t\t\t\t} else {\n\t\t\t\t\tList<ExactTypePattern> declaringTypePatterns = declA.getSignaturePattern().getExactDeclaringTypes();\n\t\t\t\t\tif (declaringTypePatterns.size() == 0) {\n\t\t\t\t\t\tshouldCheck = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (ExactTypePattern exactTypePattern : declaringTypePatterns) {\n\t\t\t\t\t\t\tif (exactTypePattern.isIncludeSubtypes()) {\n\t\t\t\t\t\t\t\tshouldCheck = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (shouldCheck) {\n\t\t\t\t// Quickly check if an ITD supplies the 'missing' member\n\t\t\t\tboolean itdMatch = false;\n\t\t\t\tList<ConcreteTypeMunger> lst = clazz.getType().getInterTypeMungers();\n\t\t\t\tfor (Iterator<ConcreteTypeMunger> iterator = lst.iterator(); iterator.hasNext() && !itdMatch;) {\n\t\t\t\t\tConcreteTypeMunger element = iterator.next();\n\t\t\t\t\tif (element.getMunger() instanceof NewFieldTypeMunger) {\n\t\t\t\t\t\tNewFieldTypeMunger nftm = (NewFieldTypeMunger) element.getMunger();\n\t\t\t\t\t\titdMatch = declA.matches(nftm.getSignature(), world);\n\t\t\t\t\t} else if (element.getMunger() instanceof NewMethodTypeMunger) {\n\t\t\t\t\t\tNewMethodTypeMunger nmtm = (NewMethodTypeMunger) element.getMunger();\n\t\t\t\t\t\titdMatch = declA.matches(nmtm.getSignature(), world);\n\t\t\t\t\t} else if (element.getMunger() instanceof NewConstructorTypeMunger) {\n\t\t\t\t\t\tNewConstructorTypeMunger nctm = (NewConstructorTypeMunger) element.getMunger();\n\t\t\t\t\t\titdMatch = declA.matches(nctm.getSignature(), world);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!itdMatch) {\n\t\t\t\t\tIMessage message = null;\n\t\t\t\t\tif (isDeclareAtField) {\n\t\t\t\t\t\tmessage = new Message(\"The field '\" + declA.getSignaturePattern().toString() + \"' does not exist\",\n\t\t\t\t\t\t\t\tdeclA.getSourceLocation(), true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmessage = new Message(\"The method '\" + declA.getSignaturePattern().toString() + \"' does not exist\",\n\t\t\t\t\t\t\t\tdeclA.getSourceLocation(), true);\n\t\t\t\t\t}\n\t\t\t\t\tworld.getMessageHandler().handleMessage(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TAG: WeavingMessage\n\tprivate void reportFieldAnnotationWeavingMessage(LazyClassGen clazz, BcelField theField, DeclareAnnotation decaf,\n\t\t\tboolean isRemove) {\n\t\tif (!getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {\n\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\tWeaveMessage.constructWeavingMessage(\n\t\t\t\t\t\t\tisRemove ? WeaveMessage.WEAVEMESSAGE_REMOVES_ANNOTATION : WeaveMessage.WEAVEMESSAGE_ANNOTATES,\n\t\t\t\t\t\t\t\t\tnew String[] { theField.getFieldAsIs().toString() + \"' of type '\" + clazz.getName(),\n\t\t\t\t\t\t\t\t\t\t\tclazz.getFileName(), decaf.getAnnotationString(), \"field\", decaf.getAspect().toString(),\n\t\t\t\t\t\t\t\t\t\t\tUtility.beautifyLocation(decaf.getSourceLocation()) }));\n\t\t}\n\t}\n\n\t/**\n\t * Check if a resolved member (field/method/ctor) already has an annotation, if it does then put out a warning and return true\n\t */\n\tprivate boolean doesAlreadyHaveAnnotation(ResolvedMember rm, DeclareAnnotation deca, List<Integer> reportedProblems, boolean reportError) {\n\t\tif (rm.hasAnnotation(deca.getAnnotationType())) {\n\t\t\tif (reportError && world.getLint().elementAlreadyAnnotated.isEnabled()) {\n\t\t\t\tInteger uniqueID = rm.hashCode() * deca.hashCode();\n\t\t\t\tif (!reportedProblems.contains(uniqueID)) {\n\t\t\t\t\treportedProblems.add(uniqueID);\n\t\t\t\t\tworld.getLint().elementAlreadyAnnotated.signal(new String[] { rm.toString(),\n\t\t\t\t\t\t\tdeca.getAnnotationType().toString() }, rm.getSourceLocation(),\n\t\t\t\t\t\t\tnew ISourceLocation[] { deca.getSourceLocation() });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean doesAlreadyHaveAnnotation(LazyMethodGen rm, ResolvedMember itdfieldsig, DeclareAnnotation deca,\n\t\t\tList<Integer> reportedProblems) {\n\t\tif (rm != null && rm.hasAnnotation(deca.getAnnotationType())) {\n\t\t\tif (world.getLint().elementAlreadyAnnotated.isEnabled()) {\n\t\t\t\tInteger uniqueID = rm.hashCode() * deca.hashCode();\n\t\t\t\tif (!reportedProblems.contains(uniqueID)) {\n\t\t\t\t\treportedProblems.add(uniqueID);\n\t\t\t\t\treportedProblems.add(itdfieldsig.hashCode() * deca.hashCode());\n\t\t\t\t\tworld.getLint().elementAlreadyAnnotated.signal(new String[] { itdfieldsig.toString(),\n\t\t\t\t\t\t\tdeca.getAnnotationType().toString() }, rm.getSourceLocation(),\n\t\t\t\t\t\t\tnew ISourceLocation[] { deca.getSourceLocation() });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate Set<String> findAspectsForMungers(LazyMethodGen mg) {\n\t\tSet<String> aspectsAffectingType = new HashSet<>();\n\t\tfor (BcelShadow shadow : mg.matchedShadows) {\n\t\t\tfor (ShadowMunger munger : shadow.getMungers()) {\n\t\t\t\tif (munger instanceof BcelAdvice) {\n\t\t\t\t\tBcelAdvice bcelAdvice = (BcelAdvice) munger;\n\t\t\t\t\tif (bcelAdvice.getConcreteAspect() != null) {\n\t\t\t\t\t\taspectsAffectingType.add(bcelAdvice.getConcreteAspect().getSignature());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// It is a 'Checker' - we don't need to remember aspects\n\t\t\t\t\t// that only contributed Checkers...\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn aspectsAffectingType;\n\t}\n\n\tprivate boolean inlineSelfConstructors(List<LazyMethodGen> methodGens, List<LazyMethodGen> recursiveCtors) {\n\t\tboolean inlinedSomething = false;\n\t\tList<LazyMethodGen> newRecursiveCtors = new ArrayList<>();\n\t\tfor (LazyMethodGen methodGen : methodGens) {\n\t\t\tif (!methodGen.getName().equals(\"<init>\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tInstructionHandle ih = findSuperOrThisCall(methodGen);\n\t\t\tif (ih != null && isThisCall(ih)) {\n\t\t\t\tLazyMethodGen donor = getCalledMethod(ih);\n\t\t\t\tif (donor.equals(methodGen)) {\n\t\t\t\t\tnewRecursiveCtors.add(donor);\n\t\t\t\t} else {\n\t\t\t\t\tif (!recursiveCtors.contains(donor)) {\n\t\t\t\t\t\tinlineMethod(donor, methodGen, ih);\n\t\t\t\t\t\tinlinedSomething = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trecursiveCtors.addAll(newRecursiveCtors);\n\t\treturn inlinedSomething;\n\t}\n\n\tprivate void positionAndImplement(List<BcelShadow> initializationShadows) {\n\t\tfor (BcelShadow s : initializationShadows) {\n\t\t\tpositionInitializationShadow(s);\n\t\t\t// s.getEnclosingMethod().print();\n\t\t\ts.implement();\n\t\t}\n\t}\n\n\tprivate void positionInitializationShadow(BcelShadow s) {\n\t\tLazyMethodGen mg = s.getEnclosingMethod();\n\t\tInstructionHandle call = findSuperOrThisCall(mg);\n\t\tInstructionList body = mg.getBody();\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tif (s.getKind() == Shadow.PreInitialization) {\n\t\t\t// XXX assert first instruction is an ALOAD_0.\n\t\t\t// a pre shadow goes from AFTER the first instruction (which we\n\t\t\t// believe to\n\t\t\t// be an ALOAD_0) to just before the call to super\n\t\t\tr.associateWithTargets(Range.genStart(body, body.getStart().getNext()), Range.genEnd(body, call.getPrev()));\n\t\t} else {\n\t\t\t// assert s.getKind() == Shadow.Initialization\n\t\t\tr.associateWithTargets(Range.genStart(body, call.getNext()), Range.genEnd(body));\n\t\t}\n\t}\n\n\tprivate boolean isThisCall(InstructionHandle ih) {\n\t\tInvokeInstruction inst = (InvokeInstruction) ih.getInstruction();\n\t\treturn inst.getClassName(cpg).equals(clazz.getName());\n\t}\n\n\t/**\n\t * inline a particular call in bytecode.\n\t *\n\t * @param donor the method we want to inline\n\t * @param recipient the method containing the call we want to inline\n\t * @param call the instructionHandle in recipient's body holding the call we want to inline.\n\t */\n\tpublic static void inlineMethod(LazyMethodGen donor, LazyMethodGen recipient, InstructionHandle call) {\n\t\t// assert recipient.contains(call)\n\n\t\t/*\n\t\t * Implementation notes:\n\t\t *\n\t\t * We allocate two slots for every tempvar so we don't screw up longs and doubles which may share space. This could be\n\t\t * conservatively avoided (no reference to a long/double instruction, don't do it) or packed later. Right now we don't\n\t\t * bother to pack.\n\t\t *\n\t\t * Allocate a new var for each formal param of the inlined. Fill with stack contents. Then copy the inlined instructions in\n\t\t * with the appropriate remap table. Any framelocs used by locals in inlined are reallocated to top of frame,\n\t\t */\n\t\tfinal InstructionFactory fact = recipient.getEnclosingClass().getFactory();\n\n\t\tIntMap frameEnv = new IntMap();\n\n\t\t// this also sets up the initial environment\n\t\tInstructionList argumentStores = genArgumentStores(donor, recipient, frameEnv, fact);\n\n\t\tInstructionList inlineInstructions = genInlineInstructions(donor, recipient, frameEnv, fact, false);\n\n\t\tinlineInstructions.insert(argumentStores);\n\n\t\trecipient.getBody().append(call, inlineInstructions);\n\t\tUtility.deleteInstruction(call, recipient);\n\t}\n\n\t// public BcelVar genTempVar(UnresolvedType typeX) {\n\t// return new BcelVar(typeX.resolve(world),\n\t// genTempVarIndex(typeX.getSize()));\n\t// }\n\t//\n\t// private int genTempVarIndex(int size) {\n\t// return enclosingMethod.allocateLocal(size);\n\t// }\n\n\t/**\n\t * Input method is a synchronized method, we remove the bit flag for synchronized and then insert a try..finally block\n\t *\n\t * Some jumping through firey hoops required - depending on the input code level (1.5 or not) we may or may not be able to use\n\t * the LDC instruction that takes a class literal (doesnt on <1.5).\n\t *\n\t * FIXME asc Before promoting -Xjoinpoints:synchronization to be a standard option, this needs a bunch of tidying up - there is\n\t * some duplication that can be removed.\n\t */\n\tpublic static void transformSynchronizedMethod(LazyMethodGen synchronizedMethod) {\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.enter(\"transformSynchronizedMethod\", synchronizedMethod);\n\t\t}\n\t\t// System.err.println(\"DEBUG: Transforming synchronized method: \"+\n\t\t// synchronizedMethod.getName());\n\t\tfinal InstructionFactory fact = synchronizedMethod.getEnclosingClass().getFactory();\n\t\tInstructionList body = synchronizedMethod.getBody();\n\t\tInstructionList prepend = new InstructionList();\n\t\tType enclosingClassType = BcelWorld.makeBcelType(synchronizedMethod.getEnclosingClass().getType());\n\n\t\t// STATIC METHOD TRANSFORMATION\n\t\tif (synchronizedMethod.isStatic()) {\n\n\t\t\t// What to do here depends on the level of the class file!\n\t\t\t// LDC can handle class literals in Java5 and above *sigh*\n\t\t\tif (synchronizedMethod.getEnclosingClass().isAtLeastJava5()) {\n\t\t\t\t// MONITORENTER logic:\n\t\t\t\t// 0: ldc #2; //class C\n\t\t\t\t// 2: dup\n\t\t\t\t// 3: astore_0\n\t\t\t\t// 4: monitorenter\n\t\t\t\tint slotForLockObject = synchronizedMethod.allocateLocal(enclosingClassType);\n\t\t\t\tprepend.append(fact.createConstant(enclosingClassType));\n\t\t\t\tprepend.append(InstructionFactory.createDup(1));\n\t\t\t\tprepend.append(InstructionFactory.createStore(enclosingClassType, slotForLockObject));\n\t\t\t\tprepend.append(InstructionFactory.MONITORENTER);\n\n\t\t\t\t// MONITOREXIT logic:\n\n\t\t\t\t// We basically need to wrap the code from the method in a\n\t\t\t\t// finally block that\n\t\t\t\t// will ensure monitorexit is called. Content on the finally\n\t\t\t\t// block seems to\n\t\t\t\t// be always:\n\t\t\t\t//\n\t\t\t\t// E1: ALOAD_1\n\t\t\t\t// MONITOREXIT\n\t\t\t\t// ATHROW\n\t\t\t\t//\n\t\t\t\t// so lets build that:\n\t\t\t\tInstructionList finallyBlock = new InstructionList();\n\t\t\t\tfinallyBlock.append(InstructionFactory.createLoad(Type.getType(java.lang.Class.class), slotForLockObject));\n\t\t\t\tfinallyBlock.append(InstructionConstants.MONITOREXIT);\n\t\t\t\tfinallyBlock.append(InstructionConstants.ATHROW);\n\n\t\t\t\t// finally -> E1\n\t\t\t\t// | GETSTATIC java.lang.System.out Ljava/io/PrintStream; (line\n\t\t\t\t// 21)\n\t\t\t\t// | LDC \"hello\"\n\t\t\t\t// | INVOKEVIRTUAL java.io.PrintStream.println\n\t\t\t\t// (Ljava/lang/String;)V\n\t\t\t\t// | ALOAD_1 (line 20)\n\t\t\t\t// | MONITOREXIT\n\t\t\t\t// finally -> E1\n\t\t\t\t// GOTO L0\n\t\t\t\t// finally -> E1\n\t\t\t\t// | E1: ALOAD_1\n\t\t\t\t// | MONITOREXIT\n\t\t\t\t// finally -> E1\n\t\t\t\t// ATHROW\n\t\t\t\t// L0: RETURN (line 23)\n\n\t\t\t\t// search for 'returns' and make them jump to the\n\t\t\t\t// aload_<n>,monitorexit\n\t\t\t\tInstructionHandle walker = body.getStart();\n\t\t\t\tList<InstructionHandle> rets = new ArrayList<>();\n\t\t\t\twhile (walker != null) {\n\t\t\t\t\tif (walker.getInstruction().isReturnInstruction()) {\n\t\t\t\t\t\trets.add(walker);\n\t\t\t\t\t}\n\t\t\t\t\twalker = walker.getNext();\n\t\t\t\t}\n\t\t\t\tif (!rets.isEmpty()) {\n\t\t\t\t\t// need to ensure targeters for 'return' now instead target\n\t\t\t\t\t// the load instruction\n\t\t\t\t\t// (so we never jump over the monitorexit logic)\n\n\t\t\t\t\tfor (InstructionHandle element : rets) {\n\t\t\t\t\t\tInstructionList monitorExitBlock = new InstructionList();\n\t\t\t\t\t\tmonitorExitBlock.append(InstructionFactory.createLoad(enclosingClassType, slotForLockObject));\n\t\t\t\t\t\tmonitorExitBlock.append(InstructionConstants.MONITOREXIT);\n\t\t\t\t\t\t// monitorExitBlock.append(Utility.copyInstruction(element\n\t\t\t\t\t\t// .getInstruction()));\n\t\t\t\t\t\t// element.setInstruction(InstructionFactory.createLoad(\n\t\t\t\t\t\t// classType,slotForThis));\n\t\t\t\t\t\tInstructionHandle monitorExitBlockStart = body.insert(element, monitorExitBlock);\n\n\t\t\t\t\t\t// now move the targeters from the RET to the start of\n\t\t\t\t\t\t// the monitorexit block\n\t\t\t\t\t\tfor (InstructionTargeter targeter : element.getTargetersCopy()) {\n\t\t\t\t\t\t\t// what kinds are there?\n\t\t\t\t\t\t\tif (targeter instanceof LocalVariableTag) {\n\t\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t\t} else if (targeter instanceof LineNumberTag) {\n\t\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t\t\t// } else if (targeter instanceof\n\t\t\t\t\t\t\t\t// InstructionBranch &&\n\t\t\t\t\t\t\t\t// ((InstructionBranch)targeter).isGoto()) {\n\t\t\t\t\t\t\t\t// // move it...\n\t\t\t\t\t\t\t\t// targeter.updateTarget(element,\n\t\t\t\t\t\t\t\t// monitorExitBlockStart);\n\t\t\t\t\t\t\t} else if (targeter instanceof InstructionBranch) {\n\t\t\t\t\t\t\t\t// move it\n\t\t\t\t\t\t\t\ttargeter.updateTarget(element, monitorExitBlockStart);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow new BCException(\"Unexpected targeter encountered during transform: \" + targeter);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now the magic, putting the finally block around the code\n\t\t\t\tInstructionHandle finallyStart = finallyBlock.getStart();\n\n\t\t\t\tInstructionHandle tryPosition = body.getStart();\n\t\t\t\tInstructionHandle catchPosition = body.getEnd();\n\t\t\t\tbody.insert(body.getStart(), prepend); // now we can put the\n\t\t\t\t// monitorenter stuff on\n\t\t\t\tsynchronizedMethod.getBody().append(finallyBlock);\n\t\t\t\tsynchronizedMethod.addExceptionHandler(tryPosition, catchPosition, finallyStart, null/* ==finally */, false);\n\t\t\t\tsynchronizedMethod.addExceptionHandler(finallyStart, finallyStart.getNext(), finallyStart, null, false);\n\t\t\t} else {\n\n\t\t\t\t// TRANSFORMING STATIC METHOD ON PRE JAVA5\n\n\t\t\t\t// Hideous nightmare, class literal references prior to Java5\n\n\t\t\t\t// YIKES! this is just the code for MONITORENTER !\n\t\t\t\t// 0: getstatic #59; //Field class$1:Ljava/lang/Class;\n\t\t\t\t// 3: dup\n\t\t\t\t// 4: ifnonnull 32\n\t\t\t\t// 7: pop\n\t\t\t\t// try\n\t\t\t\t// 8: ldc #61; //String java.lang.String\n\t\t\t\t// 10: invokestatic #44; //Method\n\t\t\t\t// java/lang/Class.forName:(Ljava/lang/String;)Ljava/lang/Class;\n\t\t\t\t// 13: dup\n\t\t\t\t// catch\n\t\t\t\t// 14: putstatic #59; //Field class$1:Ljava/lang/Class;\n\t\t\t\t// 17: goto 32\n\t\t\t\t// 20: new #46; //class java/lang/NoClassDefFoundError\n\t\t\t\t// 23: dup_x1\n\t\t\t\t// 24: swap\n\t\t\t\t// 25: invokevirtual #52; //Method\n\t\t\t\t// java/lang/Throwable.getMessage:()Ljava/lang/String;\n\t\t\t\t// 28: invokespecial #54; //Method\n\t\t\t\t// java/lang/NoClassDefFoundError.\"<init>\":(Ljava/lang/String;)V\n\t\t\t\t// 31: athrow\n\t\t\t\t// 32: dup <-- partTwo (branch target)\n\t\t\t\t// 33: astore_0\n\t\t\t\t// 34: monitorenter\n\t\t\t\t//\n\t\t\t\t// plus exceptiontable entry!\n\t\t\t\t// 8 13 20 Class java/lang/ClassNotFoundException\n\t\t\t\tType classType = BcelWorld.makeBcelType(synchronizedMethod.getEnclosingClass().getType());\n\t\t\t\tType clazzType = Type.getType(Class.class);\n\n\t\t\t\tInstructionList parttwo = new InstructionList();\n\t\t\t\tparttwo.append(InstructionFactory.createDup(1));\n\t\t\t\tint slotForThis = synchronizedMethod.allocateLocal(classType);\n\t\t\t\tparttwo.append(InstructionFactory.createStore(clazzType, slotForThis)); // ? should be the real type ? String or\n\t\t\t\t// something?\n\t\t\t\tparttwo.append(InstructionFactory.MONITORENTER);\n\n\t\t\t\tString fieldname = synchronizedMethod.getEnclosingClass().allocateField(\"class$\");\n\t\t\t\tFieldGen f = new FieldGen(Modifier.STATIC | Modifier.PRIVATE, Type.getType(Class.class), fieldname,\n\t\t\t\t\t\tsynchronizedMethod.getEnclosingClass().getConstantPool());\n\t\t\t\tsynchronizedMethod.getEnclosingClass().addField(f, null);\n\n\t\t\t\t// 10: invokestatic #44; //Method\n\t\t\t\t// java/lang/Class.forName:(Ljava/lang/String;)Ljava/lang/Class;\n\t\t\t\t// 13: dup\n\t\t\t\t// 14: putstatic #59; //Field class$1:Ljava/lang/Class;\n\t\t\t\t// 17: goto 32\n\t\t\t\t// 20: new #46; //class java/lang/NoClassDefFoundError\n\t\t\t\t// 23: dup_x1\n\t\t\t\t// 24: swap\n\t\t\t\t// 25: invokevirtual #52; //Method\n\t\t\t\t// java/lang/Throwable.getMessage:()Ljava/lang/String;\n\t\t\t\t// 28: invokespecial #54; //Method\n\t\t\t\t// java/lang/NoClassDefFoundError.\"<init>\":(Ljava/lang/String;)V\n\t\t\t\t// 31: athrow\n\t\t\t\tString name = synchronizedMethod.getEnclosingClass().getName();\n\n\t\t\t\tprepend.append(fact.createGetStatic(name, fieldname, Type.getType(Class.class)));\n\t\t\t\tprepend.append(InstructionFactory.createDup(1));\n\t\t\t\tprepend.append(InstructionFactory.createBranchInstruction(Constants.IFNONNULL, parttwo.getStart()));\n\t\t\t\tprepend.append(InstructionFactory.POP);\n\n\t\t\t\tprepend.append(fact.createConstant(name));\n\t\t\t\tInstructionHandle tryInstruction = prepend.getEnd();\n\t\t\t\tprepend.append(fact.createInvoke(\"java.lang.Class\", \"forName\", clazzType,\n\t\t\t\t\t\tnew Type[] { Type.getType(String.class) }, Constants.INVOKESTATIC));\n\t\t\t\tInstructionHandle catchInstruction = prepend.getEnd();\n\t\t\t\tprepend.append(InstructionFactory.createDup(1));\n\n\t\t\t\tprepend.append(fact.createPutStatic(synchronizedMethod.getEnclosingClass().getType().getName(), fieldname,\n\t\t\t\t\t\tType.getType(Class.class)));\n\t\t\t\tprepend.append(InstructionFactory.createBranchInstruction(Constants.GOTO, parttwo.getStart()));\n\n\t\t\t\t// start of catch block\n\t\t\t\tInstructionList catchBlockForLiteralLoadingFail = new InstructionList();\n\t\t\t\tcatchBlockForLiteralLoadingFail.append(fact.createNew((ObjectType) Type.getType(NoClassDefFoundError.class)));\n\t\t\t\tcatchBlockForLiteralLoadingFail.append(InstructionFactory.createDup_1(1));\n\t\t\t\tcatchBlockForLiteralLoadingFail.append(InstructionFactory.SWAP);\n\t\t\t\tcatchBlockForLiteralLoadingFail.append(fact.createInvoke(\"java.lang.Throwable\", \"getMessage\",\n\t\t\t\t\t\tType.getType(String.class), Type.NO_ARGS, Constants.INVOKEVIRTUAL));\n\t\t\t\tcatchBlockForLiteralLoadingFail.append(fact.createInvoke(\"java.lang.NoClassDefFoundError\", \"<init>\", Type.VOID,\n\t\t\t\t\t\tnew Type[] { Type.getType(String.class) }, Constants.INVOKESPECIAL));\n\t\t\t\tcatchBlockForLiteralLoadingFail.append(InstructionFactory.ATHROW);\n\t\t\t\tInstructionHandle catchBlockStart = catchBlockForLiteralLoadingFail.getStart();\n\t\t\t\tprepend.append(catchBlockForLiteralLoadingFail);\n\t\t\t\tprepend.append(parttwo);\n\t\t\t\t// MONITORENTER\n\t\t\t\t// pseudocode: load up 'this' (var0), dup it, store it in a new\n\t\t\t\t// local var (for use with monitorexit) and call\n\t\t\t\t// monitorenter:\n\t\t\t\t// ALOAD_0, DUP, ASTORE_<n>, MONITORENTER\n\t\t\t\t// prepend.append(InstructionFactory.createLoad(classType,0));\n\t\t\t\t// prepend.append(InstructionFactory.createDup(1));\n\t\t\t\t// int slotForThis =\n\t\t\t\t// synchronizedMethod.allocateLocal(classType);\n\t\t\t\t// prepend.append(InstructionFactory.createStore(classType,\n\t\t\t\t// slotForThis));\n\t\t\t\t// prepend.append(InstructionFactory.MONITORENTER);\n\n\t\t\t\t// MONITOREXIT\n\t\t\t\t// here be dragons\n\n\t\t\t\t// We basically need to wrap the code from the method in a\n\t\t\t\t// finally block that\n\t\t\t\t// will ensure monitorexit is called. Content on the finally\n\t\t\t\t// block seems to\n\t\t\t\t// be always:\n\t\t\t\t//\n\t\t\t\t// E1: ALOAD_1\n\t\t\t\t// MONITOREXIT\n\t\t\t\t// ATHROW\n\t\t\t\t//\n\t\t\t\t// so lets build that:\n\t\t\t\tInstructionList finallyBlock = new InstructionList();\n\t\t\t\tfinallyBlock.append(InstructionFactory.createLoad(Type.getType(java.lang.Class.class), slotForThis));\n\t\t\t\tfinallyBlock.append(InstructionConstants.MONITOREXIT);\n\t\t\t\tfinallyBlock.append(InstructionConstants.ATHROW);\n\n\t\t\t\t// finally -> E1\n\t\t\t\t// | GETSTATIC java.lang.System.out Ljava/io/PrintStream; (line\n\t\t\t\t// 21)\n\t\t\t\t// | LDC \"hello\"\n\t\t\t\t// | INVOKEVIRTUAL java.io.PrintStream.println\n\t\t\t\t// (Ljava/lang/String;)V\n\t\t\t\t// | ALOAD_1 (line 20)\n\t\t\t\t// | MONITOREXIT\n\t\t\t\t// finally -> E1\n\t\t\t\t// GOTO L0\n\t\t\t\t// finally -> E1\n\t\t\t\t// | E1: ALOAD_1\n\t\t\t\t// | MONITOREXIT\n\t\t\t\t// finally -> E1\n\t\t\t\t// ATHROW\n\t\t\t\t// L0: RETURN (line 23)\n\t\t\t\t// frameEnv.put(donorFramePos, thisSlot);\n\n\t\t\t\t// search for 'returns' and make them to the\n\t\t\t\t// aload_<n>,monitorexit\n\t\t\t\tInstructionHandle walker = body.getStart();\n\t\t\t\tList<InstructionHandle> rets = new ArrayList<>();\n\t\t\t\twhile (walker != null) { // !walker.equals(body.getEnd())) {\n\t\t\t\t\tif (walker.getInstruction().isReturnInstruction()) {\n\t\t\t\t\t\trets.add(walker);\n\t\t\t\t\t}\n\t\t\t\t\twalker = walker.getNext();\n\t\t\t\t}\n\t\t\t\tif (rets.size() > 0) {\n\t\t\t\t\t// need to ensure targeters for 'return' now instead target\n\t\t\t\t\t// the load instruction\n\t\t\t\t\t// (so we never jump over the monitorexit logic)\n\n\t\t\t\t\tfor (InstructionHandle ret : rets) {\n\t\t\t\t\t\t// System.err.println(\"Adding monitor exit block at \"+\n\t\t\t\t\t\t// element);\n\t\t\t\t\t\tInstructionList monitorExitBlock = new InstructionList();\n\t\t\t\t\t\tmonitorExitBlock.append(InstructionFactory.createLoad(classType, slotForThis));\n\t\t\t\t\t\tmonitorExitBlock.append(InstructionConstants.MONITOREXIT);\n\t\t\t\t\t\t// monitorExitBlock.append(Utility.copyInstruction(element\n\t\t\t\t\t\t// .getInstruction()));\n\t\t\t\t\t\t// element.setInstruction(InstructionFactory.createLoad(\n\t\t\t\t\t\t// classType,slotForThis));\n\t\t\t\t\t\tInstructionHandle monitorExitBlockStart = body.insert(ret, monitorExitBlock);\n\n\t\t\t\t\t\t// now move the targeters from the RET to the start of\n\t\t\t\t\t\t// the monitorexit block\n\t\t\t\t\t\tfor (InstructionTargeter targeter : ret.getTargetersCopy()) {\n\t\t\t\t\t\t\t// what kinds are there?\n\t\t\t\t\t\t\tif (targeter instanceof LocalVariableTag) {\n\t\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t\t} else if (targeter instanceof LineNumberTag) {\n\t\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t\t\t// } else if (targeter instanceof GOTO ||\n\t\t\t\t\t\t\t\t// targeter instanceof GOTO_W) {\n\t\t\t\t\t\t\t\t// // move it...\n\t\t\t\t\t\t\t\t// targeter.updateTarget(element,\n\t\t\t\t\t\t\t\t// monitorExitBlockStart);\n\t\t\t\t\t\t\t} else if (targeter instanceof InstructionBranch) {\n\t\t\t\t\t\t\t\t// move it\n\t\t\t\t\t\t\t\ttargeter.updateTarget(ret, monitorExitBlockStart);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow new BCException(\"Unexpected targeter encountered during transform: \" + targeter);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// body =\n\t\t\t\t// rewriteWithMonitorExitCalls(body,fact,true,slotForThis,\n\t\t\t\t// classType);\n\t\t\t\t// synchronizedMethod.setBody(body);\n\n\t\t\t\t// now the magic, putting the finally block around the code\n\t\t\t\tInstructionHandle finallyStart = finallyBlock.getStart();\n\n\t\t\t\tInstructionHandle tryPosition = body.getStart();\n\t\t\t\tInstructionHandle catchPosition = body.getEnd();\n\t\t\t\tbody.insert(body.getStart(), prepend); // now we can put the\n\t\t\t\t// monitorenter stuff on\n\n\t\t\t\tsynchronizedMethod.getBody().append(finallyBlock);\n\t\t\t\tsynchronizedMethod.addExceptionHandler(tryPosition, catchPosition, finallyStart, null/* ==finally */, false);\n\t\t\t\tsynchronizedMethod.addExceptionHandler(tryInstruction, catchInstruction, catchBlockStart,\n\t\t\t\t\t\t(ObjectType) Type.getType(ClassNotFoundException.class), true);\n\t\t\t\tsynchronizedMethod.addExceptionHandler(finallyStart, finallyStart.getNext(), finallyStart, null, false);\n\t\t\t}\n\t\t} else {\n\n\t\t\t// TRANSFORMING NON STATIC METHOD\n\t\t\tType classType = BcelWorld.makeBcelType(synchronizedMethod.getEnclosingClass().getType());\n\t\t\t// MONITORENTER\n\t\t\t// pseudocode: load up 'this' (var0), dup it, store it in a new\n\t\t\t// local var (for use with monitorexit) and call\n\t\t\t// monitorenter:\n\t\t\t// ALOAD_0, DUP, ASTORE_<n>, MONITORENTER\n\t\t\tprepend.append(InstructionFactory.createLoad(classType, 0));\n\t\t\tprepend.append(InstructionFactory.createDup(1));\n\t\t\tint slotForThis = synchronizedMethod.allocateLocal(classType);\n\t\t\tprepend.append(InstructionFactory.createStore(classType, slotForThis));\n\t\t\tprepend.append(InstructionFactory.MONITORENTER);\n\t\t\t// body.insert(body.getStart(),prepend);\n\n\t\t\t// MONITOREXIT\n\n\t\t\t// We basically need to wrap the code from the method in a finally\n\t\t\t// block that\n\t\t\t// will ensure monitorexit is called. Content on the finally block\n\t\t\t// seems to\n\t\t\t// be always:\n\t\t\t//\n\t\t\t// E1: ALOAD_1\n\t\t\t// MONITOREXIT\n\t\t\t// ATHROW\n\t\t\t//\n\t\t\t// so lets build that:\n\t\t\tInstructionList finallyBlock = new InstructionList();\n\t\t\tfinallyBlock.append(InstructionFactory.createLoad(classType, slotForThis));\n\t\t\tfinallyBlock.append(InstructionConstants.MONITOREXIT);\n\t\t\tfinallyBlock.append(InstructionConstants.ATHROW);\n\n\t\t\t// finally -> E1\n\t\t\t// | GETSTATIC java.lang.System.out Ljava/io/PrintStream; (line 21)\n\t\t\t// | LDC \"hello\"\n\t\t\t// | INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V\n\t\t\t// | ALOAD_1 (line 20)\n\t\t\t// | MONITOREXIT\n\t\t\t// finally -> E1\n\t\t\t// GOTO L0\n\t\t\t// finally -> E1\n\t\t\t// | E1: ALOAD_1\n\t\t\t// | MONITOREXIT\n\t\t\t// finally -> E1\n\t\t\t// ATHROW\n\t\t\t// L0: RETURN (line 23)\n\t\t\t// frameEnv.put(donorFramePos, thisSlot);\n\n\t\t\t// search for 'returns' and make them to the aload_<n>,monitorexit\n\t\t\tInstructionHandle walker = body.getStart();\n\t\t\tList<InstructionHandle> rets = new ArrayList<>();\n\t\t\twhile (walker != null) { // !walker.equals(body.getEnd())) {\n\t\t\t\tif (walker.getInstruction().isReturnInstruction()) {\n\t\t\t\t\trets.add(walker);\n\t\t\t\t}\n\t\t\t\twalker = walker.getNext();\n\t\t\t}\n\t\t\tif (!rets.isEmpty()) {\n\t\t\t\t// need to ensure targeters for 'return' now instead target the\n\t\t\t\t// load instruction\n\t\t\t\t// (so we never jump over the monitorexit logic)\n\n\t\t\t\tfor (InstructionHandle element : rets) {\n\t\t\t\t\t// System.err.println(\"Adding monitor exit block at \"+element\n\t\t\t\t\t// );\n\t\t\t\t\tInstructionList monitorExitBlock = new InstructionList();\n\t\t\t\t\tmonitorExitBlock.append(InstructionFactory.createLoad(classType, slotForThis));\n\t\t\t\t\tmonitorExitBlock.append(InstructionConstants.MONITOREXIT);\n\t\t\t\t\t// monitorExitBlock.append(Utility.copyInstruction(element.\n\t\t\t\t\t// getInstruction()));\n\t\t\t\t\t// element.setInstruction(InstructionFactory.createLoad(\n\t\t\t\t\t// classType,slotForThis));\n\t\t\t\t\tInstructionHandle monitorExitBlockStart = body.insert(element, monitorExitBlock);\n\n\t\t\t\t\t// now move the targeters from the RET to the start of the\n\t\t\t\t\t// monitorexit block\n\t\t\t\t\tfor (InstructionTargeter targeter : element.getTargetersCopy()) {\n\t\t\t\t\t\t// what kinds are there?\n\t\t\t\t\t\tif (targeter instanceof LocalVariableTag) {\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t} else if (targeter instanceof LineNumberTag) {\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t\t// } else if (targeter instanceof GOTO ||\n\t\t\t\t\t\t\t// targeter instanceof GOTO_W) {\n\t\t\t\t\t\t\t// // move it...\n\t\t\t\t\t\t\t// targeter.updateTarget(element,\n\t\t\t\t\t\t\t// monitorExitBlockStart);\n\t\t\t\t\t\t} else if (targeter instanceof InstructionBranch) {\n\t\t\t\t\t\t\t// move it\n\t\t\t\t\t\t\ttargeter.updateTarget(element, monitorExitBlockStart);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new BCException(\"Unexpected targeter encountered during transform: \" + targeter);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now the magic, putting the finally block around the code\n\t\t\tInstructionHandle finallyStart = finallyBlock.getStart();\n\n\t\t\tInstructionHandle tryPosition = body.getStart();\n\t\t\tInstructionHandle catchPosition = body.getEnd();\n\t\t\tbody.insert(body.getStart(), prepend); // now we can put the\n\t\t\t// monitorenter stuff on\n\t\t\tsynchronizedMethod.getBody().append(finallyBlock);\n\t\t\tsynchronizedMethod.addExceptionHandler(tryPosition, catchPosition, finallyStart, null/* ==finally */, false);\n\t\t\tsynchronizedMethod.addExceptionHandler(finallyStart, finallyStart.getNext(), finallyStart, null, false);\n\t\t\t// also the exception handling for the finally block jumps to itself\n\n\t\t\t// max locals will already have been modified in the allocateLocal()\n\t\t\t// call\n\n\t\t\t// synchronized bit is removed on LazyMethodGen.pack()\n\t\t}\n\n\t\t// gonna have to go through and change all aload_0s to load the var from\n\t\t// a variable,\n\t\t// going to add a new variable for the this var\n\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.exit(\"transformSynchronizedMethod\");\n\t\t}\n\t}\n\n\t/**\n\t * generate the instructions to be inlined.\n\t *\n\t * @param donor the method from which we will copy (and adjust frame and jumps) instructions.\n\t * @param recipient the method the instructions will go into. Used to get the frame size so we can allocate new frame locations\n\t *        for locals in donor.\n\t * @param frameEnv an environment to map from donor frame to recipient frame, initially populated with argument locations.\n\t * @param fact an instruction factory for recipient\n\t */\n\tstatic InstructionList genInlineInstructions(LazyMethodGen donor, LazyMethodGen recipient, IntMap frameEnv,\n\t\t\tInstructionFactory fact, boolean keepReturns) {\n\t\tInstructionList footer = new InstructionList();\n\t\tInstructionHandle end = footer.append(InstructionConstants.NOP);\n\n\t\tInstructionList ret = new InstructionList();\n\t\tInstructionList sourceList = donor.getBody();\n\n\t\tMap<InstructionHandle, InstructionHandle> srcToDest = new HashMap<>();\n\t\tConstantPool donorCpg = donor.getEnclosingClass().getConstantPool();\n\t\tConstantPool recipientCpg = recipient.getEnclosingClass().getConstantPool();\n\n\t\tboolean isAcrossClass = donorCpg != recipientCpg;\n\t\tBootstrapMethods bootstrapMethods = null;\n\t\t// first pass: copy the instructions directly, populate the srcToDest\n\t\t// map,\n\t\t// fix frame instructions\n\t\tfor (InstructionHandle src = sourceList.getStart(); src != null; src = src.getNext()) {\n\t\t\tInstruction fresh = Utility.copyInstruction(src.getInstruction());\n\t\t\tInstructionHandle dest;\n\n\t\t\t// OPTIMIZE optimize this stuff?\n\t\t\tif (fresh.isConstantPoolInstruction()) {\n\t\t\t\t// need to reset index to go to new constant pool. This is totally\n\t\t\t\t// a computation leak... we're testing this LOTS of times. Sigh.\n\t\t\t\tif (isAcrossClass) {\n\t\t\t\t\tInstructionCP cpi = (InstructionCP) fresh;\n\t\t\t\t\tcpi.setIndex(recipientCpg.addConstant(donorCpg.getConstant(cpi.getIndex()), donorCpg));\n\t\t\t\t}\n\t\t\t\t// May need to copy bootstrapmethods across too.\n\t\t\t\t//\t\t\t\tif (fresh instanceof InvokeDynamic) {\n\t\t\t\t//\t\t\t\t\tInvokeDynamic id = (InvokeDynamic)fresh;\n\t\t\t\t//\t\t\t\t\tConstantInvokeDynamic cid = (ConstantInvokeDynamic)donorCpg.getConstant(src.getInstruction().getIndex());\n\t\t\t\t//\t\t\t\t\tint bmaIndex = cid.getBootstrapMethodAttrIndex();\n\t\t\t\t//\t\t\t\t\tif (bootstrapMethods == null) {\n\t\t\t\t//\t\t\t\t\t\tCollection<Attribute> attributes = donor.getEnclosingClass().getAttributes();\n\t\t\t\t//\t\t\t\t\t\tif (attributes != null) {\n\t\t\t\t//\t\t\t\t\t\t\tfor (Attribute attribute: attributes) {\n\t\t\t\t//\t\t\t\t\t\t\t\tif (attribute instanceof BootstrapMethods) {\n\t\t\t\t//\t\t\t\t\t\t\t\t\tbootstrapMethods = (BootstrapMethods)attribute;\n\t\t\t\t//\t\t\t\t\t\t\t\t}\n\t\t\t\t//\t\t\t\t\t\t\t}\n\t\t\t\t//\t\t\t\t\t\t}\n\t\t\t\t//\t\t\t\t\t\tBootstrapMethods.BootstrapMethod bootstrapMethod =\n\t\t\t\t//\t\t\t\t\t\t\t\tbootstrapMethods.getBootstrapMethods()[bmaIndex];\n\t\t\t\t//\t\t\t\t\t\tConstantMethodHandle methodhandle = (ConstantMethodHandle)donorCpg.getConstant(bootstrapMethod.getBootstrapMethodRef());\n\t\t\t\t//\t\t\t\t\t\tint bootstrapMethodArguments[] = bootstrapMethod.getBootstrapArguments();\n\t\t\t\t//\n\t\t\t\t//\t\t\t\t\t\t// Finally have all we need to build the new one...\n\t\t\t\t//\n\t\t\t\t//\t\t\t\t\t\tint newMethodHandleIndex = recipientCpg.addConstant(methodhandle, donorCpg);\n\t\t\t\t//\t\t\t\t\t\tint[] newMethodArguments = new int[bootstrapMethodArguments.length];\n\t\t\t\t//\t\t\t\t\t\tfor (int a=0; a<bootstrapMethodArguments.length; a++) {\n\t\t\t\t//\t\t\t\t\t\t\tnewMethodArguments[a] = recipientCpg.addConstant(donorCpg.getConstant(bootstrapMethodArguments[a]),donorCpg);\n\t\t\t\t//\t\t\t\t\t\t}\n\t\t\t\t//\t\t\t\t\t\tBootstrapMethods.BootstrapMethod newBootstrapMethod =\n\t\t\t\t//\t\t\t\t\t\t\t\tnew BootstrapMethods.BootstrapMethod(newMethodHandleIndex,newMethodArguments);\n\t\t\t\t//\n\t\t\t\t//\t\t\t\t\t\tCollection<Attribute> newAttributes = recipient.getEnclosingClass().getAttributes();\n\t\t\t\t//\t\t\t\t\t\tBootstrapMethods newBootstrapMethods = null;\n\t\t\t\t//\t\t\t\t\t\tfor (Attribute attr: newAttributes) {\n\t\t\t\t//\t\t\t\t\t\t\tif (attr instanceof BootstrapMethods) {\n\t\t\t\t//\t\t\t\t\t\t\t\tnewBootstrapMethods = (BootstrapMethods)newBootstrapMethods;\n\t\t\t\t//\t\t\t\t\t\t\t}\n\t\t\t\t//\t\t\t\t\t\t}\n\t\t\t\t//\t\t\t\t\t\tif (newBootstrapMethods == null) {\n\t\t\t\t//\t\t\t\t\t\t\tnewBootstrapMethods =\n\t\t\t\t//\t\t\t\t\t\t\t\t\tnew BootstrapMethods(recipientCpg.addUtf8(\"BootstrapMethods\"),\n\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\t2+newBootstrapMethod.getLength(),\n\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\tnew BootstrapMethods.BootstrapMethod[] {newBootstrapMethod},\n\t\t\t\t//\t\t\t\t\t\t\t\t\t\t\trecipientCpg);\n\t\t\t\t//\t\t\t\t\t\t\trecipient.getEnclosingClass().addAttribute(newBootstrapMethods);\n\t\t\t\t//\t\t\t\t\t\t}\n\t\t\t\t// TODO need to copy over lambda$0 support methods too...\n\t\t\t\t//\t\t\t\t\t}\n\t\t\t\t//\n\t\t\t\t//\t\t\t\t}\n\t\t\t}\n\t\t\tif (src.getInstruction() == Range.RANGEINSTRUCTION) {\n\t\t\t\tdest = ret.append(Range.RANGEINSTRUCTION);\n\t\t\t} else if (fresh.isReturnInstruction()) {\n\t\t\t\tif (keepReturns) {\n\t\t\t\t\tdest = ret.append(fresh);\n\t\t\t\t} else {\n\t\t\t\t\tdest = ret.append(InstructionFactory.createBranchInstruction(Constants.GOTO, end));\n\t\t\t\t}\n\t\t\t} else if (fresh instanceof InstructionBranch) {\n\t\t\t\tdest = ret.append((InstructionBranch) fresh);\n\t\t\t} else if (fresh.isLocalVariableInstruction() || fresh instanceof RET) {\n\n\t\t\t\t// IndexedInstruction indexed = (IndexedInstruction) fresh;\n\t\t\t\tint oldIndex = fresh.getIndex();\n\t\t\t\tint freshIndex;\n\t\t\t\tif (!frameEnv.hasKey(oldIndex)) {\n\t\t\t\t\tfreshIndex = recipient.allocateLocal(2);\n\t\t\t\t\tframeEnv.put(oldIndex, freshIndex);\n\t\t\t\t} else {\n\t\t\t\t\tfreshIndex = frameEnv.get(oldIndex);\n\t\t\t\t}\n\t\t\t\tif (fresh instanceof RET) {\n\t\t\t\t\tfresh.setIndex(freshIndex);\n\t\t\t\t} else {\n\t\t\t\t\tfresh = ((InstructionLV) fresh).setIndexAndCopyIfNecessary(freshIndex);\n\t\t\t\t}\n\t\t\t\tdest = ret.append(fresh);\n\t\t\t} else {\n\t\t\t\tdest = ret.append(fresh);\n\t\t\t}\n\t\t\tsrcToDest.put(src, dest);\n\t\t}\n\n\t\t// second pass: retarget branch instructions, copy ranges and tags\n\t\tMap<Tag, Tag> tagMap = new HashMap<>();\n\t\tMap<BcelShadow, BcelShadow> shadowMap = new HashMap<>();\n\t\tfor (InstructionHandle dest = ret.getStart(), src = sourceList.getStart(); dest != null; dest = dest.getNext(), src = src\n\t\t\t\t.getNext()) {\n\t\t\tInstruction inst = dest.getInstruction();\n\n\t\t\t// retarget branches\n\t\t\tif (inst instanceof InstructionBranch) {\n\t\t\t\tInstructionBranch branch = (InstructionBranch) inst;\n\t\t\t\tInstructionHandle oldTarget = branch.getTarget();\n\t\t\t\tInstructionHandle newTarget = srcToDest.get(oldTarget);\n\t\t\t\tif (newTarget == null) {\n\t\t\t\t\t// assert this is a GOTO\n\t\t\t\t\t// this was a return instruction we previously replaced\n\t\t\t\t} else {\n\t\t\t\t\tbranch.setTarget(newTarget);\n\t\t\t\t\tif (branch instanceof InstructionSelect) {\n\t\t\t\t\t\tInstructionSelect select = (InstructionSelect) branch;\n\t\t\t\t\t\tInstructionHandle[] oldTargets = select.getTargets();\n\t\t\t\t\t\tfor (int k = oldTargets.length - 1; k >= 0; k--) {\n\t\t\t\t\t\t\tselect.setTarget(k, srcToDest.get(oldTargets[k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// copy over tags and range attributes\n\n\t\t\tfor (InstructionTargeter old : src.getTargeters()) {\n\t\t\t\tif (old instanceof Tag) {\n\t\t\t\t\tTag oldTag = (Tag) old;\n\t\t\t\t\tTag fresh = tagMap.get(oldTag);\n\t\t\t\t\tif (fresh == null) {\n\t\t\t\t\t\tfresh = oldTag.copy();\n\t\t\t\t\t\tif (old instanceof LocalVariableTag) {\n\t\t\t\t\t\t\t// LocalVariable\n\t\t\t\t\t\t\tLocalVariableTag lvTag = (LocalVariableTag) old;\n\t\t\t\t\t\t\tLocalVariableTag lvTagFresh = (LocalVariableTag) fresh;\n\t\t\t\t\t\t\tif (lvTag.getSlot() == 0) {\n\t\t\t\t\t\t\t\tfresh = new LocalVariableTag(lvTag.getRealType().getSignature(), \"ajc$aspectInstance\",\n\t\t\t\t\t\t\t\t\t\tframeEnv.get(lvTag.getSlot()), 0);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// // Do not move it - when copying the code from the aspect to the affected target, 'this' is\n\t\t\t\t\t\t\t\t// // going to change from aspect to affected type. So just fix the type\n\t\t\t\t\t\t\t\t// System.out.println(\"For local variable tag at instruction \" + src + \" changing slot from \"\n\t\t\t\t\t\t\t\t// + lvTag.getSlot() + \" > \" + frameEnv.get(lvTag.getSlot()));\n\t\t\t\t\t\t\t\tlvTagFresh.updateSlot(frameEnv.get(lvTag.getSlot()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttagMap.put(oldTag, fresh);\n\t\t\t\t\t}\n\t\t\t\t\tdest.addTargeter(fresh);\n\t\t\t\t} else if (old instanceof ExceptionRange) {\n\t\t\t\t\tExceptionRange er = (ExceptionRange) old;\n\t\t\t\t\tif (er.getStart() == src) {\n\t\t\t\t\t\tExceptionRange freshEr = new ExceptionRange(recipient.getBody(), er.getCatchType(), er.getPriority());\n\t\t\t\t\t\tfreshEr.associateWithTargets(dest, srcToDest.get(er.getEnd()), srcToDest.get(er.getHandler()));\n\t\t\t\t\t}\n\t\t\t\t} else if (old instanceof ShadowRange) {\n\t\t\t\t\tShadowRange oldRange = (ShadowRange) old;\n\t\t\t\t\tif (oldRange.getStart() == src) {\n\t\t\t\t\t\tBcelShadow oldShadow = oldRange.getShadow();\n\t\t\t\t\t\tBcelShadow freshEnclosing = oldShadow.getEnclosingShadow() == null ? null : shadowMap\n\t\t\t\t\t\t\t\t.get(oldShadow.getEnclosingShadow());\n\t\t\t\t\t\tBcelShadow freshShadow = oldShadow.copyInto(recipient, freshEnclosing);\n\t\t\t\t\t\tShadowRange freshRange = new ShadowRange(recipient.getBody());\n\t\t\t\t\t\tfreshRange.associateWithShadow(freshShadow);\n\t\t\t\t\t\tfreshRange.associateWithTargets(dest, srcToDest.get(oldRange.getEnd()));\n\t\t\t\t\t\tshadowMap.put(oldShadow, freshShadow); // oldRange, freshRange\n\t\t\t\t\t\t// recipient.matchedShadows.add(freshShadow);\n\t\t\t\t\t\t// XXX should go through the NEW copied shadow and\n\t\t\t\t\t\t// update\n\t\t\t\t\t\t// the thisVar, targetVar, and argsVar\n\t\t\t\t\t\t// ??? Might want to also go through at this time and\n\t\t\t\t\t\t// add\n\t\t\t\t\t\t// \"extra\" vars to the shadow.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!keepReturns) {\n\t\t\tret.append(footer);\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// static InstructionList rewriteWithMonitorExitCalls(InstructionList\n\t// sourceList,InstructionFactory fact,boolean keepReturns,int\n\t// monitorVarSlot,Type monitorVarType)\n\t// {\n\t// InstructionList footer = new InstructionList();\n\t// InstructionHandle end = footer.append(InstructionConstants.NOP);\n\t//\n\t// InstructionList newList = new InstructionList();\n\t//\n\t// Map srcToDest = new HashMap();\n\t//\n\t// // first pass: copy the instructions directly, populate the srcToDest\n\t// map,\n\t// // fix frame instructions\n\t// for (InstructionHandle src = sourceList.getStart(); src != null; src =\n\t// src.getNext()) {\n\t// Instruction fresh = Utility.copyInstruction(src.getInstruction());\n\t// InstructionHandle dest;\n\t// if (src.getInstruction() == Range.RANGEINSTRUCTION) {\n\t// dest = newList.append(Range.RANGEINSTRUCTION);\n\t// } else if (fresh.isReturnInstruction()) {\n\t// if (keepReturns) {\n\t// newList.append(InstructionFactory.createLoad(monitorVarType,monitorVarSlot\n\t// ));\n\t// newList.append(InstructionConstants.MONITOREXIT);\n\t// dest = newList.append(fresh);\n\t// } else {\n\t// dest =\n\t// newList.append(InstructionFactory.createBranchInstruction(Constants.GOTO,\n\t// end));\n\t// }\n\t// } else if (fresh instanceof InstructionBranch) {\n\t// dest = newList.append((InstructionBranch) fresh);\n\t// } else if (\n\t// fresh.isLocalVariableInstruction() || fresh instanceof RET) {\n\t// //IndexedInstruction indexed = (IndexedInstruction) fresh;\n\t// int oldIndex = fresh.getIndex();\n\t// int freshIndex;\n\t// // if (!frameEnv.hasKey(oldIndex)) {\n\t// // freshIndex = recipient.allocateLocal(2);\n\t// // frameEnv.put(oldIndex, freshIndex);\n\t// // } else {\n\t// freshIndex = oldIndex;//frameEnv.get(oldIndex);\n\t// // }\n\t// if (fresh instanceof RET) {\n\t// fresh.setIndex(freshIndex);\n\t// } else {\n\t// fresh = ((InstructionLV)fresh).setIndexAndCopyIfNecessary(freshIndex);\n\t// }\n\t// dest = newList.append(fresh);\n\t// } else {\n\t// dest = newList.append(fresh);\n\t// }\n\t// srcToDest.put(src, dest);\n\t// }\n\t//\n\t// // second pass: retarget branch instructions, copy ranges and tags\n\t// Map tagMap = new HashMap();\n\t// for (InstructionHandle dest = newList.getStart(), src =\n\t// sourceList.getStart();\n\t// dest != null;\n\t// dest = dest.getNext(), src = src.getNext()) {\n\t// Instruction inst = dest.getInstruction();\n\t//\n\t// // retarget branches\n\t// if (inst instanceof InstructionBranch) {\n\t// InstructionBranch branch = (InstructionBranch) inst;\n\t// InstructionHandle oldTarget = branch.getTarget();\n\t// InstructionHandle newTarget =\n\t// (InstructionHandle) srcToDest.get(oldTarget);\n\t// if (newTarget == null) {\n\t// // assert this is a GOTO\n\t// // this was a return instruction we previously replaced\n\t// } else {\n\t// branch.setTarget(newTarget);\n\t// if (branch instanceof InstructionSelect) {\n\t// InstructionSelect select = (InstructionSelect) branch;\n\t// InstructionHandle[] oldTargets = select.getTargets();\n\t// for (int k = oldTargets.length - 1; k >= 0; k--) {\n\t// select.setTarget(\n\t// k,\n\t// (InstructionHandle) srcToDest.get(oldTargets[k]));\n\t// }\n\t// }\n\t// }\n\t// }\n\t//\n\t// //copy over tags and range attributes\n\t// Iterator tIter = src.getTargeters().iterator();\n\t//\n\t// while (tIter.hasNext()) {\n\t// InstructionTargeter old = (InstructionTargeter)tIter.next();\n\t// if (old instanceof Tag) {\n\t// Tag oldTag = (Tag) old;\n\t// Tag fresh = (Tag) tagMap.get(oldTag);\n\t// if (fresh == null) {\n\t// fresh = oldTag.copy();\n\t// tagMap.put(oldTag, fresh);\n\t// }\n\t// dest.addTargeter(fresh);\n\t// } else if (old instanceof ExceptionRange) {\n\t// ExceptionRange er = (ExceptionRange) old;\n\t// if (er.getStart() == src) {\n\t// ExceptionRange freshEr =\n\t// new ExceptionRange(newList/*recipient.getBody()*/,er.getCatchType(),er.\n\t// getPriority());\n\t// freshEr.associateWithTargets(\n\t// dest,\n\t// (InstructionHandle)srcToDest.get(er.getEnd()),\n\t// (InstructionHandle)srcToDest.get(er.getHandler()));\n\t// }\n\t// }\n\t// /*else if (old instanceof ShadowRange) {\n\t// ShadowRange oldRange = (ShadowRange) old;\n\t// if (oldRange.getStart() == src) {\n\t// BcelShadow oldShadow = oldRange.getShadow();\n\t// BcelShadow freshEnclosing =\n\t// oldShadow.getEnclosingShadow() == null\n\t// ? null\n\t// : (BcelShadow) shadowMap.get(oldShadow.getEnclosingShadow());\n\t// BcelShadow freshShadow =\n\t// oldShadow.copyInto(recipient, freshEnclosing);\n\t// ShadowRange freshRange = new ShadowRange(recipient.getBody());\n\t// freshRange.associateWithShadow(freshShadow);\n\t// freshRange.associateWithTargets(\n\t// dest,\n\t// (InstructionHandle) srcToDest.get(oldRange.getEnd()));\n\t// shadowMap.put(oldRange, freshRange);\n\t// //recipient.matchedShadows.add(freshShadow);\n\t// // XXX should go through the NEW copied shadow and update\n\t// // the thisVar, targetVar, and argsVar\n\t// // ??? Might want to also go through at this time and add\n\t// // \"extra\" vars to the shadow.\n\t// }\n\t// }*/\n\t// }\n\t// }\n\t// if (!keepReturns) newList.append(footer);\n\t// return newList;\n\t// }\n\n\t/**\n\t * generate the argument stores in preparation for inlining.\n\t *\n\t * @param donor the method we will inline from. Used to get the signature.\n\t * @param recipient the method we will inline into. Used to get the frame size so we can allocate fresh locations.\n\t * @param frameEnv an empty environment we populate with a map from donor frame to recipient frame.\n\t * @param fact an instruction factory for recipient\n\t */\n\tprivate static InstructionList genArgumentStores(LazyMethodGen donor, LazyMethodGen recipient, IntMap frameEnv,\n\t\t\tInstructionFactory fact) {\n\t\tInstructionList ret = new InstructionList();\n\n\t\tint donorFramePos = 0;\n\n\t\t// writing ret back to front because we're popping.\n\t\tif (!donor.isStatic()) {\n\t\t\tint targetSlot = recipient.allocateLocal(Type.OBJECT);\n\t\t\tret.insert(InstructionFactory.createStore(Type.OBJECT, targetSlot));\n\t\t\tframeEnv.put(donorFramePos, targetSlot);\n\t\t\tdonorFramePos += 1;\n\t\t}\n\t\tType[] argTypes = donor.getArgumentTypes();\n\t\tfor (Type argType : argTypes) {\n\t\t\tint argSlot = recipient.allocateLocal(argType);\n\t\t\tret.insert(InstructionFactory.createStore(argType, argSlot));\n\t\t\tframeEnv.put(donorFramePos, argSlot);\n\t\t\tdonorFramePos += argType.getSize();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/**\n\t * get a called method: Assumes the called method is in this class, and the reference to it is exact (a la INVOKESPECIAL).\n\t *\n\t * @param ih The InvokeInstruction instructionHandle pointing to the called method.\n\t */\n\tprivate LazyMethodGen getCalledMethod(InstructionHandle ih) {\n\t\tInvokeInstruction inst = (InvokeInstruction) ih.getInstruction();\n\n\t\tString methodName = inst.getName(cpg);\n\t\tString signature = inst.getSignature(cpg);\n\n\t\treturn clazz.getLazyMethodGen(methodName, signature);\n\t}\n\n\tprivate void weaveInAddedMethods() {\n\t\taddedLazyMethodGens.sort(new Comparator<LazyMethodGen>() {\n\t\t\tpublic int compare(LazyMethodGen aa, LazyMethodGen bb) {\n\t\t\t\tint i = aa.getName().compareTo(bb.getName());\n\t\t\t\tif (i != 0) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t\treturn aa.getSignature().compareTo(bb.getSignature());\n\t\t\t}\n\t\t});\n\n\t\tfor (LazyMethodGen addedMember : addedLazyMethodGens) {\n\t\t\tclazz.addMethodGen(addedMember);\n\t\t}\n\t}\n\n\t// void addPerSingletonField(Member field) {\n\t// ObjectType aspectType = (ObjectType)\n\t// BcelWorld.makeBcelType(field.getReturnType());\n\t// String aspectName = field.getReturnType().getName();\n\t//\n\t// LazyMethodGen clinit = clazz.getStaticInitializer();\n\t// InstructionList setup = new InstructionList();\n\t// InstructionFactory fact = clazz.getFactory();\n\t//\n\t// setup.append(fact.createNew(aspectType));\n\t// setup.append(InstructionFactory.createDup(1));\n\t// setup.append(fact.createInvoke(aspectName, \"<init>\", Type.VOID, new\n\t// Type[0], Constants.INVOKESPECIAL));\n\t// setup.append(fact.createFieldAccess(aspectName, field.getName(),\n\t// aspectType, Constants.PUTSTATIC));\n\t// clinit.getBody().insert(setup);\n\t// }\n\n\t/**\n\t * Returns null if this is not a Java constructor, and then we won't weave into it at all\n\t */\n\tprivate InstructionHandle findSuperOrThisCall(LazyMethodGen mg) {\n\t\tint depth = 1;\n\t\tInstructionHandle start = mg.getBody().getStart();\n\t\twhile (true) {\n\t\t\tif (start == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tInstruction inst = start.getInstruction();\n\t\t\tif (inst.opcode == Constants.INVOKESPECIAL && ((InvokeInstruction) inst).getName(cpg).equals(\"<init>\")) {\n\t\t\t\tdepth--;\n\t\t\t\tif (depth == 0) {\n\t\t\t\t\treturn start;\n\t\t\t\t}\n\t\t\t} else if (inst.opcode == Constants.NEW) {\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t\tstart = start.getNext();\n\t\t}\n\t}\n\n\t// ----\n\n\tprivate boolean match(LazyMethodGen mg) {\n\t\tBcelShadow enclosingShadow;\n\t\tList<BcelShadow> shadowAccumulator = new ArrayList<>();\n\t\tboolean isOverweaving = world.isOverWeaving();\n\t\tboolean startsAngly = mg.getName().charAt(0) == '<';\n\t\t// we want to match ajsynthetic constructors...\n\t\tif (startsAngly && mg.getName().equals(\"<init>\")) {\n\t\t\treturn matchInit(mg, shadowAccumulator);\n\t\t} else if (!shouldWeaveBody(mg)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif (startsAngly && mg.getName().equals(\"<clinit>\")) {\n\t\t\t\t// clinitShadow =\n\t\t\t\tenclosingShadow = BcelShadow.makeStaticInitialization(world, mg);\n\t\t\t\t// System.err.println(enclosingShadow);\n\t\t\t} else if (mg.isAdviceMethod()) {\n\t\t\t\tenclosingShadow = BcelShadow.makeAdviceExecution(world, mg);\n\t\t\t} else {\n\t\t\t\tAjAttribute.EffectiveSignatureAttribute effective = mg.getEffectiveSignature();\n\t\t\t\tif (effective == null) {\n\t\t\t\t\t// Don't want ajc$preClinit to be considered for matching\n\t\t\t\t\tif (isOverweaving && mg.getName().startsWith(NameMangler.PREFIX)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (mg.getName().startsWith(SWITCH_TABLE_SYNTHETIC_METHOD_PREFIX)\n\t\t\t\t\t\t\t&& Objects.equals(mg.getReturnType().getSignature(), \"[I\")) {\n\t\t\t\t\t\t// this is a synthetic switch helper, should be skipped (since it's not 'declared')\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tenclosingShadow = BcelShadow.makeMethodExecution(world, mg, !canMatchBodyShadows);\n\t\t\t\t} else if (effective.isWeaveBody()) {\n\t\t\t\t\tResolvedMember rm = effective.getEffectiveSignature();\n\n\t\t\t\t\t// Annotations for things with effective signatures are\n\t\t\t\t\t// never stored in the effective\n\t\t\t\t\t// signature itself - we have to hunt for them. Storing them\n\t\t\t\t\t// in the effective signature\n\t\t\t\t\t// would mean keeping two sets up to date (no way!!)\n\n\t\t\t\t\tfixParameterNamesForResolvedMember(rm, mg.getMemberView());\n\t\t\t\t\tfixAnnotationsForResolvedMember(rm, mg.getMemberView());\n\n\t\t\t\t\tenclosingShadow = BcelShadow.makeShadowForMethod(world, mg, effective.getShadowKind(), rm);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (canMatchBodyShadows) {\n\t\t\t\tfor (InstructionHandle h = mg.getBody().getStart(); h != null; h = h.getNext()) {\n\t\t\t\t\tmatch(mg, h, enclosingShadow, shadowAccumulator);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// FIXME asc change from string match if we can, rather brittle.\n\t\t\t// this check actually prevents field-exec jps\n\t\t\tif (canMatch(enclosingShadow.getKind())\n\t\t\t\t\t&& !(mg.getName().charAt(0) == 'a' && mg.getName().startsWith(\"ajc$interFieldInit\"))) {\n\t\t\t\tif (match(enclosingShadow, shadowAccumulator)) {\n\t\t\t\t\tenclosingShadow.init();\n\t\t\t\t}\n\t\t\t}\n\t\t\tmg.matchedShadows = shadowAccumulator;\n\t\t\treturn !shadowAccumulator.isEmpty();\n\t\t}\n\t}\n\n\tprivate boolean matchInit(LazyMethodGen mg, List<BcelShadow> shadowAccumulator) {\n\t\tBcelShadow enclosingShadow;\n\t\t// XXX the enclosing join point is wrong for things before ignoreMe.\n\t\tInstructionHandle superOrThisCall = findSuperOrThisCall(mg);\n\n\t\t// we don't walk bodies of things where it's a wrong constructor thingie\n\t\tif (superOrThisCall == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tenclosingShadow = BcelShadow.makeConstructorExecution(world, mg, superOrThisCall);\n\t\tif (mg.getEffectiveSignature() != null) {\n\t\t\tenclosingShadow.setMatchingSignature(mg.getEffectiveSignature().getEffectiveSignature());\n\t\t}\n\n\t\t// walk the body\n\t\tboolean beforeSuperOrThisCall = true;\n\t\tif (shouldWeaveBody(mg)) {\n\t\t\tif (canMatchBodyShadows) {\n\t\t\t\tfor (InstructionHandle h = mg.getBody().getStart(); h != null; h = h.getNext()) {\n\t\t\t\t\tif (h == superOrThisCall) {\n\t\t\t\t\t\tbeforeSuperOrThisCall = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmatch(mg, h, beforeSuperOrThisCall ? null : enclosingShadow, shadowAccumulator);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (canMatch(Shadow.ConstructorExecution)) {\n\t\t\t\tmatch(enclosingShadow, shadowAccumulator);\n\t\t\t}\n\t\t}\n\n\t\t// XXX we don't do pre-inits of interfaces\n\n\t\t// now add interface inits\n\t\tif (!isThisCall(superOrThisCall)) {\n\t\t\tInstructionHandle curr = enclosingShadow.getRange().getStart();\n\t\t\tfor (IfaceInitList l : addedSuperInitializersAsList) {\n\t\t\t\tMember ifaceInitSig = AjcMemberMaker.interfaceConstructor(l.onType);\n\n\t\t\t\tBcelShadow initShadow = BcelShadow.makeIfaceInitialization(world, mg, ifaceInitSig);\n\n\t\t\t\t// insert code in place\n\t\t\t\tInstructionList inits = genInitInstructions(l.list, false);\n\t\t\t\tif (match(initShadow, shadowAccumulator) || !inits.isEmpty()) {\n\t\t\t\t\tinitShadow.initIfaceInitializer(curr);\n\t\t\t\t\tinitShadow.getRange().insert(inits, Range.OutsideBefore);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now we add our initialization code\n\t\t\tInstructionList inits = genInitInstructions(addedThisInitializers, false);\n\t\t\tenclosingShadow.getRange().insert(inits, Range.OutsideBefore);\n\t\t}\n\n\t\t// actually, you only need to inline the self constructors that are\n\t\t// in a particular group (partition the constructors into groups where\n\t\t// members\n\t\t// call or are called only by those in the group). Then only inline\n\t\t// constructors\n\t\t// in groups where at least one initialization jp matched. Future work.\n\t\tboolean addedInitialization = match(BcelShadow.makeUnfinishedInitialization(world, mg), initializationShadows);\n\t\taddedInitialization |= match(BcelShadow.makeUnfinishedPreinitialization(world, mg), initializationShadows);\n\t\tmg.matchedShadows = shadowAccumulator;\n\t\treturn addedInitialization || !shadowAccumulator.isEmpty();\n\t}\n\n\tprivate boolean shouldWeaveBody(LazyMethodGen mg) {\n\t\tif (mg.isBridgeMethod()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (mg.isAjSynthetic()) {\n\t\t\treturn mg.getName().equals(\"<clinit>\");\n\t\t}\n\t\tAjAttribute.EffectiveSignatureAttribute a = mg.getEffectiveSignature();\n\t\tif (a != null) {\n\t\t\treturn a.isWeaveBody();\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * first sorts the mungers, then gens the initializers in the right order\n\t */\n\tprivate InstructionList genInitInstructions(List<ConcreteTypeMunger> list, boolean isStatic) {\n\t\tlist = PartialOrder.sort(list);\n\t\tif (list == null) {\n\t\t\tthrow new BCException(\"circularity in inter-types\");\n\t\t}\n\n\t\tInstructionList ret = new InstructionList();\n\n\t\tfor (ConcreteTypeMunger cmunger : list) {\n\t\t\tNewFieldTypeMunger munger = (NewFieldTypeMunger) cmunger.getMunger();\n\t\t\tResolvedMember initMethod = munger.getInitMethod(cmunger.getAspectType());\n\t\t\tif (!isStatic) {\n\t\t\t\tret.append(InstructionConstants.ALOAD_0);\n\t\t\t}\n\t\t\tret.append(Utility.createInvoke(fact, world, initMethod));\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate void match(LazyMethodGen mg, InstructionHandle ih, BcelShadow enclosingShadow, List<BcelShadow> shadowAccumulator) {\n\t\tInstruction i = ih.getInstruction();\n\n\t\t// Exception handlers (pr230817)\n\t\tif (canMatch(Shadow.ExceptionHandler) && !Range.isRangeHandle(ih)) {\n\t\t\tSet<InstructionTargeter> targeters = ih.getTargetersCopy();\n\t\t\t// If in Java7 there may be overlapping exception ranges for multi catch - we should recognize that\n\t\t\tfor (InstructionTargeter t : targeters) {\n\t\t\t\tif (t instanceof ExceptionRange) {\n\t\t\t\t\t// assert t.getHandler() == ih\n\t\t\t\t\tExceptionRange er = (ExceptionRange) t;\n\t\t\t\t\tif (er.getCatchType() == null) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (isInitFailureHandler(ih)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ih.getInstruction().isStoreInstruction() && ih.getInstruction().getOpcode() != Constants.NOP) {\n\t\t\t\t\t\t// If using cobertura, the catch block stats with\n\t\t\t\t\t\t// INVOKESTATIC rather than ASTORE, in order that the ranges\n\t\t\t\t\t\t// for the methodcall and exceptionhandler shadows\n\t\t\t\t\t\t// that occur at this same\n\t\t\t\t\t\t// line, we need to modify the instruction list to\n\t\t\t\t\t\t// split them - adding a\n\t\t\t\t\t\t// NOP before the invokestatic that gets all the targeters\n\t\t\t\t\t\t// that were aimed at the INVOKESTATIC\n\t\t\t\t\t\tmg.getBody().insert(ih, InstructionConstants.NOP);\n\t\t\t\t\t\tInstructionHandle newNOP = ih.getPrev();\n\t\t\t\t\t\t// what about a try..catch that starts at the start\n\t\t\t\t\t\t// of the exception handler? need to only include\n\t\t\t\t\t\t// certain targeters really.\n\t\t\t\t\t\ter.updateTarget(ih, newNOP, mg.getBody());\n\t\t\t\t\t\tfor (InstructionTargeter t2 : targeters) {\n\t\t\t\t\t\t\tnewNOP.addTargeter(t2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tih.removeAllTargeters();\n\t\t\t\t\t\tmatch(BcelShadow.makeExceptionHandler(world, er, mg, newNOP, enclosingShadow), shadowAccumulator);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch(BcelShadow.makeExceptionHandler(world, er, mg, ih, enclosingShadow), shadowAccumulator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((i instanceof FieldInstruction) && (canMatch(Shadow.FieldGet) || canMatch(Shadow.FieldSet))) {\n\t\t\tFieldInstruction fi = (FieldInstruction) i;\n\n\t\t\tif (fi.opcode == Constants.PUTFIELD || fi.opcode == Constants.PUTSTATIC) {\n\t\t\t\t// check for sets of constant fields. We first check the\n\t\t\t\t// previous\n\t\t\t\t// instruction. If the previous instruction is a LD_WHATEVER\n\t\t\t\t// (push\n\t\t\t\t// constant on the stack) then we must resolve the field to\n\t\t\t\t// determine\n\t\t\t\t// if it's final. If it is final, then we don't generate a\n\t\t\t\t// shadow.\n\t\t\t\tInstructionHandle prevHandle = ih.getPrev();\n\t\t\t\tInstruction prevI = prevHandle.getInstruction();\n\t\t\t\tif (Utility.isConstantPushInstruction(prevI)) {\n\t\t\t\t\tMember field = BcelWorld.makeFieldJoinPointSignature(clazz, (FieldInstruction) i);\n\t\t\t\t\tResolvedMember resolvedField = field.resolve(world);\n\t\t\t\t\tif (resolvedField == null) {\n\t\t\t\t\t\t// we can't find the field, so it's not a join point.\n\t\t\t\t\t} else if (Modifier.isFinal(resolvedField.getModifiers())) {\n\t\t\t\t\t\t// it's final, so it's the set of a final constant, so\n\t\t\t\t\t\t// it's\n\t\t\t\t\t\t// not a join point according to 1.0.6 and 1.1.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (canMatch(Shadow.FieldSet)) {\n\t\t\t\t\t\t\tmatchSetInstruction(mg, ih, enclosingShadow, shadowAccumulator);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (canMatch(Shadow.FieldSet)) {\n\t\t\t\t\t\tmatchSetInstruction(mg, ih, enclosingShadow, shadowAccumulator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (canMatch(Shadow.FieldGet)) {\n\t\t\t\t\tmatchGetInstruction(mg, ih, enclosingShadow, shadowAccumulator);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (i instanceof InvokeInstruction) {\n\t\t\tInvokeInstruction ii = (InvokeInstruction) i;\n\t\t\tif (ii.getMethodName(clazz.getConstantPool()).equals(\"<init>\")) {\n\t\t\t\tif (canMatch(Shadow.ConstructorCall)) {\n\t\t\t\t\tmatch(BcelShadow.makeConstructorCall(world, mg, ih, enclosingShadow), shadowAccumulator);\n\t\t\t\t}\n\t\t\t} else if (ii.opcode == Constants.INVOKESPECIAL) {\n\t\t\t\tString onTypeName = ii.getClassName(cpg);\n\t\t\t\tif (onTypeName.equals(mg.getEnclosingClass().getName())) {\n\t\t\t\t\t// we are private\n\t\t\t\t\tmatchInvokeInstruction(mg, ih, ii, enclosingShadow, shadowAccumulator);\n\t\t\t\t} else {\n\t\t\t\t\t// we are a super call, and this is not a join point in\n\t\t\t\t\t// AspectJ-1.{0,1}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ii.getOpcode()!=Constants.INVOKEDYNAMIC) {\n\t\t\t\t\tmatchInvokeInstruction(mg, ih, ii, enclosingShadow, shadowAccumulator);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (world.isJoinpointArrayConstructionEnabled() && i.isArrayCreationInstruction()) {\n\t\t\tif (canMatch(Shadow.ConstructorCall)) {\n\t\t\t\tif (i.opcode == Constants.ANEWARRAY) {\n\t\t\t\t\t// ANEWARRAY arrayInstruction = (ANEWARRAY)i;\n\t\t\t\t\t// ObjectType arrayType = i.getLoadClassType(clazz.getConstantPool());\n\t\t\t\t\tBcelShadow ctorCallShadow = BcelShadow.makeArrayConstructorCall(world, mg, ih, enclosingShadow);\n\t\t\t\t\tmatch(ctorCallShadow, shadowAccumulator);\n\t\t\t\t} else if (i.opcode == Constants.NEWARRAY) {\n\t\t\t\t\t// NEWARRAY arrayInstruction = (NEWARRAY)i;\n\t\t\t\t\t// Type arrayType = i.getType();\n\t\t\t\t\tBcelShadow ctorCallShadow = BcelShadow.makeArrayConstructorCall(world, mg, ih, enclosingShadow);\n\t\t\t\t\tmatch(ctorCallShadow, shadowAccumulator);\n\t\t\t\t} else if (i instanceof MULTIANEWARRAY) {\n\t\t\t\t\t// MULTIANEWARRAY arrayInstruction = (MULTIANEWARRAY) i;\n\t\t\t\t\t// ObjectType arrayType = arrayInstruction.getLoadClassType(clazz.getConstantPool());\n\t\t\t\t\tBcelShadow ctorCallShadow = BcelShadow.makeArrayConstructorCall(world, mg, ih, enclosingShadow);\n\t\t\t\t\tmatch(ctorCallShadow, shadowAccumulator);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// see pr77166 if you are thinking about implementing this\n\t\t\t// } else if (i instanceof AALOAD ) {\n\t\t\t// AALOAD arrayLoad = (AALOAD)i;\n\t\t\t// Type arrayType = arrayLoad.getType(clazz.getConstantPoolGen());\n\t\t\t// BcelShadow arrayLoadShadow =\n\t\t\t// BcelShadow.makeArrayLoadCall(world,mg,ih,enclosingShadow);\n\t\t\t// match(arrayLoadShadow,shadowAccumulator);\n\t\t\t// } else if (i instanceof AASTORE) {\n\t\t\t// // ... magic required\n\t\t} else if (world.isJoinpointSynchronizationEnabled()\n\t\t\t\t&& ((i.getOpcode() == Constants.MONITORENTER) || (i.getOpcode() == Constants.MONITOREXIT))) {\n\t\t\t// if (canMatch(Shadow.Monitoring)) {\n\t\t\tif (i.getOpcode() == Constants.MONITORENTER) {\n\t\t\t\tBcelShadow monitorEntryShadow = BcelShadow.makeMonitorEnter(world, mg, ih, enclosingShadow);\n\t\t\t\tmatch(monitorEntryShadow, shadowAccumulator);\n\t\t\t} else {\n\t\t\t\tBcelShadow monitorExitShadow = BcelShadow.makeMonitorExit(world, mg, ih, enclosingShadow);\n\t\t\t\tmatch(monitorExitShadow, shadowAccumulator);\n\t\t\t}\n\t\t\t// }\n\t\t}\n\n\t}\n\n\tprivate boolean isInitFailureHandler(InstructionHandle ih) {\n\t\t// Skip the astore_0 and aload_0 at the start of the handler and\n\t\t// then check if the instruction following these is\n\t\t// 'putstatic ajc$initFailureCause'. If it is then we are\n\t\t// in the handler we created in AspectClinit.generatePostSyntheticCode()\n\t\tInstructionHandle twoInstructionsAway = ih.getNext().getNext();\n\t\tif (twoInstructionsAway.getInstruction().opcode == Constants.PUTSTATIC) {\n\t\t\tString name = ((FieldInstruction) twoInstructionsAway.getInstruction()).getFieldName(cpg);\n\t\t\tif (name.equals(NameMangler.INITFAILURECAUSE_FIELD_NAME)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void matchSetInstruction(LazyMethodGen mg, InstructionHandle ih, BcelShadow enclosingShadow,\n\t\t\tList<BcelShadow> shadowAccumulator) {\n\t\tFieldInstruction fi = (FieldInstruction) ih.getInstruction();\n\t\tMember field = BcelWorld.makeFieldJoinPointSignature(clazz, fi);\n\n\t\t// synthetic fields are never join points\n\t\tif (field.getName().startsWith(NameMangler.PREFIX)) {\n\t\t\treturn;\n\t\t}\n\n\t\tResolvedMember resolvedField = field.resolve(world);\n\t\tif (resolvedField == null) {\n\t\t\t// we can't find the field, so it's not a join point.\n\t\t\treturn;\n\t\t} else if (Modifier.isFinal(resolvedField.getModifiers())\n\t\t\t\t&& Utility.isConstantPushInstruction(ih.getPrev().getInstruction())) {\n\t\t\t// it's the set of a final constant, so it's\n\t\t\t// not a join point according to 1.0.6 and 1.1.\n\t\t\treturn;\n\t\t} else if (resolvedField.isSynthetic()) {\n\t\t\t// sets of synthetics aren't join points in 1.1\n\t\t\treturn;\n\t\t} else {\n\t\t\t// Fix for bug 172107 (similar the \"get\" fix for bug 109728)\n\t\t\tBcelShadow bs = BcelShadow.makeFieldSet(world, resolvedField, mg, ih, enclosingShadow);\n\t\t\tString cname = fi.getClassName(cpg);\n\t\t\tif (!resolvedField.getDeclaringType().getName().equals(cname)) {\n\t\t\t\tbs.setActualTargetType(cname);\n\t\t\t}\n\t\t\tmatch(bs, shadowAccumulator);\n\t\t}\n\t}\n\n\tprivate void matchGetInstruction(LazyMethodGen mg, InstructionHandle ih, BcelShadow enclosingShadow,\n\t\t\tList<BcelShadow> shadowAccumulator) {\n\t\tFieldInstruction fi = (FieldInstruction) ih.getInstruction();\n\t\tMember field = BcelWorld.makeFieldJoinPointSignature(clazz, fi);\n\n\t\t// synthetic fields are never join points\n\t\tif (field.getName().startsWith(NameMangler.PREFIX)) {\n\t\t\treturn;\n\t\t}\n\n\t\tResolvedMember resolvedField = field.resolve(world);\n\t\tif (resolvedField == null) {\n\t\t\t// we can't find the field, so it's not a join point.\n\t\t\treturn;\n\t\t} else if (resolvedField.isSynthetic()) {\n\t\t\t// sets of synthetics aren't join points in 1.1\n\t\t\treturn;\n\t\t} else {\n\t\t\tBcelShadow bs = BcelShadow.makeFieldGet(world, resolvedField, mg, ih, enclosingShadow);\n\t\t\tString cname = fi.getClassName(cpg);\n\t\t\tif (!resolvedField.getDeclaringType().getName().equals(cname)) {\n\t\t\t\tbs.setActualTargetType(cname);\n\t\t\t}\n\t\t\tmatch(bs, shadowAccumulator);\n\t\t}\n\t}\n\n\t/**\n\t * For some named resolved type, this method looks for a member with a particular name - it should only be used when you truly\n\t * believe there is only one member with that name in the type as it returns the first one it finds.\n\t */\n\tprivate ResolvedMember findResolvedMemberNamed(ResolvedType type, String methodName) {\n\t\tResolvedMember[] allMethods = type.getDeclaredMethods();\n\t\tfor (ResolvedMember member : allMethods) {\n\t\t\tif (member.getName().equals(methodName)) {\n\t\t\t\treturn member;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Find the specified member in the specified type.\n\t *\n\t * @param type the type to search for the member\n\t * @param methodName the name of the method to find\n\t * @param params the method parameters that the discovered method should have\n\t */\n\tprivate ResolvedMember findResolvedMemberNamed(ResolvedType type, String methodName, UnresolvedType[] params) {\n\t\tResolvedMember[] allMethods = type.getDeclaredMethods();\n\t\tList<ResolvedMember> candidates = new ArrayList<>();\n\t\tfor (ResolvedMember candidate : allMethods) {\n\t\t\tif (candidate.getName().equals(methodName)) {\n\t\t\t\tif (candidate.getArity() == params.length) {\n\t\t\t\t\tcandidates.add(candidate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (candidates.size() == 0) {\n\t\t\treturn null;\n\t\t} else if (candidates.size() == 1) {\n\t\t\treturn candidates.get(0);\n\t\t} else {\n\t\t\t// multiple candidates\n\t\t\tfor (ResolvedMember candidate : candidates) {\n\t\t\t\t// These checks will break down with generics... but that would need two ITDs with the same name, same arity and\n\t\t\t\t// generics\n\t\t\t\tboolean allOK = true;\n\t\t\t\tUnresolvedType[] candidateParams = candidate.getParameterTypes();\n\t\t\t\tfor (int p = 0; p < candidateParams.length; p++) {\n\t\t\t\t\tif (!candidateParams[p].getErasureSignature().equals(params[p].getErasureSignature())) {\n\t\t\t\t\t\tallOK = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allOK) {\n\t\t\t\t\treturn candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * For a given resolvedmember, this will discover the real annotations for it. <b>Should only be used when the resolvedmember is\n\t * the contents of an effective signature attribute, as thats the only time when the annotations aren't stored directly in the\n\t * resolvedMember</b>\n\t *\n\t * @param rm the sig we want it to pretend to be 'int A.m()' or somesuch ITD like thing\n\t * @param declaredSig the real sig 'blah.ajc$xxx'\n\t */\n\tprivate void fixParameterNamesForResolvedMember(ResolvedMember rm, ResolvedMember declaredSig) {\n\n\t\tUnresolvedType memberHostType = declaredSig.getDeclaringType();\n\t\tString methodName = declaredSig.getName();\n\t\tString[] pnames = null;\n\t\tif (rm.getKind() == Member.METHOD && !rm.isAbstract()) {\n\t\t\tif (methodName.startsWith(\"ajc$inlineAccessMethod\") || methodName.startsWith(\"ajc$superDispatch\")) {\n\t\t\t\tResolvedMember resolvedDooberry = world.resolve(declaredSig);\n\t\t\t\tpnames = resolvedDooberry.getParameterNames();\n\t\t\t} else {\n\t\t\t\tResolvedMember realthing = AjcMemberMaker.interMethodDispatcher(rm.resolve(world), memberHostType).resolve(world);\n\t\t\t\tResolvedMember theRealMember = findResolvedMemberNamed(memberHostType.resolve(world), realthing.getName());\n\t\t\t\tif (theRealMember != null) {\n\t\t\t\t\tpnames = theRealMember.getParameterNames();\n\t\t\t\t\t// static ITDs don't need any parameter shifting\n\t\t\t\t\tif (pnames.length > 0 && pnames[0].equals(\"ajc$this_\")) {\n\t\t\t\t\t\tString[] pnames2 = new String[pnames.length - 1];\n\t\t\t\t\t\tSystem.arraycopy(pnames, 1, pnames2, 0, pnames2.length);\n\t\t\t\t\t\tpnames = pnames2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// i think ctors are missing from here... copy code from below...\n\t\t}\n\t\trm.setParameterNames(pnames);\n\t}\n\n\t/**\n\t * For a given resolvedmember, this will discover the real annotations for it. <b>Should only be used when the resolvedmember is\n\t * the contents of an effective signature attribute, as thats the only time when the annotations aren't stored directly in the\n\t * resolvedMember</b>\n\t *\n\t * @param rm the sig we want it to pretend to be 'int A.m()' or somesuch ITD like thing\n\t * @param declaredSig the real sig 'blah.ajc$xxx'\n\t */\n\tprivate void fixAnnotationsForResolvedMember(ResolvedMember rm, ResolvedMember declaredSig) {\n\t\ttry {\n\t\t\tUnresolvedType memberHostType = declaredSig.getDeclaringType();\n\t\t\tboolean containsKey = mapToAnnotationHolder.containsKey(rm);\n\t\t\tResolvedMember realAnnotationHolder = mapToAnnotationHolder.get(rm);\n\t\t\tString methodName = declaredSig.getName();\n\t\t\t// FIXME asc shouldnt really rely on string names !\n\t\t\tif (!containsKey) {\n\t\t\t\tif (rm.getKind() == Member.FIELD) {\n\t\t\t\t\tif (methodName.startsWith(\"ajc$inlineAccessField\")) {\n\t\t\t\t\t\trealAnnotationHolder = world.resolve(rm);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tResolvedMember realthing = AjcMemberMaker.interFieldInitializer(rm, memberHostType);\n\t\t\t\t\t\trealAnnotationHolder = world.resolve(realthing);\n\t\t\t\t\t}\n\t\t\t\t} else if (rm.getKind() == Member.METHOD && !rm.isAbstract()) {\n\t\t\t\t\tif (methodName.startsWith(\"ajc$inlineAccessMethod\") || methodName.startsWith(\"ajc$superDispatch\")) {\n\t\t\t\t\t\trealAnnotationHolder = world.resolve(declaredSig);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tResolvedMember realthing = AjcMemberMaker.interMethodDispatcher(rm.resolve(world), memberHostType).resolve(world);\n\t\t\t\t\t\trealAnnotationHolder = findResolvedMemberNamed(memberHostType.resolve(world), realthing.getName(),realthing.getParameterTypes());\n\t\t\t\t\t\tif (realAnnotationHolder == null) {\n\t\t\t\t\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\t\t\t\t\t\"Known limitation in M4 - can't find ITD members when type variable is used as an argument and has upper bound specified\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (rm.getKind() == Member.CONSTRUCTOR) {\n\t\t\t\t\tResolvedMember realThing = AjcMemberMaker.postIntroducedConstructor(memberHostType.resolve(world),rm.getDeclaringType(), rm.getParameterTypes());\n\t\t\t\t\trealAnnotationHolder = world.resolve(realThing);\n\t\t\t\t\t// AMC temp guard for M4\n\t\t\t\t\tif (realAnnotationHolder == null) {\n\t\t\t\t\t\tthrow new UnsupportedOperationException(\"Known limitation in M4 - can't find ITD members when type variable is used as an argument and has upper bound specified\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmapToAnnotationHolder.put(rm, realAnnotationHolder);\n\t\t\t}\n\t\t\tResolvedType[] annotationTypes;\n\t\t\tAnnotationAJ[] annotations;\n\t\t\tif (realAnnotationHolder!=null) {\n\t\t\t\tannotationTypes = realAnnotationHolder.getAnnotationTypes();\n\t\t\t\tannotations = realAnnotationHolder.getAnnotations();\n\t\t\t\tif (annotationTypes==null) {\n\t\t\t\t\tannotationTypes = ResolvedType.EMPTY_ARRAY;\n\t\t\t\t}\n\t\t\t\tif (annotations==null) {\n\t\t\t\t\tannotations = AnnotationAJ.EMPTY_ARRAY;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tannotations = AnnotationAJ.EMPTY_ARRAY;\n\t\t\t\tannotationTypes = ResolvedType.EMPTY_ARRAY;\n\t\t\t}\n\t\t\trm.setAnnotations(annotations);\n\t\t\trm.setAnnotationTypes(annotationTypes);\n\t\t} catch (UnsupportedOperationException ex) {\n\t\t\tthrow ex;\n\t\t} catch (Throwable t) {\n\t\t\t// FIXME asc remove this catch after more testing has confirmed the\n\t\t\t// above stuff is OK\n\t\t\tthrow new BCException(\"Unexpectedly went bang when searching for annotations on \" + rm, t);\n\t\t}\n\t}\n\n\tprivate void matchInvokeInstruction(LazyMethodGen mg, InstructionHandle ih, InvokeInstruction invoke,\n\t\t\tBcelShadow enclosingShadow, List<BcelShadow> shadowAccumulator) {\n\t\tString methodName = invoke.getName(cpg);\n\t\tif (methodName.startsWith(NameMangler.PREFIX)) {\n\t\t\tMember jpSig = world.makeJoinPointSignatureForMethodInvocation(clazz, invoke);\n\t\t\tResolvedMember declaredSig = jpSig.resolve(world);\n\t\t\t// System.err.println(method + \", declaredSig: \" +declaredSig);\n\t\t\tif (declaredSig == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (declaredSig.getKind() == Member.FIELD) {\n\t\t\t\tShadow.Kind kind;\n\t\t\t\tif (jpSig.getReturnType().equals(UnresolvedType.VOID)) {\n\t\t\t\t\tkind = Shadow.FieldSet;\n\t\t\t\t} else {\n\t\t\t\t\tkind = Shadow.FieldGet;\n\t\t\t\t}\n\n\t\t\t\tif (canMatch(Shadow.FieldGet) || canMatch(Shadow.FieldSet)) {\n\t\t\t\t\tmatch(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow, kind, declaredSig), shadowAccumulator);\n\t\t\t\t}\n\t\t\t} else if (!declaredSig.getName().startsWith(NameMangler.PREFIX)) {\n\t\t\t\t// 307147 - resolution above may have found the real method directly rather\n\t\t\t\t// than needing to go through the effective signature attribute\n\t\t\t\tif (canMatch(Shadow.MethodCall)) {\n\t\t\t\t\tmatch(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow, Shadow.MethodCall, declaredSig),\n\t\t\t\t\t\t\tshadowAccumulator);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tAjAttribute.EffectiveSignatureAttribute effectiveSig = declaredSig.getEffectiveSignature();\n\t\t\t\tif (effectiveSig == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// System.err.println(\"call to inter-type member: \" +\n\t\t\t\t// effectiveSig);\n\t\t\t\tif (effectiveSig.isWeaveBody()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tResolvedMember rm = effectiveSig.getEffectiveSignature();\n\t\t\t\tfixParameterNamesForResolvedMember(rm, declaredSig);\n\t\t\t\tfixAnnotationsForResolvedMember(rm, declaredSig); // abracadabra\n\n\t\t\t\tif (canMatch(effectiveSig.getShadowKind())) {\n\t\t\t\t\tmatch(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow, effectiveSig.getShadowKind(), rm),\n\t\t\t\t\t\t\tshadowAccumulator);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (canMatch(Shadow.MethodCall)) {\n\t\t\t\tboolean proceed = true;\n\t\t\t\t// overweaving needs to ignore some calls added by the previous weave\n\t\t\t\tif (world.isOverWeaving()) {\n\t\t\t\t\tString s = invoke.getClassName(mg.getConstantPool());\n\t\t\t\t\t// skip all the inc/dec/isValid/etc\n\t\t\t\t\tif (s.length() > 4\n\t\t\t\t\t\t\t&& s.charAt(4) == 'a'\n\t\t\t\t\t\t\t&& (s.equals(\"org.aspectj.runtime.internal.CFlowCounter\")\n\t\t\t\t\t\t\t\t\t|| s.equals(\"org.aspectj.runtime.internal.CFlowStack\") || s\n\t\t\t\t\t\t\t\t\t.equals(\"org.aspectj.runtime.reflect.Factory\"))) {\n\t\t\t\t\t\tproceed = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (methodName.equals(\"aspectOf\")) {\n\t\t\t\t\t\t\tproceed = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (methodName.startsWith(SWITCH_TABLE_SYNTHETIC_METHOD_PREFIX)) {\n\t\t\t\t\tproceed = false;\n\t\t\t\t}\n\n\t\t\t\tif (proceed) {\n\t\t\t\t\tmatch(BcelShadow.makeMethodCall(world, mg, ih, enclosingShadow), shadowAccumulator);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// static ... so all worlds will share the config for the first one\n\t// created...\n\tprivate static boolean checkedXsetForLowLevelContextCapturing = false;\n\tprivate static boolean captureLowLevelContext = false;\n\n\tprivate boolean match(BcelShadow shadow, List<BcelShadow> shadowAccumulator) {\n\t\t// Duplicate blocks - one with context one without, seems faster than multiple 'ifs'\n\t\tif (captureLowLevelContext) {\n\t\t\tContextToken shadowMatchToken = CompilationAndWeavingContext.enteringPhase(\n\t\t\t\t\tCompilationAndWeavingContext.MATCHING_SHADOW, shadow);\n\t\t\tboolean isMatched = false;\n\n\t\t\tShadow.Kind shadowKind = shadow.getKind();\n\t\t\tList<ShadowMunger> candidateMungers = indexedShadowMungers[shadowKind.getKey()];\n\n\t\t\t// System.out.println(\"Candidates \" + candidateMungers);\n\t\t\tif (candidateMungers != null) {\n\t\t\t\tfor (ShadowMunger munger : candidateMungers) {\n\n\t\t\t\t\tContextToken mungerMatchToken = CompilationAndWeavingContext.enteringPhase(\n\t\t\t\t\t\t\tCompilationAndWeavingContext.MATCHING_POINTCUT, munger.getPointcut());\n\t\t\t\t\tif (munger.match(shadow, world)) {\n\t\t\t\t\t\tshadow.addMunger(munger);\n\t\t\t\t\t\tisMatched = true;\n\t\t\t\t\t\tif (shadow.getKind() == Shadow.StaticInitialization) {\n\t\t\t\t\t\t\tclazz.warnOnAddedStaticInitializer(shadow, munger.getSourceLocation());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tCompilationAndWeavingContext.leavingPhase(mungerMatchToken);\n\t\t\t\t}\n\n\t\t\t\tif (isMatched) {\n\t\t\t\t\tshadowAccumulator.add(shadow);\n\t\t\t\t}\n\t\t\t}\n\t\t\tCompilationAndWeavingContext.leavingPhase(shadowMatchToken);\n\t\t\treturn isMatched;\n\t\t} else {\n\t\t\tboolean isMatched = false;\n\n\t\t\tShadow.Kind shadowKind = shadow.getKind();\n\t\t\tList<ShadowMunger> candidateMungers = indexedShadowMungers[shadowKind.getKey()];\n\n\t\t\t// System.out.println(\"Candidates at \" + shadowKind + \" are \" + candidateMungers);\n\t\t\tif (candidateMungers != null) {\n\t\t\t\tfor (ShadowMunger munger : candidateMungers) {\n\t\t\t\t\tif (munger.match(shadow, world)) {\n\t\t\t\t\t\tshadow.addMunger(munger);\n\t\t\t\t\t\tisMatched = true;\n\t\t\t\t\t\tif (shadow.getKind() == Shadow.StaticInitialization) {\n\t\t\t\t\t\t\tclazz.warnOnAddedStaticInitializer(shadow, munger.getSourceLocation());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isMatched) {\n\t\t\t\t\tshadowAccumulator.add(shadow);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isMatched;\n\t\t}\n\t}\n\n\t// ----\n\n\tprivate void implement(LazyMethodGen mg) {\n\t\tList<BcelShadow> shadows = mg.matchedShadows;\n\t\tif (shadows == null) {\n\t\t\treturn;\n\t\t}\n\t\t// We depend on a partial order such that inner shadows are earlier on\n\t\t// the list than outer shadows. That's fine. This order is preserved if:\n\n\t\t// A preceeds B iff B.getStart() is LATER THAN A.getStart().\n\n\t\tfor (BcelShadow shadow : shadows) {\n\t\t\tContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.IMPLEMENTING_ON_SHADOW,\n\t\t\t\t\tshadow);\n\t\t\tshadow.implement();\n\t\t\tCompilationAndWeavingContext.leavingPhase(tok);\n\t\t}\n\t\t// int ii =\n\t\tmg.getMaxLocals();\n\t\tmg.matchedShadows = null;\n\t}\n\n\t// ----\n\n\tpublic LazyClassGen getLazyClassGen() {\n\t\treturn clazz;\n\t}\n\n\tpublic BcelWorld getWorld() {\n\t\treturn world;\n\t}\n\n\tpublic void setReweavableMode(boolean mode) {\n\t\tinReweavableMode = mode;\n\t}\n\n\tpublic boolean getReweavableMode() {\n\t\treturn inReweavableMode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"BcelClassWeaver instance for : \" + clazz;\n\t}\n\n}\n",
    "size": 134049
  },
  {
    "file_id": "F14",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelConstantPoolReader.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2010 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n * Andy Clement (SpringSource)\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.weaver.ConstantPoolReader;\n\n/**\n * An implementation of the constant pool reader that speaks Bcel.\n *\n * @author Andy Clement\n */\npublic class BcelConstantPoolReader implements ConstantPoolReader {\n\n\tprivate ConstantPool constantPool;\n\n\tpublic BcelConstantPoolReader(ConstantPool constantPool) {\n\t\tthis.constantPool = constantPool;\n\t}\n\n\tpublic String readUtf8(int cpIndex) {\n\t\treturn constantPool.getConstantUtf8(cpIndex).getValue();\n\t}\n\n}\n",
    "size": 1041
  },
  {
    "file_id": "F15",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelConstantPoolWriter.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2010 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n * Andy Clement (SpringSource)\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.weaver.ConstantPoolWriter;\n\n/**\n * An implementation of the constant pool writer that speaks Bcel.\n *\n * @author Andy Clement\n */\nclass BcelConstantPoolWriter implements ConstantPoolWriter {\n\n\tConstantPool pool;\n\n\tpublic BcelConstantPoolWriter(ConstantPool pool) {\n\t\tthis.pool = pool;\n\t}\n\n\tpublic int writeUtf8(String name) {\n\t\treturn pool.addUtf8(name);\n\t}\n\n}\n",
    "size": 962
  },
  {
    "file_id": "F16",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelField.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.util.List;\n\nimport org.aspectj.apache.bcel.classfile.Attribute;\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.apache.bcel.classfile.Field;\nimport org.aspectj.apache.bcel.classfile.Synthetic;\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.generic.FieldGen;\nimport org.aspectj.util.GenericSignature;\nimport org.aspectj.util.GenericSignatureParser;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjAttribute.WeaverVersionInfo;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.ISourceContext;\nimport org.aspectj.weaver.ResolvedMemberImpl;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.GenericSignatureFormatException;\n\n/**\n * An AspectJ Field object that is backed by a Bcel Field object.\n *\n * @author PARC\n * @author Andy Clement\n */\nfinal class BcelField extends ResolvedMemberImpl {\n\n\tpublic static int AccSynthetic = 0x1000;\n\n\tprivate Field field;\n\tprivate boolean isAjSynthetic;\n\tprivate boolean isSynthetic = false;\n\tprivate AnnotationAJ[] annotations;\n\tprivate final World world;\n\tprivate final BcelObjectType bcelObjectType;\n\tprivate UnresolvedType genericFieldType = null;\n\tprivate boolean unpackedGenericSignature = false;\n\tprivate boolean annotationsOnFieldObjectAreOutOfDate = false;\n\n\tBcelField(BcelObjectType declaringType, Field field) {\n\t\tsuper(FIELD, declaringType.getResolvedTypeX(), field.getModifiers(), field.getName(), field.getSignature());\n\t\tthis.field = field;\n\t\tthis.world = declaringType.getResolvedTypeX().getWorld();\n\t\tthis.bcelObjectType = declaringType;\n\t\tunpackAttributes(world);\n\t\tcheckedExceptions = UnresolvedType.NONE;\n\t}\n\n\t/**\n\t * Constructs an instance that wrappers a Field object, but where we do not (yet) have a BcelObjectType - usually because the\n\t * containing type (and this field) are being constructed at runtime (so there is no .class file to retrieve).\n\t */\n\tBcelField(String declaringTypeName, Field field, World world) {\n\t\tsuper(FIELD, UnresolvedType.forName(declaringTypeName), field.getModifiers(), field.getName(), field.getSignature());\n\t\tthis.field = field;\n\t\tthis.world = world;\n\t\tthis.bcelObjectType = null;\n\t\tunpackAttributes(world);\n\t\tcheckedExceptions = UnresolvedType.NONE;\n\t}\n\n\tprivate void unpackAttributes(World world) {\n\t\tAttribute[] attrs = field.getAttributes();\n\t\tif (attrs != null && attrs.length > 0) {\n\t\t\tISourceContext sourceContext = getSourceContext(world);\n\t\t\tList<AjAttribute> as = Utility.readAjAttributes(getDeclaringType().getClassName(), attrs, sourceContext, world,\n\t\t\t\t\t(bcelObjectType != null ? bcelObjectType.getWeaverVersionAttribute() : WeaverVersionInfo.CURRENT),\n\t\t\t\t\tnew BcelConstantPoolReader(field.getConstantPool()));\n\t\t\tas.addAll(AtAjAttributes.readAj5FieldAttributes(field, this, world.resolve(getDeclaringType()), sourceContext,\n\t\t\t\t\tworld.getMessageHandler()));\n\n\t\t\t// FIXME this code has no effect!!!??? it is set to false immediately after the block\n\t\t\t// for (AjAttribute a : as) {\n\t\t\t// if (a instanceof AjAttribute.AjSynthetic) {\n\t\t\t// isAjSynthetic = true;\n\t\t\t// } else {\n\t\t\t// throw new BCException(\"weird field attribute \" + a);\n\t\t\t// }\n\t\t\t// }\n\t\t}\n\t\tisAjSynthetic = false;\n\n\t\tfor (int i = attrs.length - 1; i >= 0; i--) {\n\t\t\tif (attrs[i] instanceof Synthetic) {\n\t\t\t\tisSynthetic = true;\n\t\t\t}\n\t\t}\n\t\t// in 1.5, synthetic is a modifier, not an attribute\n\t\tif ((field.getModifiers() & AccSynthetic) != 0) {\n\t\t\tisSynthetic = true;\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic boolean isAjSynthetic() {\n\t\treturn isAjSynthetic;\n\t}\n\n\t@Override\n\tpublic boolean isSynthetic() {\n\t\treturn isSynthetic;\n\t}\n\n\t@Override\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\n\t\tensureAnnotationTypesRetrieved();\n\t\tfor (ResolvedType aType : annotationTypes) {\n\t\t\tif (aType.equals(ofType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic ResolvedType[] getAnnotationTypes() {\n\t\tensureAnnotationTypesRetrieved();\n\t\treturn annotationTypes;\n\t}\n\n\t@Override\n\tpublic AnnotationAJ[] getAnnotations() {\n\t\tensureAnnotationTypesRetrieved();\n\t\treturn annotations;\n\t}\n\n\t@Override\n\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {\n\t\tensureAnnotationTypesRetrieved();\n\t\tfor (AnnotationAJ annotation : annotations) {\n\t\t\tif (annotation.getTypeName().equals(ofType.getName())) {\n\t\t\t\treturn annotation;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void ensureAnnotationTypesRetrieved() {\n\t\tif (annotationTypes == null) {\n\t\t\tAnnotationGen annos[] = field.getAnnotations();\n\t\t\tif (annos.length == 0) {\n\t\t\t\tannotationTypes = ResolvedType.EMPTY_ARRAY;\n\t\t\t\tannotations = AnnotationAJ.EMPTY_ARRAY;\n\t\t\t} else {\n\t\t\t\tint annosCount = annos.length;\n\t\t\t\tannotationTypes = new ResolvedType[annosCount];\n\t\t\t\tannotations = new AnnotationAJ[annosCount];\n\t\t\t\tfor (int i = 0; i < annosCount; i++) {\n\t\t\t\t\tAnnotationGen anno = annos[i];\n\t\t\t\t\tannotations[i] = new BcelAnnotation(anno, world);\n\t\t\t\t\tannotationTypes[i] = annotations[i].getType();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addAnnotation(AnnotationAJ annotation) {\n\t\tensureAnnotationTypesRetrieved();\n\t\tint len = annotations.length;\n\t\tAnnotationAJ[] ret = new AnnotationAJ[len + 1];\n\t\tSystem.arraycopy(annotations, 0, ret, 0, len);\n\t\tret[len] = annotation;\n\t\tannotations = ret;\n\n\t\tResolvedType[] newAnnotationTypes = new ResolvedType[len + 1];\n\t\tSystem.arraycopy(annotationTypes, 0, newAnnotationTypes, 0, len);\n\t\tnewAnnotationTypes[len] = annotation.getType();\n\t\tannotationTypes = newAnnotationTypes;\n\n\t\tannotationsOnFieldObjectAreOutOfDate = true;\n\t}\n\n\tpublic void removeAnnotation(AnnotationAJ annotation) {\n\t\tensureAnnotationTypesRetrieved();\n\n\t\tint len = annotations.length;\n\t\tAnnotationAJ[] ret = new AnnotationAJ[len - 1];\n\t\tint p = 0;\n\t\tfor (AnnotationAJ anno : annotations) {\n\t\t\tif (!anno.getType().equals(annotation.getType())) {\n\t\t\t\tret[p++] = anno;\n\t\t\t}\n\t\t}\n\t\tannotations = ret;\n\n\t\tResolvedType[] newAnnotationTypes = new ResolvedType[len - 1];\n\t\tp = 0;\n\t\tfor (ResolvedType anno : annotationTypes) {\n\t\t\tif (!anno.equals(annotation.getType())) {\n\t\t\t\tnewAnnotationTypes[p++] = anno;\n\t\t\t}\n\t\t}\n\t\tannotationTypes = newAnnotationTypes;\n\n\t\tannotationsOnFieldObjectAreOutOfDate = true;\n\t}\n\n\t/**\n\t * Unpack the generic signature attribute if there is one and we haven't already done so, then find the true field type of this\n\t * field (eg. List<String>).\n\t */\n\t@Override\n\tpublic UnresolvedType getGenericReturnType() {\n\t\tunpackGenericSignature();\n\t\treturn genericFieldType;\n\t}\n\n\tpublic Field getFieldAsIs() {\n\t\treturn field;\n\t}\n\n\tpublic Field getField(ConstantPool cpool) {\n\t\tif (!annotationsOnFieldObjectAreOutOfDate) {\n\t\t\treturn field;\n\t\t}\n\t\tFieldGen newFieldGen = new FieldGen(field, cpool);\n\t\tnewFieldGen.removeAnnotations();\n\t\t// List<AnnotationGen> alreadyHas = fg.getAnnotations();\n\t\t// if (annotations != null) {\n\t\t// fg.removeAnnotations();\n\t\tfor (AnnotationAJ annotation : annotations) {\n\t\t\tnewFieldGen.addAnnotation(new AnnotationGen(((BcelAnnotation) annotation).getBcelAnnotation(), cpool, true));\n\t\t}\n\t\t// for (int i = 0; i < annotations.length; i++) {\n\t\t// AnnotationAJ array_element = annotations[i];\n\t\t// boolean alreadyHasIt = false;\n\t\t// for (AnnotationGen gen : alreadyHas) {\n\t\t// if (gen.getTypeName().equals(array_element.getTypeName())) {\n\t\t// alreadyHasIt = true;\n\t\t// break;\n\t\t// }\n\t\t// }\n\t\t// if (!alreadyHasIt) {\n\t\t// fg.addAnnotation(new AnnotationGen(((BcelAnnotation) array_element).getBcelAnnotation(), cpg, true));\n\t\t// // }\n\t\t// // }\n\t\t// }\n\t\tfield = newFieldGen.getField();\n\t\tannotationsOnFieldObjectAreOutOfDate = false; // we are now correct again\n\t\treturn field;\n\t}\n\n\tprivate void unpackGenericSignature() {\n\t\tif (unpackedGenericSignature) {\n\t\t\treturn;\n\t\t}\n\t\tif (!world.isInJava5Mode()) {\n\t\t\tthis.genericFieldType = getReturnType();\n\t\t\treturn;\n\t\t}\n\t\tunpackedGenericSignature = true;\n\t\tString gSig = field.getGenericSignature();\n\t\tif (gSig != null) {\n\t\t\t// get from generic\n\t\t\tGenericSignature.FieldTypeSignature fts = new GenericSignatureParser().parseAsFieldSignature(gSig);\n\t\t\tGenericSignature.ClassSignature genericTypeSig = bcelObjectType.getGenericClassTypeSignature();\n\n\t\t\tGenericSignature.FormalTypeParameter[] parentFormals = bcelObjectType.getAllFormals();\n\t\t\tGenericSignature.FormalTypeParameter[] typeVars = ((genericTypeSig == null) ? GenericSignature.FormalTypeParameter.NONE\n\t\t\t\t\t: genericTypeSig.formalTypeParameters);\n\t\t\tGenericSignature.FormalTypeParameter[] formals = new GenericSignature.FormalTypeParameter[parentFormals.length\n\t\t\t\t\t+ typeVars.length];\n\t\t\t// put method formal in front of type formals for overriding in\n\t\t\t// lookup\n\t\t\tSystem.arraycopy(typeVars, 0, formals, 0, typeVars.length);\n\t\t\tSystem.arraycopy(parentFormals, 0, formals, typeVars.length, parentFormals.length);\n\n\t\t\ttry {\n\t\t\t\tgenericFieldType = BcelGenericSignatureToTypeXConverter.fieldTypeSignature2TypeX(fts, formals, world);\n\t\t\t} catch (GenericSignatureFormatException e) {\n\t\t\t\t// development bug, fail fast with good info\n\t\t\t\tthrow new IllegalStateException(\"While determing the generic field type of \" + this.toString()\n\t\t\t\t\t\t+ \" with generic signature \" + gSig + \" the following error was detected: \" + e.getMessage());\n\t\t\t}\n\t\t} else {\n\t\t\tgenericFieldType = getReturnType();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void evictWeavingState() {\n\t\tif (field != null) {\n\t\t\tunpackGenericSignature();\n\t\t\tunpackAttributes(world);\n\t\t\tensureAnnotationTypesRetrieved();\n\t\t\t// this.sourceContext = SourceContextImpl.UNKNOWN_SOURCE_CONTEXT;\n\t\t\tfield = null;\n\t\t}\n\t}\n}\n",
    "size": 10134
  },
  {
    "file_id": "F17",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelFieldRef.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.weaver.ResolvedType;\n\n/**\n * XXX Erik and I need to discuss this hierarchy. Having FieldRef extend Var is convenient, but hopefully there's a better design.\n *\n * This is always a static reference.\n */\npublic class BcelFieldRef extends BcelVar {\n\n\tprivate String className, fieldName;\n\n\tpublic BcelFieldRef(ResolvedType type, String className, String fieldName) {\n\t\tsuper(type, 0);\n\t\tthis.className = className;\n\t\tthis.fieldName = fieldName;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"BcelFieldRef(\" + getType() + \" \" + className + \".\" + fieldName + \")\";\n\t}\n\n\t// public int getSlot() { return slot; }\n\n\tpublic Instruction createLoad(InstructionFactory fact) {\n\t\treturn fact.createFieldAccess(className, fieldName, BcelWorld.makeBcelType(getType()), Constants.GETSTATIC);\n\t}\n\n\tpublic Instruction createStore(InstructionFactory fact) {\n\t\treturn fact.createFieldAccess(className, fieldName, BcelWorld.makeBcelType(getType()), Constants.PUTSTATIC);\n\t}\n\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\t// this is an array var\n\t// void appendConvertableArrayLoad(\n\t// InstructionList il,\n\t// InstructionFactory fact,\n\t// int index,\n\t// ResolvedType convertTo)\n\t// {\n\t// ResolvedType convertFromType = getType().getResolvedComponentType();\n\t// appendLoad(il, fact);\n\t// il.append(Utility.createConstant(fact, index));\n\t// il.append(fact.createArrayLoad(BcelWorld.makeBcelType(convertFromType)));\n\t// Utility.appendConversion(il, fact, convertFromType, convertTo);\n\t// }\n\t//\n\t// void appendConvertableArrayStore(\n\t// InstructionList il,\n\t// InstructionFactory fact,\n\t// int index,\n\t// BcelFieldRef storee)\n\t// {\n\t// ResolvedType convertToType = getType().getResolvedComponentType();\n\t// appendLoad(il, fact);\n\t// il.append(Utility.createConstant(fact, index));\n\t// storee.appendLoad(il, fact);\n\t// Utility.appendConversion(il, fact, storee.getType(), convertToType);\n\t// il.append(fact.createArrayStore(BcelWorld.makeBcelType(convertToType)));\n\t// }\n\t//\n\t// InstructionList createConvertableArrayStore(\n\t// InstructionFactory fact,\n\t// int index,\n\t// BcelFieldRef storee)\n\t// {\n\t// InstructionList il = new InstructionList();\n\t// appendConvertableArrayStore(il, fact, index, storee);\n\t// return il;\n\t// }\n\t// InstructionList createConvertableArrayLoad(\n\t// InstructionFactory fact,\n\t// int index,\n\t// ResolvedType convertTo)\n\t// {\n\t// InstructionList il = new InstructionList();\n\t// appendConvertableArrayLoad(il, fact, index, convertTo);\n\t// return il;\n\t// }\n}\n",
    "size": 3335
  },
  {
    "file_id": "F18",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.aspectj.util.GenericSignature;\nimport org.aspectj.util.GenericSignature.SimpleClassTypeSignature;\nimport org.aspectj.weaver.BoundedReferenceType;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.TypeFactory;\nimport org.aspectj.weaver.TypeVariable;\nimport org.aspectj.weaver.TypeVariableReferenceType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.tools.Trace;\nimport org.aspectj.weaver.tools.TraceFactory;\n\n/**\n * A utility class that assists in unpacking constituent parts of generic signature attributes and returning their equivalents in\n * UnresolvedType world.\n */\npublic class BcelGenericSignatureToTypeXConverter {\n\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelGenericSignatureToTypeXConverter.class);\n\n\tpublic static ResolvedType classTypeSignature2TypeX(GenericSignature.ClassTypeSignature aClassTypeSignature,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world) throws GenericSignatureFormatException {\n\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> typeMap = new HashMap<>();\n\t\tResolvedType ret = classTypeSignature2TypeX(aClassTypeSignature, typeParams, world, typeMap);\n\t\tfixUpCircularDependencies(ret, typeMap);\n\t\treturn ret;\n\t}\n\n\tprivate static ResolvedType classTypeSignature2TypeX(GenericSignature.ClassTypeSignature aClassTypeSignature,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)\n\t\t\tthrows GenericSignatureFormatException {\n\t\t// class type sig consists of an outer type, and zero or more nested types\n\t\t// the fully qualified name is outer-type.nested-type1.nested-type2....\n\t\t// each type in the hierarchy may have type arguments\n\n\t\t// first build the 'raw type' signature\n\t\tStringBuilder sig = new StringBuilder();\n\t\tsig.append(aClassTypeSignature.outerType.identifier.replace(';', ' ').trim());\n\t\tfor (int i = 0; i < aClassTypeSignature.nestedTypes.length; i++) {\n\t\t\tsig.append(\"$\");\n\t\t\tsig.append(aClassTypeSignature.nestedTypes[i].identifier.replace(';', ' ').trim());\n\t\t}\n\t\tsig.append(\";\");\n\n\t\t// now look for any type parameters.\n\t\t// I *think* we only need to worry about the 'right-most' type...\n\t\tSimpleClassTypeSignature innerType = aClassTypeSignature.outerType;\n\t\tif (aClassTypeSignature.nestedTypes.length > 0) {\n\t\t\tinnerType = aClassTypeSignature.nestedTypes[aClassTypeSignature.nestedTypes.length - 1];\n\t\t}\n\t\tif (innerType.typeArguments.length > 0) {\n\t\t\t// we have to create a parameterized type\n\t\t\t// type arguments may be array types, class types, or typevariable types\n\t\t\tResolvedType theBaseType = UnresolvedType.forSignature(sig.toString()).resolve(world);\n\n\t\t\t// Sometimes we may find that when the code is being load-time woven that the types have changed.\n\t\t\t// Perhaps an old form of a library jar is being used - this can mean we discover right here\n\t\t\t// that a type is not parameterizable (is that a word?). I think in these cases it is ok to\n\t\t\t// just return with what we know (the base type). (see pr152848)\n\t\t\tif (!(theBaseType.isGenericType() || theBaseType.isRawType())) {\n\t\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\t\ttrace.event(\"classTypeSignature2TypeX: this type is not a generic type:\", null, new Object[] { theBaseType });\n\t\t\t\t}\n\t\t\t\treturn theBaseType;\n\t\t\t}\n\n\t\t\tResolvedType[] typeArgumentTypes = new ResolvedType[innerType.typeArguments.length];\n\t\t\tfor (int i = 0; i < typeArgumentTypes.length; i++) {\n\t\t\t\ttypeArgumentTypes[i] = typeArgument2TypeX(innerType.typeArguments[i], typeParams, world,\n\t\t\t\t\t\tinProgressTypeVariableResolutions);\n\t\t\t}\n\t\t\treturn TypeFactory.createParameterizedType(theBaseType, typeArgumentTypes, world);\n\n\t\t\t// world.resolve(UnresolvedType.forParameterizedTypes(\n\t\t\t// UnresolvedType.forSignature(sig.toString()).resolve(world),\n\t\t\t// typeArgumentTypes));\n\t\t} else {\n\t\t\t// we have a non-parameterized type\n\t\t\treturn world.resolve(UnresolvedType.forSignature(sig.toString()));\n\t\t}\n\t}\n\n\tpublic static ResolvedType fieldTypeSignature2TypeX(GenericSignature.FieldTypeSignature aFieldTypeSignature,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world) throws GenericSignatureFormatException {\n\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> typeMap = new HashMap<>();\n\t\tResolvedType ret = fieldTypeSignature2TypeX(aFieldTypeSignature, typeParams, world, typeMap);\n\t\tfixUpCircularDependencies(ret, typeMap);\n\t\treturn ret;\n\t}\n\n\tprivate static ResolvedType fieldTypeSignature2TypeX(GenericSignature.FieldTypeSignature aFieldTypeSignature,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)\n\t\t\tthrows GenericSignatureFormatException {\n\t\tif (aFieldTypeSignature.isClassTypeSignature()) {\n\t\t\treturn classTypeSignature2TypeX((GenericSignature.ClassTypeSignature) aFieldTypeSignature, typeParams, world,\n\t\t\t\t\tinProgressTypeVariableResolutions);\n\t\t} else if (aFieldTypeSignature.isArrayTypeSignature()) {\n\t\t\tint dims = 0;\n\t\t\tGenericSignature.TypeSignature ats = aFieldTypeSignature;\n\t\t\twhile (ats instanceof GenericSignature.ArrayTypeSignature) {\n\t\t\t\tdims++;\n\t\t\t\tats = ((GenericSignature.ArrayTypeSignature) ats).typeSig;\n\t\t\t}\n\t\t\treturn world.resolve(UnresolvedType.makeArray(\n\t\t\t\t\ttypeSignature2TypeX(ats, typeParams, world, inProgressTypeVariableResolutions), dims));\n\t\t} else if (aFieldTypeSignature.isTypeVariableSignature()) {\n\t\t\tResolvedType rtx = typeVariableSignature2TypeX((GenericSignature.TypeVariableSignature) aFieldTypeSignature,\n\t\t\t\t\ttypeParams, world, inProgressTypeVariableResolutions);\n\t\t\treturn rtx;\n\t\t} else {\n\t\t\tthrow new GenericSignatureFormatException(\"Cant understand field type signature: \" + aFieldTypeSignature);\n\t\t}\n\t}\n\n\tpublic static TypeVariable formalTypeParameter2TypeVariable(GenericSignature.FormalTypeParameter aFormalTypeParameter,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world) throws GenericSignatureFormatException {\n\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> typeMap = new HashMap<>();\n\t\treturn formalTypeParameter2TypeVariable(aFormalTypeParameter, typeParams, world, typeMap);\n\t}\n\n\tprivate static TypeVariable formalTypeParameter2TypeVariable(GenericSignature.FormalTypeParameter aFormalTypeParameter,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)\n\t\t\tthrows GenericSignatureFormatException {\n\t\tUnresolvedType upperBound = fieldTypeSignature2TypeX(aFormalTypeParameter.classBound, typeParams, world,\n\t\t\t\tinProgressTypeVariableResolutions);\n\t\tUnresolvedType[] ifBounds = new UnresolvedType[aFormalTypeParameter.interfaceBounds.length];\n\t\tfor (int i = 0; i < ifBounds.length; i++) {\n\t\t\tifBounds[i] = fieldTypeSignature2TypeX(aFormalTypeParameter.interfaceBounds[i], typeParams, world,\n\t\t\t\t\tinProgressTypeVariableResolutions);\n\t\t}\n\t\treturn new TypeVariable(aFormalTypeParameter.identifier, upperBound, ifBounds);\n\t}\n\n\tprivate static ResolvedType typeArgument2TypeX(GenericSignature.TypeArgument aTypeArgument,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)\n\t\t\tthrows GenericSignatureFormatException {\n\t\tif (aTypeArgument.isWildcard) {\n\t\t\treturn UnresolvedType.SOMETHING.resolve(world);\n\t\t}\n\t\tif (aTypeArgument.isMinus) {\n\t\t\tUnresolvedType bound = fieldTypeSignature2TypeX(aTypeArgument.signature, typeParams, world,\n\t\t\t\t\tinProgressTypeVariableResolutions);\n\t\t\tResolvedType resolvedBound = world.resolve(bound);\n\t\t\tif (resolvedBound.isMissing()) {\n\t\t\t\tworld.getLint().cantFindType.signal(\"Unable to find type (for bound): \" + resolvedBound.getName(), null);\n\t\t\t\tresolvedBound = world.resolve(UnresolvedType.OBJECT);\n\t\t\t}\n\t\t\tReferenceType rBound = (ReferenceType) resolvedBound;\n\t\t\treturn new BoundedReferenceType(rBound, false, world);\n\t\t} else if (aTypeArgument.isPlus) {\n\t\t\tUnresolvedType bound = fieldTypeSignature2TypeX(aTypeArgument.signature, typeParams, world,\n\t\t\t\t\tinProgressTypeVariableResolutions);\n\t\t\tResolvedType resolvedBound = world.resolve(bound);\n\t\t\tif (resolvedBound.isMissing()) {\n\t\t\t\tworld.getLint().cantFindType.signal(\"Unable to find type (for bound): \" + resolvedBound.getName(), null);\n\t\t\t\tresolvedBound = world.resolve(UnresolvedType.OBJECT);\n\t\t\t}\n\t\t\tReferenceType rBound = (ReferenceType) resolvedBound;\n\t\t\treturn new BoundedReferenceType(rBound, true, world);\n\t\t} else {\n\t\t\treturn fieldTypeSignature2TypeX(aTypeArgument.signature, typeParams, world, inProgressTypeVariableResolutions);\n\t\t}\n\t}\n\n\tpublic static ResolvedType typeSignature2TypeX(GenericSignature.TypeSignature aTypeSig,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world) throws GenericSignatureFormatException {\n\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> typeMap = new HashMap<>();\n\t\tResolvedType ret = typeSignature2TypeX(aTypeSig, typeParams, world, typeMap);\n\t\tfixUpCircularDependencies(ret, typeMap);\n\t\treturn ret;\n\t}\n\n\tprivate static ResolvedType typeSignature2TypeX(GenericSignature.TypeSignature aTypeSig,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)\n\t\t\tthrows GenericSignatureFormatException {\n\t\tif (aTypeSig.isBaseType()) {\n\t\t\treturn world.resolve(UnresolvedType.forSignature(((GenericSignature.BaseTypeSignature) aTypeSig).toString()));\n\t\t} else {\n\t\t\treturn fieldTypeSignature2TypeX((GenericSignature.FieldTypeSignature) aTypeSig, typeParams, world,\n\t\t\t\t\tinProgressTypeVariableResolutions);\n\t\t}\n\t}\n\n\tprivate static ResolvedType typeVariableSignature2TypeX(GenericSignature.TypeVariableSignature aTypeVarSig,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)\n\t\t\tthrows GenericSignatureFormatException {\n\t\tGenericSignature.FormalTypeParameter typeVarBounds = null;\n\t\tfor (GenericSignature.FormalTypeParameter typeParam : typeParams) {\n\t\t\tif (typeParam.identifier.equals(aTypeVarSig.typeVariableName)) {\n\t\t\t\ttypeVarBounds = typeParam;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (typeVarBounds == null) {\n\t\t\t// blowing up here breaks the situation with ITDs where the type variable is mentioned in the\n\t\t\t// declaring type and used somewhere in the signature. Temporary change to allow it to return just a\n\t\t\t// 'dumb' typevariablereference.\n\t\t\treturn new TypeVariableReferenceType(new TypeVariable(aTypeVarSig.typeVariableName), world);\n\t\t\t// throw new GenericSignatureFormatException(\"Undeclared type variable in signature: \" + aTypeVarSig.typeVariableName);\n\t\t}\n\t\tif (inProgressTypeVariableResolutions.containsKey(typeVarBounds)) {\n\t\t\treturn inProgressTypeVariableResolutions.get(typeVarBounds);\n\t\t}\n\t\tinProgressTypeVariableResolutions.put(typeVarBounds, new FTPHolder(typeVarBounds, world));\n\t\tReferenceType ret = new TypeVariableReferenceType(formalTypeParameter2TypeVariable(typeVarBounds, typeParams, world,\n\t\t\t\tinProgressTypeVariableResolutions), world);\n\t\tinProgressTypeVariableResolutions.put(typeVarBounds, ret);\n\t\treturn ret;\n\t}\n\n\tprivate static void fixUpCircularDependencies(ResolvedType aTypeX,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> typeVariableResolutions) {\n\t\tif (!(aTypeX instanceof ReferenceType)) {\n\t\t\treturn;\n\t\t}\n\n\t\tReferenceType rt = (ReferenceType) aTypeX;\n\t\tTypeVariable[] typeVars = rt.getTypeVariables();\n\t\tif (typeVars != null) {\n\t\t\tfor (TypeVariable typeVar : typeVars) {\n\t\t\t\tif (typeVar.getUpperBound() instanceof FTPHolder) {\n\t\t\t\t\tGenericSignature.FormalTypeParameter key = ((FTPHolder) typeVar.getUpperBound()).ftpToBeSubstituted;\n\t\t\t\t\ttypeVar.setUpperBound(typeVariableResolutions.get(key));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class FTPHolder extends ReferenceType {\n\t\tpublic GenericSignature.FormalTypeParameter ftpToBeSubstituted;\n\n\t\tpublic FTPHolder(GenericSignature.FormalTypeParameter ftp, World world) {\n\t\t\tsuper(\"Ljava/lang/Object;\", world);\n\t\t\tthis.ftpToBeSubstituted = ftp;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"placeholder for TypeVariable of \" + ftpToBeSubstituted.toString();\n\t\t}\n\n\t\tpublic ResolvedType resolve(World world) {\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic boolean isCacheable() {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static class GenericSignatureFormatException extends Exception {\n\t\tpublic GenericSignatureFormatException(String explanation) {\n\t\t\tsuper(explanation);\n\t\t}\n\t}\n}\n",
    "size": 13176
  },
  {
    "file_id": "F19",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelMethod.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\nimport org.aspectj.apache.bcel.classfile.AnnotationDefault;\nimport org.aspectj.apache.bcel.classfile.Attribute;\nimport org.aspectj.apache.bcel.classfile.ExceptionTable;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.apache.bcel.classfile.LineNumber;\nimport org.aspectj.apache.bcel.classfile.LineNumberTable;\nimport org.aspectj.apache.bcel.classfile.LocalVariable;\nimport org.aspectj.apache.bcel.classfile.LocalVariableTable;\nimport org.aspectj.apache.bcel.classfile.Method;\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.classfile.annotation.NameValuePair;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.bridge.SourceLocation;\nimport org.aspectj.util.GenericSignature;\nimport org.aspectj.util.GenericSignature.TypeVariableSignature;\nimport org.aspectj.util.GenericSignatureParser;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjAttribute.WeaverVersionInfo;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.ISourceContext;\nimport org.aspectj.weaver.MemberKind;\nimport org.aspectj.weaver.ResolvedMemberImpl;\nimport org.aspectj.weaver.ResolvedPointcutDefinition;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.TypeVariable;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.GenericSignatureFormatException;\n\n//public final\nclass BcelMethod extends ResolvedMemberImpl {\n\n  private final static String ASPECTJ_ANNOTATION_PACKAGE = \"org.aspectj.lang.annotation\";\n  private final static char PACKAGE_INITIAL_CHAR = ASPECTJ_ANNOTATION_PACKAGE.charAt(0);\n\n\tprivate Method method;\n\n\t// these fields are not set for many BcelMethods...\n\tprivate ShadowMunger associatedShadowMunger;\n\tprivate ResolvedPointcutDefinition preResolvedPointcut; // used when ajc has pre-resolved the pointcut of some @Advice\n\tprivate AjAttribute.EffectiveSignatureAttribute effectiveSignature;\n\n\tprivate AjAttribute.MethodDeclarationLineNumberAttribute declarationLineNumber;\n\tprivate final BcelObjectType bcelObjectType;\n\n\tprivate int bitflags;\n\tprivate static final int KNOW_IF_SYNTHETIC = 0x0001;\n\tprivate static final int PARAMETER_NAMES_INITIALIZED = 0x0002;\n\tprivate static final int CAN_BE_PARAMETERIZED = 0x0004;\n\tprivate static final int UNPACKED_GENERIC_SIGNATURE = 0x0008;\n\tprivate static final int IS_AJ_SYNTHETIC = 0x0040;\n\tprivate static final int IS_SYNTHETIC = 0x0080;\n\tprivate static final int IS_SYNTHETIC_INVERSE = 0x7f7f; // all bits but\n\t// IS_SYNTHETIC (and\n\t// topmost bit)\n\tprivate static final int HAS_ANNOTATIONS = 0x0400;\n\tprivate static final int HAVE_DETERMINED_ANNOTATIONS = 0x0800;\n\n\t// genericized version of return and parameter types\n\tprivate UnresolvedType genericReturnType = null;\n\tprivate UnresolvedType[] genericParameterTypes = null;\n\n\tBcelMethod(BcelObjectType declaringType, Method method) {\n\t\tsuper(method.getName().equals(\"<init>\") ? CONSTRUCTOR : (method.getName().equals(\"<clinit>\") ? STATIC_INITIALIZATION\n\t\t\t\t: METHOD), declaringType.getResolvedTypeX(), method.getModifiers(), method.getName(), method.getSignature());\n\t\tthis.method = method;\n\t\tsourceContext = declaringType.getResolvedTypeX().getSourceContext();\n\t\tbcelObjectType = declaringType;\n\t\tunpackJavaAttributes();\n\t\tunpackAjAttributes(bcelObjectType.getWorld());\n\t}\n\n\t/**\n\t * This constructor expects to be passed the attributes, rather than deserializing them.\n\t */\n\tBcelMethod(BcelObjectType declaringType, Method method, List<AjAttribute> attributes) {\n\t\tsuper(method.getName().equals(\"<init>\") ? CONSTRUCTOR : (method.getName().equals(\"<clinit>\") ? STATIC_INITIALIZATION\n\t\t\t\t: METHOD), declaringType.getResolvedTypeX(), method.getModifiers(), method.getName(), method.getSignature());\n\t\tthis.method = method;\n\t\tsourceContext = declaringType.getResolvedTypeX().getSourceContext();\n\t\tbcelObjectType = declaringType;\n\t\tunpackJavaAttributes();\n\t\tprocessAttributes(bcelObjectType.getWorld(), attributes);\n\t}\n\n\t// ----\n\n\tprivate void unpackJavaAttributes() {\n\t\tExceptionTable exnTable = method.getExceptionTable();\n\t\tcheckedExceptions = (exnTable == null) ? UnresolvedType.NONE : UnresolvedType.forNames(exnTable.getExceptionNames());\n\t}\n\n\t@Override\n\tpublic String[] getParameterNames() {\n\t\tdetermineParameterNames();\n\t\treturn super.getParameterNames();\n\t}\n\n\tpublic int getLineNumberOfFirstInstruction() {\n\t\tLineNumberTable lnt = method.getLineNumberTable();\n\t\tif (lnt == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tLineNumber[] lns = lnt.getLineNumberTable();\n\t\tif (lns == null || lns.length == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn lns[0].getLineNumber();\n\t}\n\n\tpublic void determineParameterNames() {\n\t\tif ((bitflags & PARAMETER_NAMES_INITIALIZED) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tbitflags |= PARAMETER_NAMES_INITIALIZED;\n\t\tLocalVariableTable varTable = method.getLocalVariableTable();\n\t\tint len = getArity();\n\t\tif (varTable == null) {\n\t\t\t// do we have an annotation with the argNames value specified...\n\t\t\tAnnotationAJ[] annos = getAnnotations();\n\t\t\tif (annos != null && annos.length != 0) {\n\t\t\t\tAnnotationAJ[] axs = getAnnotations();\n\t\t\t\tfor (AnnotationAJ annotationX : axs) {\n\t\t\t\t\tString typename = annotationX.getTypeName();\n\t\t\t\t\tif (typename.charAt(0) == PACKAGE_INITIAL_CHAR) {\n\t\t\t\t\t\tif (typename.equals(\"org.aspectj.lang.annotation.Pointcut\")\n\t\t\t\t\t\t\t\t|| typename.equals(\"org.aspectj.lang.annotation.Before\")\n\t\t\t\t\t\t\t\t|| typename.equals(\"org.aspectj.lang.annotation.Around\")\n\t\t\t\t\t\t\t\t|| typename.startsWith(\"org.aspectj.lang.annotation.After\")) {\n\t\t\t\t\t\t\tAnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();\n\t\t\t\t\t\t\tif (a != null) {\n\t\t\t\t\t\t\t\tList<NameValuePair> values = a.getValues();\n\t\t\t\t\t\t\t\tfor (NameValuePair nvPair : values) {\n\t\t\t\t\t\t\t\t\tif (nvPair.getNameString().equals(\"argNames\")) {\n\t\t\t\t\t\t\t\t\t\tString argNames = nvPair.getValue().stringifyValue();\n\t\t\t\t\t\t\t\t\t\tStringTokenizer argNameTokenizer = new StringTokenizer(argNames, \" ,\");\n\t\t\t\t\t\t\t\t\t\tList<String> argsList = new ArrayList<>();\n\t\t\t\t\t\t\t\t\t\twhile (argNameTokenizer.hasMoreTokens()) {\n\t\t\t\t\t\t\t\t\t\t\targsList.add(argNameTokenizer.nextToken());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tint requiredCount = getParameterTypes().length;\n\t\t\t\t\t\t\t\t\t\twhile (argsList.size() < requiredCount) {\n\t\t\t\t\t\t\t\t\t\t\targsList.add(\"arg\" + argsList.size());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tsetParameterNames(argsList.toArray(new String[]{}));\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetParameterNames(Utility.makeArgNames(len));\n\t\t} else {\n\t\t\tUnresolvedType[] paramTypes = getParameterTypes();\n\t\t\tString[] paramNames = new String[len];\n\t\t\tint index = Modifier.isStatic(modifiers) ? 0 : 1;\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tLocalVariable lv = varTable.getLocalVariable(index);\n\t\t\t\tif (lv == null) {\n\t\t\t\t\tparamNames[i] = \"arg\" + i;\n\t\t\t\t} else {\n\t\t\t\t\tparamNames[i] = lv.getName();\n\t\t\t\t}\n\t\t\t\tindex += paramTypes[i].getSize();\n\t\t\t}\n\t\t\tsetParameterNames(paramNames);\n\t\t}\n\t}\n\n\tprivate void unpackAjAttributes(World world) {\n\t\tassociatedShadowMunger = null;\n\t\tResolvedType resolvedDeclaringType = getDeclaringType().resolve(world);\n\t\tWeaverVersionInfo wvinfo = bcelObjectType.getWeaverVersionAttribute();\n\t\tList<AjAttribute> as = Utility.readAjAttributes(resolvedDeclaringType.getClassName(), method.getAttributes(),\n\t\t\t\tresolvedDeclaringType.getSourceContext(), world, wvinfo, new BcelConstantPoolReader(method.getConstantPool()));\n\t\tprocessAttributes(world, as);\n\t\tas = AtAjAttributes.readAj5MethodAttributes(method, this, resolvedDeclaringType, preResolvedPointcut,\n\t\t\t\tresolvedDeclaringType.getSourceContext(), world.getMessageHandler());\n\t\tprocessAttributes(world, as);\n\t}\n\n\tprivate void processAttributes(World world, List<AjAttribute> as) {\n\t\tfor (AjAttribute attr : as) {\n\t\t\tif (attr instanceof AjAttribute.MethodDeclarationLineNumberAttribute) {\n\t\t\t\tdeclarationLineNumber = (AjAttribute.MethodDeclarationLineNumberAttribute) attr;\n\t\t\t} else if (attr instanceof AjAttribute.AdviceAttribute) {\n\t\t\t\tassociatedShadowMunger = ((AjAttribute.AdviceAttribute) attr).reify(this, world, (ResolvedType) getDeclaringType());\n\t\t\t} else if (attr instanceof AjAttribute.AjSynthetic) {\n\t\t\t\tbitflags |= IS_AJ_SYNTHETIC;\n\t\t\t} else if (attr instanceof AjAttribute.EffectiveSignatureAttribute) {\n\t\t\t\teffectiveSignature = (AjAttribute.EffectiveSignatureAttribute) attr;\n\t\t\t} else if (attr instanceof AjAttribute.PointcutDeclarationAttribute) {\n\t\t\t\t// this is an @AspectJ annotated advice method, with pointcut pre-resolved by ajc\n\t\t\t\tpreResolvedPointcut = ((AjAttribute.PointcutDeclarationAttribute) attr).reify();\n\t\t\t} else {\n\t\t\t\tthrow new BCException(\"weird method attribute \" + attr);\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t// // for testing - if we have this attribute, return it - will return null\n\t// if\n\t// // it doesnt know anything\n\t// public AjAttribute[] getAttributes(String name) {\n\t// List results = new ArrayList();\n\t// List l = Utility.readAjAttributes(getDeclaringType().getClassName(),\n\t// method.getAttributes(),\n\t// getSourceContext(bcelObjectType.getWorld()), bcelObjectType.getWorld(),\n\t// bcelObjectType.getWeaverVersionAttribute());\n\t// for (Iterator iter = l.iterator(); iter.hasNext();) {\n\t// AjAttribute element = (AjAttribute) iter.next();\n\t// if (element.getNameString().equals(name))\n\t// results.add(element);\n\t// }\n\t// if (results.size() > 0) {\n\t// return (AjAttribute[]) results.toArray(new AjAttribute[] {});\n\t// }\n\t// return null;\n\t// }\n\n\t@Override\n\tpublic String getAnnotationDefaultValue() {\n\t\tAttribute[] attrs = method.getAttributes();\n\t\tfor (Attribute attribute : attrs) {\n\t\t\tif (attribute.getName().equals(\"AnnotationDefault\")) {\n\t\t\t\tAnnotationDefault def = (AnnotationDefault) attribute;\n\t\t\t\treturn def.getElementValue().stringifyValue();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t// for testing - use with the method above\n\tpublic String[] getAttributeNames(boolean onlyIncludeAjOnes) {\n\t\tAttribute[] as = method.getAttributes();\n\t\tList<String> names = new ArrayList<>();\n\t\t// String[] strs = new String[as.length];\n\t\tfor (Attribute a : as) {\n\t\t\tif (!onlyIncludeAjOnes || a.getName().startsWith(AjAttribute.AttributePrefix)) {\n\t\t\t\tnames.add(a.getName());\n\t\t\t}\n\t\t}\n\t\treturn names.toArray(new String[] {});\n\t}\n\n\t@Override\n\tpublic boolean isAjSynthetic() {\n\t\treturn (bitflags & IS_AJ_SYNTHETIC) != 0;\n\t}\n\n\t@Override\n\tpublic ShadowMunger getAssociatedShadowMunger() {\n\t\treturn associatedShadowMunger;\n\t}\n\n\t@Override\n\tpublic AjAttribute.EffectiveSignatureAttribute getEffectiveSignature() {\n\t\treturn effectiveSignature;\n\t}\n\n\tpublic boolean hasDeclarationLineNumberInfo() {\n\t\treturn declarationLineNumber != null;\n\t}\n\n\tpublic int getDeclarationLineNumber() {\n\t\tif (declarationLineNumber != null) {\n\t\t\treturn declarationLineNumber.getLineNumber();\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic int getDeclarationOffset() {\n\t\tif (declarationLineNumber != null) {\n\t\t\treturn declarationLineNumber.getOffset();\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t@Override\n\tpublic ISourceLocation getSourceLocation() {\n\t\tISourceLocation ret = super.getSourceLocation();\n\t\tif ((ret == null || ret.getLine() == 0) && hasDeclarationLineNumberInfo()) {\n\t\t\t// lets see if we can do better\n\t\t\tISourceContext isc = getSourceContext();\n\t\t\tif (isc != null) {\n\t\t\t\tret = isc.makeSourceLocation(getDeclarationLineNumber(), getDeclarationOffset());\n\t\t\t} else {\n\t\t\t\tret = new SourceLocation(null, getDeclarationLineNumber());\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic MemberKind getKind() {\n\t\tif (associatedShadowMunger != null) {\n\t\t\treturn ADVICE;\n\t\t} else {\n\t\t\treturn super.getKind();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\n\t\tensureAnnotationsRetrieved();\n\t\tfor (ResolvedType aType : annotationTypes) {\n\t\t\tif (aType.equals(ofType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic AnnotationAJ[] getAnnotations() {\n\t\tensureAnnotationsRetrieved();\n\t\tif ((bitflags & HAS_ANNOTATIONS) != 0) {\n\t\t\treturn annotations;\n\t\t} else {\n\t\t\treturn AnnotationAJ.EMPTY_ARRAY;\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResolvedType[] getAnnotationTypes() {\n\t\tensureAnnotationsRetrieved();\n\t\treturn annotationTypes;\n\t}\n\n\t@Override\n\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {\n\t\tensureAnnotationsRetrieved();\n\t\tif ((bitflags & HAS_ANNOTATIONS) == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (AnnotationAJ annotation : annotations) {\n\t\t\tif (annotation.getTypeName().equals(ofType.getName())) {\n\t\t\t\treturn annotation;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void addAnnotation(AnnotationAJ annotation) {\n\t\tensureAnnotationsRetrieved();\n\t\tif ((bitflags & HAS_ANNOTATIONS) == 0) {\n\t\t\tannotations = new AnnotationAJ[1];\n\t\t\tannotations[0] = annotation;\n\t\t\tannotationTypes = new ResolvedType[1];\n\t\t\tannotationTypes[0] = annotation.getType();\n\t\t} else {\n\t\t\t// Add it to the set of annotations\n\t\t\tint len = annotations.length;\n\t\t\tAnnotationAJ[] ret = new AnnotationAJ[len + 1];\n\t\t\tSystem.arraycopy(annotations, 0, ret, 0, len);\n\t\t\tret[len] = annotation;\n\t\t\tannotations = ret;\n\t\t\tResolvedType[] newAnnotationTypes = new ResolvedType[len + 1];\n\t\t\tSystem.arraycopy(annotationTypes, 0, newAnnotationTypes, 0, len);\n\t\t\tnewAnnotationTypes[len] = annotation.getType();\n\t\t\tannotationTypes = newAnnotationTypes;\n\t\t}\n\t\tbitflags |= HAS_ANNOTATIONS;\n\t}\n\n\tpublic void removeAnnotation(ResolvedType annotationType) {\n\t\tensureAnnotationsRetrieved();\n\t\tif ((bitflags & HAS_ANNOTATIONS) == 0) {\n\t\t\t// nothing to do, why did we get called?\n\t\t} else {\n\t\t\tint len = annotations.length;\n\t\t\tif (len == 1) {\n\t\t\t\tbitflags &= ~HAS_ANNOTATIONS;\n\t\t\t\tannotations = null;\n\t\t\t\tannotationTypes = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAnnotationAJ[] ret = new AnnotationAJ[len - 1];\n\t\t\tint p = 0;\n\t\t\tfor (AnnotationAJ annotation : annotations) {\n\t\t\t\tif (!annotation.getType().equals(annotationType)) {\n\t\t\t\t\tret[p++] = annotation;\n\t\t\t\t}\n\t\t\t}\n\t\t\tannotations = ret;\n\n\t\t\tResolvedType[] newAnnotationTypes = new ResolvedType[len - 1];\n\t\t\tp = 0;\n\t\t\tfor (AnnotationAJ annotation : annotations) {\n\t\t\t\tif (!annotation.getType().equals(annotationType)) {\n\t\t\t\t\tnewAnnotationTypes[p++] = annotationType;\n\t\t\t\t}\n\t\t\t}\n\t\t\tannotationTypes = newAnnotationTypes;\n\t\t}\n\t\tbitflags |= HAS_ANNOTATIONS;\n\t}\n\n\tpublic void addParameterAnnotation(int param, AnnotationAJ anno) {\n\t\tensureParameterAnnotationsRetrieved();\n\t\tif (parameterAnnotations == NO_PARAMETER_ANNOTATIONXS) {\n\t\t\t// First time we've added any, so lets set up the array\n\t\t\tparameterAnnotations = new AnnotationAJ[getArity()][];\n\t\t\tfor (int i = 0; i < getArity(); i++) {\n\t\t\t\tparameterAnnotations[i] = AnnotationAJ.EMPTY_ARRAY;\n\t\t\t}\n\t\t}\n\t\tint existingCount = parameterAnnotations[param].length;\n\t\tif (existingCount == 0) {\n\t\t\tAnnotationAJ[] annoArray = new AnnotationAJ[1];\n\t\t\tannoArray[0] = anno;\n\t\t\tparameterAnnotations[param] = annoArray;\n\t\t} else {\n\t\t\tAnnotationAJ[] newAnnoArray = new AnnotationAJ[existingCount + 1];\n\t\t\tSystem.arraycopy(parameterAnnotations[param], 0, newAnnoArray, 0, existingCount);\n\t\t\tnewAnnoArray[existingCount] = anno;\n\t\t\tparameterAnnotations[param] = newAnnoArray;\n\t\t}\n\t}\n\n\tprivate void ensureAnnotationsRetrieved() {\n\t\tif (method == null) {\n\t\t\treturn; // must be ok, we have evicted it\n\t\t}\n\t\tif ((bitflags & HAVE_DETERMINED_ANNOTATIONS) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tbitflags |= HAVE_DETERMINED_ANNOTATIONS;\n\t\tAnnotationGen annos[] = method.getAnnotations();\n\t\tif (annos.length == 0) {\n\t\t\tannotationTypes = ResolvedType.NONE;\n\t\t\tannotations = AnnotationAJ.EMPTY_ARRAY;\n\t\t} else {\n\t\t\tint annoCount = annos.length;\n\t\t\tannotationTypes = new ResolvedType[annoCount];\n\t\t\tannotations = new AnnotationAJ[annoCount];\n\t\t\tfor (int i = 0; i < annoCount; i++) {\n\t\t\t\tAnnotationGen annotation = annos[i];\n\t\t\t\tannotations[i] = new BcelAnnotation(annotation, bcelObjectType.getWorld());\n\t\t\t\tannotationTypes[i] = annotations[i].getType();\n\t\t\t}\n\t\t\tbitflags |= HAS_ANNOTATIONS;\n\t\t}\n\t}\n\n\tprivate void ensureParameterAnnotationsRetrieved() {\n\t\tif (method == null) {\n\t\t\treturn; // must be ok, we have evicted it\n\t\t}\n\t\tAnnotationGen[][] pAnns = method.getParameterAnnotations();\n\t\tif (parameterAnnotationTypes == null || pAnns.length != parameterAnnotationTypes.length) {\n\t\t\tif (pAnns == Method.NO_PARAMETER_ANNOTATIONS) {\n\t\t\t\tparameterAnnotationTypes = BcelMethod.NO_PARAMETER_ANNOTATION_TYPES;\n\t\t\t\tparameterAnnotations = BcelMethod.NO_PARAMETER_ANNOTATIONXS;\n\t\t\t} else {\n\t\t\t\tAnnotationGen annos[][] = method.getParameterAnnotations();\n\t\t\t\tparameterAnnotations = new AnnotationAJ[annos.length][];\n\t\t\t\tparameterAnnotationTypes = new ResolvedType[annos.length][];\n\t\t\t\tfor (int i = 0; i < annos.length; i++) {\n\t\t\t\t\tAnnotationGen[] annosOnThisParam = annos[i];\n\t\t\t\t\tif (annos[i].length == 0) {\n\t\t\t\t\t\tparameterAnnotations[i] = AnnotationAJ.EMPTY_ARRAY;\n\t\t\t\t\t\tparameterAnnotationTypes[i] = ResolvedType.NONE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparameterAnnotations[i] = new AnnotationAJ[annosOnThisParam.length];\n\t\t\t\t\t\tparameterAnnotationTypes[i] = new ResolvedType[annosOnThisParam.length];\n\t\t\t\t\t\tfor (int j = 0; j < annosOnThisParam.length; j++) {\n\t\t\t\t\t\t\tparameterAnnotations[i][j] = new BcelAnnotation(annosOnThisParam[j], bcelObjectType.getWorld());\n\t\t\t\t\t\t\tparameterAnnotationTypes[i][j] = bcelObjectType.getWorld().resolve(\n\t\t\t\t\t\t\t\t\tUnresolvedType.forSignature(annosOnThisParam[j].getTypeSignature()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic AnnotationAJ[][] getParameterAnnotations() {\n\t\tensureParameterAnnotationsRetrieved();\n\t\treturn parameterAnnotations;\n\t}\n\n\t@Override\n\tpublic ResolvedType[][] getParameterAnnotationTypes() {\n\t\tensureParameterAnnotationsRetrieved();\n\t\treturn parameterAnnotationTypes;\n\t}\n\n\t/**\n\t * A method can be parameterized if it has one or more generic parameters. A generic parameter (type variable parameter) is\n\t * identified by the prefix \"T\"\n\t */\n\t@Override\n\tpublic boolean canBeParameterized() {\n\t\tunpackGenericSignature();\n\t\treturn (bitflags & CAN_BE_PARAMETERIZED) != 0;\n\t}\n\n\t@Override\n\tpublic UnresolvedType[] getGenericParameterTypes() {\n\t\tunpackGenericSignature();\n\t\treturn genericParameterTypes;\n\t}\n\n\t/**\n\t * Return the parameterized/generic return type or the normal return type if the method is not generic.\n\t */\n\t@Override\n\tpublic UnresolvedType getGenericReturnType() {\n\t\tunpackGenericSignature();\n\t\treturn genericReturnType;\n\t}\n\n\t/** For testing only */\n\tpublic Method getMethod() {\n\t\treturn method;\n\t}\n\n\tprivate void unpackGenericSignature() {\n\t\tif ((bitflags & UNPACKED_GENERIC_SIGNATURE) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tbitflags |= UNPACKED_GENERIC_SIGNATURE;\n\t\tif (!bcelObjectType.getWorld().isInJava5Mode()) {\n\t\t\tgenericReturnType = getReturnType();\n\t\t\tgenericParameterTypes = getParameterTypes();\n\t\t\treturn;\n\t\t}\n\t\tString gSig = method.getGenericSignature();\n\t\tif (gSig != null) {\n\t\t\tGenericSignature.MethodTypeSignature mSig = new GenericSignatureParser().parseAsMethodSignature(gSig);// method\n\t\t\t// .\n\t\t\t// getGenericSignature\n\t\t\t// ());\n\t\t\tif (mSig.formalTypeParameters.length > 0) {\n\t\t\t\t// generic method declaration\n\t\t\t\tbitflags |= CAN_BE_PARAMETERIZED;\n\t\t\t}\n\n\t\t\ttypeVariables = new TypeVariable[mSig.formalTypeParameters.length];\n\t\t\tfor (int i = 0; i < typeVariables.length; i++) {\n\t\t\t\tGenericSignature.FormalTypeParameter methodFtp = mSig.formalTypeParameters[i];\n\t\t\t\ttry {\n\t\t\t\t\ttypeVariables[i] = BcelGenericSignatureToTypeXConverter.formalTypeParameter2TypeVariable(methodFtp,\n\t\t\t\t\t\t\tmSig.formalTypeParameters, bcelObjectType.getWorld());\n\t\t\t\t} catch (GenericSignatureFormatException e) {\n\t\t\t\t\t// this is a development bug, so fail fast with good info\n\t\t\t\t\tthrow new IllegalStateException(\"While getting the type variables for method \" + this.toString()\n\t\t\t\t\t\t\t+ \" with generic signature \" + mSig + \" the following error condition was detected: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tGenericSignature.FormalTypeParameter[] parentFormals = bcelObjectType.getAllFormals();\n\t\t\tGenericSignature.FormalTypeParameter[] formals = new GenericSignature.FormalTypeParameter[parentFormals.length\n\t\t\t\t\t+ mSig.formalTypeParameters.length];\n\t\t\t// put method formal in front of type formals for overriding in\n\t\t\t// lookup\n\t\t\tSystem.arraycopy(mSig.formalTypeParameters, 0, formals, 0, mSig.formalTypeParameters.length);\n\t\t\tSystem.arraycopy(parentFormals, 0, formals, mSig.formalTypeParameters.length, parentFormals.length);\n\t\t\tGenericSignature.TypeSignature returnTypeSignature = mSig.returnType;\n\t\t\ttry {\n\t\t\t\tgenericReturnType = BcelGenericSignatureToTypeXConverter.typeSignature2TypeX(returnTypeSignature, formals,\n\t\t\t\t\t\tbcelObjectType.getWorld());\n\t\t\t} catch (GenericSignatureFormatException e) {\n\t\t\t\t// development bug, fail fast with good info\n\t\t\t\tthrow new IllegalStateException(\"While determing the generic return type of \" + this.toString()\n\t\t\t\t\t\t+ \" with generic signature \" + gSig + \" the following error was detected: \" + e.getMessage());\n\t\t\t}\n\t\t\tGenericSignature.TypeSignature[] paramTypeSigs = mSig.parameters;\n\t\t\tif (paramTypeSigs.length == 0) {\n\t\t\t\tgenericParameterTypes = UnresolvedType.NONE;\n\t\t\t} else {\n\t\t\t\tgenericParameterTypes = new UnresolvedType[paramTypeSigs.length];\n\t\t\t}\n\t\t\tfor (int i = 0; i < paramTypeSigs.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tgenericParameterTypes[i] = BcelGenericSignatureToTypeXConverter.typeSignature2TypeX(paramTypeSigs[i], formals,\n\t\t\t\t\t\t\tbcelObjectType.getWorld());\n\t\t\t\t} catch (GenericSignatureFormatException e) {\n\t\t\t\t\t// development bug, fail fast with good info\n\t\t\t\t\tthrow new IllegalStateException(\"While determining the generic parameter types of \" + this.toString()\n\t\t\t\t\t\t\t+ \" with generic signature \" + gSig + \" the following error was detected: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t\tif (paramTypeSigs[i] instanceof TypeVariableSignature) {\n\t\t\t\t\tbitflags |= CAN_BE_PARAMETERIZED;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgenericReturnType = getReturnType();\n\t\t\tgenericParameterTypes = getParameterTypes();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void evictWeavingState() {\n\t\tif (method != null) {\n\t\t\tunpackGenericSignature();\n\t\t\tunpackJavaAttributes();\n\t\t\tensureAnnotationsRetrieved();\n\t\t\tensureParameterAnnotationsRetrieved();\n\t\t\tdetermineParameterNames();\n\t\t\t// this.sourceContext = SourceContextImpl.UNKNOWN_SOURCE_CONTEXT;\n\t\t\tmethod = null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isSynthetic() {\n\t\tif ((bitflags & KNOW_IF_SYNTHETIC) == 0) {\n\t\t\tworkOutIfSynthetic();\n\t\t}\n\t\treturn (bitflags & IS_SYNTHETIC) != 0;// isSynthetic;\n\t}\n\n\t// Pre Java5 synthetic is an attribute 'Synthetic', post Java5 it is a\n\t// modifier (4096 or 0x1000)\n\tprivate void workOutIfSynthetic() {\n\t\tif ((bitflags & KNOW_IF_SYNTHETIC) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tbitflags |= KNOW_IF_SYNTHETIC;\n\t\tJavaClass jc = bcelObjectType.getJavaClass();\n\t\tbitflags &= IS_SYNTHETIC_INVERSE; // unset the bit\n\t\tif (jc == null) {\n\t\t\treturn; // what the hell has gone wrong?\n\t\t}\n\t\tif (jc.getMajor() < 49/* Java5 */) {\n\t\t\t// synthetic is an attribute\n\t\t\tString[] synthetics = getAttributeNames(false);\n\t\t\tif (synthetics != null) {\n\t\t\t\tfor (String synthetic : synthetics) {\n\t\t\t\t\tif (synthetic.equals(\"Synthetic\")) {\n\t\t\t\t\t\tbitflags |= IS_SYNTHETIC;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// synthetic is a modifier (4096)\n\t\t\tif ((modifiers & 4096) != 0) {\n\t\t\t\tbitflags |= IS_SYNTHETIC;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether or not the given object is equivalent to the current one. Returns true if\n\t * getMethod().getCode().getCodeString() are equal. Allows for different line number tables.\n\t */\n\t// bug 154054: is similar to equals(Object) however\n\t// doesn't require implementing equals in Method and Code\n\t// which proved expensive. Currently used within\n\t// CrosscuttingMembers.replaceWith() to decide if we need\n\t// to do a full build\n\t@Override\n\tpublic boolean isEquivalentTo(Object other) {\n\t\tif (!(other instanceof BcelMethod)) {\n\t\t\treturn false;\n\t\t}\n\t\tBcelMethod o = (BcelMethod) other;\n\t\treturn getMethod().getCode().getCodeString().equals(o.getMethod().getCode().getCodeString());\n\t}\n\n\t/**\n\t * Return true if the method represents the default constructor. Hard to determine this from bytecode, but the existence of the\n\t * MethodDeclarationLineNumber attribute should tell us.\n\t *\n\t * @return true if this BcelMethod represents the default constructor\n\t */\n\t@Override\n\tpublic boolean isDefaultConstructor() {\n\t\tboolean mightBe = !hasDeclarationLineNumberInfo() && name.equals(\"<init>\") && parameterTypes.length == 0;\n\t\tif (mightBe) {\n\t\t\t// TODO would be nice to do a check to see if the file was compiled with javac or ajc?\n\t\t\t// maybe by checking the constant pool for aspectj strings?\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n}\n",
    "size": 25037
  },
  {
    "file_id": "F20",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelObjectType.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n *     RonBodkin/AndyClement optimizations for memory consumption/speed\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.PrintStream;\nimport java.lang.ref.WeakReference;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.aspectj.apache.bcel.classfile.Attribute;\nimport org.aspectj.apache.bcel.classfile.AttributeUtils;\nimport org.aspectj.apache.bcel.classfile.ConstantClass;\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.apache.bcel.classfile.EnclosingMethod;\nimport org.aspectj.apache.bcel.classfile.Field;\nimport org.aspectj.apache.bcel.classfile.InnerClass;\nimport org.aspectj.apache.bcel.classfile.InnerClasses;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.apache.bcel.classfile.Method;\nimport org.aspectj.apache.bcel.classfile.Signature;\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.classfile.annotation.EnumElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.NameValuePair;\nimport org.aspectj.asm.AsmManager;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.util.GenericSignature;\nimport org.aspectj.util.GenericSignature.FormalTypeParameter;\nimport org.aspectj.weaver.AbstractReferenceTypeDelegate;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjcMemberMaker;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.AnnotationTargetKind;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.BindingScope;\nimport org.aspectj.weaver.ConcreteTypeMunger;\nimport org.aspectj.weaver.ISourceContext;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedPointcutDefinition;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.SourceContextImpl;\nimport org.aspectj.weaver.TypeVariable;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeaverStateInfo;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.GenericSignatureFormatException;\nimport org.aspectj.weaver.patterns.Declare;\nimport org.aspectj.weaver.patterns.DeclareErrorOrWarning;\nimport org.aspectj.weaver.patterns.DeclarePrecedence;\nimport org.aspectj.weaver.patterns.FormalBinding;\nimport org.aspectj.weaver.patterns.IScope;\nimport org.aspectj.weaver.patterns.PerClause;\n\npublic class BcelObjectType extends AbstractReferenceTypeDelegate {\n\tpublic JavaClass javaClass;\n\tprivate boolean artificial; // Was the BcelObject built from an artificial set of bytes? Or from the real ondisk stuff?\n\tprivate LazyClassGen lazyClassGen = null; // set lazily if it's an aspect\n\n\tprivate int modifiers;\n\tprivate String className;\n\n\tprivate String superclassSignature;\n\tprivate String superclassName;\n\tprivate String[] interfaceSignatures;\n\n\tprivate ResolvedMember[] fields = null;\n\tprivate ResolvedMember[] methods = null;\n\tprivate ResolvedType[] annotationTypes = null;\n\tprivate AnnotationAJ[] annotations = null;\n\tprivate TypeVariable[] typeVars = null;\n\tprivate String retentionPolicy;\n\tprivate AnnotationTargetKind[] annotationTargetKinds;\n\n\t// Aspect related stuff (pointcuts *could* be in a java class)\n\tprivate AjAttribute.WeaverVersionInfo wvInfo = AjAttribute.WeaverVersionInfo.UNKNOWN;\n\tprivate ResolvedPointcutDefinition[] pointcuts = null;\n\tprivate ResolvedMember[] privilegedAccess = null;\n\tprivate WeaverStateInfo weaverState = null;\n\tprivate PerClause perClause = null;\n\tprivate List<ConcreteTypeMunger> typeMungers = Collections.emptyList();\n\tprivate List<Declare> declares = Collections.emptyList();\n\n\tprivate GenericSignature.FormalTypeParameter[] formalsForResolution = null;\n\tprivate String declaredSignature = null;\n\n\tprivate boolean hasBeenWoven = false;\n\tprivate boolean isGenericType = false;\n\tprivate boolean isInterface;\n\tprivate boolean isEnum;\n\tprivate boolean isAnnotation;\n\tprivate boolean isAnonymous;\n\tprivate boolean isNested;\n\tprivate boolean isObject = false; // set upon construction\n\tprivate boolean isAnnotationStyleAspect = false;// set upon construction\n\tprivate boolean isCodeStyleAspect = false; // not redundant with field\n\t// above!\n\n\tprivate WeakReference<ResolvedType> superTypeReference = new WeakReference<>(null);\n\tprivate WeakReference<ResolvedType[]> superInterfaceReferences = new WeakReference<>(null);\n\n\tprivate int bitflag = 0x0000;\n\n\t// discovery bits\n\tprivate static final int DISCOVERED_ANNOTATION_RETENTION_POLICY = 0x0001;\n\tprivate static final int UNPACKED_GENERIC_SIGNATURE = 0x0002;\n\tprivate static final int UNPACKED_AJATTRIBUTES = 0x0004; // see note(1)\n\t// below\n\tprivate static final int DISCOVERED_ANNOTATION_TARGET_KINDS = 0x0008;\n\tprivate static final int DISCOVERED_DECLARED_SIGNATURE = 0x0010;\n\tprivate static final int DISCOVERED_WHETHER_ANNOTATION_STYLE = 0x0020;\n\n\tprivate static final int ANNOTATION_UNPACK_IN_PROGRESS = 0x0100;\n\n\tprivate static final String[] NO_INTERFACE_SIGS = new String[] {};\n\n\t/*\n\t * Notes: note(1): in some cases (perclause inheritance) we encounter unpacked state when calling getPerClause\n\t *\n\t * note(2): A BcelObjectType is 'damaged' if it has been modified from what was original constructed from the bytecode. This\n\t * currently happens if the parents are modified or an annotation is added - ideally BcelObjectType should be immutable but\n\t * that's a bigger piece of work. XXX\n\t */\n\n\tBcelObjectType(ReferenceType resolvedTypeX, JavaClass javaClass, boolean artificial, boolean exposedToWeaver) {\n\t\tsuper(resolvedTypeX, exposedToWeaver);\n\t\tthis.javaClass = javaClass;\n\t\tthis.artificial = artificial;\n\t\tinitializeFromJavaclass();\n\n\t\t// ATAJ: set the delegate right now for @AJ pointcut, else it is done\n\t\t// too late to lookup\n\t\t// @AJ pc refs annotation in class hierarchy\n\t\tresolvedTypeX.setDelegate(this);\n\n\t\tISourceContext sourceContext = resolvedTypeX.getSourceContext();\n\t\tif (sourceContext == SourceContextImpl.UNKNOWN_SOURCE_CONTEXT) {\n\t\t\tsourceContext = new SourceContextImpl(this);\n\t\t\tsetSourceContext(sourceContext);\n\t\t}\n\n\t\t// this should only ever be java.lang.Object which is\n\t\t// the only class in Java-1.4 with no superclasses\n\t\tisObject = (javaClass.getSuperclassNameIndex() == 0);\n\t\tensureAspectJAttributesUnpacked();\n\n\t\t// Experimental code leading to undesired ripple effects elsewhere, requiring more rework\n\t\t/*\n\t\tfinal String fileName = javaClass.getFileName();\n\t\tfinal String sourceFileName = javaClass.getSourceFileName();\n\t\tif (fileName == null || !fileName.endsWith(\".class\"))\n\t\t\tsetSourcefilename(sourceFileName);\n\t\telse if (sourceFileName == null || sourceFileName.isEmpty() || sourceFileName.endsWith(\".class\"))\n\t\t\tsetSourcefilename(fileName);\n\t\telse\n\t\t\tsetSourcefilename(fileName + \" (from \" + sourceFileName + \")\");\n\t\t*/\n\n\t\tsetSourcefilename(javaClass.getSourceFileName());\n\t}\n\n\t// repeat initialization\n\tpublic void setJavaClass(JavaClass newclass, boolean artificial) {\n\t\tthis.javaClass = newclass;\n\t\tthis.artificial = artificial;\n\t\tresetState();\n\t\tinitializeFromJavaclass();\n\t}\n\n\t@Override\n\tpublic boolean isCacheable() {\n\t\treturn true;\n\t}\n\n\tprivate void initializeFromJavaclass() {\n\t\tisInterface = javaClass.isInterface();\n\t\tisEnum = javaClass.isEnum();\n\t\tisAnnotation = javaClass.isAnnotation();\n\t\tisAnonymous = javaClass.isAnonymous();\n\t\tisNested = javaClass.isNested();\n\t\tmodifiers = javaClass.getModifiers();\n\t\tsuperclassName = javaClass.getSuperclassName();\n\t\tclassName = javaClass.getClassName();\n\t\tcachedGenericClassTypeSignature = null;\n\t}\n\n\t// --- getters\n\n\t// Java related\n\tpublic boolean isInterface() {\n\t\treturn isInterface;\n\t}\n\n\tpublic boolean isEnum() {\n\t\treturn isEnum;\n\t}\n\n\tpublic boolean isAnnotation() {\n\t\treturn isAnnotation;\n\t}\n\n\tpublic boolean isAnonymous() {\n\t\treturn isAnonymous;\n\t}\n\n\tpublic boolean isNested() {\n\t\treturn isNested;\n\t}\n\n\tpublic int getModifiers() {\n\t\treturn modifiers;\n\t}\n\n\t/**\n\t * Must take into account generic signature\n\t */\n\tpublic ResolvedType getSuperclass() {\n\t\tif (isObject) {\n\t\t\treturn null;\n\t\t}\n\t\tResolvedType supertype = superTypeReference.get();\n\t\tif (supertype == null) {\n\t\t\tensureGenericSignatureUnpacked();\n\t\t\tif (superclassSignature == null) {\n\t\t\t\tif (superclassName == null) {\n\t\t\t\t\tsuperclassName = javaClass.getSuperclassName();\n\t\t\t\t}\n\t\t\t\tsuperclassSignature = getResolvedTypeX().getWorld().resolve(UnresolvedType.forName(superclassName)).getSignature();\n\t\t\t}\n\t\t\tWorld world = getResolvedTypeX().getWorld();\n\t\t\tsupertype = world.resolve(UnresolvedType.forSignature(superclassSignature));\n\t\t\tsuperTypeReference = new WeakReference<>(supertype);\n\t\t}\n\t\treturn supertype;\n\t}\n\n\tpublic World getWorld() {\n\t\treturn getResolvedTypeX().getWorld();\n\t}\n\n\t/**\n\t * Retrieves the declared interfaces - this allows for the generic signature on a type. If specified then the generic signature\n\t * is used to work out the types - this gets around the results of erasure when the class was originally compiled.\n\t */\n\tpublic ResolvedType[] getDeclaredInterfaces() {\n\n\t\tResolvedType[] cachedInterfaceTypes = superInterfaceReferences.get();\n\t\tif (cachedInterfaceTypes == null) {\n\t\t\tensureGenericSignatureUnpacked();\n\t\t\tResolvedType[] interfaceTypes = null;\n\t\t\tif (interfaceSignatures == null) {\n\t\t\t\tString[] names = javaClass.getInterfaceNames();\n\t\t\t\tif (names.length == 0) {\n\t\t\t\t\tinterfaceSignatures = NO_INTERFACE_SIGS;\n\t\t\t\t\tinterfaceTypes = ResolvedType.NONE;\n\t\t\t\t} else {\n\t\t\t\t\tinterfaceSignatures = new String[names.length];\n\t\t\t\t\tinterfaceTypes = new ResolvedType[names.length];\n\t\t\t\t\tfor (int i = 0, len = names.length; i < len; i++) {\n\t\t\t\t\t\tinterfaceTypes[i] = getResolvedTypeX().getWorld().resolve(UnresolvedType.forName(names[i]));\n\t\t\t\t\t\tinterfaceSignatures[i] = interfaceTypes[i].getSignature();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinterfaceTypes = new ResolvedType[interfaceSignatures.length];\n\t\t\t\tfor (int i = 0, len = interfaceSignatures.length; i < len; i++) {\n\t\t\t\t\tinterfaceTypes[i] = getResolvedTypeX().getWorld().resolve(UnresolvedType.forSignature(interfaceSignatures[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuperInterfaceReferences = new WeakReference<>(interfaceTypes);\n\t\t\treturn interfaceTypes;\n\t\t} else {\n\t\t\treturn cachedInterfaceTypes;\n\t\t}\n\t}\n\n\tpublic ResolvedMember[] getDeclaredMethods() {\n\t\tensureGenericSignatureUnpacked();\n\t\tif (methods == null) {\n\t\t\tMethod[] ms = javaClass.getMethods();\n\t\t\tResolvedMember[] newMethods = new ResolvedMember[ms.length];\n\t\t\tfor (int i = ms.length - 1; i >= 0; i--) {\n\t\t\t\tnewMethods[i] = new BcelMethod(this, ms[i]);\n\t\t\t}\n\t\t\tmethods = newMethods;\n\t\t}\n\t\treturn methods;\n\t}\n\n\tpublic ResolvedMember[] getDeclaredFields() {\n\t\tensureGenericSignatureUnpacked();\n\t\tif (fields == null) {\n\t\t\tField[] fs = javaClass.getFields();\n\t\t\tResolvedMember[] newfields = new ResolvedMember[fs.length];\n\t\t\tfor (int i = 0, len = fs.length; i < len; i++) {\n\t\t\t\tnewfields[i] = new BcelField(this, fs[i]);\n\t\t\t}\n\t\t\tfields = newfields;\n\t\t}\n\t\treturn fields;\n\t}\n\n\tpublic TypeVariable[] getTypeVariables() {\n\t\tif (!isGeneric()) {\n\t\t\treturn TypeVariable.NONE;\n\t\t}\n\n\t\tif (typeVars == null) {\n\t\t\tGenericSignature.ClassSignature classSig = getGenericClassTypeSignature();\n\t\t\ttypeVars = new TypeVariable[classSig.formalTypeParameters.length];\n\t\t\tfor (int i = 0; i < typeVars.length; i++) {\n\t\t\t\tGenericSignature.FormalTypeParameter ftp = classSig.formalTypeParameters[i];\n\t\t\t\ttry {\n\t\t\t\t\ttypeVars[i] = BcelGenericSignatureToTypeXConverter.formalTypeParameter2TypeVariable(ftp,\n\t\t\t\t\t\t\tclassSig.formalTypeParameters, getResolvedTypeX().getWorld());\n\t\t\t\t} catch (GenericSignatureFormatException e) {\n\t\t\t\t\t// this is a development bug, so fail fast with good info\n\t\t\t\t\tthrow new IllegalStateException(\"While getting the type variables for type \" + this.toString()\n\t\t\t\t\t\t\t+ \" with generic signature \" + classSig + \" the following error condition was detected: \"\n\t\t\t\t\t\t\t+ e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn typeVars;\n\t}\n\n\tpublic Collection<ConcreteTypeMunger> getTypeMungers() {\n\t\treturn typeMungers;\n\t}\n\n\tpublic Collection<Declare> getDeclares() {\n\t\treturn declares;\n\t}\n\n\tpublic Collection<ResolvedMember> getPrivilegedAccesses() {\n\t\tif (privilegedAccess == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn Arrays.asList(privilegedAccess);\n\t}\n\n\tpublic ResolvedMember[] getDeclaredPointcuts() {\n\t\treturn pointcuts;\n\t}\n\n\tpublic boolean isAspect() {\n\t\treturn perClause != null;\n\t}\n\n\t/**\n\t * Check if the type is an @AJ aspect (no matter if used from an LTW point of view). Such aspects are annotated with @Aspect\n\t *\n\t * @return true for @AJ aspect\n\t */\n\tpublic boolean isAnnotationStyleAspect() {\n\t\tif ((bitflag & DISCOVERED_WHETHER_ANNOTATION_STYLE) == 0) {\n\t\t\tbitflag |= DISCOVERED_WHETHER_ANNOTATION_STYLE;\n\t\t\tisAnnotationStyleAspect = !isCodeStyleAspect && hasAnnotation(AjcMemberMaker.ASPECT_ANNOTATION);\n\t\t}\n\t\treturn isAnnotationStyleAspect;\n\t}\n\n\t/**\n\t * Process any org.aspectj.weaver attributes stored against the class.\n\t */\n\tprivate void ensureAspectJAttributesUnpacked() {\n\t\tif ((bitflag & UNPACKED_AJATTRIBUTES) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tbitflag |= UNPACKED_AJATTRIBUTES;\n\t\tIMessageHandler msgHandler = getResolvedTypeX().getWorld().getMessageHandler();\n\t\t// Pass in empty list that can store things for readAj5 to process\n\t\tList<AjAttribute> l = null;\n\t\ttry {\n\t\t\tl = Utility.readAjAttributes(className, javaClass.getAttributes(), getResolvedTypeX().getSourceContext(),\n\t\t\t\t\tgetResolvedTypeX().getWorld(), AjAttribute.WeaverVersionInfo.UNKNOWN,\n\t\t\t\t\tnew BcelConstantPoolReader(javaClass.getConstantPool()));\n\t\t} catch (RuntimeException re) {\n\t\t\tthrow new RuntimeException(\"Problem processing attributes in \" + javaClass.getFileName(), re);\n\t\t}\n\t\tList<ResolvedPointcutDefinition> pointcuts = new ArrayList<>();\n\t\ttypeMungers = new ArrayList<>();\n\t\tdeclares = new ArrayList<>();\n\t\tprocessAttributes(l, pointcuts, false);\n\t\tReferenceType type = getResolvedTypeX();\n\t\tAsmManager asmManager = ((BcelWorld) type.getWorld()).getModelAsAsmManager();\n\t\tl = AtAjAttributes.readAj5ClassAttributes(asmManager, javaClass, type, type.getSourceContext(), msgHandler,\n\t\t\t\tisCodeStyleAspect);\n\t\tAjAttribute.Aspect deferredAspectAttribute = processAttributes(l, pointcuts, true);\n\n\t\tif (pointcuts.size() == 0) {\n\t\t\tthis.pointcuts = ResolvedPointcutDefinition.NO_POINTCUTS;\n\t\t} else {\n\t\t\tthis.pointcuts = pointcuts.toArray(ResolvedPointcutDefinition.NO_POINTCUTS);\n\t\t}\n\n\t\tresolveAnnotationDeclares(l);\n\n\t\tif (deferredAspectAttribute != null) {\n\t\t\t// we can finally process the aspect and its associated perclause...\n\t\t\tperClause = deferredAspectAttribute.reifyFromAtAspectJ(this.getResolvedTypeX());\n\t\t}\n\t\tif (isAspect() && !Modifier.isAbstract(getModifiers()) && isGeneric()) {\n\t\t\tmsgHandler.handleMessage(MessageUtil.error(\"The generic aspect '\" + getResolvedTypeX().getName()\n\t\t\t\t\t+ \"' must be declared abstract\", getResolvedTypeX().getSourceLocation()));\n\t\t}\n\n\t}\n\n\tprivate AjAttribute.Aspect processAttributes(List<AjAttribute> attributeList, List<ResolvedPointcutDefinition> pointcuts,\n\t\t\tboolean fromAnnotations) {\n\t\tAjAttribute.Aspect deferredAspectAttribute = null;\n\t\tfor (AjAttribute a : attributeList) {\n\t\t\tif (a instanceof AjAttribute.Aspect) {\n\t\t\t\tif (fromAnnotations) {\n\t\t\t\t\tdeferredAspectAttribute = (AjAttribute.Aspect) a;\n\t\t\t\t} else {\n\t\t\t\t\tperClause = ((AjAttribute.Aspect) a).reify(this.getResolvedTypeX());\n\t\t\t\t\tisCodeStyleAspect = true;\n\t\t\t\t}\n\t\t\t} else if (a instanceof AjAttribute.PointcutDeclarationAttribute) {\n\t\t\t\tpointcuts.add(((AjAttribute.PointcutDeclarationAttribute) a).reify());\n\t\t\t} else if (a instanceof AjAttribute.WeaverState) {\n\t\t\t\tweaverState = ((AjAttribute.WeaverState) a).reify();\n\t\t\t} else if (a instanceof AjAttribute.TypeMunger) {\n\t\t\t\ttypeMungers.add(((AjAttribute.TypeMunger) a).reify(getResolvedTypeX().getWorld(), getResolvedTypeX()));\n\t\t\t} else if (a instanceof AjAttribute.DeclareAttribute) {\n\t\t\t\tdeclares.add(((AjAttribute.DeclareAttribute) a).getDeclare());\n\t\t\t} else if (a instanceof AjAttribute.PrivilegedAttribute) {\n\t\t\t\tAjAttribute.PrivilegedAttribute privAttribute = (AjAttribute.PrivilegedAttribute) a;\n\t\t\t\tprivilegedAccess = privAttribute.getAccessedMembers();\n\t\t\t} else if (a instanceof AjAttribute.SourceContextAttribute) {\n\t\t\t\tif (getResolvedTypeX().getSourceContext() instanceof SourceContextImpl) {\n\t\t\t\t\tAjAttribute.SourceContextAttribute sca = (AjAttribute.SourceContextAttribute) a;\n\t\t\t\t\t((SourceContextImpl) getResolvedTypeX().getSourceContext()).configureFromAttribute(sca.getSourceFileName(),\n\t\t\t\t\t\t\tsca.getLineBreaks());\n\n\t\t\t\t\tsetSourcefilename(sca.getSourceFileName());\n\t\t\t\t}\n\t\t\t} else if (a instanceof AjAttribute.WeaverVersionInfo) {\n\t\t\t\t// Set the weaver version used to build this type\n\t\t\t\twvInfo = (AjAttribute.WeaverVersionInfo) a;\n\t\t\t} else {\n\t\t\t\tthrow new BCException(\"bad attribute \" + a);\n\t\t\t}\n\t\t}\n\t\treturn deferredAspectAttribute;\n\t}\n\n\t/**\n\t * Extra processing step needed because declares that come from annotations are not pre-resolved. We can't do the resolution\n\t * until *after* the pointcuts have been resolved.\n\t */\n\tprivate void resolveAnnotationDeclares(List<AjAttribute> attributeList) {\n\t\tFormalBinding[] bindings = FormalBinding.NONE;\n\t\tIScope bindingScope = new BindingScope(getResolvedTypeX(), getResolvedTypeX().getSourceContext(), bindings);\n\t\tfor (AjAttribute a : attributeList) {\n\t\t\tif (a instanceof AjAttribute.DeclareAttribute) {\n\t\t\t\tDeclare decl = (((AjAttribute.DeclareAttribute) a).getDeclare());\n\t\t\t\tif (decl instanceof DeclareErrorOrWarning) {\n\t\t\t\t\tdecl.resolve(bindingScope);\n\t\t\t\t} else if (decl instanceof DeclarePrecedence) {\n\t\t\t\t\t((DeclarePrecedence) decl).setScopeForResolution(bindingScope);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic PerClause getPerClause() {\n\t\tensureAspectJAttributesUnpacked();\n\t\treturn perClause;\n\t}\n\n\tpublic JavaClass getJavaClass() {\n\t\treturn javaClass;\n\t}\n\n\t/**\n\t * @return true if built from bytes obtained from somewhere. False if built from bytes retrieved from disk.\n\t */\n\tpublic boolean isArtificial() {\n\t\treturn artificial;\n\t}\n\n\tpublic void resetState() {\n\t\tif (javaClass == null) {\n\t\t\t// we might store the classname and allow reloading?\n\t\t\t// At this point we are relying on the world to not evict if it\n\t\t\t// might want to reweave multiple times\n\t\t\tthrow new BCException(\"can't weave evicted type\");\n\t\t}\n\n\t\tbitflag = 0x0000;\n\n\t\tthis.annotationTypes = null;\n\t\tthis.annotations = null;\n\t\tthis.interfaceSignatures = null;\n\t\tthis.superclassSignature = null;\n\t\tthis.superclassName = null;\n\t\tthis.fields = null;\n\t\tthis.methods = null;\n\t\tthis.pointcuts = null;\n\t\tthis.perClause = null;\n\t\tthis.weaverState = null;\n\t\tthis.lazyClassGen = null;\n\t\thasBeenWoven = false;\n\n\t\tisObject = (javaClass.getSuperclassNameIndex() == 0);\n\t\tisAnnotationStyleAspect = false;\n\t\tensureAspectJAttributesUnpacked();\n\t}\n\n\tpublic void finishedWith() {\n\t\t// memory usage experiments....\n\t\t// this.interfaces = null;\n\t\t// this.superClass = null;\n\t\t// this.fields = null;\n\t\t// this.methods = null;\n\t\t// this.pointcuts = null;\n\t\t// this.perClause = null;\n\t\t// this.weaverState = null;\n\t\t// this.lazyClassGen = null;\n\t\t// this next line frees up memory, but need to understand incremental\n\t\t// implications\n\t\t// before leaving it in.\n\t\t// getResolvedTypeX().setSourceContext(null);\n\t}\n\n\tpublic WeaverStateInfo getWeaverState() {\n\t\treturn weaverState;\n\t}\n\n\tvoid setWeaverState(WeaverStateInfo weaverState) {\n\t\tthis.weaverState = weaverState;\n\t}\n\n\tpublic void printWackyStuff(PrintStream out) {\n\t\tif (typeMungers.size() > 0) {\n\t\t\tout.println(\"  TypeMungers: \" + typeMungers);\n\t\t}\n\t\tif (declares.size() > 0) {\n\t\t\tout.println(\"     declares: \" + declares);\n\t\t}\n\t}\n\n\t/**\n\t * Return the lazyClassGen associated with this type. For aspect types, this value will be cached, since it is used to inline\n\t * advice. For non-aspect types, this lazyClassGen is always newly constructed.\n\t */\n\tpublic LazyClassGen getLazyClassGen() {\n\t\tLazyClassGen ret = lazyClassGen;\n\t\tif (ret == null) {\n\t\t\t// System.err.println(\"creating lazy class gen for: \" + this);\n\t\t\tret = new LazyClassGen(this);\n\t\t\t// ret.print(System.err);\n\t\t\t// System.err.println(\"made LCG from : \" +\n\t\t\t// this.getJavaClass().getSuperclassName );\n\t\t\tif (isAspect()) {\n\t\t\t\tlazyClassGen = ret;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic boolean isSynthetic() {\n\t\treturn getResolvedTypeX().isSynthetic();\n\t}\n\n\tpublic AjAttribute.WeaverVersionInfo getWeaverVersionAttribute() {\n\t\treturn wvInfo;\n\t}\n\n\t// -- annotation related\n\n\tpublic ResolvedType[] getAnnotationTypes() {\n\t\tensureAnnotationsUnpacked();\n\t\treturn annotationTypes;\n\t}\n\n\tpublic AnnotationAJ[] getAnnotations() {\n\t\tensureAnnotationsUnpacked();\n\t\treturn annotations;\n\t}\n\n\tpublic boolean hasAnnotations() {\n\t\tensureAnnotationsUnpacked();\n\t\treturn annotations.length != 0;\n\t}\n\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\n\t\t// Due to re-entrancy we may be in the middle of unpacking the annotations already... in which case use this slow\n\t\t// alternative until the stack unwinds itself\n\t\tif (isUnpackingAnnotations()) {\n\t\t\tAnnotationGen annos[] = javaClass.getAnnotations();\n\t\t\tif (annos == null || annos.length == 0) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tString lookingForSignature = ofType.getSignature();\n\t\t\t\tfor (AnnotationGen annotation : annos) {\n\t\t\t\t\tif (lookingForSignature.equals(annotation.getTypeSignature())) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tensureAnnotationsUnpacked();\n\t\tfor (int i = 0, max = annotationTypes.length; i < max; i++) {\n\t\t\tUnresolvedType ax = annotationTypes[i];\n\t\t\tif (ax == null) {\n\t\t\t\tthrow new RuntimeException(\"Annotation entry \" + i + \" on type \" + this.getResolvedTypeX().getName() + \" is null!\");\n\t\t\t}\n\t\t\tif (ax.equals(ofType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isAnnotationWithRuntimeRetention() {\n\t\treturn (getRetentionPolicy() == null ? false : getRetentionPolicy().equals(\"RUNTIME\"));\n\t}\n\n\tpublic String getRetentionPolicy() {\n\t\tif ((bitflag & DISCOVERED_ANNOTATION_RETENTION_POLICY) == 0) {\n\t\t\tbitflag |= DISCOVERED_ANNOTATION_RETENTION_POLICY;\n\t\t\tretentionPolicy = null; // null means we have no idea\n\t\t\tif (isAnnotation()) {\n\t\t\t\tensureAnnotationsUnpacked();\n\t\t\t\tfor (int i = annotations.length - 1; i >= 0; i--) {\n\t\t\t\t\tAnnotationAJ ax = annotations[i];\n\t\t\t\t\tif (ax.getTypeName().equals(UnresolvedType.AT_RETENTION.getName())) {\n\t\t\t\t\t\tList<NameValuePair> values = ((BcelAnnotation) ax).getBcelAnnotation().getValues();\n\t\t\t\t\t\tfor (NameValuePair element : values) {\n\t\t\t\t\t\t\tEnumElementValue v = (EnumElementValue) element.getValue();\n\t\t\t\t\t\t\tretentionPolicy = v.getEnumValueString();\n\t\t\t\t\t\t\treturn retentionPolicy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn retentionPolicy;\n\t}\n\n\tpublic boolean canAnnotationTargetType() {\n\t\tAnnotationTargetKind[] targetKinds = getAnnotationTargetKinds();\n\t\tif (targetKinds == null) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (AnnotationTargetKind targetKind : targetKinds) {\n\t\t\tif (targetKind.equals(AnnotationTargetKind.TYPE)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic AnnotationTargetKind[] getAnnotationTargetKinds() {\n\t\tif ((bitflag & DISCOVERED_ANNOTATION_TARGET_KINDS) != 0) {\n\t\t\treturn annotationTargetKinds;\n\t\t}\n\t\tbitflag |= DISCOVERED_ANNOTATION_TARGET_KINDS;\n\t\tannotationTargetKinds = null; // null means we have no idea or the\n\t\t// @Target annotation hasn't been used\n\t\tList<AnnotationTargetKind> targetKinds = new ArrayList<>();\n\t\tif (isAnnotation()) {\n\t\t\tAnnotationAJ[] annotationsOnThisType = getAnnotations();\n\t\t\tfor (AnnotationAJ a : annotationsOnThisType) {\n\t\t\t\tif (a.getTypeName().equals(UnresolvedType.AT_TARGET.getName())) {\n\t\t\t\t\tSet<String> targets = a.getTargets();\n\t\t\t\t\tif (targets != null) {\n\t\t\t\t\t\tfor (String targetKind : targets) {\n\t\t\t\t\t\t\tif (targetKind.equals(\"ANNOTATION_TYPE\")) {\n\t\t\t\t\t\t\t\ttargetKinds.add(AnnotationTargetKind.ANNOTATION_TYPE);\n\t\t\t\t\t\t\t} else if (targetKind.equals(\"CONSTRUCTOR\")) {\n\t\t\t\t\t\t\t\ttargetKinds.add(AnnotationTargetKind.CONSTRUCTOR);\n\t\t\t\t\t\t\t} else if (targetKind.equals(\"FIELD\")) {\n\t\t\t\t\t\t\t\ttargetKinds.add(AnnotationTargetKind.FIELD);\n\t\t\t\t\t\t\t} else if (targetKind.equals(\"LOCAL_VARIABLE\")) {\n\t\t\t\t\t\t\t\ttargetKinds.add(AnnotationTargetKind.LOCAL_VARIABLE);\n\t\t\t\t\t\t\t} else if (targetKind.equals(\"METHOD\")) {\n\t\t\t\t\t\t\t\ttargetKinds.add(AnnotationTargetKind.METHOD);\n\t\t\t\t\t\t\t} else if (targetKind.equals(\"PACKAGE\")) {\n\t\t\t\t\t\t\t\ttargetKinds.add(AnnotationTargetKind.PACKAGE);\n\t\t\t\t\t\t\t} else if (targetKind.equals(\"PARAMETER\")) {\n\t\t\t\t\t\t\t\ttargetKinds.add(AnnotationTargetKind.PARAMETER);\n\t\t\t\t\t\t\t} else if (targetKind.equals(\"TYPE\")) {\n\t\t\t\t\t\t\t\ttargetKinds.add(AnnotationTargetKind.TYPE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!targetKinds.isEmpty()) {\n\t\t\t\tannotationTargetKinds = new AnnotationTargetKind[targetKinds.size()];\n\t\t\t\treturn targetKinds.toArray(annotationTargetKinds);\n\t\t\t}\n\t\t}\n\t\treturn annotationTargetKinds;\n\t}\n\n\t// --- unpacking methods\n\n\tprivate boolean isUnpackingAnnotations() {\n\t\treturn (bitflag & ANNOTATION_UNPACK_IN_PROGRESS) != 0;\n\t}\n\n\tprivate void ensureAnnotationsUnpacked() {\n\t\tif (isUnpackingAnnotations()) {\n\t\t\tthrow new BCException(\"Re-entered weaver instance whilst unpacking annotations on \" + this.className);\n\t\t}\n\t\tif (annotationTypes == null) {\n\t\t\ttry {\n\t\t\t\tbitflag |= ANNOTATION_UNPACK_IN_PROGRESS;\n\t\t\t\tAnnotationGen annos[] = javaClass.getAnnotations();\n\t\t\t\tif (annos == null || annos.length == 0) {\n\t\t\t\t\tannotationTypes = ResolvedType.NONE;\n\t\t\t\t\tannotations = AnnotationAJ.EMPTY_ARRAY;\n\t\t\t\t} else {\n\t\t\t\t\tWorld w = getResolvedTypeX().getWorld();\n\t\t\t\t\tannotationTypes = new ResolvedType[annos.length];\n\t\t\t\t\tannotations = new AnnotationAJ[annos.length];\n\t\t\t\t\tfor (int i = 0; i < annos.length; i++) {\n\t\t\t\t\t\tAnnotationGen annotation = annos[i];\n\t\t\t\t\t\tString typeSignature = annotation.getTypeSignature();\n\t\t\t\t\t\tResolvedType rType = w.resolve(UnresolvedType.forSignature(typeSignature));\n\t\t\t\t\t\tif (rType == null) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\"Whilst unpacking annotations on '\" + getResolvedTypeX().getName()\n\t\t\t\t\t\t\t\t\t+ \"', failed to resolve type '\" + typeSignature + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tannotationTypes[i] = rType;\n\t\t\t\t\t\tannotations[i] = new BcelAnnotation(annotation, rType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tbitflag &= ~ANNOTATION_UNPACK_IN_PROGRESS;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ---\n\n\tpublic String getDeclaredGenericSignature() {\n\t\tensureGenericInfoProcessed();\n\t\treturn declaredSignature;\n\t}\n\n\tprivate void ensureGenericSignatureUnpacked() {\n\t\tif ((bitflag & UNPACKED_GENERIC_SIGNATURE) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tbitflag |= UNPACKED_GENERIC_SIGNATURE;\n\t\tif (!getResolvedTypeX().getWorld().isInJava5Mode()) {\n\t\t\treturn;\n\t\t}\n\t\tGenericSignature.ClassSignature cSig = getGenericClassTypeSignature();\n\t\tif (cSig != null) {\n\t\t\tformalsForResolution = cSig.formalTypeParameters;\n\t\t\tif (isNested()) {\n\t\t\t\t// we have to find any type variables from the outer type before\n\t\t\t\t// proceeding with resolution.\n\t\t\t\tGenericSignature.FormalTypeParameter[] extraFormals = getFormalTypeParametersFromOuterClass();\n\t\t\t\tif (extraFormals.length > 0) {\n\t\t\t\t\tList<FormalTypeParameter> allFormals = new ArrayList<>();\n\t\t\t\t\tCollections.addAll(allFormals, formalsForResolution);\n\t\t\t\t\tCollections.addAll(allFormals, extraFormals);\n\t\t\t\t\tformalsForResolution = new GenericSignature.FormalTypeParameter[allFormals.size()];\n\t\t\t\t\tallFormals.toArray(formalsForResolution);\n\t\t\t\t}\n\t\t\t}\n\t\t\tGenericSignature.ClassTypeSignature superSig = cSig.superclassSignature;\n\t\t\ttry {\n\t\t\t\t// this.superClass =\n\t\t\t\t// BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(\n\t\t\t\t// superSig, formalsForResolution,\n\t\t\t\t// getResolvedTypeX().getWorld());\n\n\t\t\t\tResolvedType rt = BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(superSig, formalsForResolution,\n\t\t\t\t\t\tgetResolvedTypeX().getWorld());\n\t\t\t\tthis.superclassSignature = rt.getSignature();\n\t\t\t\tthis.superclassName = rt.getName();\n\n\t\t\t} catch (GenericSignatureFormatException e) {\n\t\t\t\t// development bug, fail fast with good info\n\t\t\t\tthrow new IllegalStateException(\"While determining the generic superclass of \" + this.className\n\t\t\t\t\t\t+ \" with generic signature \" + getDeclaredGenericSignature() + \" the following error was detected: \"\n\t\t\t\t\t\t+ e.getMessage());\n\t\t\t}\n\t\t\t// this.interfaces = new\n\t\t\t// ResolvedType[cSig.superInterfaceSignatures.length];\n\t\t\tif (cSig.superInterfaceSignatures.length == 0) {\n\t\t\t\tthis.interfaceSignatures = NO_INTERFACE_SIGS;\n\t\t\t} else {\n\t\t\t\tthis.interfaceSignatures = new String[cSig.superInterfaceSignatures.length];\n\t\t\t\tfor (int i = 0; i < cSig.superInterfaceSignatures.length; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// this.interfaces[i] =\n\t\t\t\t\t\t// BcelGenericSignatureToTypeXConverter.\n\t\t\t\t\t\t// classTypeSignature2TypeX(\n\t\t\t\t\t\t// cSig.superInterfaceSignatures[i],\n\t\t\t\t\t\t// formalsForResolution,\n\t\t\t\t\t\t// getResolvedTypeX().getWorld());\n\t\t\t\t\t\tthis.interfaceSignatures[i] = BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(\n\t\t\t\t\t\t\t\tcSig.superInterfaceSignatures[i], formalsForResolution, getResolvedTypeX().getWorld())\n\t\t\t\t\t\t\t\t.getSignature();\n\t\t\t\t\t} catch (GenericSignatureFormatException e) {\n\t\t\t\t\t\t// development bug, fail fast with good info\n\t\t\t\t\t\tthrow new IllegalStateException(\"While determing the generic superinterfaces of \" + this.className\n\t\t\t\t\t\t\t\t+ \" with generic signature \" + getDeclaredGenericSignature()\n\t\t\t\t\t\t\t\t+ \" the following error was detected: \" + e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isGeneric()) {\n\t\t\t// update resolved typex to point at generic type not raw type.\n\t\t\tReferenceType genericType = this.resolvedTypeX.getGenericType();\n\t\t\t// genericType.setSourceContext(this.resolvedTypeX.getSourceContext());\n\t\t\t// Can be null if unpacking whilst building the bcel delegate (in call hierarchy from BcelWorld.addSourceObjectType()\n\t\t\t// line 453) - see 317139\n\t\t\tif (genericType != null) {\n\t\t\t\tgenericType.setStartPos(this.resolvedTypeX.getStartPos());\n\t\t\t\tthis.resolvedTypeX = genericType;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic GenericSignature.FormalTypeParameter[] getAllFormals() {\n\t\tensureGenericSignatureUnpacked();\n\t\tif (formalsForResolution == null) {\n\t\t\treturn FormalTypeParameter.NONE;\n\t\t} else {\n\t\t\treturn formalsForResolution;\n\t\t}\n\t}\n\n\tpublic ResolvedType getOuterClass() {\n\t\tif (!isNested()) {\n\t\t\tthrow new IllegalStateException(\"Can't get the outer class of non-nested type: \" + className);\n\t\t}\n\n\t\t// try finding outer class name from InnerClasses attribute assigned to this class\n\t\tfor (Attribute attr : javaClass.getAttributes()) {\n\t\t\tif (attr instanceof InnerClasses) {\n\t\t\t\t// search for InnerClass entry that has current class as inner and some other class as outer\n\t\t\t\tInnerClass[] innerClss = ((InnerClasses) attr).getInnerClasses();\n\t\t\t\tConstantPool cpool = javaClass.getConstantPool();\n\t\t\t\tfor (InnerClass innerCls : innerClss) {\n\n\t\t\t\t\t// skip entries that miss any necessary component, 0 index means \"undefined\", from JVM Spec 2nd ed. par. 4.7.5\n\t\t\t\t\tif (innerCls.getInnerClassIndex() == 0 || innerCls.getOuterClassIndex() == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// resolve inner class name, check if it matches current class name\n\t\t\t\t\tConstantClass innerClsInfo = (ConstantClass) cpool.getConstant(innerCls.getInnerClassIndex());\n\n\t\t\t\t\t// class names in constant pool use '/' instead of '.', from JVM Spec 2nd ed. par. 4.2\n\t\t\t\t\tString innerClsName = cpool.getConstantUtf8(innerClsInfo.getNameIndex()).getValue().replace('/', '.');\n\n\t\t\t\t\tif (innerClsName.compareTo(className) == 0) {\n\t\t\t\t\t\t// resolve outer class name\n\t\t\t\t\t\tConstantClass outerClsInfo = (ConstantClass) cpool.getConstant(innerCls.getOuterClassIndex());\n\n\t\t\t\t\t\t// class names in constant pool use '/' instead of '.', from JVM Spec 2nd ed. par. 4.2\n\t\t\t\t\t\tString outerClsName = cpool.getConstantUtf8(outerClsInfo.getNameIndex()).getValue().replace('/', '.');\n\n\t\t\t\t\t\tUnresolvedType outer = UnresolvedType.forName(outerClsName);\n\t\t\t\t\t\treturn outer.resolve(getResolvedTypeX().getWorld());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (Attribute attr : javaClass.getAttributes()) { // bug339300\n\t\t\tConstantPool cpool = javaClass.getConstantPool();\n\t\t\tif (attr instanceof EnclosingMethod) {\n\t\t\t\tEnclosingMethod enclosingMethodAttribute = (EnclosingMethod) attr;\n\t\t\t\tif (enclosingMethodAttribute.getEnclosingClassIndex() != 0) {\n\t\t\t\t\tConstantClass outerClassInfo = enclosingMethodAttribute.getEnclosingClass();\n\t\t\t\t\tString outerClassName = cpool.getConstantUtf8(outerClassInfo.getNameIndex()).getValue().replace('/', '.');\n\t\t\t\t\tUnresolvedType outer = UnresolvedType.forName(outerClassName);\n\t\t\t\t\treturn outer.resolve(getResolvedTypeX().getWorld());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// try finding outer class name by assuming standard class name mangling convention of javac for this class\n\t\tint lastDollar = className.lastIndexOf('$');\n\t\tif (lastDollar == -1) {\n\t\t\t// Is this class damaged/obfuscated? Why did we think it was nested but couldn't find the parent using\n\t\t\t// the attributes above. For now just ignore it... I wonder when ignoring this will come back to bite!\n\t\t\treturn null;\n\t\t}\n\t\tString superClassName = className.substring(0, lastDollar);\n\t\tUnresolvedType outer = UnresolvedType.forName(superClassName);\n\t\treturn outer.resolve(getResolvedTypeX().getWorld());\n\t}\n\n\tprivate void ensureGenericInfoProcessed() {\n\t\tif ((bitflag & DISCOVERED_DECLARED_SIGNATURE) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tbitflag |= DISCOVERED_DECLARED_SIGNATURE;\n\t\tSignature sigAttr = AttributeUtils.getSignatureAttribute(javaClass.getAttributes());\n\t\tdeclaredSignature = (sigAttr == null ? null : sigAttr.getSignature());\n\t\tif (declaredSignature != null) {\n\t\t\tisGenericType = (declaredSignature.charAt(0) == '<');\n\t\t}\n\t}\n\n\tpublic boolean isGeneric() {\n\t\tensureGenericInfoProcessed();\n\t\treturn isGenericType;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn (javaClass == null ? \"BcelObjectType\" : \"BcelObjectTypeFor:\" + className);\n\t}\n\n\t// --- state management\n\n\tpublic void evictWeavingState() {\n\t\t// Can't chuck all this away\n\t\tif (getResolvedTypeX().getWorld().couldIncrementalCompileFollow()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (javaClass != null) {\n\t\t\t// Force retrieval of any lazy information\n\t\t\tensureAnnotationsUnpacked();\n\t\t\tensureGenericInfoProcessed();\n\n\t\t\tgetDeclaredInterfaces();\n\t\t\tgetDeclaredFields();\n\t\t\tgetDeclaredMethods();\n\t\t\t// The lazyClassGen is preserved for aspects - it exists to enable\n\t\t\t// around advice\n\t\t\t// inlining since the method will need 'injecting' into the affected\n\t\t\t// class. If\n\t\t\t// XnoInline is on, we can chuck away the lazyClassGen since it\n\t\t\t// won't be required\n\t\t\t// later.\n\t\t\tif (getResolvedTypeX().getWorld().isXnoInline()) {\n\t\t\t\tlazyClassGen = null;\n\t\t\t}\n\n\t\t\t// discard expensive bytecode array containing reweavable info\n\t\t\tif (weaverState != null) {\n\t\t\t\tweaverState.setReweavable(false);\n\t\t\t\tweaverState.setUnwovenClassFileData(null);\n\t\t\t}\n\t\t\tfor (int i = methods.length - 1; i >= 0; i--) {\n\t\t\t\tmethods[i].evictWeavingState();\n\t\t\t}\n\t\t\tfor (int i = fields.length - 1; i >= 0; i--) {\n\t\t\t\tfields[i].evictWeavingState();\n\t\t\t}\n\t\t\tjavaClass = null;\n\t\t\tthis.artificial = true;\n\t\t\t// setSourceContext(SourceContextImpl.UNKNOWN_SOURCE_CONTEXT); //\n\t\t\t// bit naughty\n\t\t\t// interfaces=null; // force reinit - may get us the right\n\t\t\t// instances!\n\t\t\t// superClass=null;\n\t\t}\n\t}\n\n\tpublic void weavingCompleted() {\n\t\thasBeenWoven = true;\n\t\tif (getResolvedTypeX().getWorld().isRunMinimalMemory()) {\n\t\t\tevictWeavingState();\n\t\t}\n\t\tif (getSourceContext() != null && !getResolvedTypeX().isAspect()) {\n\t\t\tgetSourceContext().tidy();\n\t\t}\n\t}\n\n\tpublic boolean hasBeenWoven() {\n\t\treturn hasBeenWoven;\n\t}\n\n\t@Override\n\tpublic boolean copySourceContext() {\n\t\treturn false;\n\t}\n\n\tpublic void setExposedToWeaver(boolean b) {\n\t\texposedToWeaver = b;\n\t}\n\n\t@Override\n\tpublic int getCompilerVersion() {\n\t\treturn wvInfo.getMajorVersion();\n\t}\n\n\tpublic void ensureConsistent() {\n\t\tsuperTypeReference.clear();\n\t\tsuperInterfaceReferences.clear();\n\t}\n\n\tpublic boolean isWeavable() {\n\t\treturn true;\n\t}\n}\n",
    "size": 36117
  },
  {
    "file_id": "F21",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n * initial implementation              Alexandre Vasseur\n *******************************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.util.List;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.InstructionBranch;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.ReferenceType;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjcMemberMaker;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.patterns.PerClause;\n\n/**\n * Adds aspectOf(), hasAspect() etc to the annotation defined aspects\n *\n * @author Alexandre Vasseur\n * @author Andy Clement\n */\npublic class BcelPerClauseAspectAdder extends BcelTypeMunger {\n\n\tprivate final PerClause.Kind kind;\n\n\tprivate boolean hasGeneratedInner = false;\n\n\tpublic BcelPerClauseAspectAdder(ResolvedType aspect, PerClause.Kind kind) {\n\t\tsuper(null, aspect);\n\t\tthis.kind = kind;\n\t\tif (kind == PerClause.SINGLETON || kind == PerClause.PERTYPEWITHIN || kind == PerClause.PERCFLOW) {\n\t\t\t// no inner needed\n\t\t\thasGeneratedInner = true;\n\t\t}\n\t}\n\n\tpublic boolean munge(BcelClassWeaver weaver) {\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\n\t\tdoAggressiveInner(gen);\n\n\t\t// Only munge the aspect type\n\t\tif (!gen.getType().equals(aspectType)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn doMunge(gen, true);\n\t}\n\n\tpublic boolean forceMunge(LazyClassGen gen, boolean checkAlreadyThere) {\n\t\tdoAggressiveInner(gen);\n\t\treturn doMunge(gen, checkAlreadyThere);\n\t}\n\n\tprivate void doAggressiveInner(LazyClassGen gen) {\n\t\t// agressively generate the inner interface if any\n\t\t// Note: we do so because of the bug #75442 that leads to have this interface implemented by all classes and not\n\t\t// only those matched by the per clause, which fails under LTW since the very first class\n\t\t// gets weaved and impl this interface that is still not defined.\n\t\tif (!hasGeneratedInner) {\n\t\t\tif (kind == PerClause.PEROBJECT) {// redundant test - see constructor, but safer\n\t\t\t\t// inner class\n\t\t\t\tUnresolvedType interfaceTypeX = AjcMemberMaker.perObjectInterfaceType(aspectType);\n\t\t\t\tLazyClassGen interfaceGen = new LazyClassGen(interfaceTypeX.getName(), \"java.lang.Object\", null,\n\t\t\t\t\t\tConstants.ACC_INTERFACE + Constants.ACC_PUBLIC + Constants.ACC_ABSTRACT, new String[0], getWorld());\n\t\t\t\tinterfaceGen.addMethodGen(makeMethodGen(interfaceGen, AjcMemberMaker.perObjectInterfaceGet(aspectType)));\n\t\t\t\tinterfaceGen.addMethodGen(makeMethodGen(interfaceGen, AjcMemberMaker.perObjectInterfaceSet(aspectType)));\n\t\t\t\t// not really an inner class of it but that does not matter, we pass back to the LTW\n\t\t\t\tgen.addGeneratedInner(interfaceGen);\n\t\t\t}\n\t\t\thasGeneratedInner = true;\n\t\t}\n\t}\n\n\tprivate boolean doMunge(LazyClassGen gen, boolean checkAlreadyThere) {\n\t\tif (checkAlreadyThere && hasPerClauseMembersAlready(gen)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tgeneratePerClauseMembers(gen);\n\n\t\tif (kind == PerClause.SINGLETON) {\n\t\t\tgeneratePerSingletonAspectOfMethod(gen);\n\t\t\tgeneratePerSingletonHasAspectMethod(gen);\n\t\t\tgeneratePerSingletonAjcClinitMethod(gen);\n\t\t} else if (kind == PerClause.PEROBJECT) {\n\t\t\tgeneratePerObjectAspectOfMethod(gen);\n\t\t\tgeneratePerObjectHasAspectMethod(gen);\n\t\t\tgeneratePerObjectBindMethod(gen);\n\t\t\t// these will be added by the PerObjectInterface munger that affects the type - pr144602\n\t\t\t// generatePerObjectGetSetMethods(gen);\n\t\t} else if (kind == PerClause.PERCFLOW) {\n\t\t\tgeneratePerCflowAspectOfMethod(gen);\n\t\t\tgeneratePerCflowHasAspectMethod(gen);\n\t\t\tgeneratePerCflowPushMethod(gen);\n\t\t\tgeneratePerCflowAjcClinitMethod(gen);\n\t\t} else if (kind == PerClause.PERTYPEWITHIN) {\n\t\t\tgeneratePerTWAspectOfMethod(gen);\n\t\t\tgeneratePerTWHasAspectMethod(gen);\n\t\t\tgeneratePerTWGetInstanceMethod(gen);\n\t\t\tgeneratePerTWCreateAspectInstanceMethod(gen);\n\t\t\tgeneratePerTWGetWithinTypeNameMethod(gen);\n\t\t} else {\n\t\t\tthrow new Error(\"should not happen - not such kind \" + kind.getName());\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\n\t\treturn null;\n\t}\n\n\tpublic ResolvedMember getSignature() {\n\t\treturn null;\n\t}\n\n\tpublic boolean matches(ResolvedType onType) {\n\t\t// cannot always do the right thing because may need to eagerly generate ajcMightHaveAspect interface for LTW (says Alex)\n\t\tif (hasGeneratedInner) { // pr237419 - not always going to generate the marker interface\n\t\t\treturn aspectType.equals(onType);\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate boolean hasPerClauseMembersAlready(LazyClassGen classGen) {\n\t\tList<LazyMethodGen> methodGens = classGen.getMethodGens();\n\t\tfor (LazyMethodGen method: methodGens) {\n\t\t\tif (\"aspectOf\".equals(method.getName())) {\n\t\t\t\tif (\"()\".equals(method.getParameterSignature()) && (kind == PerClause.SINGLETON || kind == PerClause.PERCFLOW)) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (\"(Ljava/lang/Object;)\".equals(method.getParameterSignature()) && kind == PerClause.PEROBJECT) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (\"(Ljava/lang/Class;)\".equals(method.getParameterSignature()) && kind == PerClause.PERTYPEWITHIN) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void generatePerClauseMembers(LazyClassGen classGen) {\n\t\t// FIXME Alex handle when field already there - or handle it with / similar to isAnnotationDefinedAspect()\n\t\t// for that use aspectType and iterate on the fields.\n\n\t\t// FIXME Alex percflowX is not using this one but AJ code style does generate it so..\n\t\tResolvedMember failureFieldInfo = AjcMemberMaker.initFailureCauseField(aspectType);\n\t\tif (kind == PerClause.SINGLETON) {\n\t\t\tclassGen.addField(makeFieldGen(classGen, failureFieldInfo), null);\n\t\t}\n\n\t\tif (kind == PerClause.SINGLETON) {\n\t\t\tResolvedMember perSingletonFieldInfo = AjcMemberMaker.perSingletonField(aspectType);\n\t\t\tclassGen.addField(makeFieldGen(classGen, perSingletonFieldInfo), null);\n\t\t\t// pr144602 - don't need to do this, PerObjectInterface munger will do it\n\t\t\t// } else if (kind == PerClause.PEROBJECT) {\n\t\t\t// ResolvedMember perObjectFieldInfo = AjcMemberMaker.perObjectField(aspectType, aspectType);\n\t\t\t// classGen.addField(makeFieldGen(classGen, perObjectFieldInfo).(), null);\n\t\t\t// // if lazy generation of the inner interface MayHaveAspect works on LTW (see previous note)\n\t\t\t// // it should be done here.\n\t\t} else if (kind == PerClause.PERCFLOW) {\n\t\t\tResolvedMember perCflowFieldInfo = AjcMemberMaker.perCflowField(aspectType);\n\t\t\tclassGen.addField(makeFieldGen(classGen, perCflowFieldInfo), null);\n\t\t} else if (kind == PerClause.PERTYPEWITHIN) {\n\t\t\tResolvedMember perTypeWithinForField = AjcMemberMaker.perTypeWithinWithinTypeField(aspectType, aspectType);\n\t\t\tclassGen.addField(makeFieldGen(classGen, perTypeWithinForField), null);\n\t\t}\n\t}\n\n\tprivate void generatePerSingletonAspectOfMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perSingletonAspectOfMethod(aspectType));\n\t\tflagAsSynthetic(method, false);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\til.append(Utility.createGet(factory, AjcMemberMaker.perSingletonField(aspectType)));\n\t\tInstructionBranch ifNotNull = InstructionFactory.createBranchInstruction(Constants.IFNONNULL, null);\n\t\til.append(ifNotNull);\n\t\til.append(factory.createNew(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName()));\n\t\til.append(InstructionConstants.DUP);\n\t\til.append(InstructionFactory.PUSH(classGen.getConstantPool(), aspectType.getName()));\n\t\til.append(Utility.createGet(factory, AjcMemberMaker.initFailureCauseField(aspectType)));\n\t\til.append(factory.createInvoke(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName(), \"<init>\", Type.VOID, new Type[] {\n\t\t\t\tType.STRING, new ObjectType(\"java.lang.Throwable\") }, Constants.INVOKESPECIAL));\n\t\til.append(InstructionConstants.ATHROW);\n\t\tInstructionHandle ifElse = il.append(Utility.createGet(factory, AjcMemberMaker.perSingletonField(aspectType)));\n\t\til.append(InstructionFactory.createReturn(Type.OBJECT));\n\t\tifNotNull.setTarget(ifElse);\n\t}\n\n\tprivate void generatePerSingletonHasAspectMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perSingletonHasAspectMethod(aspectType));\n\t\tflagAsSynthetic(method, false);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\til.append(Utility.createGet(factory, AjcMemberMaker.perSingletonField(aspectType)));\n\t\tInstructionBranch ifNull = InstructionFactory.createBranchInstruction(Constants.IFNULL, null);\n\t\til.append(ifNull);\n\t\til.append(InstructionFactory.PUSH(classGen.getConstantPool(), true));\n\t\til.append(InstructionFactory.createReturn(Type.INT));\n\t\tInstructionHandle ifElse = il.append(InstructionFactory.PUSH(classGen.getConstantPool(), false));\n\t\til.append(InstructionFactory.createReturn(Type.INT));\n\t\tifNull.setTarget(ifElse);\n\t}\n\n\tprivate void generatePerSingletonAjcClinitMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.ajcPostClinitMethod(aspectType));\n\t\tflagAsSynthetic(method, true);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\til.append(factory.createNew(aspectType.getName()));\n\t\til.append(InstructionConstants.DUP);\n\t\til.append(factory.createInvoke(aspectType.getName(), \"<init>\", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));\n\t\til.append(Utility.createSet(factory, AjcMemberMaker.perSingletonField(aspectType)));\n\t\til.append(InstructionFactory.createReturn(Type.VOID));\n\n\t\t// patch <clinit> to delegate to ajc$postClinit at the end\n\t\tLazyMethodGen clinit = classGen.getStaticInitializer();\n\t\til = new InstructionList();\n\t\tInstructionHandle tryStart = il.append(factory.createInvoke(aspectType.getName(), NameMangler.AJC_POST_CLINIT_NAME,\n\t\t\t\tType.VOID, Type.NO_ARGS, Constants.INVOKESTATIC));\n\t\tInstructionBranch tryEnd = InstructionFactory.createBranchInstruction(Constants.GOTO, null);\n\t\til.append(tryEnd);\n\t\tInstructionHandle handler = il.append(InstructionConstants.ASTORE_0);\n\t\til.append(InstructionConstants.ALOAD_0);\n\t\til.append(Utility.createSet(factory, AjcMemberMaker.initFailureCauseField(aspectType)));\n\t\til.append(InstructionFactory.createReturn(Type.VOID));\n\t\ttryEnd.setTarget(il.getEnd());\n\n\t\t// replace the original \"return\" with a \"nop\"\n\t\t// TODO AV - a bit odd, looks like Bcel alters bytecode and has a IMPDEP1 in its representation\n\t\tif (clinit.getBody().getEnd().getInstruction().opcode == Constants.IMPDEP1) {\n\t\t\tclinit.getBody().getEnd().getPrev().setInstruction(InstructionConstants.NOP);\n\t\t}\n\t\tclinit.getBody().getEnd().setInstruction(InstructionConstants.NOP);\n\t\tclinit.getBody().append(il);\n\n\t\tclinit.addExceptionHandler(tryStart, handler.getPrev(), handler, new ObjectType(\"java.lang.Throwable\"), false);\n\t}\n\n\tprivate void generatePerObjectAspectOfMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tReferenceType interfaceType = (ReferenceType) BcelWorld.makeBcelType(AjcMemberMaker.perObjectInterfaceType(aspectType));\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perObjectAspectOfMethod(aspectType));\n\t\tflagAsSynthetic(method, false);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\til.append(InstructionConstants.ALOAD_0);\n\t\til.append(factory.createInstanceOf(interfaceType));\n\t\tInstructionBranch ifEq = InstructionFactory.createBranchInstruction(Constants.IFEQ, null);\n\t\til.append(ifEq);\n\t\til.append(InstructionConstants.ALOAD_0);\n\t\til.append(factory.createCheckCast(interfaceType));\n\t\til.append(Utility.createInvoke(factory, Constants.INVOKEINTERFACE, AjcMemberMaker.perObjectInterfaceGet(aspectType)));\n\t\til.append(InstructionConstants.DUP);\n\t\tInstructionBranch ifNull = InstructionFactory.createBranchInstruction(Constants.IFNULL, null);\n\t\til.append(ifNull);\n\t\til.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(aspectType)));\n\t\tInstructionHandle ifNullElse = il.append(InstructionConstants.POP);\n\t\tifNull.setTarget(ifNullElse);\n\t\tInstructionHandle ifEqElse = il.append(factory.createNew(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName()));\n\t\tifEq.setTarget(ifEqElse);\n\t\til.append(InstructionConstants.DUP);\n\t\til.append(factory.createInvoke(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName(), \"<init>\", Type.VOID, Type.NO_ARGS,\n\t\t\t\tConstants.INVOKESPECIAL));\n\t\til.append(InstructionConstants.ATHROW);\n\t}\n\n\tprivate void generatePerObjectHasAspectMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tReferenceType interfaceType = (ReferenceType) BcelWorld.makeBcelType(AjcMemberMaker.perObjectInterfaceType(aspectType));\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perObjectHasAspectMethod(aspectType));\n\t\tflagAsSynthetic(method, false);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\til.append(InstructionConstants.ALOAD_0);\n\t\til.append(factory.createInstanceOf(interfaceType));\n\t\tInstructionBranch ifEq = InstructionFactory.createBranchInstruction(Constants.IFEQ, null);\n\t\til.append(ifEq);\n\t\til.append(InstructionConstants.ALOAD_0);\n\t\til.append(factory.createCheckCast(interfaceType));\n\t\til.append(Utility.createInvoke(factory, Constants.INVOKEINTERFACE, AjcMemberMaker.perObjectInterfaceGet(aspectType)));\n\t\tInstructionBranch ifNull = InstructionFactory.createBranchInstruction(Constants.IFNULL, null);\n\t\til.append(ifNull);\n\t\til.append(InstructionConstants.ICONST_1);\n\t\til.append(InstructionFactory.createReturn(Type.INT));\n\t\tInstructionHandle ifEqElse = il.append(InstructionConstants.ICONST_0);\n\t\tifEq.setTarget(ifEqElse);\n\t\tifNull.setTarget(ifEqElse);\n\t\til.append(InstructionFactory.createReturn(Type.INT));\n\t}\n\n\tprivate void generatePerObjectBindMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tReferenceType interfaceType = (ReferenceType) BcelWorld.makeBcelType(AjcMemberMaker.perObjectInterfaceType(aspectType));\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perObjectBind(aspectType));\n\t\tflagAsSynthetic(method, true);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\til.append(InstructionConstants.ALOAD_0);\n\t\til.append(factory.createInstanceOf(interfaceType));\n\t\tInstructionBranch ifEq = InstructionFactory.createBranchInstruction(Constants.IFEQ, null);\n\t\til.append(ifEq);\n\t\til.append(InstructionConstants.ALOAD_0);\n\t\til.append(factory.createCheckCast(interfaceType));\n\t\til.append(Utility.createInvoke(factory, Constants.INVOKEINTERFACE, AjcMemberMaker.perObjectInterfaceGet(aspectType)));\n\t\tInstructionBranch ifNonNull = InstructionFactory.createBranchInstruction(Constants.IFNONNULL, null);\n\t\til.append(ifNonNull);\n\t\til.append(InstructionConstants.ALOAD_0);\n\t\til.append(factory.createCheckCast(interfaceType));\n\t\til.append(factory.createNew(aspectType.getName()));\n\t\til.append(InstructionConstants.DUP);\n\t\til.append(factory.createInvoke(aspectType.getName(), \"<init>\", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));\n\t\til.append(Utility.createInvoke(factory, Constants.INVOKEINTERFACE, AjcMemberMaker.perObjectInterfaceSet(aspectType)));\n\t\tInstructionHandle end = il.append(InstructionFactory.createReturn(Type.VOID));\n\t\tifEq.setTarget(end);\n\t\tifNonNull.setTarget(end);\n\t}\n\n\t// private void generatePerObjectGetSetMethods(LazyClassGen classGen) {\n\t// InstructionFactory factory = classGen.getFactory();\n\t//\n\t// LazyMethodGen methodGet = makeMethodGen(classGen, AjcMemberMaker.perObjectInterfaceGet(aspectType));\n\t// flagAsSynthetic(methodGet, true);\n\t// classGen.addMethodGen(methodGet);\n\t// InstructionList ilGet = methodGet.getBody();\n\t// ilGet = new InstructionList();\n\t// ilGet.append(InstructionConstants.ALOAD_0);\n\t// ilGet.append(Utility.createGet(factory, AjcMemberMaker.perObjectField(aspectType, aspectType)));\n\t// ilGet.append(InstructionFactory.createReturn(Type.OBJECT));\n\t//\n\t// LazyMethodGen methodSet = makeMethodGen(classGen, AjcMemberMaker.perObjectInterfaceSet(aspectType));\n\t// flagAsSynthetic(methodSet, true);\n\t// classGen.addMethodGen(methodSet);\n\t// InstructionList ilSet = methodSet.getBody();\n\t// ilSet = new InstructionList();\n\t// ilSet.append(InstructionConstants.ALOAD_0);\n\t// ilSet.append(InstructionConstants.ALOAD_1);\n\t// ilSet.append(Utility.createSet(factory, AjcMemberMaker.perObjectField(aspectType, aspectType)));\n\t// ilSet.append(InstructionFactory.createReturn(Type.VOID));\n\t// }\n\n\tprivate void generatePerCflowAspectOfMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perCflowAspectOfMethod(aspectType));\n\t\tflagAsSynthetic(method, false);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\til.append(Utility.createGet(factory, AjcMemberMaker.perCflowField(aspectType)));\n\t\til.append(Utility.createInvoke(factory, Constants.INVOKEVIRTUAL, AjcMemberMaker.cflowStackPeekInstance()));\n\t\til.append(factory.createCheckCast((ReferenceType) BcelWorld.makeBcelType(aspectType)));\n\t\til.append(InstructionFactory.createReturn(Type.OBJECT));\n\t}\n\n\tprivate void generatePerCflowHasAspectMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perCflowHasAspectMethod(aspectType));\n\t\tflagAsSynthetic(method, false);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\til.append(Utility.createGet(factory, AjcMemberMaker.perCflowField(aspectType)));\n\t\til.append(Utility.createInvoke(factory, Constants.INVOKEVIRTUAL, AjcMemberMaker.cflowStackIsValid()));\n\t\til.append(InstructionFactory.createReturn(Type.INT));\n\t}\n\n\tprivate void generatePerCflowPushMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perCflowPush(aspectType));\n\t\tflagAsSynthetic(method, true);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\til.append(Utility.createGet(factory, AjcMemberMaker.perCflowField(aspectType)));\n\t\til.append(factory.createNew(aspectType.getName()));\n\t\til.append(InstructionConstants.DUP);\n\t\til.append(factory.createInvoke(aspectType.getName(), \"<init>\", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));\n\t\til.append(Utility.createInvoke(factory, Constants.INVOKEVIRTUAL, AjcMemberMaker.cflowStackPushInstance()));\n\t\til.append(InstructionFactory.createReturn(Type.VOID));\n\t}\n\n\tprivate void generatePerCflowAjcClinitMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\n\t\tLazyMethodGen method = classGen.getAjcPreClinit(); // Creates a clinit if there isn't one\n\n\t\tInstructionList il = new InstructionList();\n\t\til.append(factory.createNew(AjcMemberMaker.CFLOW_STACK_TYPE.getName()));\n\t\til.append(InstructionConstants.DUP);\n\t\til.append(factory.createInvoke(AjcMemberMaker.CFLOW_STACK_TYPE.getName(), \"<init>\", Type.VOID, Type.NO_ARGS,\n\t\t\t\tConstants.INVOKESPECIAL));\n\t\til.append(Utility.createSet(factory, AjcMemberMaker.perCflowField(aspectType)));\n\t\tmethod.getBody().insert(il);\n\t}\n\n\tprivate void generatePerTWAspectOfMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinAspectOfMethod(aspectType, classGen.getWorld()\n\t\t\t\t.isInJava5Mode()));\n\t\tflagAsSynthetic(method, false);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\tInstructionHandle tryStart = il.append(InstructionConstants.ALOAD_0);\n\n\t\til.append(Utility.createInvoke(factory, Constants.INVOKESTATIC, AjcMemberMaker.perTypeWithinGetInstance(aspectType)));\n\t\til.append(InstructionConstants.ASTORE_1);\n\t\til.append(InstructionConstants.ALOAD_1);\n\t\tInstructionBranch ifNonNull = InstructionFactory.createBranchInstruction(Constants.IFNONNULL, null);\n\t\til.append(ifNonNull);\n\t\til.append(factory.createNew(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName()));\n\t\til.append(InstructionConstants.DUP);\n\t\til.append(InstructionFactory.PUSH(classGen.getConstantPool(), aspectType.getName()));\n\t\til.append(InstructionConstants.ACONST_NULL);\n\t\til.append(factory.createInvoke(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName(), \"<init>\", Type.VOID, new Type[] {\n\t\t\t\tType.STRING, new ObjectType(\"java.lang.Throwable\") }, Constants.INVOKESPECIAL));\n\t\til.append(InstructionConstants.ATHROW);\n\t\tInstructionHandle ifElse = il.append(InstructionConstants.ALOAD_1);\n\t\tifNonNull.setTarget(ifElse);\n\t\til.append(InstructionFactory.createReturn(Type.OBJECT));\n\n\t\tInstructionHandle handler = il.append(InstructionConstants.ASTORE_1);\n\t\til.append(factory.createNew(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName()));\n\t\til.append(InstructionConstants.DUP);\n\t\til.append(factory.createInvoke(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName(), \"<init>\", Type.VOID, Type.NO_ARGS,\n\t\t\t\tConstants.INVOKESPECIAL));\n\t\til.append(InstructionConstants.ATHROW);\n\n\t\tmethod.addExceptionHandler(tryStart, handler.getPrev(), handler, new ObjectType(\"java.lang.Exception\"), false);\n\t}\n\n\t// Create 'public String getWithinTypeName() { return ajc$withinType;}'\n\tprivate void generatePerTWGetWithinTypeNameMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinGetWithinTypeNameMethod(aspectType, classGen\n\t\t\t\t.getWorld().isInJava5Mode()));\n\t\tflagAsSynthetic(method, false);\n\t\tclassGen.addMethodGen(method);\n\t\t// 0: aload_0\n\t\t// 1: getfield #14; //Field ajc$withinType:Ljava/lang/String;\n\t\t// 4: areturn\n\t\tInstructionList il = method.getBody();\n\t\til.append(InstructionConstants.ALOAD_0);\n\t\til.append(Utility.createGet(factory, AjcMemberMaker.perTypeWithinWithinTypeField(aspectType, aspectType)));\n\t\til.append(InstructionConstants.ARETURN);\n\t}\n\n\tprivate void generatePerTWHasAspectMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinHasAspectMethod(aspectType, classGen.getWorld()\n\t\t\t\t.isInJava5Mode()));\n\t\tflagAsSynthetic(method, false);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\tInstructionHandle tryStart = il.append(InstructionConstants.ALOAD_0);\n\t\til.append(Utility.createInvoke(factory, Constants.INVOKESTATIC, AjcMemberMaker.perTypeWithinGetInstance(aspectType)));\n\t\tInstructionBranch ifNull = InstructionFactory.createBranchInstruction(Constants.IFNULL, null);\n\t\til.append(ifNull);\n\t\til.append(InstructionConstants.ICONST_1);\n\t\til.append(InstructionConstants.IRETURN);\n\t\tInstructionHandle ifElse = il.append(InstructionConstants.ICONST_0);\n\t\tifNull.setTarget(ifElse);\n\t\til.append(InstructionConstants.IRETURN);\n\n\t\tInstructionHandle handler = il.append(InstructionConstants.ASTORE_1);\n\t\til.append(InstructionConstants.ICONST_0);\n\t\til.append(InstructionConstants.IRETURN);\n\n\t\tmethod.addExceptionHandler(tryStart, handler.getPrev(), handler, new ObjectType(\"java.lang.Exception\"), false);\n\t}\n\n\tprivate void generatePerTWGetInstanceMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinGetInstance(aspectType));\n\t\tflagAsSynthetic(method, true);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\tInstructionHandle tryStart = il.append(InstructionConstants.ALOAD_0);\n\t\til.append(InstructionFactory.PUSH(factory.getConstantPool(), NameMangler.perTypeWithinLocalAspectOf(aspectType)));\n\t\til.append(InstructionConstants.ACONST_NULL);// Class[] for \"getDeclaredMethod\"\n\t\til.append(factory.createInvoke(\"java/lang/Class\", \"getDeclaredMethod\", Type.getType(\"Ljava/lang/reflect/Method;\"),\n\t\t\t\tnew Type[] { Type.getType(\"Ljava/lang/String;\"), Type.getType(\"[Ljava/lang/Class;\") }, Constants.INVOKEVIRTUAL));\n\t\til.append(InstructionConstants.ACONST_NULL);// Object for \"invoke\", static method\n\t\til.append(InstructionConstants.ACONST_NULL);// Object[] for \"invoke\", no arg\n\t\til.append(factory.createInvoke(\"java/lang/reflect/Method\", \"invoke\", Type.OBJECT, new Type[] {\n\t\t\t\tType.getType(\"Ljava/lang/Object;\"), Type.getType(\"[Ljava/lang/Object;\") }, Constants.INVOKEVIRTUAL));\n\t\til.append(factory.createCheckCast((ReferenceType) BcelWorld.makeBcelType(aspectType)));\n\t\til.append(InstructionConstants.ARETURN);\n\n\t\tInstructionHandle handler = il.append(InstructionConstants.ASTORE_1);\n\t\til.append(InstructionConstants.ACONST_NULL);\n\t\til.append(InstructionConstants.ARETURN);\n\n\t\tmethod.addExceptionHandler(tryStart, handler.getPrev(), handler, new ObjectType(\"java.lang.Exception\"), false);\n\t}\n\n\tprivate void generatePerTWCreateAspectInstanceMethod(LazyClassGen classGen) {\n\t\tInstructionFactory factory = classGen.getFactory();\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinCreateAspectInstance(aspectType));\n\t\tflagAsSynthetic(method, true);\n\t\tclassGen.addMethodGen(method);\n\n\t\tInstructionList il = method.getBody();\n\t\til.append(factory.createNew(aspectType.getName()));\n\t\til.append(InstructionConstants.DUP);\n\t\til.append(factory.createInvoke(aspectType.getName(), \"<init>\", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));\n\t\til.append(InstructionConstants.ASTORE_1);\n\t\til.append(InstructionConstants.ALOAD_1);\n\t\til.append(InstructionConstants.ALOAD_0);\n\t\til.append(Utility.createSet(factory, AjcMemberMaker.perTypeWithinWithinTypeField(aspectType, aspectType)));\n\t\til.append(InstructionConstants.ALOAD_1);\n\t\til.append(InstructionConstants.ARETURN);\n\t}\n\n\t/**\n\t * Add standard Synthetic (if wished) and AjSynthetic (always) attributes\n\t *\n\t * @param methodGen\n\t * @param makeJavaSynthetic true if standard Synthetic attribute must be set as well (invisible to user)\n\t */\n\tprivate static void flagAsSynthetic(LazyMethodGen methodGen, boolean makeJavaSynthetic) {\n\t\tif (makeJavaSynthetic) {\n\t\t\tmethodGen.makeSynthetic();\n\t\t}\n\t\tmethodGen.addAttribute(Utility\n\t\t\t\t.bcelAttribute(new AjAttribute.AjSynthetic(), methodGen.getEnclosingClass().getConstantPool()));\n\t}\n\n\t// public boolean isLateTypeMunger() {\n\t// return true;\n\t// }\n}\n",
    "size": 26937
  },
  {
    "file_id": "F22",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelRenderer.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.ReferenceType;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.MemberImpl;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.ast.And;\nimport org.aspectj.weaver.ast.Call;\nimport org.aspectj.weaver.ast.CallExpr;\nimport org.aspectj.weaver.ast.Expr;\nimport org.aspectj.weaver.ast.FieldGet;\nimport org.aspectj.weaver.ast.FieldGetCall;\nimport org.aspectj.weaver.ast.HasAnnotation;\nimport org.aspectj.weaver.ast.IExprVisitor;\nimport org.aspectj.weaver.ast.ITestVisitor;\nimport org.aspectj.weaver.ast.Instanceof;\nimport org.aspectj.weaver.ast.Literal;\nimport org.aspectj.weaver.ast.Not;\nimport org.aspectj.weaver.ast.Or;\nimport org.aspectj.weaver.ast.Test;\nimport org.aspectj.weaver.ast.Var;\nimport org.aspectj.weaver.internal.tools.MatchingContextBasedTest;\n\n// we generate right to left, btw.\npublic final class BcelRenderer implements ITestVisitor, IExprVisitor {\n\n\tprivate InstructionList instructions;\n\tprivate InstructionFactory fact;\n\tprivate BcelWorld world;\n\n\tInstructionHandle sk, fk, next = null;\n\n\tprivate BcelRenderer(InstructionFactory fact, BcelWorld world) {\n\t\tsuper();\n\t\tthis.fact = fact;\n\t\tthis.world = world;\n\t\tthis.instructions = new InstructionList();\n\t}\n\n\t// ---- renderers\n\n\tpublic static InstructionList renderExpr(InstructionFactory fact, BcelWorld world, Expr e) {\n\t\tBcelRenderer renderer = new BcelRenderer(fact, world);\n\t\te.accept(renderer);\n\t\treturn renderer.instructions;\n\t}\n\n\tpublic static InstructionList renderExpr(InstructionFactory fact, BcelWorld world, Expr e, Type desiredType) {\n\t\tBcelRenderer renderer = new BcelRenderer(fact, world);\n\t\te.accept(renderer);\n\t\tInstructionList il = renderer.instructions;\n\t\til.append(Utility.createConversion(fact, BcelWorld.makeBcelType(e.getType()), desiredType));\n\t\treturn il;\n\t}\n\n\tpublic static InstructionList renderExprs(InstructionFactory fact, BcelWorld world, Expr[] es) {\n\t\tBcelRenderer renderer = new BcelRenderer(fact, world);\n\t\tfor (int i = es.length - 1; i >= 0; i--) {\n\t\t\tes[i].accept(renderer);\n\t\t}\n\t\treturn renderer.instructions;\n\t}\n\n\t/*\n\t * Get the instructions representing this test.\n\t *\n\t * @param e test to render\n\t *\n\t * @param sk instructionHandle to jump to if our rendered check succeeds (typically start of advice)\n\t *\n\t * @param fk instructionHandle to jump to if our rendered check fails (typically after end of advice)\n\t *\n\t * @param next instructionHandle that will follow this generated code. Passing in null will generate one unnecessary GOTO\n\t * instruction.\n\t *\n\t * @returns the instruction list representing this expression\n\t */\n\tpublic static InstructionList renderTest(InstructionFactory fact, BcelWorld world, Test e, InstructionHandle sk,\n\t\t\tInstructionHandle fk, InstructionHandle next) {\n\t\tBcelRenderer renderer = new BcelRenderer(fact, world);\n\t\trenderer.recur(e, sk, fk, next);\n\t\treturn renderer.instructions;\n\t}\n\n\t// ---- recurrers\n\n\tprivate void recur(Test e, InstructionHandle sk, InstructionHandle fk, InstructionHandle next) {\n\t\tthis.sk = sk;\n\t\tthis.fk = fk;\n\t\tthis.next = next;\n\t\te.accept(this);\n\t}\n\n\t// ---- test visitors\n\n\tpublic void visit(And e) {\n\t\tInstructionHandle savedFk = fk;\n\t\trecur(e.getRight(), sk, fk, next);\n\t\tInstructionHandle ning = instructions.getStart();\n\t\trecur(e.getLeft(), ning, savedFk, ning);\n\t}\n\n\tpublic void visit(Or e) {\n\t\tInstructionHandle savedSk = sk;\n\t\trecur(e.getRight(), sk, fk, next);\n\t\trecur(e.getLeft(), savedSk, instructions.getStart(), instructions.getStart());\n\t}\n\n\tpublic void visit(Not e) {\n\t\trecur(e.getBody(), fk, sk, next);\n\t}\n\n\tpublic void visit(Instanceof i) {\n\t\tinstructions.insert(createJumpBasedOnBooleanOnStack());\n\t\tinstructions.insert(Utility.createInstanceof(fact, (ReferenceType) BcelWorld.makeBcelType(i.getType())));\n\t\ti.getVar().accept(this);\n\t}\n\n\tpublic void visit(HasAnnotation hasAnnotation) {\n\t\t// in Java:\n\t\t// foo.class.isAnnotationPresent(annotationClass);\n\t\t// in bytecode:\n\n\t\t// ifnull? skip to the end if it is as getClass() will fail (see pr 257833)\n\n\t\t// load var onto the stack (done for us later)\n\t\t// invokevirtual java/lang/Object.getClass:()Ljava/lang/Class\n\t\t// ldc_w annotationClass\n\t\t// invokevirtual java/lang/Class.isAnnotationPresent:(Ljava/lang/Class;)Z\n\t\tInstructionList il = new InstructionList();\n\n\t\t// If it is null jump past the advice call\n\t\til.append(InstructionFactory.createBranchInstruction(Constants.IFNULL, fk));\n\n\t\t// Load up the var again\n\t\til.append(((BcelVar) hasAnnotation.getVar()).createLoad(fact));\n\n\t\tMember getClass = MemberImpl.method(UnresolvedType.OBJECT, 0, UnresolvedType.JL_CLASS, \"getClass\", UnresolvedType.NONE);\n\t\til.append(Utility.createInvoke(fact, world, getClass));\n\t\t// aload annotationClass\n\t\til.append(fact.createConstant(new ObjectType(hasAnnotation.getAnnotationType().getName())));\n\t\t// int annClassIndex = fact.getConstantPool().addClass(hasAnnotation.getAnnotationType().getSignature());\n\t\t// il.append(new LDC_W(annClassIndex));\n\t\tMember isAnnotationPresent = MemberImpl.method(UnresolvedType.JL_CLASS, 0, UnresolvedType.BOOLEAN, \"isAnnotationPresent\",\n\t\t\t\tnew UnresolvedType[] { UnresolvedType.JL_CLASS });\n\t\til.append(Utility.createInvoke(fact, world, isAnnotationPresent));\n\t\til.append(createJumpBasedOnBooleanOnStack());\n\t\tinstructions.insert(il);\n\t\thasAnnotation.getVar().accept(this);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see org.aspectj.weaver.ast.ITestVisitor#visit(org.aspectj.weaver.internal.tools.MatchingContextBasedTest)\n\t */\n\tpublic void visit(MatchingContextBasedTest matchingContextTest) {\n\t\tthrow new UnsupportedOperationException(\"matching context extension not supported in bytecode weaving\");\n\t}\n\n\tprivate InstructionList createJumpBasedOnBooleanOnStack() {\n\t\tInstructionList il = new InstructionList();\n\t\tif (sk == fk) {\n\t\t\t// don't bother generating if it doesn't matter\n\t\t\tif (sk != next) {\n\t\t\t\til.insert(InstructionFactory.createBranchInstruction(Constants.GOTO, sk));\n\t\t\t}\n\t\t\treturn il;\n\t\t}\n\n\t\tif (fk == next) {\n\t\t\til.insert(InstructionFactory.createBranchInstruction(Constants.IFNE, sk));\n\t\t} else if (sk == next) {\n\t\t\til.insert(InstructionFactory.createBranchInstruction(Constants.IFEQ, fk));\n\t\t} else {\n\t\t\til.insert(InstructionFactory.createBranchInstruction(Constants.GOTO, sk));\n\t\t\til.insert(InstructionFactory.createBranchInstruction(Constants.IFEQ, fk));\n\t\t}\n\t\treturn il;\n\t}\n\n\tpublic void visit(Literal literal) {\n\t\tif (literal == Literal.FALSE) {\n\t\t\tthrow new BCException(\"visiting a false expression\");\n\t\t}\n\t}\n\n\tpublic void visit(Call call) {\n\t\tMember method = call.getMethod();\n\t\t// assert method.isStatic()\n\t\tExpr[] args = call.getArgs();\n\t\tInstructionList callIl = new InstructionList();\n\t\tfor (int i = 0, len = args.length; i < len; i++) {\n\t\t\t// XXX only correct for static method calls\n\t\t\tType desiredType = BcelWorld.makeBcelType(method.getParameterTypes()[i]);\n\t\t\tExpr arg = args[i];\n\t\t\t// if arg is null it is because we couldn't bind it properly, for example see 162135\n\t\t\tif (arg == null) {\n\t\t\t\tInstructionList iList = new InstructionList();\n\t\t\t\tiList.append(InstructionFactory.createNull(desiredType));\n\t\t\t\tcallIl.append(iList);\n\t\t\t} else {\n\t\t\t\tcallIl.append(renderExpr(fact, world, arg, desiredType));\n\t\t\t}\n\t\t}\n\t\t// System.out.println(\"rendered args: \" + callIl);\n\t\tcallIl.append(Utility.createInvoke(fact, world, method));\n\t\tcallIl.append(createJumpBasedOnBooleanOnStack());\n\t\tinstructions.insert(callIl);\n\t}\n\n\tpublic void visit(FieldGetCall fieldGetCall) {\n\t\tMember field = fieldGetCall.getField();\n\t\tMember method = fieldGetCall.getMethod();\n\t\tInstructionList il = new InstructionList();\n\t\til.append(Utility.createGet(fact, field));\n\t\t// assert !method.isStatic()\n\t\tExpr[] args = fieldGetCall.getArgs();\n\t\t// System.out.println(\"args: \" + Arrays.asList(args));\n\t\til.append(renderExprs(fact, world, args));\n\t\t// System.out.println(\"rendered args: \" + callIl);\n\t\til.append(Utility.createInvoke(fact, world, method));\n\t\til.append(createJumpBasedOnBooleanOnStack());\n\t\tinstructions.insert(il);\n\t}\n\n\t// ---- expr visitors\n\n\tpublic void visit(Var var) {\n\t\tBcelVar bvar = (BcelVar) var;\n\t\tbvar.insertLoad(instructions, fact);\n\t}\n\n\tpublic void visit(FieldGet fieldGet) {\n\t\tMember field = fieldGet.getField();\n\t\t// assert field.isStatic()\n\t\tinstructions.insert(Utility.createGet(fact, field));\n\t}\n\n\tpublic void visit(CallExpr call) {\n\t\tMember method = call.getMethod();\n\t\t// assert method.isStatic()\n\t\tExpr[] args = call.getArgs();\n\t\tInstructionList callIl = renderExprs(fact, world, args);\n\t\tcallIl.append(Utility.createInvoke(fact, world, method));\n\t\tinstructions.insert(callIl);\n\t}\n\n}\n",
    "size": 9455
  },
  {
    "file_id": "F23",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelShadow.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n *     Alexandre Vasseur    support for @AJ aspects\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.apache.bcel.classfile.Field;\nimport org.aspectj.apache.bcel.generic.ArrayType;\nimport org.aspectj.apache.bcel.generic.BranchHandle;\nimport org.aspectj.apache.bcel.generic.FieldInstruction;\nimport org.aspectj.apache.bcel.generic.INVOKEINTERFACE;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionBranch;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionLV;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.InstructionTargeter;\nimport org.aspectj.apache.bcel.generic.InvokeInstruction;\nimport org.aspectj.apache.bcel.generic.LineNumberTag;\nimport org.aspectj.apache.bcel.generic.LocalVariableTag;\nimport org.aspectj.apache.bcel.generic.MULTIANEWARRAY;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.TargetLostException;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.AjcMemberMaker;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.ConcreteTypeMunger;\nimport org.aspectj.weaver.IntMap;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.MemberImpl;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.NewConstructorTypeMunger;\nimport org.aspectj.weaver.NewFieldTypeMunger;\nimport org.aspectj.weaver.NewMethodTypeMunger;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedMemberImpl;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeaverMessages;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.ast.Var;\nimport org.aspectj.weaver.patterns.AbstractPatternNodeVisitor;\nimport org.aspectj.weaver.patterns.AndPointcut;\nimport org.aspectj.weaver.patterns.NotPointcut;\nimport org.aspectj.weaver.patterns.OrPointcut;\nimport org.aspectj.weaver.patterns.ThisOrTargetPointcut;\n\n\n/*\n * Some fun implementation stuff:\n *\n *   * expressionKind advice is non-execution advice\n *     * may have a target.\n *     * if the body is extracted, it will be extracted into\n *       a static method.  The first argument to the static\n *       method is the target\n *     * advice may expose a this object, but that's the advice's\n *       consideration, not ours.  This object will NOT be cached in another\n *       local, but will always come from frame zero.\n *\n *   * non-expressionKind advice is execution advice\n *     * may have a this.\n *     * target is same as this, and is exposed that way to advice\n *       (i.e., target will not be cached, will always come from frame zero)\n *     * if the body is extracted, it will be extracted into a method\n *       with same static/dynamic modifier as enclosing method.  If non-static,\n *       target of callback call will be this.\n *\n *   * because of these two facts, the setup of the actual arguments (including\n *     possible target) callback method is the same for both kinds of advice:\n *     push the targetVar, if it exists (it will not exist for advice on static\n *     things), then push all the argVars.\n *\n * Protected things:\n *\n *   * the above is sufficient for non-expressionKind advice for protected things,\n *     since the target will always be this.\n *\n *   * For expressionKind things, we have to modify the signature of the callback\n *     method slightly.  For non-static expressionKind things, we modify\n *     the first argument of the callback method NOT to be the type specified\n *     by the method/field signature (the owner), but rather we type it to\n *     the currentlyEnclosing type. We are guaranteed this will be fine,\n *     since the verifier verifies that the target is a subtype of the currently\n *     enclosingType.\n *\n * Worries:\n *\n *    * ConstructorCalls will be weirder than all of these, since they\n *      supposedly don't have a target (according to AspectJ), but they clearly\n *      do have a target of sorts, just one that needs to be pushed on the stack,\n *      dupped, and not touched otherwise until the constructor runs.\n *\n * @author Jim Hugunin\n * @author Erik Hilsdale\n *\n */\n\npublic class BcelShadow extends Shadow {\n\n\tprivate static final String[] NoDeclaredExceptions = new String[0];\n\n\tprivate ShadowRange range;\n\tprivate final BcelWorld world;\n\tprivate final LazyMethodGen enclosingMethod;\n\n\t// TESTING this will tell us if the optimisation succeeded *on the last shadow processed*\n\tpublic static boolean appliedLazyTjpOptimization;\n\n\t// Some instructions have a target type that will vary\n\t// from the signature (pr109728) (1.4 declaring type issue)\n\tprivate String actualInstructionTargetType;\n\n\t/**\n\t * This generates an unassociated shadow, rooted in a particular method but not rooted to any particular point in the code. It\n\t * should be given to a rooted ShadowRange in the {@link ShadowRange#associateWithShadow(BcelShadow)} method.\n\t */\n\tpublic BcelShadow(BcelWorld world, Kind kind, Member signature, LazyMethodGen enclosingMethod, BcelShadow enclosingShadow) {\n\t\tsuper(kind, signature, enclosingShadow);\n\t\tthis.world = world;\n\t\tthis.enclosingMethod = enclosingMethod;\n\t}\n\n\t// ---- copies all state, including Shadow's mungers...\n\n\tpublic BcelShadow copyInto(LazyMethodGen recipient, BcelShadow enclosing) {\n\t\tBcelShadow s = new BcelShadow(world, getKind(), getSignature(), recipient, enclosing);\n\t\tif (mungers.size() > 0) {\n\t\t\tList<ShadowMunger> src = mungers;\n\t\t\tif (s.mungers == Collections.EMPTY_LIST) {\n\t\t\t\ts.mungers = new ArrayList<>();\n\t\t\t}\n\t\t\tList<ShadowMunger> dest = s.mungers;\n\t\t\tfor (ShadowMunger shadowMunger : src) {\n\t\t\t\tdest.add(shadowMunger);\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t// ---- overridden behaviour\n\n\t@Override\n\tpublic World getIWorld() {\n\t\treturn world;\n\t}\n\n\t// see comment in deleteNewAndDup\n\t// } else if (inst.opcode == Constants.DUP_X2) {\n\t// // This code seen in the wild (by Brad):\n\t// // 40: new #12; //class java/lang/StringBuffer\n\t// // STACK: STRINGBUFFER\n\t// // 43: dup\n\t// // STACK: STRINGBUFFER/STRINGBUFFER\n\t// // 44: aload_0\n\t// // STACK: STRINGBUFFER/STRINGBUFFER/THIS\n\t// // 45: dup_x2\n\t// // STACK: THIS/STRINGBUFFER/STRINGBUFFER/THIS\n\t// // 46: getfield #36; //Field value:Ljava/lang/String;\n\t// // STACK: THIS/STRINGBUFFER/STRINGBUFFER/STRING<value>\n\t// // 49: invokestatic #37; //Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String;\n\t// // STACK: THIS/STRINGBUFFER/STRINGBUFFER/STRING\n\t// // 52: invokespecial #19; //Method java/lang/StringBuffer.\"<init>\":(Ljava/lang/String;)V\n\t// // STACK: THIS/STRINGBUFFER\n\t// // 55: aload_1\n\t// // STACK: THIS/STRINGBUFFER/LOCAL1\n\t// // 56: invokevirtual #22; //Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;\n\t// // STACK: THIS/STRINGBUFFER\n\t// // 59: invokevirtual #34; //Method java/lang/StringBuffer.toString:()Ljava/lang/String;\n\t// // STACK: THIS/STRING\n\t// // 62: putfield #36; //Field value:Ljava/lang/String;\n\t// // STACK: <empty>\n\t// // 65: return\n\t//\n\t// // if we attempt to match on the ctor call to StringBuffer.<init> then we get into trouble.\n\t// // if we simply delete the new/dup pair without fixing up the dup_x2 then the dup_x2 will fail due to there\n\t// // not being 3 elements on the stack for it to work with. The fix *in this situation* is to change it to\n\t// // a simple 'dup'\n\t//\n\t// // this fix is *not* very clean - but a general purpose decent solution will take much longer and this\n\t// // bytecode sequence has only been seen once in the wild.\n\t// ih.setInstruction(InstructionConstants.DUP);\n\n\t/**\n\t * The new/dup (or new/dup_x1/swap) are removed and will be readded later (after the advice call) by the caller of this method.\n\t * The groovy compiler produces unusual code where the new/dup isn't visible (when making a this() call from an existing ctor),\n\t * an aload_0 is used to load the uninitialized object (as an example see the ctors in grails.util.BuildSettings).\n\t *\n\t * @return true if managed to remove them\n\t */\n\tprivate boolean deleteNewAndDup() {\n\t\tfinal ConstantPool cpool = getEnclosingClass().getConstantPool();\n\t\tint depth = 1;\n\t\tInstructionHandle ih = range.getStart();\n\n\t\t// Go back from where we are looking for 'NEW' that takes us to a stack depth of 0. INVOKESPECIAL <init>\n\t\twhile (ih != null) {\n\t\t\tInstruction inst = ih.getInstruction();\n\t\t\tif (inst.opcode == Constants.INVOKESPECIAL && ((InvokeInstruction) inst).getName(cpool).equals(\"<init>\")) {\n\t\t\t\tdepth++;\n\t\t\t} else if (inst.opcode == Constants.NEW) {\n\t\t\t\tdepth--;\n\t\t\t\tif (depth == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// need a testcase to show this can really happen in a modern compiler - removed due to 315398 - moved this out to\n\t\t\t\t// comment proceeding this method:\n\n\t\t\t}\n\t\t\tih = ih.getPrev();\n\t\t}\n\t\tif (ih == null) {\n\t\t\treturn false;\n\t\t}\n\t\t// now IH points to the NEW. We're followed by the DUP, and that is followed\n\t\t// by the actual instruction we care about.\n\t\tInstructionHandle newHandle = ih;\n\t\tInstructionHandle endHandle = newHandle.getNext();\n\t\tInstructionHandle nextHandle;\n\t\tif (endHandle.getInstruction().opcode == Constants.DUP) {\n\t\t\tnextHandle = endHandle.getNext();\n\t\t\tretargetFrom(newHandle, nextHandle);\n\t\t\tretargetFrom(endHandle, nextHandle);\n\t\t} else if (endHandle.getInstruction().opcode == Constants.DUP_X1) {\n\t\t\tInstructionHandle dupHandle = endHandle;\n\t\t\tendHandle = endHandle.getNext();\n\t\t\tnextHandle = endHandle.getNext();\n\t\t\tboolean skipEndRepositioning = false;\n\t\t\tif (endHandle.getInstruction().opcode == Constants.SWAP) {\n\t\t\t} else if (endHandle.getInstruction().opcode == Constants.IMPDEP1) {\n\t\t\t\tskipEndRepositioning = true; // pr186884\n\t\t\t} else {\n\t\t\t\t// XXX see next XXX comment\n\t\t\t\tthrow new RuntimeException(\"Unhandled kind of new \" + endHandle);\n\t\t\t}\n\t\t\t// Now make any jumps to the 'new', the 'dup' or the 'end' now target the nextHandle\n\t\t\tretargetFrom(newHandle, nextHandle);\n\t\t\tretargetFrom(dupHandle, nextHandle);\n\t\t\tif (!skipEndRepositioning) {\n\t\t\t\tretargetFrom(endHandle, nextHandle);\n\t\t\t}\n\t\t} else {\n\t\t\tendHandle = newHandle;\n\t\t\tnextHandle = endHandle.getNext();\n\t\t\tretargetFrom(newHandle, nextHandle);\n\t\t\t// add a POP here... we found a NEW w/o a dup or anything else, so\n\t\t\t// we must be in statement context.\n\t\t\tgetRange().insert(InstructionConstants.POP, Range.OutsideAfter);\n\t\t}\n\t\t// assert (dupHandle.getInstruction() instanceof DUP);\n\n\t\ttry {\n\t\t\trange.getBody().delete(newHandle, endHandle);\n\t\t} catch (TargetLostException e) {\n\t\t\tthrow new BCException(\"shouldn't happen\");\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void retargetFrom(InstructionHandle old, InstructionHandle fresh) {\n\t\tfor (InstructionTargeter targeter : old.getTargetersCopy()) {\n\t\t\tif (targeter instanceof ExceptionRange) {\n\t\t\t\tExceptionRange it = (ExceptionRange) targeter;\n\t\t\t\tit.updateTarget(old, fresh, it.getBody());\n\t\t\t} else {\n\t\t\t\ttargeter.updateTarget(old, fresh);\n\t\t\t}\n\t\t}\n\t}\n\n\t// records advice that is stopping us doing the lazyTjp optimization\n\tprivate List<BcelAdvice> badAdvice = null;\n\n\tpublic void addAdvicePreventingLazyTjp(BcelAdvice advice) {\n\t\tif (badAdvice == null) {\n\t\t\tbadAdvice = new ArrayList<>();\n\t\t}\n\t\tbadAdvice.add(advice);\n\t}\n\n\t@Override\n\tprotected void prepareForMungers() {\n\t\t// if we're a constructor call, we need to remove the new:dup or the new:dup_x1:swap,\n\t\t// and store all our arguments on the frame.\n\n\t\t// ??? This is a bit of a hack (for the Java langauge). We do this because\n\t\t// we sometime add code \"outsideBefore\" when dealing with weaving join points. We only\n\t\t// do this for exposing state that is on the stack. It turns out to just work for\n\t\t// everything except for constructor calls and exception handlers. If we were to clean\n\t\t// this up, every ShadowRange would have three instructionHandle points, the start of\n\t\t// the arg-setup code, the start of the running code, and the end of the running code.\n\t\tboolean deletedNewAndDup = true;\n\t\tif (getKind() == ConstructorCall) {\n\t\t\tif (!world.isJoinpointArrayConstructionEnabled() || !this.getSignature().getDeclaringType().isArray()) {\n\t\t\t\tdeletedNewAndDup = deleteNewAndDup(); // no new/dup for new array construction\n\t\t\t}\n\t\t\tinitializeArgVars();\n\t\t} else if (getKind() == PreInitialization) { // pr74952\n\t\t\tShadowRange range = getRange();\n\t\t\trange.insert(InstructionConstants.NOP, Range.InsideAfter);\n\t\t} else if (getKind() == ExceptionHandler) {\n\n\t\t\tShadowRange range = getRange();\n\t\t\tInstructionList body = range.getBody();\n\t\t\tInstructionHandle start = range.getStart();\n\n\t\t\t// Create a store instruction to put the value from the top of the\n\t\t\t// stack into a local variable slot. This is a trimmed version of\n\t\t\t// what is in initializeArgVars() (since there is only one argument\n\t\t\t// at a handler jp and only before advice is supported) (pr46298)\n\t\t\targVars = new BcelVar[1];\n\t\t\t// int positionOffset = (hasTarget() ? 1 : 0) + ((hasThis() && !getKind().isTargetSameAsThis()) ? 1 : 0);\n\t\t\tUnresolvedType tx = getArgType(0);\n\t\t\targVars[0] = genTempVar(tx, \"ajc$arg0\");\n\t\t\tInstructionHandle insertedInstruction = range.insert(argVars[0].createStore(getFactory()), Range.OutsideBefore);\n\n\t\t\t// Now the exception range starts just after our new instruction.\n\t\t\t// The next bit of code changes the exception range to point at\n\t\t\t// the store instruction\n\t\t\tfor (InstructionTargeter t : start.getTargetersCopy()) {\n\t\t\t\tif (t instanceof ExceptionRange) {\n\t\t\t\t\tExceptionRange er = (ExceptionRange) t;\n\t\t\t\t\ter.updateTarget(start, insertedInstruction, body);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// now we ask each munger to request our state\n\t\tisThisJoinPointLazy = true;// world.isXlazyTjp(); // lazy is default now\n\n\t\tbadAdvice = null;\n\t\tfor (ShadowMunger munger : mungers) {\n\t\t\tmunger.specializeOn(this);\n\t\t}\n\n\t\tinitializeThisJoinPoint();\n\n\t\tif (thisJoinPointVar != null && !isThisJoinPointLazy && badAdvice != null && badAdvice.size() > 1) {\n\t\t\t// something stopped us making it a lazy tjp\n\t\t\t// can't build tjp lazily, no suitable test...\n\t\t\tint valid = 0;\n\t\t\tfor (BcelAdvice element : badAdvice) {\n\t\t\t\tISourceLocation sLoc = element.getSourceLocation();\n\t\t\t\tif (sLoc != null && sLoc.getLine() > 0) {\n\t\t\t\t\tvalid++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valid != 0) {\n\t\t\t\tISourceLocation[] badLocs = new ISourceLocation[valid];\n\t\t\t\tint i = 0;\n\t\t\t\tfor (BcelAdvice element : badAdvice) {\n\t\t\t\t\tISourceLocation sLoc = element.getSourceLocation();\n\t\t\t\t\tif (sLoc != null && sLoc.getLine() > 0) {\n\t\t\t\t\t\tbadLocs[i++] = sLoc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworld.getLint().multipleAdviceStoppingLazyTjp\n\t\t\t\t\t\t.signal(new String[] { this.toString() }, getSourceLocation(), badLocs);\n\t\t\t}\n\t\t}\n\t\tbadAdvice = null;\n\n\t\t// If we are an expression kind, we require our target/arguments on the stack\n\t\t// before we do our actual thing. However, they may have been removed\n\t\t// from the stack as the shadowMungers have requested state.\n\t\t// if any of our shadowMungers requested either the arguments or target,\n\t\t// the munger will have added code\n\t\t// to pop the target/arguments into temporary variables, represented by\n\t\t// targetVar and argVars. In such a case, we must make sure to re-push the\n\t\t// values.\n\n\t\t// If we are nonExpressionKind, we don't expect arguments on the stack\n\t\t// so this is moot. If our argVars happen to be null, then we know that\n\t\t// no ShadowMunger has squirrelled away our arguments, so they're still\n\t\t// on the stack.\n\t\tInstructionFactory fact = getFactory();\n\t\tif (getKind().argsOnStack() && argVars != null) {\n\n\t\t\t// Special case first (pr46298). If we are an exception handler and the instruction\n\t\t\t// just after the shadow is a POP then we should remove the pop. The code\n\t\t\t// above which generated the store instruction has already cleared the stack.\n\t\t\t// We also don't generate any code for the arguments in this case as it would be\n\t\t\t// an incorrect aload.\n\t\t\tif (getKind() == ExceptionHandler && range.getEnd().getNext().getInstruction().equals(InstructionConstants.POP)) {\n\t\t\t\t// easier than deleting it ...\n\t\t\t\trange.getEnd().getNext().setInstruction(InstructionConstants.NOP);\n\t\t\t} else {\n\t\t\t\trange.insert(BcelRenderer.renderExprs(fact, world, argVars), Range.InsideBefore);\n\t\t\t\tif (targetVar != null) {\n\t\t\t\t\trange.insert(BcelRenderer.renderExpr(fact, world, targetVar), Range.InsideBefore);\n\t\t\t\t}\n\t\t\t\tif (getKind() == ConstructorCall) {\n\t\t\t\t\tif (!world.isJoinpointArrayConstructionEnabled() || !this.getSignature().getDeclaringType().isArray()) {\n\t\t\t\t\t\tif (deletedNewAndDup) { // if didnt delete them, dont insert any!\n\t\t\t\t\t\t\trange.insert(InstructionFactory.createDup(1), Range.InsideBefore);\n\t\t\t\t\t\t\trange.insert(fact.createNew((ObjectType) BcelWorld.makeBcelType(getSignature().getDeclaringType())),\n\t\t\t\t\t\t\t\t\tRange.InsideBefore);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ---- getters\n\n\tpublic ShadowRange getRange() {\n\t\treturn range;\n\t}\n\n\tpublic void setRange(ShadowRange range) {\n\t\tthis.range = range;\n\t}\n\n\tprivate int sourceline = -1;\n\n\tpublic int getSourceLine() {\n\t\t// if the kind of join point for which we are a shadow represents\n\t\t// a method or constructor execution, then the best source line is\n\t\t// the one from the enclosingMethod declarationLineNumber if available.\n\t\tif (sourceline != -1) {\n\t\t\treturn sourceline;\n\t\t}\n\t\tKind kind = getKind();\n\t\tif ((kind == MethodExecution) || (kind == ConstructorExecution) || (kind == AdviceExecution)\n\t\t\t\t|| (kind == StaticInitialization) || (kind == PreInitialization) || (kind == Initialization)) {\n\t\t\tif (getEnclosingMethod().hasDeclaredLineNumberInfo()) {\n\t\t\t\tsourceline = getEnclosingMethod().getDeclarationLineNumber();\n\t\t\t\treturn sourceline;\n\t\t\t}\n\t\t}\n\n\t\tif (range == null) {\n\t\t\tif (getEnclosingMethod().hasBody()) {\n\t\t\t\tsourceline = Utility.getSourceLine(getEnclosingMethod().getBody().getStart());\n\t\t\t\treturn sourceline;\n\t\t\t} else {\n\t\t\t\tsourceline = 0;\n\t\t\t\treturn sourceline;\n\t\t\t}\n\t\t}\n\t\tsourceline = Utility.getSourceLine(range.getStart());\n\t\tif (sourceline < 0) {\n\t\t\tsourceline = 0;\n\t\t}\n\t\treturn sourceline;\n\t}\n\n\t@Override\n\tpublic ResolvedType getEnclosingType() {\n\t\treturn getEnclosingClass().getType();\n\t}\n\n\tpublic LazyClassGen getEnclosingClass() {\n\t\treturn enclosingMethod.getEnclosingClass();\n\t}\n\n\tpublic BcelWorld getWorld() {\n\t\treturn world;\n\t}\n\n\t// ---- factory methods\n\n\tpublic static BcelShadow makeConstructorExecution(BcelWorld world, LazyMethodGen enclosingMethod,\n\t\t\tInstructionHandle justBeforeStart) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tBcelShadow s = new BcelShadow(world, ConstructorExecution, world.makeJoinPointSignatureFromMethod(enclosingMethod,\n\t\t\t\tMember.CONSTRUCTOR), enclosingMethod, null);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body, justBeforeStart.getNext()), Range.genEnd(body));\n\t\treturn s;\n\t}\n\n\tpublic static BcelShadow makeStaticInitialization(BcelWorld world, LazyMethodGen enclosingMethod) {\n\t\tInstructionList body = enclosingMethod.getBody();\n\t\t// move the start past ajc$preClinit\n\t\tInstructionHandle clinitStart = body.getStart();\n\t\tif (clinitStart.getInstruction() instanceof InvokeInstruction) {\n\t\t\tInvokeInstruction ii = (InvokeInstruction) clinitStart.getInstruction();\n\t\t\tif (ii.getName(enclosingMethod.getEnclosingClass().getConstantPool()).equals(NameMangler.AJC_PRE_CLINIT_NAME)) {\n\t\t\t\tclinitStart = clinitStart.getNext();\n\t\t\t}\n\t\t}\n\n\t\tInstructionHandle clinitEnd = body.getEnd();\n\n\t\t// XXX should move the end before the postClinit, but the return is then tricky...\n\t\t// if (clinitEnd.getInstruction() instanceof InvokeInstruction) {\n\t\t// InvokeInstruction ii = (InvokeInstruction)clinitEnd.getInstruction();\n\t\t// if (ii.getName(enclosingMethod.getEnclosingClass().getConstantPool()).equals(NameMangler.AJC_POST_CLINIT_NAME)) {\n\t\t// clinitEnd = clinitEnd.getPrev();\n\t\t// }\n\t\t// }\n\n\t\tBcelShadow s = new BcelShadow(world, StaticInitialization, world.makeJoinPointSignatureFromMethod(enclosingMethod,\n\t\t\t\tMember.STATIC_INITIALIZATION), enclosingMethod, null);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body, clinitStart), Range.genEnd(body, clinitEnd));\n\t\treturn s;\n\t}\n\n\t/**\n\t * Make the shadow for an exception handler. Currently makes an empty shadow that only allows before advice to be woven into it.\n\t */\n\n\tpublic static BcelShadow makeExceptionHandler(BcelWorld world, ExceptionRange exceptionRange, LazyMethodGen enclosingMethod,\n\t\t\tInstructionHandle startOfHandler, BcelShadow enclosingShadow) {\n\t\tInstructionList body = enclosingMethod.getBody();\n\t\tUnresolvedType catchType = exceptionRange.getCatchType();\n\t\tUnresolvedType inType = enclosingMethod.getEnclosingClass().getType();\n\n\t\tResolvedMemberImpl sig = MemberImpl.makeExceptionHandlerSignature(inType, catchType);\n\t\tsig.setParameterNames(new String[] { findHandlerParamName(startOfHandler) });\n\n\t\tBcelShadow s = new BcelShadow(world, ExceptionHandler, sig, enclosingMethod, enclosingShadow);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tInstructionHandle start = Range.genStart(body, startOfHandler);\n\t\tInstructionHandle end = Range.genEnd(body, start);\n\n\t\tr.associateWithTargets(start, end);\n\t\texceptionRange.updateTarget(startOfHandler, start, body);\n\t\treturn s;\n\t}\n\n\tprivate static String findHandlerParamName(InstructionHandle startOfHandler) {\n\t\tif (startOfHandler.getInstruction().isStoreInstruction() && startOfHandler.getNext() != null) {\n\t\t\tint slot = startOfHandler.getInstruction().getIndex();\n\t\t\t// System.out.println(\"got store: \" + startOfHandler.getInstruction() + \", \" + index);\n\t\t\tfor (InstructionTargeter targeter : startOfHandler.getNext().getTargeters()) {\n\t\t\t\tif (targeter instanceof LocalVariableTag) {\n\t\t\t\t\tLocalVariableTag t = (LocalVariableTag) targeter;\n\t\t\t\t\tif (t.getSlot() == slot) {\n\t\t\t\t\t\treturn t.getName();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn \"<missing>\";\n\t}\n\n\t/** create an init join point associated w/ an interface in the body of a constructor */\n\n\tpublic static BcelShadow makeIfaceInitialization(BcelWorld world, LazyMethodGen constructor,\n\t\t\tMember interfaceConstructorSignature) {\n\t\t// this call marks the instruction list as changed\n\t\tconstructor.getBody();\n\t\t// UnresolvedType inType = constructor.getEnclosingClass().getType();\n\t\tBcelShadow s = new BcelShadow(world, Initialization, interfaceConstructorSignature, constructor, null);\n\t\t// s.fallsThrough = true;\n\t\t// ShadowRange r = new ShadowRange(body);\n\t\t// r.associateWithShadow(s);\n\t\t// InstructionHandle start = Range.genStart(body, handle);\n\t\t// InstructionHandle end = Range.genEnd(body, handle);\n\t\t//\n\t\t// r.associateWithTargets(start, end);\n\t\treturn s;\n\t}\n\n\tpublic void initIfaceInitializer(InstructionHandle end) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(this);\n\t\tInstructionHandle nop = body.insert(end, InstructionConstants.NOP);\n\n\t\tr.associateWithTargets(Range.genStart(body, nop), Range.genEnd(body, nop));\n\t}\n\n\t// public static BcelShadow makeIfaceConstructorExecution(\n\t// BcelWorld world,\n\t// LazyMethodGen constructor,\n\t// InstructionHandle next,\n\t// Member interfaceConstructorSignature)\n\t// {\n\t// // final InstructionFactory fact = constructor.getEnclosingClass().getFactory();\n\t// InstructionList body = constructor.getBody();\n\t// // UnresolvedType inType = constructor.getEnclosingClass().getType();\n\t// BcelShadow s =\n\t// new BcelShadow(\n\t// world,\n\t// ConstructorExecution,\n\t// interfaceConstructorSignature,\n\t// constructor,\n\t// null);\n\t// s.fallsThrough = true;\n\t// ShadowRange r = new ShadowRange(body);\n\t// r.associateWithShadow(s);\n\t// // ??? this may or may not work\n\t// InstructionHandle start = Range.genStart(body, next);\n\t// //InstructionHandle end = Range.genEnd(body, body.append(start, fact.NOP));\n\t// InstructionHandle end = Range.genStart(body, next);\n\t// //body.append(start, fact.NOP);\n\t//\n\t// r.associateWithTargets(start, end);\n\t// return s;\n\t// }\n\n\t/**\n\t * Create an initialization join point associated with a constructor, but not with any body of code yet. If this is actually\n\t * matched, its range will be set when we inline self constructors.\n\t *\n\t * @param constructor The constructor starting this initialization.\n\t */\n\tpublic static BcelShadow makeUnfinishedInitialization(BcelWorld world, LazyMethodGen constructor) {\n\t\tBcelShadow ret = new BcelShadow(world, Initialization, world.makeJoinPointSignatureFromMethod(constructor,\n\t\t\t\tMember.CONSTRUCTOR), constructor, null);\n\t\tif (constructor.getEffectiveSignature() != null) {\n\t\t\tret.setMatchingSignature(constructor.getEffectiveSignature().getEffectiveSignature());\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static BcelShadow makeUnfinishedPreinitialization(BcelWorld world, LazyMethodGen constructor) {\n\t\tBcelShadow ret = new BcelShadow(world, PreInitialization, world.makeJoinPointSignatureFromMethod(constructor,\n\t\t\t\tMember.CONSTRUCTOR), constructor, null);\n\t\tif (constructor.getEffectiveSignature() != null) {\n\t\t\tret.setMatchingSignature(constructor.getEffectiveSignature().getEffectiveSignature());\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static BcelShadow makeMethodExecution(BcelWorld world, LazyMethodGen enclosingMethod, boolean lazyInit) {\n\t\tif (!lazyInit) {\n\t\t\treturn makeMethodExecution(world, enclosingMethod);\n\t\t}\n\n\t\tBcelShadow s = new BcelShadow(world, MethodExecution, enclosingMethod.getMemberView(), enclosingMethod, null);\n\n\t\treturn s;\n\t}\n\n\tpublic void init() {\n\t\tif (range != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(this);\n\t\tr.associateWithTargets(Range.genStart(body), Range.genEnd(body));\n\t}\n\n\tpublic static BcelShadow makeMethodExecution(BcelWorld world, LazyMethodGen enclosingMethod) {\n\t\treturn makeShadowForMethod(world, enclosingMethod, MethodExecution, enclosingMethod.getMemberView());\n\t}\n\n\tpublic static BcelShadow makeShadowForMethod(BcelWorld world, LazyMethodGen enclosingMethod, Shadow.Kind kind, Member sig) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tBcelShadow s = new BcelShadow(world, kind, sig, enclosingMethod, null);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(// OPTIMIZE this occurs lots of times for all jp kinds...\n\t\t\t\tRange.genStart(body), Range.genEnd(body));\n\t\treturn s;\n\t}\n\n\tpublic static BcelShadow makeAdviceExecution(BcelWorld world, LazyMethodGen enclosingMethod) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tBcelShadow s = new BcelShadow(world, AdviceExecution,\n\t\t\t\tworld.makeJoinPointSignatureFromMethod(enclosingMethod, Member.ADVICE), enclosingMethod, null);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body), Range.genEnd(body));\n\t\treturn s;\n\t}\n\n\t// constructor call shadows are <em>initially</em> just around the\n\t// call to the constructor. If ANY advice gets put on it, we move\n\t// the NEW instruction inside the join point, which involves putting\n\t// all the arguments in temps.\n\tpublic static BcelShadow makeConstructorCall(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle callHandle,\n\t\t\tBcelShadow enclosingShadow) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\n\t\tMember sig = world.makeJoinPointSignatureForMethodInvocation(enclosingMethod.getEnclosingClass(),\n\t\t\t\t(InvokeInstruction) callHandle.getInstruction());\n\n\t\tBcelShadow s = new BcelShadow(world, ConstructorCall, sig, enclosingMethod, enclosingShadow);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body, callHandle), Range.genEnd(body, callHandle));\n\t\tretargetAllBranches(callHandle, r.getStart());\n\t\treturn s;\n\t}\n\n\tpublic static BcelShadow makeArrayConstructorCall(BcelWorld world, LazyMethodGen enclosingMethod,\n\t\t\tInstructionHandle arrayInstruction, BcelShadow enclosingShadow) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tMember sig = world.makeJoinPointSignatureForArrayConstruction(enclosingMethod.getEnclosingClass(), arrayInstruction);\n\t\tBcelShadow s = new BcelShadow(world, ConstructorCall, sig, enclosingMethod, enclosingShadow);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body, arrayInstruction), Range.genEnd(body, arrayInstruction));\n\t\tretargetAllBranches(arrayInstruction, r.getStart());\n\t\treturn s;\n\t}\n\n\tpublic static BcelShadow makeMonitorEnter(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle monitorInstruction,\n\t\t\tBcelShadow enclosingShadow) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tMember sig = world.makeJoinPointSignatureForMonitorEnter(enclosingMethod.getEnclosingClass(), monitorInstruction);\n\t\tBcelShadow s = new BcelShadow(world, SynchronizationLock, sig, enclosingMethod, enclosingShadow);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body, monitorInstruction), Range.genEnd(body, monitorInstruction));\n\t\tretargetAllBranches(monitorInstruction, r.getStart());\n\t\treturn s;\n\t}\n\n\tpublic static BcelShadow makeMonitorExit(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle monitorInstruction,\n\t\t\tBcelShadow enclosingShadow) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tMember sig = world.makeJoinPointSignatureForMonitorExit(enclosingMethod.getEnclosingClass(), monitorInstruction);\n\t\tBcelShadow s = new BcelShadow(world, SynchronizationUnlock, sig, enclosingMethod, enclosingShadow);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body, monitorInstruction), Range.genEnd(body, monitorInstruction));\n\t\tretargetAllBranches(monitorInstruction, r.getStart());\n\t\treturn s;\n\t}\n\n\t// see pr77166\n\t// public static BcelShadow makeArrayLoadCall(\n\t// BcelWorld world,\n\t// LazyMethodGen enclosingMethod,\n\t// InstructionHandle arrayInstruction,\n\t// BcelShadow enclosingShadow)\n\t// {\n\t// final InstructionList body = enclosingMethod.getBody();\n\t// Member sig = world.makeJoinPointSignatureForArrayLoad(enclosingMethod.getEnclosingClass(),arrayInstruction);\n\t// BcelShadow s =\n\t// new BcelShadow(\n\t// world,\n\t// MethodCall,\n\t// sig,\n\t// enclosingMethod,\n\t// enclosingShadow);\n\t// ShadowRange r = new ShadowRange(body);\n\t// r.associateWithShadow(s);\n\t// r.associateWithTargets(\n\t// Range.genStart(body, arrayInstruction),\n\t// Range.genEnd(body, arrayInstruction));\n\t// retargetAllBranches(arrayInstruction, r.getStart());\n\t// return s;\n\t// }\n\n\tpublic static BcelShadow makeMethodCall(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle callHandle,\n\t\t\tBcelShadow enclosingShadow) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tBcelShadow s = new BcelShadow(world, MethodCall, world.makeJoinPointSignatureForMethodInvocation(\n\t\t\t\tenclosingMethod.getEnclosingClass(), (InvokeInstruction) callHandle.getInstruction()), enclosingMethod,\n\t\t\t\tenclosingShadow);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body, callHandle), Range.genEnd(body, callHandle));\n\t\tretargetAllBranches(callHandle, r.getStart());\n\t\treturn s;\n\t}\n\n\tpublic static BcelShadow makeShadowForMethodCall(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle callHandle,\n\t\t\tBcelShadow enclosingShadow, Kind kind, ResolvedMember sig) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tBcelShadow s = new BcelShadow(world, kind, sig, enclosingMethod, enclosingShadow);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body, callHandle), Range.genEnd(body, callHandle));\n\t\tretargetAllBranches(callHandle, r.getStart());\n\t\treturn s;\n\t}\n\n\tpublic static BcelShadow makeFieldGet(BcelWorld world, ResolvedMember field, LazyMethodGen enclosingMethod,\n\t\t\tInstructionHandle getHandle, BcelShadow enclosingShadow) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tBcelShadow s = new BcelShadow(world, FieldGet, field,\n\t\t// BcelWorld.makeFieldSignature(\n\t\t// enclosingMethod.getEnclosingClass(),\n\t\t// (FieldInstruction) getHandle.getInstruction()),\n\t\t\t\tenclosingMethod, enclosingShadow);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body, getHandle), Range.genEnd(body, getHandle));\n\t\tretargetAllBranches(getHandle, r.getStart());\n\t\treturn s;\n\t}\n\n\tpublic static BcelShadow makeFieldSet(BcelWorld world, ResolvedMember field, LazyMethodGen enclosingMethod,\n\t\t\tInstructionHandle setHandle, BcelShadow enclosingShadow) {\n\t\tfinal InstructionList body = enclosingMethod.getBody();\n\t\tBcelShadow s = new BcelShadow(world, FieldSet, field,\n\t\t// BcelWorld.makeFieldJoinPointSignature(\n\t\t// enclosingMethod.getEnclosingClass(),\n\t\t// (FieldInstruction) setHandle.getInstruction()),\n\t\t\t\tenclosingMethod, enclosingShadow);\n\t\tShadowRange r = new ShadowRange(body);\n\t\tr.associateWithShadow(s);\n\t\tr.associateWithTargets(Range.genStart(body, setHandle), Range.genEnd(body, setHandle));\n\t\tretargetAllBranches(setHandle, r.getStart());\n\t\treturn s;\n\t}\n\n\tpublic static void retargetAllBranches(InstructionHandle from, InstructionHandle to) {\n\t\tfor (InstructionTargeter source : from.getTargetersCopy()) {\n\t\t\tif (source instanceof InstructionBranch) {\n\t\t\t\tsource.updateTarget(from, to);\n\t\t\t}\n\t\t}\n\t}\n\n\t// // ---- type access methods\n\t// private ObjectType getTargetBcelType() {\n\t// return (ObjectType) BcelWorld.makeBcelType(getTargetType());\n\t// }\n\t// private Type getArgBcelType(int arg) {\n\t// return BcelWorld.makeBcelType(getArgType(arg));\n\t// }\n\n\t// ---- kinding\n\n\t/**\n\t * If the end of my range has no real instructions following then my context needs a return at the end.\n\t */\n\tpublic boolean terminatesWithReturn() {\n\t\treturn getRange().getRealNext() == null;\n\t}\n\n\t/**\n\t * Is arg0 occupied with the value of this\n\t */\n\tpublic boolean arg0HoldsThis() {\n\t\tif (getKind().isEnclosingKind()) {\n\t\t\treturn !Modifier.isStatic(getSignature().getModifiers());\n\t\t} else if (enclosingShadow == null) {\n\t\t\t// XXX this is mostly right\n\t\t\t// this doesn't do the right thing for calls in the pre part of introduced constructors.\n\t\t\treturn !enclosingMethod.isStatic();\n\t\t} else {\n\t\t\treturn ((BcelShadow) enclosingShadow).arg0HoldsThis();\n\t\t}\n\t}\n\n\t// ---- argument getting methods\n\n\tprivate BcelVar thisVar = null;\n\tprivate BcelVar targetVar = null;\n\tprivate BcelVar[] argVars = null;\n\tprivate Map<ResolvedType, AnnotationAccessVar> kindedAnnotationVars = null;\n\tprivate Map<ResolvedType, TypeAnnotationAccessVar> thisAnnotationVars = null;\n\tprivate Map<ResolvedType, TypeAnnotationAccessVar> targetAnnotationVars = null;\n\t// private Map/* <UnresolvedType,BcelVar> */[] argAnnotationVars = null;\n\tprivate Map<ResolvedType, AnnotationAccessVar> withinAnnotationVars = null;\n\tprivate Map<ResolvedType, AnnotationAccessVar> withincodeAnnotationVars = null;\n\tprivate boolean allArgVarsInitialized = false;\n\n\t// If in annotation style and the relevant advice is using PJP then this will\n\t// be set to true when the closure variable is initialized - if it gets set\n\t// (which means link() has been called) then we will need to call unlink()\n\t// after the code has been run.\n\tboolean closureVarInitialized = false;\n\n\t@Override\n\tpublic Var getThisVar() {\n\t\tif (!hasThis()) {\n\t\t\tthrow new IllegalStateException(\"no this\");\n\t\t}\n\t\tinitializeThisVar();\n\t\treturn thisVar;\n\t}\n\n\t@Override\n\tpublic Var getThisAnnotationVar(UnresolvedType forAnnotationType) {\n\t\tif (!hasThis()) {\n\t\t\tthrow new IllegalStateException(\"no this\");\n\t\t}\n\t\tinitializeThisAnnotationVars(); // FIXME asc Why bother with this if we always return one?\n\t\t// Even if we can't find one, we have to return one as we might have this annotation at runtime\n\t\tVar v = thisAnnotationVars.get(forAnnotationType);\n\t\tif (v == null) {\n\t\t\tv = new TypeAnnotationAccessVar(forAnnotationType.resolve(world), (BcelVar) getThisVar());\n\t\t}\n\t\treturn v;\n\t}\n\n\t@Override\n\tpublic Var getTargetVar() {\n\t\tif (!hasTarget()) {\n\t\t\tthrow new IllegalStateException(\"no target\");\n\t\t}\n\t\tinitializeTargetVar();\n\t\treturn targetVar;\n\t}\n\n\t@Override\n\tpublic Var getTargetAnnotationVar(UnresolvedType forAnnotationType) {\n\t\tif (!hasTarget()) {\n\t\t\tthrow new IllegalStateException(\"no target\");\n\t\t}\n\t\tinitializeTargetAnnotationVars(); // FIXME asc why bother with this if we always return one?\n\t\tVar v = targetAnnotationVars.get(forAnnotationType);\n\t\t// Even if we can't find one, we have to return one as we might have this annotation at runtime\n\t\tif (v == null) {\n\t\t\tv = new TypeAnnotationAccessVar(forAnnotationType.resolve(world), (BcelVar) getTargetVar());\n\t\t}\n\t\treturn v;\n\t}\n\n\t@Override\n\tpublic Var getArgVar(int i) {\n\t\tensureInitializedArgVar(i);\n\t\treturn argVars[i];\n\t}\n\n\t@Override\n\tpublic Var getArgAnnotationVar(int i, UnresolvedType forAnnotationType) {\n\t\treturn new TypeAnnotationAccessVar(forAnnotationType.resolve(world), (BcelVar) getArgVar(i));\n\t\t// initializeArgAnnotationVars();\n\t\t//\n\t\t// Var v = (Var) argAnnotationVars[i].get(forAnnotationType);\n\t\t// if (v == null) {\n\t\t// v = new TypeAnnotationAccessVar(forAnnotationType.resolve(world), (BcelVar) getArgVar(i));\n\t\t// }\n\t\t// return v;\n\t}\n\n\t@Override\n\tpublic Var getKindedAnnotationVar(UnresolvedType forAnnotationType) {\n\t\tinitializeKindedAnnotationVars();\n\t\treturn kindedAnnotationVars.get(forAnnotationType);\n\t}\n\n\t@Override\n\tpublic Var getWithinAnnotationVar(UnresolvedType forAnnotationType) {\n\t\tinitializeWithinAnnotationVars();\n\t\treturn withinAnnotationVars.get(forAnnotationType);\n\t}\n\n\t@Override\n\tpublic Var getWithinCodeAnnotationVar(UnresolvedType forAnnotationType) {\n\t\tinitializeWithinCodeAnnotationVars();\n\t\treturn withincodeAnnotationVars.get(forAnnotationType);\n\t}\n\n\t// reflective thisJoinPoint support\n\tprivate BcelVar thisJoinPointVar = null;\n\tprivate boolean isThisJoinPointLazy;\n\tprivate int lazyTjpConsumers = 0;\n\tprivate BcelVar thisJoinPointStaticPartVar = null;\n\n\t// private BcelVar thisEnclosingJoinPointStaticPartVar = null;\n\n\t@Override\n\tpublic final Var getThisJoinPointStaticPartVar() {\n\t\treturn getThisJoinPointStaticPartBcelVar();\n\t}\n\n\t@Override\n\tpublic final Var getThisEnclosingJoinPointStaticPartVar() {\n\t\treturn getThisEnclosingJoinPointStaticPartBcelVar();\n\t}\n\n\tpublic void requireThisJoinPoint(boolean hasGuardTest, boolean isAround) {\n\t\tif (!isAround) {\n\t\t\tif (!hasGuardTest) {\n\t\t\t\tisThisJoinPointLazy = false;\n\t\t\t} else {\n\t\t\t\tlazyTjpConsumers++;\n\t\t\t}\n\t\t}\n\t\t// if (!hasGuardTest) {\n\t\t// isThisJoinPointLazy = false;\n\t\t// } else {\n\t\t// lazyTjpConsumers++;\n\t\t// }\n\t\tif (thisJoinPointVar == null) {\n\t\t\tthisJoinPointVar = genTempVar(UnresolvedType.forName(\"org.aspectj.lang.JoinPoint\"));\n\t\t}\n\t}\n\n\t@Override\n\tpublic Var getThisJoinPointVar() {\n\t\trequireThisJoinPoint(false, false);\n\t\treturn thisJoinPointVar;\n\t}\n\n\tvoid initializeThisJoinPoint() {\n\t\tif (thisJoinPointVar == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isThisJoinPointLazy) {\n\t\t\tisThisJoinPointLazy = checkLazyTjp();\n\t\t}\n\n\t\tif (isThisJoinPointLazy) {\n\t\t\tappliedLazyTjpOptimization = true;\n\t\t\tcreateThisJoinPoint(); // make sure any state needed is initialized, but throw the instructions out\n\n\t\t\tif (lazyTjpConsumers == 1) {\n\t\t\t\treturn; // special case only one lazyTjpUser\n\t\t\t}\n\n\t\t\tInstructionFactory fact = getFactory();\n\t\t\tInstructionList il = new InstructionList();\n\t\t\til.append(InstructionConstants.ACONST_NULL);\n\t\t\til.append(thisJoinPointVar.createStore(fact));\n\t\t\trange.insert(il, Range.OutsideBefore);\n\t\t} else {\n\t\t\tappliedLazyTjpOptimization = false;\n\t\t\tInstructionFactory fact = getFactory();\n\t\t\tInstructionList il = createThisJoinPoint();\n\t\t\til.append(thisJoinPointVar.createStore(fact));\n\t\t\trange.insert(il, Range.OutsideBefore);\n\t\t}\n\t}\n\n\tprivate boolean checkLazyTjp() {\n\t\t// check for around advice\n\t\tfor (ShadowMunger munger : mungers) {\n\t\t\tif (munger instanceof Advice) {\n\t\t\t\tif (((Advice) munger).getKind() == AdviceKind.Around) {\n\t\t\t\t\tif (munger.getSourceLocation() != null) { // do we know enough to bother reporting?\n\t\t\t\t\t\tif (world.getLint().canNotImplementLazyTjp.isEnabled()) {\n\t\t\t\t\t\t\tworld.getLint().canNotImplementLazyTjp.signal(new String[]{toString()}, getSourceLocation(),\n\t\t\t\t\t\t\t\t\tnew ISourceLocation[]{munger.getSourceLocation()});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tInstructionList loadThisJoinPoint() {\n\t\tInstructionFactory fact = getFactory();\n\t\tInstructionList il = new InstructionList();\n\n\t\tif (isThisJoinPointLazy) {\n\t\t\t// If we're lazy, build the join point right here.\n\t\t\til.append(createThisJoinPoint());\n\n\t\t\t// Does someone else need it? If so, store it for later retrieval\n\t\t\tif (lazyTjpConsumers > 1) {\n\t\t\t\til.append(thisJoinPointVar.createStore(fact));\n\n\t\t\t\tInstructionHandle end = il.append(thisJoinPointVar.createLoad(fact));\n\n\t\t\t\til.insert(InstructionFactory.createBranchInstruction(Constants.IFNONNULL, end));\n\t\t\t\til.insert(thisJoinPointVar.createLoad(fact));\n\t\t\t}\n\t\t} else {\n\t\t\t// If not lazy, its already been built and stored, just retrieve it\n\t\t\tthisJoinPointVar.appendLoad(il, fact);\n\t\t}\n\n\t\treturn il;\n\t}\n\n\tInstructionList createThisJoinPoint() {\n\t\tInstructionFactory fact = getFactory();\n\t\tInstructionList il = new InstructionList();\n\n\t\tBcelVar staticPart = getThisJoinPointStaticPartBcelVar();\n\t\tstaticPart.appendLoad(il, fact);\n\t\tif (hasThis()) {\n\t\t\t((BcelVar) getThisVar()).appendLoad(il, fact);\n\t\t} else {\n\t\t\til.append(InstructionConstants.ACONST_NULL);\n\t\t}\n\t\tif (hasTarget()) {\n\t\t\t((BcelVar) getTargetVar()).appendLoad(il, fact);\n\t\t} else {\n\t\t\til.append(InstructionConstants.ACONST_NULL);\n\t\t}\n\n\t\tswitch (getArgCount()) {\n\t\tcase 0:\n\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.reflect.Factory\", \"makeJP\", LazyClassGen.tjpType, new Type[] {\n\t\t\t\t\tLazyClassGen.staticTjpType, Type.OBJECT, Type.OBJECT }, Constants.INVOKESTATIC));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t((BcelVar) getArgVar(0)).appendLoadAndConvert(il, fact, world.getCoreType(ResolvedType.OBJECT));\n\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.reflect.Factory\", \"makeJP\", LazyClassGen.tjpType, new Type[] {\n\t\t\t\t\tLazyClassGen.staticTjpType, Type.OBJECT, Type.OBJECT, Type.OBJECT }, Constants.INVOKESTATIC));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t((BcelVar) getArgVar(0)).appendLoadAndConvert(il, fact, world.getCoreType(ResolvedType.OBJECT));\n\t\t\t((BcelVar) getArgVar(1)).appendLoadAndConvert(il, fact, world.getCoreType(ResolvedType.OBJECT));\n\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.reflect.Factory\", \"makeJP\", LazyClassGen.tjpType, new Type[] {\n\t\t\t\t\tLazyClassGen.staticTjpType, Type.OBJECT, Type.OBJECT, Type.OBJECT, Type.OBJECT }, Constants.INVOKESTATIC));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\til.append(makeArgsObjectArray());\n\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.reflect.Factory\", \"makeJP\", LazyClassGen.tjpType, new Type[] {\n\t\t\t\t\tLazyClassGen.staticTjpType, Type.OBJECT, Type.OBJECT, new ArrayType(Type.OBJECT, 1) }, Constants.INVOKESTATIC));\n\t\t\tbreak;\n\t\t}\n\n\t\treturn il;\n\t}\n\n\tpublic BcelVar getThisJoinPointStaticPartBcelVar() {\n\t\treturn getThisJoinPointStaticPartBcelVar(false);\n\t}\n\n\t@Override\n\tpublic BcelVar getThisAspectInstanceVar(ResolvedType aspectType) {\n\t\treturn new AspectInstanceVar(aspectType);\n\t}\n\n\t/**\n\t * Get the Var for the xxxxJpStaticPart, xxx = this or enclosing\n\t *\n\t * @param isEnclosingJp true to have the enclosingJpStaticPart\n\t * @return\n\t */\n\tpublic BcelVar getThisJoinPointStaticPartBcelVar(final boolean isEnclosingJp) {\n\t\tif (thisJoinPointStaticPartVar == null) {\n\t\t\tField field = getEnclosingClass().getTjpField(this, isEnclosingJp);\n\t\t\tResolvedType sjpType = null;\n\t\t\tif (world.isTargettingAspectJRuntime12()) { // TAG:SUPPORTING12: We didn't have different jpsp types in 1.2\n\t\t\t\tsjpType = world.getCoreType(UnresolvedType.JOINPOINT_STATICPART);\n\t\t\t} else {\n\t\t\t\tsjpType = isEnclosingJp ? world.getCoreType(UnresolvedType.JOINPOINT_ENCLOSINGSTATICPART) : world\n\t\t\t\t\t\t.getCoreType(UnresolvedType.JOINPOINT_STATICPART);\n\t\t\t}\n\t\t\tthisJoinPointStaticPartVar = new BcelFieldRef(sjpType, getEnclosingClass().getClassName(), field.getName());\n\t\t\t// getEnclosingClass().warnOnAddedStaticInitializer(this,munger.getSourceLocation());\n\t\t}\n\t\treturn thisJoinPointStaticPartVar;\n\t}\n\n\t/**\n\t * Get the Var for the enclosingJpStaticPart\n\t *\n\t * @return\n\t */\n\tpublic BcelVar getThisEnclosingJoinPointStaticPartBcelVar() {\n\t\tif (enclosingShadow == null) {\n\t\t\t// the enclosing of an execution is itself\n\t\t\treturn getThisJoinPointStaticPartBcelVar(true);\n\t\t} else {\n\t\t\treturn ((BcelShadow) enclosingShadow).getThisJoinPointStaticPartBcelVar(true);\n\t\t}\n\t}\n\n\t// ??? need to better understand all the enclosing variants\n\t@Override\n\tpublic Member getEnclosingCodeSignature() {\n\t\tif (getKind().isEnclosingKind()) {\n\t\t\treturn getSignature();\n\t\t} else if (getKind() == Shadow.PreInitialization) {\n\t\t\t// PreInit doesn't enclose code but its signature\n\t\t\t// is correctly the signature of the ctor.\n\t\t\treturn getSignature();\n\t\t} else if (enclosingShadow == null) {\n\t\t\treturn getEnclosingMethod().getMemberView();\n\t\t} else {\n\t\t\treturn enclosingShadow.getSignature();\n\t\t}\n\t}\n\n\tpublic Member getRealEnclosingCodeSignature() {\n\t\treturn enclosingMethod.getMemberView();\n\t}\n\n\t// public Member getEnclosingCodeSignatureForModel() {\n\t// if (getKind().isEnclosingKind()) {\n\t// return getSignature();\n\t// } else if (getKind() == Shadow.PreInitialization) {\n\t// // PreInit doesn't enclose code but its signature\n\t// // is correctly the signature of the ctor.\n\t// return getSignature();\n\t// } else if (enclosingShadow == null) {\n\t// return getEnclosingMethod().getMemberView();\n\t// } else {\n\t// if (enclosingShadow.getKind() == Shadow.MethodExecution && enclosingMethod.getEffectiveSignature() != null) {\n\t//\n\t// } else {\n\t// return enclosingShadow.getSignature();\n\t// }\n\t// }\n\t// }\n\n\tprivate InstructionList makeArgsObjectArray() {\n\t\tInstructionFactory fact = getFactory();\n\t\tBcelVar arrayVar = genTempVar(UnresolvedType.OBJECTARRAY);\n\t\tfinal InstructionList il = new InstructionList();\n\t\tint alen = getArgCount();\n\t\til.append(Utility.createConstant(fact, alen));\n\t\til.append(fact.createNewArray(Type.OBJECT, (short) 1));\n\t\tarrayVar.appendStore(il, fact);\n\n\t\tint stateIndex = 0;\n\t\tfor (int i = 0, len = getArgCount(); i < len; i++) {\n\t\t\tarrayVar.appendConvertableArrayStore(il, fact, stateIndex, (BcelVar) getArgVar(i));\n\t\t\tstateIndex++;\n\t\t}\n\t\tarrayVar.appendLoad(il, fact);\n\t\treturn il;\n\t}\n\n\t// ---- initializing var tables\n\n\t/*\n\t * initializing this is doesn't do anything, because this is protected from side-effects, so we don't need to copy its location\n\t */\n\n\tprivate void initializeThisVar() {\n\t\tif (thisVar != null) {\n\t\t\treturn;\n\t\t}\n\t\tthisVar = new BcelVar(getThisType().resolve(world), 0);\n\t\tthisVar.setPositionInAroundState(0);\n\t}\n\n\tpublic void initializeTargetVar() {\n\t\tInstructionFactory fact = getFactory();\n\t\tif (targetVar != null) {\n\t\t\treturn;\n\t\t}\n\t\tif (getKind().isTargetSameAsThis()) {\n\t\t\tif (hasThis()) {\n\t\t\t\tinitializeThisVar();\n\t\t\t}\n\t\t\ttargetVar = thisVar;\n\t\t} else {\n\t\t\tinitializeArgVars(); // gotta pop off the args before we find the target\n\t\t\tUnresolvedType type = getTargetType();\n\t\t\ttype = ensureTargetTypeIsCorrect(type);\n\t\t\ttargetVar = genTempVar(type, \"ajc$target\");\n\t\t\trange.insert(targetVar.createStore(fact), Range.OutsideBefore);\n\t\t\ttargetVar.setPositionInAroundState(hasThis() ? 1 : 0);\n\t\t}\n\t}\n\n\t/*\n\t * PR 72528 This method double checks the target type under certain conditions. The Java 1.4 compilers seem to take calls to\n\t * clone methods on array types and create bytecode that looks like clone is being called on Object. If we advise a clone call\n\t * with around advice we extract the call into a helper method which we can then refer to. Because the type in the bytecode for\n\t * the call to clone is Object we create a helper method with an Object parameter - this is not correct as we have lost the fact\n\t * that the actual type is an array type. If we don't do the check below we will create code that fails java verification. This\n\t * method checks for the peculiar set of conditions and if they are true, it has a sneak peek at the code before the call to see\n\t * what is on the stack.\n\t */\n\tpublic UnresolvedType ensureTargetTypeIsCorrect(UnresolvedType tx) {\n\n\t\tMember msig = getSignature();\n\t\tif (msig.getArity() == 0 && getKind() == MethodCall && msig.getName().charAt(0) == 'c' && tx.equals(ResolvedType.OBJECT)\n\t\t\t\t&& msig.getReturnType().equals(ResolvedType.OBJECT) && msig.getName().equals(\"clone\")) {\n\n\t\t\t// Lets go back through the code from the start of the shadow\n\t\t\tInstructionHandle searchPtr = range.getStart().getPrev();\n\t\t\twhile (Range.isRangeHandle(searchPtr) || searchPtr.getInstruction().isStoreInstruction()) { // ignore this instruction -\n\t\t\t\t// it doesnt give us the\n\t\t\t\t// info we want\n\t\t\t\tsearchPtr = searchPtr.getPrev();\n\t\t\t}\n\n\t\t\t// A load instruction may tell us the real type of what the clone() call is on\n\t\t\tif (searchPtr.getInstruction().isLoadInstruction()) {\n\t\t\t\tLocalVariableTag lvt = LazyMethodGen.getLocalVariableTag(searchPtr, searchPtr.getInstruction().getIndex());\n\t\t\t\tif (lvt != null) {\n\t\t\t\t\treturn UnresolvedType.forSignature(lvt.getType());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// A field access instruction may tell us the real type of what the clone() call is on\n\t\t\tif (searchPtr.getInstruction() instanceof FieldInstruction) {\n\t\t\t\tFieldInstruction si = (FieldInstruction) searchPtr.getInstruction();\n\t\t\t\tType t = si.getFieldType(getEnclosingClass().getConstantPool());\n\t\t\t\treturn BcelWorld.fromBcel(t);\n\t\t\t}\n\t\t\t// A new array instruction obviously tells us it is an array type !\n\t\t\tif (searchPtr.getInstruction().opcode == Constants.ANEWARRAY) {\n\t\t\t\t// ANEWARRAY ana = (ANEWARRAY)searchPoint.getInstruction();\n\t\t\t\t// Type t = ana.getType(getEnclosingClass().getConstantPool());\n\t\t\t\t// Just use a standard java.lang.object array - that will work fine\n\t\t\t\treturn BcelWorld.fromBcel(new ArrayType(Type.OBJECT, 1));\n\t\t\t}\n\t\t\t// A multi new array instruction obviously tells us it is an array type !\n\t\t\tif (searchPtr.getInstruction() instanceof MULTIANEWARRAY) {\n\t\t\t\tMULTIANEWARRAY ana = (MULTIANEWARRAY) searchPtr.getInstruction();\n\t\t\t\t// Type t = ana.getType(getEnclosingClass().getConstantPool());\n\t\t\t\t// t = new ArrayType(t,ana.getDimensions());\n\t\t\t\t// Just use a standard java.lang.object array - that will work fine\n\t\t\t\treturn BcelWorld.fromBcel(new ArrayType(Type.OBJECT, ana.getDimensions()));\n\t\t\t}\n\t\t\tthrow new BCException(\"Can't determine real target of clone() when processing instruction \"\n\t\t\t\t\t+ searchPtr.getInstruction() + \".  Perhaps avoid selecting clone with your pointcut?\");\n\t\t}\n\t\treturn tx;\n\t}\n\n\tpublic void ensureInitializedArgVar(int argNumber) {\n\t\tif (allArgVarsInitialized || (argVars != null && argVars[argNumber] != null)) {\n\t\t\treturn;\n\t\t}\n\t\tInstructionFactory fact = getFactory();\n\t\tint len = getArgCount();\n\t\tif (argVars == null) {\n\t\t\targVars = new BcelVar[len];\n\t\t}\n\n\t\t// Need to initialize argument i\n\t\tint positionOffset = (hasTarget() ? 1 : 0) + ((hasThis() && !getKind().isTargetSameAsThis()) ? 1 : 0);\n\n\t\tif (getKind().argsOnStack()) {\n\t\t\t// Let's just do them all now since they are on the stack\n\t\t\t// we move backwards because we're popping off the stack\n\t\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\t\tUnresolvedType type = getArgType(i);\n\t\t\t\tBcelVar tmp = genTempVar(type, \"ajc$arg\" + i);\n\t\t\t\trange.insert(tmp.createStore(getFactory()), Range.OutsideBefore);\n\t\t\t\tint position = i;\n\t\t\t\tposition += positionOffset;\n\t\t\t\ttmp.setPositionInAroundState(position);\n\t\t\t\targVars[i] = tmp;\n\t\t\t}\n\t\t\tallArgVarsInitialized = true;\n\t\t} else {\n\t\t\tint index = 0;\n\t\t\tif (arg0HoldsThis()) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tboolean allInited = true;\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tUnresolvedType type = getArgType(i);\n\t\t\t\tif (i == argNumber) {\n\t\t\t\t\targVars[argNumber] = genTempVar(type, \"ajc$arg\" + argNumber);\n\t\t\t\t\trange.insert(argVars[argNumber].createCopyFrom(fact, index), Range.OutsideBefore);\n\t\t\t\t\targVars[argNumber].setPositionInAroundState(argNumber + positionOffset);\n\t\t\t\t}\n\t\t\t\tallInited = allInited && argVars[i] != null;\n\t\t\t\tindex += type.getSize();\n\t\t\t}\n\t\t\tif (allInited && (argNumber + 1) == len) {\n\t\t\t\tallArgVarsInitialized = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Initialize all the available arguments at the shadow. This means creating a copy of them that we can then use for advice\n\t * calls (the copy ensures we are not affected by other advice changing the values). This method initializes all arguments\n\t * whereas the method ensureInitializedArgVar will only ensure a single argument is setup.\n\t */\n\tpublic void initializeArgVars() {\n\t\tif (allArgVarsInitialized) {\n\t\t\treturn;\n\t\t}\n\t\tInstructionFactory fact = getFactory();\n\t\tint len = getArgCount();\n\t\tif (argVars == null) {\n\t\t\targVars = new BcelVar[len];\n\t\t}\n\t\tint positionOffset = (hasTarget() ? 1 : 0) + ((hasThis() && !getKind().isTargetSameAsThis()) ? 1 : 0);\n\n\t\tif (getKind().argsOnStack()) {\n\t\t\t// we move backwards because we're popping off the stack\n\t\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\t\tUnresolvedType type = getArgType(i);\n\t\t\t\tBcelVar tmp = genTempVar(type, \"ajc$arg\" + i);\n\t\t\t\trange.insert(tmp.createStore(getFactory()), Range.OutsideBefore);\n\t\t\t\tint position = i;\n\t\t\t\tposition += positionOffset;\n\t\t\t\ttmp.setPositionInAroundState(position);\n\t\t\t\targVars[i] = tmp;\n\t\t\t}\n\t\t} else {\n\t\t\tint index = 0;\n\t\t\tif (arg0HoldsThis()) {\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tUnresolvedType type = getArgType(i);\n\t\t\t\tif (argVars[i] == null) {\n\t\t\t\t\tBcelVar tmp = genTempVar(type, \"ajc$arg\" + i);\n\t\t\t\t\trange.insert(tmp.createCopyFrom(fact, index), Range.OutsideBefore);\n\t\t\t\t\targVars[i] = tmp;\n\t\t\t\t\ttmp.setPositionInAroundState(i + positionOffset);\n\t\t\t\t}\n\t\t\t\tindex += type.resolve(world).getSize();\n\t\t\t}\n\t\t}\n\t\tallArgVarsInitialized = true;\n\n\t}\n\n\tpublic void initializeForAroundClosure() {\n\t\tinitializeArgVars();\n\t\tif (hasTarget()) {\n\t\t\tinitializeTargetVar();\n\t\t}\n\t\tif (hasThis()) {\n\t\t\tinitializeThisVar();\n\t\t\t// System.out.println(\"initialized: \" + this + \" thisVar = \" + thisVar);\n\t\t}\n\t}\n\n\tpublic void initializeThisAnnotationVars() {\n\t\tif (thisAnnotationVars != null) {\n\t\t\treturn;\n\t\t}\n\t\tthisAnnotationVars = new HashMap<>();\n\t\t// populate..\n\t}\n\n\tpublic void initializeTargetAnnotationVars() {\n\t\tif (targetAnnotationVars != null) {\n\t\t\treturn;\n\t\t}\n\t\tif (getKind().isTargetSameAsThis()) {\n\t\t\tif (hasThis()) {\n\t\t\t\tinitializeThisAnnotationVars();\n\t\t\t}\n\t\t\ttargetAnnotationVars = thisAnnotationVars;\n\t\t} else {\n\t\t\ttargetAnnotationVars = new HashMap<>();\n\t\t\tResolvedType[] rtx = this.getTargetType().resolve(world).getAnnotationTypes(); // what about annotations we havent\n\t\t\t// gotten yet but we will get in\n\t\t\t// subclasses?\n\t\t\tfor (ResolvedType typeX : rtx) {\n\t\t\t\ttargetAnnotationVars.put(typeX, new TypeAnnotationAccessVar(typeX, (BcelVar) getTargetVar()));\n\t\t\t}\n\t\t\t// populate.\n\t\t}\n\t}\n\n\t// public void initializeArgAnnotationVars() {\n\t// if (argAnnotationVars != null) {\n\t// return;\n\t// }\n\t// int numArgs = getArgCount();\n\t// argAnnotationVars = new Map[numArgs];\n\t// for (int i = 0; i < argAnnotationVars.length; i++) {\n\t// argAnnotationVars[i] = new HashMap();\n\t// // FIXME asc just delete this logic - we always build the Var on demand, as we don't know at weave time\n\t// // what the full set of annotations could be (due to static/dynamic type differences...)\n\t// }\n\t// }\n\n\tprotected ResolvedMember getRelevantMember(ResolvedMember foundMember, Member relevantMember, ResolvedType relevantType) {\n\t\tif (foundMember != null) {\n\t\t\treturn foundMember;\n\t\t}\n\n\t\tfoundMember = getSignature().resolve(world);\n\t\tif (foundMember == null && relevantMember != null) {\n\t\t\tfoundMember = relevantType.lookupMemberWithSupersAndITDs(relevantMember);\n\t\t}\n\n\t\t// check the ITD'd dooberries\n\t\tList<ConcreteTypeMunger> mungers = relevantType.resolve(world).getInterTypeMungers();\n\t\tfor (ConcreteTypeMunger typeMunger : mungers) {\n\t\t\tif (typeMunger.getMunger() instanceof NewMethodTypeMunger || typeMunger.getMunger() instanceof NewConstructorTypeMunger) {\n\t\t\t\tResolvedMember fakerm = typeMunger.getSignature();\n\t\t\t\tif (fakerm.getName().equals(getSignature().getName())\n\t\t\t\t\t\t&& fakerm.getParameterSignature().equals(getSignature().getParameterSignature())) {\n\t\t\t\t\tif (foundMember.getKind() == ResolvedMember.CONSTRUCTOR) {\n\t\t\t\t\t\tfoundMember = AjcMemberMaker.interConstructor(relevantType, foundMember, typeMunger.getAspectType());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfoundMember = AjcMemberMaker.interMethod(foundMember, typeMunger.getAspectType(), false);\n\t\t\t\t\t\t// ResolvedMember o = AjcMemberMaker.interMethodBody(fakerm, typeMunger.getAspectType());\n\t\t\t\t\t\t// // Object os = o.getAnnotations();\n\t\t\t\t\t\t// ResolvedMember foundMember2 = findMethod(typeMunger.getAspectType(), o);\n\t\t\t\t\t\t// Object os2 = foundMember2.getAnnotations();\n\t\t\t\t\t\t// int stop = 1;\n\t\t\t\t\t\t// foundMember = foundMember2;\n\t\t\t\t\t\t// foundMember = AjcMemberMaker.interMethod(foundMember, typeMunger.getAspectType());\n\t\t\t\t\t}\n\t\t\t\t\t// in the above.. what about if it's on an Interface? Can that happen?\n\t\t\t\t\t// then the last arg of the above should be true\n\t\t\t\t\treturn foundMember;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundMember;\n\t}\n\n\tprotected ResolvedType[] getAnnotations(ResolvedMember foundMember, Member relevantMember, ResolvedType relevantType) {\n\t\tif (foundMember == null) {\n\t\t\t// check the ITD'd dooberries\n\t\t\tList<ConcreteTypeMunger> mungers = relevantType.resolve(world).getInterTypeMungers();\n\t\t\tfor (ConcreteTypeMunger typeMunger : mungers) {\n\t\t\t\tif (typeMunger.getMunger() instanceof NewMethodTypeMunger\n\t\t\t\t\t\t|| typeMunger.getMunger() instanceof NewConstructorTypeMunger) {\n\t\t\t\t\tResolvedMember fakerm = typeMunger.getSignature();\n\t\t\t\t\t// if (fakerm.hasAnnotations())\n\n\t\t\t\t\tResolvedMember ajcMethod = (getSignature().getKind() == ResolvedMember.CONSTRUCTOR ? AjcMemberMaker\n\t\t\t\t\t\t\t.postIntroducedConstructor(typeMunger.getAspectType(), fakerm.getDeclaringType(),\n\t\t\t\t\t\t\t\t\tfakerm.getParameterTypes()) : AjcMemberMaker.interMethodDispatcher(fakerm,\n\t\t\t\t\t\t\ttypeMunger.getAspectType()));\n\t\t\t\t\t// AjcMemberMaker.interMethodBody(fakerm,typeMunger.getAspectType()));\n\t\t\t\t\tResolvedMember rmm = findMethod(typeMunger.getAspectType(), ajcMethod);\n\t\t\t\t\tif (fakerm.getName().equals(getSignature().getName())\n\t\t\t\t\t\t\t&& fakerm.getParameterSignature().equals(getSignature().getParameterSignature())) {\n\t\t\t\t\t\trelevantType = typeMunger.getAspectType();\n\t\t\t\t\t\tfoundMember = rmm;\n\t\t\t\t\t\treturn foundMember.getAnnotationTypes();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// didn't find in ITDs, look in supers\n\t\t\tfoundMember = relevantType.lookupMemberWithSupersAndITDs(relevantMember);\n\t\t\tif (foundMember == null) {\n\t\t\t\tthrow new IllegalStateException(\"Couldn't find member \" + relevantMember + \" for type \" + relevantType);\n\t\t\t}\n\t\t}\n\t\treturn foundMember.getAnnotationTypes();\n\t}\n\n\t/**\n\t * By determining what \"kind\" of shadow we are, we can find out the annotations on the appropriate element (method, field,\n\t * constructor, type). Then create one BcelVar entry in the map for each annotation, keyed by annotation type.\n\t */\n\tpublic void initializeKindedAnnotationVars() {\n\t\tif (kindedAnnotationVars != null) {\n\t\t\treturn;\n\t\t}\n\t\tkindedAnnotationVars = new HashMap<>();\n\n\t\tResolvedType[] annotations = null;\n\t\tMember shadowSignature = getSignature();\n\t\tMember annotationHolder = getSignature();\n\t\tResolvedType relevantType = shadowSignature.getDeclaringType().resolve(world);\n\n\t\tif (relevantType.isRawType() || relevantType.isParameterizedType()) {\n\t\t\trelevantType = relevantType.getGenericType();\n\t\t}\n\n\t\t// Determine the annotations that are of interest\n\t\tif (getKind() == Shadow.StaticInitialization) {\n\t\t\tannotations = relevantType.resolve(world).getAnnotationTypes();\n\t\t} else if (getKind() == Shadow.MethodCall || getKind() == Shadow.ConstructorCall) {\n\t\t\tResolvedMember foundMember = findMethod2(relevantType.resolve(world).getDeclaredMethods(), getSignature());\n\t\t\tannotations = getAnnotations(foundMember, shadowSignature, relevantType);\n\t\t\tannotationHolder = getRelevantMember(foundMember, shadowSignature, relevantType);\n\t\t\trelevantType = annotationHolder.getDeclaringType().resolve(world);\n\t\t} else if (getKind() == Shadow.FieldSet || getKind() == Shadow.FieldGet) {\n\t\t\tannotationHolder = findField(relevantType.getDeclaredFields(), getSignature());\n\n\t\t\tif (annotationHolder == null) {\n\t\t\t\t// check the ITD'd dooberries\n\t\t\t\tList<ConcreteTypeMunger> mungers = relevantType.resolve(world).getInterTypeMungers();\n\t\t\t\tfor (ConcreteTypeMunger typeMunger : mungers) {\n\t\t\t\t\tif (typeMunger.getMunger() instanceof NewFieldTypeMunger) {\n\t\t\t\t\t\tResolvedMember fakerm = typeMunger.getSignature();\n\t\t\t\t\t\t// if (fakerm.hasAnnotations())\n\t\t\t\t\t\tResolvedMember ajcMethod = AjcMemberMaker.interFieldInitializer(fakerm, typeMunger.getAspectType());\n\t\t\t\t\t\tResolvedMember rmm = findMethod(typeMunger.getAspectType(), ajcMethod);\n\t\t\t\t\t\tif (fakerm.equals(getSignature())) {\n\t\t\t\t\t\t\trelevantType = typeMunger.getAspectType();\n\t\t\t\t\t\t\tannotationHolder = rmm;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tannotations = ((ResolvedMember) annotationHolder).getAnnotationTypes();\n\n\t\t} else if (getKind() == Shadow.MethodExecution || getKind() == Shadow.ConstructorExecution\n\t\t\t\t|| getKind() == Shadow.AdviceExecution) {\n\n\t\t\tResolvedMember foundMember = findMethod2(relevantType.getDeclaredMethods(), getSignature());\n\t\t\tannotations = getAnnotations(foundMember, shadowSignature, relevantType);\n\t\t\tannotationHolder = getRelevantMember(foundMember, annotationHolder, relevantType);\n\t\t\tUnresolvedType ut = annotationHolder.getDeclaringType();\n\t\t\trelevantType = ut.resolve(world);\n\n\t\t} else if (getKind() == Shadow.ExceptionHandler) {\n\t\t\trelevantType = getSignature().getParameterTypes()[0].resolve(world);\n\t\t\tannotations = relevantType.getAnnotationTypes();\n\n\t\t} else if (getKind() == Shadow.PreInitialization || getKind() == Shadow.Initialization) {\n\t\t\tResolvedMember found = findMethod2(relevantType.getDeclaredMethods(), getSignature());\n\t\t\tannotations = found.getAnnotationTypes();\n\t\t}\n\n\t\tif (annotations == null) {\n\t\t\t// We can't have recognized the shadow - should blow up now to be on the safe side\n\t\t\tthrow new BCException(\"Could not discover annotations for shadow: \" + getKind());\n\t\t}\n\n\t\tfor (ResolvedType annotationType : annotations) {\n\t\t\tAnnotationAccessVar accessVar = new AnnotationAccessVar(this, getKind(), annotationType.resolve(world), relevantType,\n\t\t\t\t\tannotationHolder, false);\n\t\t\tkindedAnnotationVars.put(annotationType, accessVar);\n\t\t}\n\t}\n\n\tprivate ResolvedMember findMethod2(ResolvedMember members[], Member sig) {\n\t\tString signatureName = sig.getName();\n\t\tString parameterSignature = sig.getParameterSignature();\n\t\tfor (ResolvedMember member : members) {\n\t\t\tif (member.getName().equals(signatureName) && member.getParameterSignature().equals(parameterSignature)) {\n\t\t\t\treturn member;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate ResolvedMember findMethod(ResolvedType aspectType, ResolvedMember ajcMethod) {\n\t\tResolvedMember decMethods[] = aspectType.getDeclaredMethods();\n\t\tfor (ResolvedMember member : decMethods) {\n\t\t\tif (member.equals(ajcMethod)) {\n\t\t\t\treturn member;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate ResolvedMember findField(ResolvedMember[] members, Member lookingFor) {\n\t\tfor (ResolvedMember member : members) {\n\t\t\tif (member.getName().equals(getSignature().getName()) && member.getType().equals(getSignature().getType())) {\n\t\t\t\treturn member;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void initializeWithinAnnotationVars() {\n\t\tif (withinAnnotationVars != null) {\n\t\t\treturn;\n\t\t}\n\t\twithinAnnotationVars = new HashMap<>();\n\n\t\tResolvedType[] annotations = getEnclosingType().resolve(world).getAnnotationTypes();\n\t\tfor (ResolvedType ann : annotations) {\n\t\t\tKind k = Shadow.StaticInitialization;\n\t\t\twithinAnnotationVars.put(ann, new AnnotationAccessVar(this, k, ann, getEnclosingType(), null, true));\n\t\t}\n\t}\n\n\tpublic void initializeWithinCodeAnnotationVars() {\n\t\tif (withincodeAnnotationVars != null) {\n\t\t\treturn;\n\t\t}\n\t\twithincodeAnnotationVars = new HashMap<>();\n\n\t\t// For some shadow we are interested in annotations on the method containing that shadow.\n\t\tResolvedType[] annotations = getEnclosingMethod().getMemberView().getAnnotationTypes();\n\t\tfor (ResolvedType ann : annotations) {\n\t\t\tKind k = (getEnclosingMethod().getMemberView().getKind() == Member.CONSTRUCTOR ? Shadow.ConstructorExecution\n\t\t\t\t\t: Shadow.MethodExecution);\n\t\t\twithincodeAnnotationVars.put(ann, new AnnotationAccessVar(this, k, ann, getEnclosingType(),\n\t\t\t\t\tgetEnclosingCodeSignature(), true));\n\t\t}\n\t}\n\n\t// ---- weave methods\n\n\tvoid weaveBefore(BcelAdvice munger) {\n\t\trange.insert(munger.getAdviceInstructions(this, null, range.getRealStart()), Range.InsideBefore);\n\t}\n\n\tpublic void weaveAfter(BcelAdvice munger) {\n\t\tweaveAfterThrowing(munger, UnresolvedType.THROWABLE);\n\t\tweaveAfterReturning(munger);\n\t}\n\n\t/**\n\t * The basic strategy here is to add a set of instructions at the end of the shadow range that dispatch the advice, and then\n\t * return whatever the shadow was going to return anyway.\n\t *\n\t * To achieve this, we note all the return statements in the advice, and replace them with code that: 1) stores the return value\n\t * on top of the stack in a temp var 2) jumps to the start of our advice block 3) restores the return value at the end of the\n\t * advice block before ultimately returning\n\t *\n\t * We also need to bind the return value into a returning parameter, if the advice specified one.\n\t */\n\tpublic void weaveAfterReturning(BcelAdvice munger) {\n\t\tList<InstructionHandle> returns = findReturnInstructions();\n\t\tboolean hasReturnInstructions = !returns.isEmpty();\n\n\t\t// list of instructions that handle the actual return from the join point\n\t\tInstructionList retList = new InstructionList();\n\n\t\t// variable that holds the return value\n\t\tBcelVar returnValueVar = null;\n\n\t\tif (hasReturnInstructions) {\n\t\t\treturnValueVar = generateReturnInstructions(returns, retList);\n\t\t} else {\n\t\t\t// we need at least one instruction, as the target for jumps\n\t\t\tretList.append(InstructionConstants.NOP);\n\t\t}\n\n\t\t// list of instructions for dispatching to the advice itself\n\t\tInstructionList advice = getAfterReturningAdviceDispatchInstructions(munger, retList.getStart());\n\n\t\tif (hasReturnInstructions) {\n\t\t\tInstructionHandle gotoTarget = advice.getStart();\n\t\t\tfor (InstructionHandle ih : returns) {\n\t\t\t\tretargetReturnInstruction(munger.hasExtraParameter(), returnValueVar, gotoTarget, ih);\n\t\t\t}\n\t\t}\n\n\t\trange.append(advice);\n\t\trange.append(retList);\n\t}\n\n\t/**\n\t * @return a list of all the return instructions in the range of this shadow\n\t */\n\tprivate List<InstructionHandle> findReturnInstructions() {\n\t\tList<InstructionHandle> returns = new ArrayList<>();\n\t\tfor (InstructionHandle ih = range.getStart(); ih != range.getEnd(); ih = ih.getNext()) {\n\t\t\tif (ih.getInstruction().isReturnInstruction()) {\n\t\t\t\treturns.add(ih);\n\t\t\t}\n\t\t}\n\t\treturn returns;\n\t}\n\n\t/**\n\t * Given a list containing all the return instruction handles for this shadow, finds the last return instruction and copies it,\n\t * making this the ultimate return. If the shadow has a non-void return type, we also create a temporary variable to hold the\n\t * return value, and load the value from this var before returning (see pr148007 for why we do this - it works around a JRockit\n\t * bug, and is also closer to what javac generates)\n\t *\n\t * Sometimes the 'last return' isnt the right one - some rogue code can include the real return from the body of a subroutine\n\t * that exists at the end of the method. In this case the last return is RETURN but that may not be correct for a method with a\n\t * non-void return type... pr151673\n\t *\n\t * @param returns list of all the return instructions in the shadow\n\t * @param returnInstructions instruction list into which the return instructions should be generated\n\t * @return the variable holding the return value, if needed\n\t */\n\tprivate BcelVar generateReturnInstructions(List<InstructionHandle> returns, InstructionList returnInstructions) {\n\t\tBcelVar returnValueVar = null;\n\t\tif (this.hasANonVoidReturnType()) {\n\t\t\t// Find the last *correct* return - this is a method with a non-void return type\n\t\t\t// so ignore RETURN\n\t\t\tInstruction newReturnInstruction = null;\n\t\t\tint i = returns.size() - 1;\n\t\t\twhile (newReturnInstruction == null && i >= 0) {\n\t\t\t\tInstructionHandle ih = returns.get(i);\n\t\t\t\tif (ih.getInstruction().opcode != Constants.RETURN) {\n\t\t\t\t\tnewReturnInstruction = Utility.copyInstruction(ih.getInstruction());\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturnValueVar = genTempVar(this.getReturnType());\n\t\t\treturnValueVar.appendLoad(returnInstructions, getFactory());\n\t\t\treturnInstructions.append(newReturnInstruction);\n\t\t} else {\n\t\t\tInstructionHandle lastReturnHandle = returns.get(returns.size() - 1);\n\t\t\tInstruction newReturnInstruction = Utility.copyInstruction(lastReturnHandle.getInstruction());\n\t\t\treturnInstructions.append(newReturnInstruction);\n\t\t}\n\t\treturn returnValueVar;\n\t}\n\n\t/**\n\t * @return true, iff this shadow returns a value\n\t */\n\tprivate boolean hasANonVoidReturnType() {\n\t\treturn !this.getReturnType().equals(UnresolvedType.VOID);\n\t}\n\n\t/**\n\t * Get the list of instructions used to dispatch to the after advice\n\t *\n\t * @param munger\n\t * @param firstInstructionInReturnSequence\n\t * @return\n\t */\n\tprivate InstructionList getAfterReturningAdviceDispatchInstructions(BcelAdvice munger,\n\t\t\tInstructionHandle firstInstructionInReturnSequence) {\n\t\tInstructionList advice = new InstructionList();\n\n\t\tBcelVar tempVar = null;\n\t\tif (munger.hasExtraParameter()) {\n\t\t\ttempVar = insertAdviceInstructionsForBindingReturningParameter(advice);\n\t\t}\n\t\tadvice.append(munger.getAdviceInstructions(this, tempVar, firstInstructionInReturnSequence));\n\t\treturn advice;\n\t}\n\n\t/**\n\t * If the after() returning(Foo f) form is used, bind the return value to the parameter. If the shadow returns void, bind null.\n\t *\n\t * @param advice\n\t * @return\n\t */\n\tprivate BcelVar insertAdviceInstructionsForBindingReturningParameter(InstructionList advice) {\n\t\tBcelVar tempVar;\n\t\tUnresolvedType tempVarType = getReturnType();\n\t\tif (tempVarType.equals(UnresolvedType.VOID)) {\n\t\t\ttempVar = genTempVar(UnresolvedType.OBJECT);\n\t\t\tadvice.append(InstructionConstants.ACONST_NULL);\n\t\t\ttempVar.appendStore(advice, getFactory());\n\t\t} else {\n\t\t\ttempVar = genTempVar(tempVarType);\n\t\t\tadvice.append(InstructionFactory.createDup(tempVarType.getSize()));\n\t\t\ttempVar.appendStore(advice, getFactory());\n\t\t}\n\t\treturn tempVar;\n\t}\n\n\t/**\n\t * Helper method for weaveAfterReturning\n\t *\n\t * Each return instruction in the method body is retargeted by calling this method. The return instruction is replaced by up to\n\t * three instructions: 1) if the shadow returns a value, and that value is bound to an after returning parameter, then we DUP\n\t * the return value on the top of the stack 2) if the shadow returns a value, we store it in the returnValueVar (it will be\n\t * retrieved from here when we ultimately return after the advice dispatch) 3) if the return was the last instruction, we add a\n\t * NOP (it will fall through to the advice dispatch), otherwise we add a GOTO that branches to the supplied gotoTarget (start of\n\t * the advice dispatch)\n\t */\n\tprivate void retargetReturnInstruction(boolean hasReturningParameter, BcelVar returnValueVar, InstructionHandle gotoTarget,\n\t\t\tInstructionHandle returnHandle) {\n\t\t// pr148007, work around JRockit bug\n\t\t// replace ret with store into returnValueVar, followed by goto if not\n\t\t// at the end of the instruction list...\n\t\tInstructionList newInstructions = new InstructionList();\n\t\tif (returnValueVar != null) {\n\t\t\tif (hasReturningParameter) {\n\t\t\t\t// we have to dup the return val before consuming it...\n\t\t\t\tnewInstructions.append(InstructionFactory.createDup(this.getReturnType().getSize()));\n\t\t\t}\n\t\t\t// store the return value into this var\n\t\t\treturnValueVar.appendStore(newInstructions, getFactory());\n\t\t}\n\t\tif (!isLastInstructionInRange(returnHandle, range)) {\n\t\t\tnewInstructions.append(InstructionFactory.createBranchInstruction(Constants.GOTO, gotoTarget));\n\t\t}\n\t\tif (newInstructions.isEmpty()) {\n\t\t\tnewInstructions.append(InstructionConstants.NOP);\n\t\t}\n\t\tUtility.replaceInstruction(returnHandle, newInstructions, enclosingMethod);\n\t}\n\n\tprivate boolean isLastInstructionInRange(InstructionHandle ih, ShadowRange aRange) {\n\t\treturn ih.getNext() == aRange.getEnd();\n\t}\n\n\tpublic void weaveAfterThrowing(BcelAdvice munger, UnresolvedType catchType) {\n\t\t// a good optimization would be not to generate anything here\n\t\t// if the shadow is GUARANTEED empty (i.e., there's NOTHING, not even\n\t\t// a shadow, inside me).\n\t\tif (getRange().getStart().getNext() == getRange().getEnd()) {\n\t\t\treturn;\n\t\t}\n\t\tInstructionFactory fact = getFactory();\n\t\tInstructionList handler = new InstructionList();\n\t\tBcelVar exceptionVar = genTempVar(catchType);\n\t\texceptionVar.appendStore(handler, fact);\n\n\t\t// pr62642\n\t\t// I will now jump through some firey BCEL hoops to generate a trivial bit of code:\n\t\t// if (exc instanceof ExceptionInInitializerError)\n\t\t// throw (ExceptionInInitializerError)exc;\n\t\tif (this.getEnclosingMethod().getName().equals(\"<clinit>\")) {\n\t\t\tResolvedType eiieType = world.resolve(\"java.lang.ExceptionInInitializerError\");\n\t\t\tObjectType eiieBcelType = (ObjectType) BcelWorld.makeBcelType(eiieType);\n\t\t\tInstructionList ih = new InstructionList(InstructionConstants.NOP);\n\t\t\thandler.append(exceptionVar.createLoad(fact));\n\t\t\thandler.append(fact.createInstanceOf(eiieBcelType));\n\t\t\tInstructionBranch bi = InstructionFactory.createBranchInstruction(Constants.IFEQ, ih.getStart());\n\t\t\thandler.append(bi);\n\t\t\thandler.append(exceptionVar.createLoad(fact));\n\t\t\thandler.append(fact.createCheckCast(eiieBcelType));\n\t\t\thandler.append(InstructionConstants.ATHROW);\n\t\t\thandler.append(ih);\n\t\t}\n\n\t\tInstructionList endHandler = new InstructionList(exceptionVar.createLoad(fact));\n\t\thandler.append(munger.getAdviceInstructions(this, exceptionVar, endHandler.getStart()));\n\t\thandler.append(endHandler);\n\t\thandler.append(InstructionConstants.ATHROW);\n\t\tInstructionHandle handlerStart = handler.getStart();\n\n\t\tif (isFallsThrough()) {\n\t\t\tInstructionHandle jumpTarget = handler.append(InstructionConstants.NOP);\n\t\t\thandler.insert(InstructionFactory.createBranchInstruction(Constants.GOTO, jumpTarget));\n\t\t}\n\t\tInstructionHandle protectedEnd = handler.getStart();\n\t\trange.insert(handler, Range.InsideAfter);\n\n\t\tenclosingMethod.addExceptionHandler(range.getStart().getNext(), protectedEnd.getPrev(), handlerStart,\n\t\t\t\t(ObjectType) BcelWorld.makeBcelType(catchType), // ???Type.THROWABLE,\n\t\t\t\t// high priority if our args are on the stack\n\t\t\t\tgetKind().hasHighPriorityExceptions());\n\t}\n\n\t// ??? this shares a lot of code with the above weaveAfterThrowing\n\t// ??? would be nice to abstract that to say things only once\n\tpublic void weaveSoftener(BcelAdvice munger, UnresolvedType catchType) {\n\t\t// a good optimization would be not to generate anything here\n\t\t// if the shadow is GUARANTEED empty (i.e., there's NOTHING, not even\n\t\t// a shadow, inside me).\n\t\tif (getRange().getStart().getNext() == getRange().getEnd()) {\n\t\t\treturn;\n\t\t}\n\n\t\tInstructionFactory fact = getFactory();\n\t\tInstructionList handler = new InstructionList();\n\t\tInstructionList rtExHandler = new InstructionList();\n\t\tBcelVar exceptionVar = genTempVar(catchType);\n\n\t\thandler.append(fact.createNew(NameMangler.SOFT_EXCEPTION_TYPE));\n\t\thandler.append(InstructionFactory.createDup(1));\n\t\thandler.append(exceptionVar.createLoad(fact));\n\t\thandler.append(fact.createInvoke(NameMangler.SOFT_EXCEPTION_TYPE, \"<init>\", Type.VOID, new Type[] { Type.THROWABLE },\n\t\t\t\tConstants.INVOKESPECIAL)); // ??? special\n\t\thandler.append(InstructionConstants.ATHROW);\n\n\t\t// ENH 42737\n\t\texceptionVar.appendStore(rtExHandler, fact);\n\t\t// aload_1\n\t\trtExHandler.append(exceptionVar.createLoad(fact));\n\t\t// instanceof class java/lang/RuntimeException\n\t\trtExHandler.append(fact.createInstanceOf(new ObjectType(\"java.lang.RuntimeException\")));\n\t\t// ifeq go to new SOFT_EXCEPTION_TYPE instruction\n\t\trtExHandler.append(InstructionFactory.createBranchInstruction(Constants.IFEQ, handler.getStart()));\n\t\t// aload_1\n\t\trtExHandler.append(exceptionVar.createLoad(fact));\n\t\t// athrow\n\t\trtExHandler.append(InstructionFactory.ATHROW);\n\n\t\tInstructionHandle handlerStart = rtExHandler.getStart();\n\n\t\tif (isFallsThrough()) {\n\t\t\tInstructionHandle jumpTarget = range.getEnd();// handler.append(fact.NOP);\n\t\t\trtExHandler.insert(InstructionFactory.createBranchInstruction(Constants.GOTO, jumpTarget));\n\t\t}\n\n\t\trtExHandler.append(handler);\n\n\t\tInstructionHandle protectedEnd = rtExHandler.getStart();\n\t\trange.insert(rtExHandler, Range.InsideAfter);\n\n\t\tenclosingMethod.addExceptionHandler(range.getStart().getNext(), protectedEnd.getPrev(), handlerStart,\n\t\t\t\t(ObjectType) BcelWorld.makeBcelType(catchType),\n\t\t\t\t// high priority if our args are on the stack\n\t\t\t\tgetKind().hasHighPriorityExceptions());\n\t}\n\n\tpublic void weavePerObjectEntry(final BcelAdvice munger, final BcelVar onVar) {\n\t\tfinal InstructionFactory fact = getFactory();\n\n\t\tInstructionList entryInstructions = new InstructionList();\n\t\tInstructionList entrySuccessInstructions = new InstructionList();\n\t\tonVar.appendLoad(entrySuccessInstructions, fact);\n\n\t\tentrySuccessInstructions\n\t\t\t\t.append(Utility.createInvoke(fact, world, AjcMemberMaker.perObjectBind(munger.getConcreteAspect())));\n\n\t\tInstructionList testInstructions = munger.getTestInstructions(this, entrySuccessInstructions.getStart(),\n\t\t\t\trange.getRealStart(), entrySuccessInstructions.getStart());\n\n\t\tentryInstructions.append(testInstructions);\n\t\tentryInstructions.append(entrySuccessInstructions);\n\n\t\trange.insert(entryInstructions, Range.InsideBefore);\n\t}\n\n\t// PTWIMPL Create static initializer to call the aspect factory\n\t/**\n\t * Causes the aspect instance to be *set* for later retrievable through localAspectof()/aspectOf()\n\t */\n\tpublic void weavePerTypeWithinAspectInitialization(final BcelAdvice munger, UnresolvedType t) {\n\t\tResolvedType tResolved = t.resolve(world);\n\t\tif (tResolved.isInterface()) {\n\t\t\treturn; // Don't initialize statics in interfaces\n\t\t}\n\t\tResolvedType aspectRT = munger.getConcreteAspect();\n\t\tBcelWorld.getBcelObjectType(aspectRT);\n\n\t\t// Although matched, if the visibility rules prevent the aspect from seeing this type, don't\n\t\t// insert any code (easier to do it here than try to affect the matching logic, unfortunately)\n\t\tif (!(tResolved.canBeSeenBy(aspectRT) || aspectRT.isPrivilegedAspect())) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal InstructionFactory fact = getFactory();\n\n\t\tInstructionList entryInstructions = new InstructionList();\n\t\tInstructionList entrySuccessInstructions = new InstructionList();\n\n\t\tString aspectname = munger.getConcreteAspect().getName();\n\n\t\tString ptwField = NameMangler.perTypeWithinFieldForTarget(munger.getConcreteAspect());\n\t\tentrySuccessInstructions.append(InstructionFactory.PUSH(fact.getConstantPool(), t.getName()));\n\n\t\tentrySuccessInstructions.append(fact.createInvoke(aspectname, \"ajc$createAspectInstance\", new ObjectType(aspectname),\n\t\t\t\tnew Type[] { new ObjectType(\"java.lang.String\") }, Constants.INVOKESTATIC));\n\t\tentrySuccessInstructions.append(fact.createPutStatic(t.getName(), ptwField, new ObjectType(aspectname)));\n\n\t\tentryInstructions.append(entrySuccessInstructions);\n\n\t\trange.insert(entryInstructions, Range.InsideBefore);\n\t}\n\n\tpublic void weaveCflowEntry(final BcelAdvice munger, final Member cflowField) {\n\t\tfinal boolean isPer = munger.getKind() == AdviceKind.PerCflowBelowEntry || munger.getKind() == AdviceKind.PerCflowEntry;\n\t\tif (!isPer && getKind() == PreInitialization) {\n\t\t\treturn;\n\t\t}\n\t\tfinal Type objectArrayType = new ArrayType(Type.OBJECT, 1);\n\t\tfinal InstructionFactory fact = getFactory();\n\n\t\tfinal BcelVar testResult = genTempVar(UnresolvedType.BOOLEAN);\n\n\t\tInstructionList entryInstructions = new InstructionList();\n\t\t{\n\t\t\tInstructionList entrySuccessInstructions = new InstructionList();\n\n\t\t\tif (munger.hasDynamicTests()) {\n\t\t\t\tentryInstructions.append(Utility.createConstant(fact, 0));\n\t\t\t\ttestResult.appendStore(entryInstructions, fact);\n\n\t\t\t\tentrySuccessInstructions.append(Utility.createConstant(fact, 1));\n\t\t\t\ttestResult.appendStore(entrySuccessInstructions, fact);\n\t\t\t}\n\n\t\t\tif (isPer) {\n\t\t\t\tentrySuccessInstructions.append(fact.createInvoke(munger.getConcreteAspect().getName(),\n\t\t\t\t\t\tNameMangler.PERCFLOW_PUSH_METHOD, Type.VOID, Type.NO_ARGS, Constants.INVOKESTATIC));\n\t\t\t} else {\n\t\t\t\tBcelVar[] cflowStateVars = munger.getExposedStateAsBcelVars(false);\n\n\t\t\t\tif (cflowStateVars.length == 0) {\n\t\t\t\t\t// This should be getting managed by a counter - lets make sure.\n\t\t\t\t\tif (!cflowField.getType().getName().endsWith(\"CFlowCounter\")) {\n\t\t\t\t\t\tthrow new RuntimeException(\"Incorrectly attempting counter operation on stacked cflow\");\n\t\t\t\t\t}\n\t\t\t\t\tentrySuccessInstructions.append(Utility.createGet(fact, cflowField));\n\t\t\t\t\t// arrayVar.appendLoad(entrySuccessInstructions, fact);\n\t\t\t\t\tentrySuccessInstructions.append(fact.createInvoke(NameMangler.CFLOW_COUNTER_TYPE, \"inc\", Type.VOID,\n\t\t\t\t\t\t\tType.NO_ARGS, Constants.INVOKEVIRTUAL));\n\t\t\t\t} else {\n\t\t\t\t\tBcelVar arrayVar = genTempVar(UnresolvedType.OBJECTARRAY);\n\n\t\t\t\t\tint alen = cflowStateVars.length;\n\t\t\t\t\tentrySuccessInstructions.append(Utility.createConstant(fact, alen));\n\t\t\t\t\tentrySuccessInstructions.append(fact.createNewArray(Type.OBJECT, (short) 1));\n\t\t\t\t\tarrayVar.appendStore(entrySuccessInstructions, fact);\n\n\t\t\t\t\tfor (int i = 0; i < alen; i++) {\n\t\t\t\t\t\tarrayVar.appendConvertableArrayStore(entrySuccessInstructions, fact, i, cflowStateVars[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tentrySuccessInstructions.append(Utility.createGet(fact, cflowField));\n\t\t\t\t\tarrayVar.appendLoad(entrySuccessInstructions, fact);\n\n\t\t\t\t\tentrySuccessInstructions.append(fact.createInvoke(NameMangler.CFLOW_STACK_TYPE, \"push\", Type.VOID,\n\t\t\t\t\t\t\tnew Type[] { objectArrayType }, Constants.INVOKEVIRTUAL));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInstructionList testInstructions = munger.getTestInstructions(this, entrySuccessInstructions.getStart(),\n\t\t\t\t\trange.getRealStart(), entrySuccessInstructions.getStart());\n\t\t\tentryInstructions.append(testInstructions);\n\t\t\tentryInstructions.append(entrySuccessInstructions);\n\t\t}\n\n\t\tBcelAdvice exitAdvice = new BcelAdvice(null, null, null, 0, 0, 0, null, munger.getConcreteAspect()) {\n\t\t\t@Override\n\t\t\tpublic InstructionList getAdviceInstructions(BcelShadow s, BcelVar extraArgVar, InstructionHandle ifNoAdvice) {\n\t\t\t\tInstructionList exitInstructions = new InstructionList();\n\t\t\t\tif (munger.hasDynamicTests()) {\n\t\t\t\t\ttestResult.appendLoad(exitInstructions, fact);\n\t\t\t\t\texitInstructions.append(InstructionFactory.createBranchInstruction(Constants.IFEQ, ifNoAdvice));\n\t\t\t\t}\n\t\t\t\texitInstructions.append(Utility.createGet(fact, cflowField));\n\t\t\t\tif (munger.getKind() != AdviceKind.PerCflowEntry && munger.getKind() != AdviceKind.PerCflowBelowEntry\n\t\t\t\t\t\t&& munger.getExposedStateAsBcelVars(false).length == 0) {\n\t\t\t\t\texitInstructions.append(fact.createInvoke(NameMangler.CFLOW_COUNTER_TYPE, \"dec\", Type.VOID, Type.NO_ARGS,\n\t\t\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t\t\t} else {\n\t\t\t\t\texitInstructions.append(fact.createInvoke(NameMangler.CFLOW_STACK_TYPE, \"pop\", Type.VOID, Type.NO_ARGS,\n\t\t\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t\t\t}\n\t\t\t\treturn exitInstructions;\n\t\t\t}\n\t\t};\n//\t\tif (getKind() == PreInitialization) {\n//\t\t\tweaveAfterReturning(exitAdvice);\n//\t\t}\n//\t\telse {\n\t\t\tweaveAfter(exitAdvice);\n//\t\t}\n\n\t\trange.insert(entryInstructions, Range.InsideBefore);\n\t}\n\n\t/*\n\t * Implementation notes:\n\t *\n\t * AroundInline still extracts the instructions of the original shadow into an extracted method. This allows inlining of even\n\t * that advice that doesn't call proceed or calls proceed more than once.\n\t *\n\t * It extracts the instructions of the original shadow into a method.\n\t *\n\t * Then it extracts the instructions of the advice into a new method defined on this enclosing class. This new method can then\n\t * be specialized as below.\n\t *\n\t * Then it searches in the instructions of the advice for any call to the proceed method.\n\t *\n\t * At such a call, there is stuff on the stack representing the arguments to proceed. Pop these into the frame.\n\t *\n\t * Now build the stack for the call to the extracted method, taking values either from the join point state or from the new\n\t * frame locs from proceed. Now call the extracted method. The right return value should be on the stack, so no cast is\n\t * necessary.\n\t *\n\t * If only one call to proceed is made, we can re-inline the original shadow. We are not doing that presently.\n\t *\n\t * If the body of the advice can be determined to not alter the stack, or if this shadow doesn't care about the stack, i.e.\n\t * method-execution, then the new method for the advice can also be re-lined. We are not doing that presently.\n\t */\n\tpublic void weaveAroundInline(BcelAdvice munger, boolean hasDynamicTest) {\n\t\t// !!! THIS BLOCK OF CODE SHOULD BE IN A METHOD CALLED weaveAround(...);\n\t\tMember mungerSig = munger.getSignature();\n\t\t// Member originalSig = mungerSig; // If mungerSig is on a parameterized type, originalSig is the member on the generic type\n\t\tif (mungerSig instanceof ResolvedMember) {\n\t\t\tResolvedMember rm = (ResolvedMember) mungerSig;\n\t\t\tif (rm.hasBackingGenericMember()) {\n\t\t\t\tmungerSig = rm.getBackingGenericMember();\n\t\t\t}\n\t\t}\n\t\tResolvedType declaringAspectType = world.resolve(mungerSig.getDeclaringType(), true);\n\t\tif (declaringAspectType.isMissing()) {\n\t\t\tworld.getLint().cantFindType.signal(\n\t\t\t\t\tnew String[] { WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE,\n\t\t\t\t\t\t\tdeclaringAspectType.getClassName()) }, getSourceLocation(),\n\t\t\t\t\tnew ISourceLocation[] { munger.getSourceLocation() });\n\t\t}\n\n\t\t// ??? might want some checks here to give better errors\n\t\tResolvedType rt = (declaringAspectType.isParameterizedType() ? declaringAspectType.getGenericType() : declaringAspectType);\n\t\tBcelObjectType ot = BcelWorld.getBcelObjectType(rt);\n\t\tLazyMethodGen adviceMethod = ot.getLazyClassGen().getLazyMethodGen(mungerSig);\n\t\tif (!adviceMethod.getCanInline()) {\n\t\t\tweaveAroundClosure(munger, hasDynamicTest);\n\t\t\treturn;\n\t\t}\n\n\t\t// specific test for @AJ proceedInInners\n\t\tif (isAnnotationStylePassingProceedingJoinPointOutOfAdvice(munger, hasDynamicTest, adviceMethod)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We can't inline around methods if they have around advice on them, this\n\t\t// is because the weaving will extract the body and hence the proceed call.\n\n\t\t// TODO should consider optimizations to recognize simple cases that don't require body extraction\n\n\t\tenclosingMethod.setCanInline(false);\n\n\t\tLazyClassGen shadowClass = getEnclosingClass();\n\n\t\t// Extract the shadow into a new method. For example:\n\t\t// \"private static final void method_aroundBody0(M, M, String, org.aspectj.lang.JoinPoint)\"\n\t\t// Parameters are: this if there is one, target if there is one and its different to this, then original arguments\n\t\t// at the shadow, then tjp\n\t\tString extractedShadowMethodName = NameMangler.aroundShadowMethodName(getSignature(), shadowClass.getNewGeneratedNameTag());\n\t\tList<String> parameterNames = new ArrayList<>();\n\t\tboolean shadowClassIsInterface = shadowClass.isInterface();\n\t\tLazyMethodGen extractedShadowMethod = extractShadowInstructionsIntoNewMethod(extractedShadowMethodName,\n\t\t\t\tshadowClassIsInterface?Modifier.PUBLIC:Modifier.PRIVATE,\n\t\t\t\tmunger.getSourceLocation(), parameterNames,shadowClassIsInterface);\n\n\t\tList<BcelVar> argsToCallLocalAdviceMethodWith = new ArrayList<>();\n\t\tList<BcelVar> proceedVarList = new ArrayList<>();\n\t\tint extraParamOffset = 0;\n\n\t\t// Create the extra parameters that are needed for passing to proceed\n\t\t// This code is very similar to that found in makeCallToCallback and should\n\t\t// be rationalized in the future\n\n\t\tif (thisVar != null) {\n\t\t\targsToCallLocalAdviceMethodWith.add(thisVar);\n\t\t\tproceedVarList.add(new BcelVar(thisVar.getType(), extraParamOffset));\n\t\t\textraParamOffset += thisVar.getType().getSize();\n\t\t}\n\n\t\tif (targetVar != null && targetVar != thisVar) {\n\t\t\targsToCallLocalAdviceMethodWith.add(targetVar);\n\t\t\tproceedVarList.add(new BcelVar(targetVar.getType(), extraParamOffset));\n\t\t\textraParamOffset += targetVar.getType().getSize();\n\t\t}\n\t\tfor (int i = 0, len = getArgCount(); i < len; i++) {\n\t\t\targsToCallLocalAdviceMethodWith.add(argVars[i]);\n\t\t\tproceedVarList.add(new BcelVar(argVars[i].getType(), extraParamOffset));\n\t\t\textraParamOffset += argVars[i].getType().getSize();\n\t\t}\n\t\tif (thisJoinPointVar != null) {\n\t\t\targsToCallLocalAdviceMethodWith.add(thisJoinPointVar);\n\t\t\tproceedVarList.add(new BcelVar(thisJoinPointVar.getType(), extraParamOffset));\n\t\t\textraParamOffset += thisJoinPointVar.getType().getSize();\n\t\t}\n\n\t\t// We use the munger signature here because it allows for any parameterization of the mungers pointcut that\n\t\t// may have occurred ie. if the pointcut is p(T t) in the super aspect and that has become p(Foo t) in the sub aspect\n\t\t// then here the munger signature will have 'Foo' as an argument in it whilst the adviceMethod argument type will be\n\t\t// 'Object' - since it represents the advice method in the superaspect which uses the erasure of the type variable p(Object\n\t\t// t) - see pr174449.\n\n\t\tType[] adviceParameterTypes = BcelWorld.makeBcelTypes(munger.getSignature().getParameterTypes());\n\n\t\t// forces initialization ... dont like this but seems to be required for some tests to pass, I think that means there\n\t\t// is a LazyMethodGen method that is not correctly setup to call initialize() when it is invoked - but I dont have\n\t\t// time right now to discover which\n\t\tadviceMethod.getArgumentTypes();\n\n\t\tType[] extractedMethodParameterTypes = extractedShadowMethod.getArgumentTypes();\n\n\t\tType[] parameterTypes = new Type[extractedMethodParameterTypes.length + adviceParameterTypes.length + 1];\n\t\tint parameterIndex = 0;\n\t\tSystem.arraycopy(extractedMethodParameterTypes, 0, parameterTypes, parameterIndex, extractedMethodParameterTypes.length);\n\t\tparameterIndex += extractedMethodParameterTypes.length;\n\t\tparameterTypes[parameterIndex++] = BcelWorld.makeBcelType(adviceMethod.getEnclosingClass().getType());\n\t\tSystem.arraycopy(adviceParameterTypes, 0, parameterTypes, parameterIndex, adviceParameterTypes.length);\n\n\t\t// Extract the advice into a new method. This will go in the same type as the shadow\n\t\t// name will be something like foo_aroundBody1$advice\n\t\tString localAdviceMethodName = NameMangler.aroundAdviceMethodName(getSignature(), shadowClass.getNewGeneratedNameTag());\n\t\tint localAdviceMethodModifiers = Modifier.PRIVATE | (world.useFinal() & !shadowClassIsInterface ? Modifier.FINAL : 0) | Modifier.STATIC;\n\t\tLazyMethodGen localAdviceMethod = new LazyMethodGen(localAdviceMethodModifiers, BcelWorld.makeBcelType(mungerSig.getReturnType()), localAdviceMethodName, parameterTypes,\n\t\t\t\tNoDeclaredExceptions, shadowClass);\n\n\t\t// Doesnt work properly, so leave it out:\n\t\t// String aspectFilename = adviceMethod.getEnclosingClass().getInternalFileName();\n\t\t// String shadowFilename = shadowClass.getInternalFileName();\n\t\t// if (!aspectFilename.equals(shadowFilename)) {\n\t\t// localAdviceMethod.fromFilename = aspectFilename;\n\t\t// shadowClass.addInlinedSourceFileInfo(aspectFilename, adviceMethod.highestLineNumber);\n\t\t// }\n\n\t\tshadowClass.addMethodGen(localAdviceMethod);\n\n\t\t// create a map that will move all slots in advice method forward by extraParamOffset\n\t\t// in order to make room for the new proceed-required arguments that are added at\n\t\t// the beginning of the parameter list\n\t\tint nVars = adviceMethod.getMaxLocals() + extraParamOffset;\n\t\tIntMap varMap = IntMap.idMap(nVars);\n\t\tfor (int i = extraParamOffset; i < nVars; i++) {\n\t\t\tvarMap.put(i - extraParamOffset, i);\n\t\t}\n\n\t\tfinal InstructionFactory fact = getFactory();\n\n\t\tlocalAdviceMethod.getBody().insert(\n\t\t\t\tBcelClassWeaver.genInlineInstructions(adviceMethod, localAdviceMethod, varMap, fact, true));\n\n\t\tlocalAdviceMethod.setMaxLocals(nVars);\n\n\t\t// the shadow is now empty. First, create a correct call\n\t\t// to the around advice. This includes both the call (which may involve\n\t\t// value conversion of the advice arguments) and the return\n\t\t// (which may involve value conversion of the return value). Right now\n\t\t// we push a null for the unused closure. It's sad, but there it is.\n\n\t\tInstructionList advice = new InstructionList();\n\t\t// InstructionHandle adviceMethodInvocation;\n\t\t{\n\t\t\tfor (BcelVar var : argsToCallLocalAdviceMethodWith) {\n\t\t\t\tvar.appendLoad(advice, fact);\n\t\t\t}\n\t\t\t// ??? we don't actually need to push NULL for the closure if we take care\n\t\t\tboolean isAnnoStyleConcreteAspect = munger.getConcreteAspect().isAnnotationStyleAspect();\n\t\t\tboolean isAnnoStyleDeclaringAspect = munger.getDeclaringAspect() != null ? munger.getDeclaringAspect().resolve(world)\n\t\t\t\t\t.isAnnotationStyleAspect() : false;\n\n\t\t\tInstructionList iList = null;\n\t\t\tif (isAnnoStyleConcreteAspect && isAnnoStyleDeclaringAspect) {\n\t\t\t\tiList = this.loadThisJoinPoint();\n\t\t\t\tiList.append(Utility.createConversion(getFactory(), LazyClassGen.tjpType, LazyClassGen.proceedingTjpType));\n\t\t\t} else {\n\t\t\t\tiList = new InstructionList(InstructionConstants.ACONST_NULL);\n\t\t\t}\n\t\t\tadvice.append(munger.getAdviceArgSetup(this, null, iList));\n\t\t\t// adviceMethodInvocation =\n\t\t\tadvice.append(Utility.createInvoke(fact, localAdviceMethod)); // (fact, getWorld(), munger.getSignature()));\n\t\t\tadvice.append(Utility.createConversion(getFactory(), BcelWorld.makeBcelType(mungerSig.getReturnType()),\n\t\t\t\t\textractedShadowMethod.getReturnType(), world.isInJava5Mode()));\n\t\t\tif (!isFallsThrough()) {\n\t\t\t\tadvice.append(InstructionFactory.createReturn(extractedShadowMethod.getReturnType()));\n\t\t\t}\n\t\t}\n\n\t\t// now, situate the call inside the possible dynamic tests,\n\t\t// and actually add the whole mess to the shadow\n\t\tif (!hasDynamicTest) {\n\t\t\trange.append(advice);\n\t\t} else {\n\t\t\tInstructionList afterThingie = new InstructionList(InstructionConstants.NOP);\n\t\t\tInstructionList callback = makeCallToCallback(extractedShadowMethod);\n\t\t\tif (terminatesWithReturn()) {\n\t\t\t\tcallback.append(InstructionFactory.createReturn(extractedShadowMethod.getReturnType()));\n\t\t\t} else {\n\t\t\t\t// InstructionHandle endNop = range.insert(fact.NOP, Range.InsideAfter);\n\t\t\t\tadvice.append(InstructionFactory.createBranchInstruction(Constants.GOTO, afterThingie.getStart()));\n\t\t\t}\n\t\t\trange.append(munger.getTestInstructions(this, advice.getStart(), callback.getStart(), advice.getStart()));\n\t\t\trange.append(advice);\n\t\t\trange.append(callback);\n\t\t\trange.append(afterThingie);\n\t\t}\n\n\t\t// now search through the advice, looking for a call to PROCEED.\n\t\t// Then we replace the call to proceed with some argument setup, and a\n\t\t// call to the extracted method.\n\n\t\t// inlining support for code style aspects\n\t\tif (!munger.getDeclaringType().isAnnotationStyleAspect()) {\n\t\t\tString proceedName = NameMangler.proceedMethodName(munger.getSignature().getName());\n\n\t\t\tInstructionHandle curr = localAdviceMethod.getBody().getStart();\n\t\t\tInstructionHandle end = localAdviceMethod.getBody().getEnd();\n\t\t\tConstantPool cpg = localAdviceMethod.getEnclosingClass().getConstantPool();\n\t\t\twhile (curr != end) {\n\t\t\t\tInstructionHandle next = curr.getNext();\n\t\t\t\tInstruction inst = curr.getInstruction();\n\t\t\t\tif ((inst.opcode == Constants.INVOKESTATIC) && proceedName.equals(((InvokeInstruction) inst).getMethodName(cpg))) {\n\n\t\t\t\t\tlocalAdviceMethod.getBody().append(curr,\n\t\t\t\t\t\t\tgetRedoneProceedCall(fact, extractedShadowMethod, munger, localAdviceMethod, proceedVarList));\n\t\t\t\t\tUtility.deleteInstruction(curr, localAdviceMethod);\n\t\t\t\t}\n\t\t\t\tcurr = next;\n\t\t\t}\n\t\t\t// and that's it.\n\t\t} else {\n\t\t\t// ATAJ inlining support for @AJ aspects\n\t\t\t// [TODO document @AJ code rule: don't manipulate 2 jps proceed at the same time.. in an advice body]\n\t\t\tInstructionHandle curr = localAdviceMethod.getBody().getStart();\n\t\t\tInstructionHandle end = localAdviceMethod.getBody().getEnd();\n\t\t\tConstantPool cpg = localAdviceMethod.getEnclosingClass().getConstantPool();\n\t\t\twhile (curr != end) {\n\t\t\t\tInstructionHandle next = curr.getNext();\n\t\t\t\tInstruction inst = curr.getInstruction();\n\t\t\t\tif ((inst instanceof INVOKEINTERFACE) && \"proceed\".equals(((INVOKEINTERFACE) inst).getMethodName(cpg))) {\n\t\t\t\t\tfinal boolean isProceedWithArgs;\n\t\t\t\t\tif (((INVOKEINTERFACE) inst).getArgumentTypes(cpg).length == 1) {\n\t\t\t\t\t\t// proceed with args as a boxed Object[]\n\t\t\t\t\t\tisProceedWithArgs = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisProceedWithArgs = false;\n\t\t\t\t\t}\n\t\t\t\t\tInstructionList insteadProceedIl = getRedoneProceedCallForAnnotationStyle(fact, extractedShadowMethod, munger,\n\t\t\t\t\t\t\tlocalAdviceMethod, proceedVarList, isProceedWithArgs);\n\t\t\t\t\tlocalAdviceMethod.getBody().append(curr, insteadProceedIl);\n\t\t\t\t\tUtility.deleteInstruction(curr, localAdviceMethod);\n\t\t\t\t}\n\t\t\t\tcurr = next;\n\t\t\t}\n\t\t}\n\n\t\t// if (parameterNames.size() == 0) {\n\t\t// On return we have inserted the advice body into the local advice method. We have remapped all the local variables\n\t\t// that were referenced in the advice as we did the copy, and so the local variable table for localAdviceMethod is\n\t\t// now lacking any information about all the initial variables.\n\t\tInstructionHandle start = localAdviceMethod.getBody().getStart();\n\t\tInstructionHandle end = localAdviceMethod.getBody().getEnd();\n\n\t\t// Find the real start and end\n\t\twhile (start.getInstruction().opcode == Constants.IMPDEP1) {\n\t\t\tstart = start.getNext();\n\t\t}\n\t\twhile (end.getInstruction().opcode == Constants.IMPDEP1) {\n\t\t\tend = end.getPrev();\n\t\t}\n\t\tType[] args = localAdviceMethod.getArgumentTypes();\n\t\tint argNumber = 0;\n\t\tfor (int slot = 0; slot < extraParamOffset; argNumber++) { // slot will increase by the argument size each time\n\t\t\tString argumentName = null;\n\t\t\tif (argNumber >= args.length || parameterNames.size() == 0 || argNumber >= parameterNames.size()) {\n\t\t\t\t// this should be unnecessary as I think all known joinpoints and helper methods\n\t\t\t\t// propagate the parameter names around correctly - but just in case let us do this\n\t\t\t\t// rather than fail. If a bug is raised reporting unknown as a local variable name\n\t\t\t\t// then investigate the joinpoint giving rise to the ResolvedMember and why it has\n\t\t\t\t// no parameter names specified\n\t\t\t\targumentName = new StringBuilder(\"unknown\").append(argNumber).toString();\n\t\t\t} else {\n\t\t\t\targumentName = parameterNames.get(argNumber);\n\t\t\t}\n\t\t\tString argumentSignature = args[argNumber].getSignature();\n\t\t\tLocalVariableTag lvt = new LocalVariableTag(argumentSignature, argumentName, slot, 0);\n\t\t\tstart.addTargeter(lvt);\n\t\t\tend.addTargeter(lvt);\n\t\t\tslot += args[argNumber].getSize();\n\t\t}\n\t}\n\n\t/**\n\t * Check if the advice method passes a pjp parameter out via an invoke instruction - if so we can't risk inlining.\n\t */\n\tprivate boolean isAnnotationStylePassingProceedingJoinPointOutOfAdvice(BcelAdvice munger, boolean hasDynamicTest,\n\t\t\tLazyMethodGen adviceMethod) {\n\t\tif (munger.getConcreteAspect().isAnnotationStyleAspect()) {\n\t\t\t// if we can't find one proceed() we suspect that the call\n\t\t\t// is happening in an inner class so we don't inline it.\n\t\t\t// Note: for code style, this is done at Aspect compilation time.\n\t\t\tboolean canSeeProceedPassedToOther = false;\n\t\t\tInstructionHandle curr = adviceMethod.getBody().getStart();\n\t\t\tInstructionHandle end = adviceMethod.getBody().getEnd();\n\t\t\tConstantPool cpg = adviceMethod.getEnclosingClass().getConstantPool();\n\t\t\twhile (curr != end) {\n\t\t\t\tInstructionHandle next = curr.getNext();\n\t\t\t\tInstruction inst = curr.getInstruction();\n\t\t\t\tif ((inst instanceof InvokeInstruction)\n\t\t\t\t\t\t&& ((InvokeInstruction) inst).getSignature(cpg).indexOf(\"Lorg/aspectj/lang/ProceedingJoinPoint;\") > 0) {\n\t\t\t\t\t// we may want to refine to exclude stuff returning jp ?\n\t\t\t\t\t// does code style skip inline if i write dump(thisJoinPoint) ?\n\t\t\t\t\tcanSeeProceedPassedToOther = true;// we see one pjp passed around - dangerous\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcurr = next;\n\t\t\t}\n\t\t\tif (canSeeProceedPassedToOther) {\n\t\t\t\t// remember this decision to avoid re-analysis\n\t\t\t\tadviceMethod.setCanInline(false);\n\t\t\t\tweaveAroundClosure(munger, hasDynamicTest);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate InstructionList getRedoneProceedCall(InstructionFactory fact, LazyMethodGen callbackMethod, BcelAdvice munger,\n\t\t\tLazyMethodGen localAdviceMethod, List<BcelVar> argVarList) {\n\t\tInstructionList ret = new InstructionList();\n\t\t// we have on stack all the arguments for the ADVICE call.\n\t\t// we have in frame somewhere all the arguments for the non-advice call.\n\n\t\tBcelVar[] adviceVars = munger.getExposedStateAsBcelVars(true);\n\t\tIntMap proceedMap = makeProceedArgumentMap(adviceVars);\n\n\t\t// System.out.println(proceedMap + \" for \" + this);\n\t\t// System.out.println(argVarList);\n\n\t\tResolvedType[] proceedParamTypes = world.resolve(munger.getSignature().getParameterTypes());\n\t\t// remove this*JoinPoint* as arguments to proceed\n\t\tif (munger.getBaseParameterCount() + 1 < proceedParamTypes.length) {\n\t\t\tint len = munger.getBaseParameterCount() + 1;\n\t\t\tResolvedType[] newTypes = new ResolvedType[len];\n\t\t\tSystem.arraycopy(proceedParamTypes, 0, newTypes, 0, len);\n\t\t\tproceedParamTypes = newTypes;\n\t\t}\n\n\t\t// System.out.println(\"stateTypes: \" + Arrays.asList(stateTypes));\n\t\tBcelVar[] proceedVars = Utility.pushAndReturnArrayOfVars(proceedParamTypes, ret, fact, localAdviceMethod);\n\n\t\tType[] stateTypes = callbackMethod.getArgumentTypes();\n\t\t// System.out.println(\"stateTypes: \" + Arrays.asList(stateTypes));\n\n\t\tfor (int i = 0, len = stateTypes.length; i < len; i++) {\n\t\t\tType stateType = stateTypes[i];\n\t\t\tResolvedType stateTypeX = BcelWorld.fromBcel(stateType).resolve(world);\n\t\t\tif (proceedMap.hasKey(i)) {\n\t\t\t\t// throw new RuntimeException(\"unimplemented\");\n\t\t\t\tproceedVars[proceedMap.get(i)].appendLoadAndConvert(ret, fact, stateTypeX);\n\t\t\t} else {\n\t\t\t\targVarList.get(i).appendLoad(ret, fact);\n\t\t\t}\n\t\t}\n\n\t\tret.append(Utility.createInvoke(fact, callbackMethod));\n\t\tret.append(Utility.createConversion(fact, callbackMethod.getReturnType(),\n\t\t\t\tBcelWorld.makeBcelType(munger.getSignature().getReturnType()), world.isInJava5Mode()));\n\t\treturn ret;\n\t}\n\n\t// private static boolean bindsThisOrTarget(Pointcut pointcut) {\n\t// ThisTargetFinder visitor = new ThisTargetFinder();\n\t// pointcut.accept(visitor, null);\n\t// return visitor.bindsThisOrTarget;\n\t// }\n\n\t// private static class ThisTargetFinder extends IdentityPointcutVisitor {\n\t// boolean bindsThisOrTarget = false;\n\t//\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\n\t// if (node.isBinding()) {\n\t// bindsThisOrTarget = true;\n\t// }\n\t// return node;\n\t// }\n\t//\n\t// public Object visit(AndPointcut node, Object data) {\n\t// if (!bindsThisOrTarget) node.getLeft().accept(this, data);\n\t// if (!bindsThisOrTarget) node.getRight().accept(this, data);\n\t// return node;\n\t// }\n\t//\n\t// public Object visit(NotPointcut node, Object data) {\n\t// if (!bindsThisOrTarget) node.getNegatedPointcut().accept(this, data);\n\t// return node;\n\t// }\n\t//\n\t// public Object visit(OrPointcut node, Object data) {\n\t// if (!bindsThisOrTarget) node.getLeft().accept(this, data);\n\t// if (!bindsThisOrTarget) node.getRight().accept(this, data);\n\t// return node;\n\t// }\n\t// }\n\n\t/**\n\t * Annotation style handling for inlining.\n\t *\n\t * Note: The proceedingjoinpoint is already on the stack (since the user was calling pjp.proceed(...)\n\t *\n\t * The proceed map is ignored (in terms of argument repositioning) since we have a fixed expected format for annotation style.\n\t * The aim here is to change the proceed() call into a call to the xxx_aroundBody0 method.\n\t *\n\t *\n\t */\n\tprivate InstructionList getRedoneProceedCallForAnnotationStyle(InstructionFactory fact, LazyMethodGen callbackMethod,\n\t\t\tBcelAdvice munger, LazyMethodGen localAdviceMethod, List<BcelVar> argVarList, boolean isProceedWithArgs) {\n\t\tInstructionList ret = new InstructionList();\n\n\t\t// store the Object[] array on stack if proceed with args\n\t\tif (isProceedWithArgs) {\n\n\t\t\t// STORE the Object[] into a local variable\n\t\t\tType objectArrayType = Type.OBJECT_ARRAY;\n\t\t\tint theObjectArrayLocalNumber = localAdviceMethod.allocateLocal(objectArrayType);\n\t\t\tret.append(InstructionFactory.createStore(objectArrayType, theObjectArrayLocalNumber));\n\n\t\t\t// STORE the ProceedingJoinPoint instance into a local variable\n\t\t\tType proceedingJpType = Type.getType(\"Lorg/aspectj/lang/ProceedingJoinPoint;\");\n\t\t\tint pjpLocalNumber = localAdviceMethod.allocateLocal(proceedingJpType);\n\t\t\tret.append(InstructionFactory.createStore(proceedingJpType, pjpLocalNumber));\n\n\t\t\t// Aim here initially is to determine whether the user will have provided a new\n\t\t\t// this/target in the object array and consume them if they have, leaving us the rest of\n\t\t\t// the arguments to process as regular arguments to the invocation at the original join point\n\n\t\t\tboolean pointcutBindsThis = bindsThis(munger);\n\t\t\tboolean pointcutBindsTarget = bindsTarget(munger);\n\t\t\tboolean targetIsSameAsThis = getKind().isTargetSameAsThis();\n\n\t\t\tint nextArgumentToProvideForCallback = 0;\n\n\t\t\tif (hasThis()) {\n\t\t\t\tif (!(pointcutBindsTarget && targetIsSameAsThis)) {\n\t\t\t\t\tif (pointcutBindsThis) {\n\t\t\t\t\t\t// they have supplied new this as first entry in object array, consume it\n\t\t\t\t\t\tret.append(InstructionFactory.createLoad(objectArrayType, theObjectArrayLocalNumber));\n\t\t\t\t\t\tret.append(Utility.createConstant(fact, 0));\n\t\t\t\t\t\tret.append(InstructionFactory.createArrayLoad(Type.OBJECT));\n\t\t\t\t\t\tret.append(Utility.createConversion(fact, Type.OBJECT, callbackMethod.getArgumentTypes()[0]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// use local variable 0\n\t\t\t\t\t\tret.append(InstructionFactory.createALOAD(0));\n\t\t\t\t\t}\n\t\t\t\t\tnextArgumentToProvideForCallback++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasTarget()) {\n\t\t\t\tif (pointcutBindsTarget) {\n\t\t\t\t\tif (getKind().isTargetSameAsThis()) {\n\t\t\t\t\t\tret.append(InstructionFactory.createLoad(objectArrayType, theObjectArrayLocalNumber));\n\t\t\t\t\t\tret.append(Utility.createConstant(fact, pointcutBindsThis ? 1 : 0));\n\t\t\t\t\t\tret.append(InstructionFactory.createArrayLoad(Type.OBJECT));\n\t\t\t\t\t\tret.append(Utility.createConversion(fact, Type.OBJECT, callbackMethod.getArgumentTypes()[0]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint position = (hasThis() && pointcutBindsThis)? 1 : 0;\n\t\t\t\t\t\tret.append(InstructionFactory.createLoad(objectArrayType, theObjectArrayLocalNumber));\n\t\t\t\t\t\tret.append(Utility.createConstant(fact, position));\n\t\t\t\t\t\tret.append(InstructionFactory.createArrayLoad(Type.OBJECT));\n\t\t\t\t\t\tret.append(Utility.createConversion(fact, Type.OBJECT, callbackMethod.getArgumentTypes()[nextArgumentToProvideForCallback]));\n\t\t\t\t\t}\n\t\t\t\t\tnextArgumentToProvideForCallback++;\n\t\t\t\t} else {\n\t\t\t\t\tif (getKind().isTargetSameAsThis()) {\n\t\t\t\t\t\t// ret.append(new ALOAD(0));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret.append(InstructionFactory.createLoad(localAdviceMethod.getArgumentTypes()[0], hasThis() ? 1 : 0));\n\t\t\t\t\t\tnextArgumentToProvideForCallback++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Where to start in the object array in order to pick up arguments\n\t\t\tint indexIntoObjectArrayForArguments = (pointcutBindsThis ? 1 : 0) + (pointcutBindsTarget ? 1 : 0);\n\n\t\t\tint len = callbackMethod.getArgumentTypes().length;\n\t\t\tfor (int i = nextArgumentToProvideForCallback; i < len; i++) {\n\t\t\t\tType stateType = callbackMethod.getArgumentTypes()[i];\n\t\t\t\tBcelWorld.fromBcel(stateType).resolve(world);\n\t\t\t\tif (\"Lorg/aspectj/lang/JoinPoint;\".equals(stateType.getSignature())) {\n\t\t\t\t\tret.append(new InstructionLV(Constants.ALOAD, pjpLocalNumber));\n\t\t\t\t} else {\n\t\t\t\t\tret.append(InstructionFactory.createLoad(objectArrayType, theObjectArrayLocalNumber));\n\t\t\t\t\tret.append(Utility\n\t\t\t\t\t\t\t.createConstant(fact, i - nextArgumentToProvideForCallback + indexIntoObjectArrayForArguments));\n\t\t\t\t\tret.append(InstructionFactory.createArrayLoad(Type.OBJECT));\n\t\t\t\t\tret.append(Utility.createConversion(fact, Type.OBJECT, stateType));\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tType proceedingJpType = Type.getType(\"Lorg/aspectj/lang/ProceedingJoinPoint;\");\n\t\t\tint localJp = localAdviceMethod.allocateLocal(proceedingJpType);\n\t\t\tret.append(InstructionFactory.createStore(proceedingJpType, localJp));\n\n\t\t\tint idx = 0;\n\t\t\tfor (int i = 0, len = callbackMethod.getArgumentTypes().length; i < len; i++) {\n\t\t\t\tType stateType = callbackMethod.getArgumentTypes()[i];\n\t\t\t\t/* ResolvedType stateTypeX = */\n\t\t\t\tBcelWorld.fromBcel(stateType).resolve(world);\n\t\t\t\tif (\"Lorg/aspectj/lang/JoinPoint;\".equals(stateType.getSignature())) {\n\t\t\t\t\tret.append(InstructionFactory.createALOAD(localJp));// from localAdvice signature\n\t\t\t\t\t// } else if (\"Lorg/aspectj/lang/ProceedingJoinPoint;\".equals(stateType.getSignature())) {\n\t\t\t\t\t// //FIXME ALEX?\n\t\t\t\t\t// ret.append(new ALOAD(localJp));// from localAdvice signature\n\t\t\t\t\t// // ret.append(fact.createCheckCast(\n\t\t\t\t\t// // (ReferenceType) BcelWorld.makeBcelType(stateTypeX)\n\t\t\t\t\t// // ));\n\t\t\t\t\t// // cast ?\n\t\t\t\t\t//\n\t\t\t\t\tidx++;\n\t\t\t\t} else {\n\t\t\t\t\tret.append(InstructionFactory.createLoad(stateType, idx));\n\t\t\t\t\tidx += stateType.getSize();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// do the callback invoke\n\t\tret.append(Utility.createInvoke(fact, callbackMethod));\n\n\t\t// box it again. Handles cases where around advice does return something else than Object\n\t\tif (!UnresolvedType.OBJECT.equals(munger.getSignature().getReturnType())) {\n\t\t\tret.append(Utility.createConversion(fact, callbackMethod.getReturnType(), Type.OBJECT));\n\t\t}\n\t\tret.append(Utility.createConversion(fact, callbackMethod.getReturnType(),\n\t\t\t\tBcelWorld.makeBcelType(munger.getSignature().getReturnType()), world.isInJava5Mode()));\n\n\t\treturn ret;\n\n\t\t//\n\t\t//\n\t\t//\n\t\t// if (proceedMap.hasKey(i)) {\n\t\t// ret.append(new ALOAD(i));\n\t\t// //throw new RuntimeException(\"unimplemented\");\n\t\t// //proceedVars[proceedMap.get(i)].appendLoadAndConvert(ret, fact, stateTypeX);\n\t\t// } else {\n\t\t// //((BcelVar) argVarList.get(i)).appendLoad(ret, fact);\n\t\t// //ret.append(new ALOAD(i));\n\t\t// if (\"Lorg/aspectj/lang/JoinPoint;\".equals(stateType.getSignature())) {\n\t\t// ret.append(new ALOAD(i));\n\t\t// } else {\n\t\t// ret.append(new ALOAD(i));\n\t\t// }\n\t\t// }\n\t\t// }\n\t\t//\n\t\t// ret.append(Utility.createInvoke(fact, callbackMethod));\n\t\t// ret.append(Utility.createConversion(fact, callbackMethod.getReturnType(),\n\t\t// BcelWorld.makeBcelType(munger.getSignature().getReturnType())));\n\t\t//\n\t\t// //ret.append(new ACONST_NULL());//will be POPed\n\t\t// if (true) return ret;\n\t\t//\n\t\t//\n\t\t//\n\t\t// // we have on stack all the arguments for the ADVICE call.\n\t\t// // we have in frame somewhere all the arguments for the non-advice call.\n\t\t//\n\t\t// BcelVar[] adviceVars = munger.getExposedStateAsBcelVars();\n\t\t// IntMap proceedMap = makeProceedArgumentMap(adviceVars);\n\t\t//\n\t\t// System.out.println(proceedMap + \" for \" + this);\n\t\t// System.out.println(argVarList);\n\t\t//\n\t\t// ResolvedType[] proceedParamTypes =\n\t\t// world.resolve(munger.getSignature().getParameterTypes());\n\t\t// // remove this*JoinPoint* as arguments to proceed\n\t\t// if (munger.getBaseParameterCount()+1 < proceedParamTypes.length) {\n\t\t// int len = munger.getBaseParameterCount()+1;\n\t\t// ResolvedType[] newTypes = new ResolvedType[len];\n\t\t// System.arraycopy(proceedParamTypes, 0, newTypes, 0, len);\n\t\t// proceedParamTypes = newTypes;\n\t\t// }\n\t\t//\n\t\t// //System.out.println(\"stateTypes: \" + Arrays.asList(stateTypes));\n\t\t// BcelVar[] proceedVars =\n\t\t// Utility.pushAndReturnArrayOfVars(proceedParamTypes, ret, fact, localAdviceMethod);\n\t\t//\n\t\t// Type[] stateTypes = callbackMethod.getArgumentTypes();\n\t\t// // System.out.println(\"stateTypes: \" + Arrays.asList(stateTypes));\n\t\t//\n\t\t// for (int i=0, len=stateTypes.length; i < len; i++) {\n\t\t// Type stateType = stateTypes[i];\n\t\t// ResolvedType stateTypeX = BcelWorld.fromBcel(stateType).resolve(world);\n\t\t// if (proceedMap.hasKey(i)) {\n\t\t// //throw new RuntimeException(\"unimplemented\");\n\t\t// proceedVars[proceedMap.get(i)].appendLoadAndConvert(ret, fact, stateTypeX);\n\t\t// } else {\n\t\t// ((BcelVar) argVarList.get(i)).appendLoad(ret, fact);\n\t\t// }\n\t\t// }\n\t\t//\n\t\t// ret.append(Utility.createInvoke(fact, callbackMethod));\n\t\t// ret.append(Utility.createConversion(fact, callbackMethod.getReturnType(),\n\t\t// BcelWorld.makeBcelType(munger.getSignature().getReturnType())));\n\t\t// return ret;\n\t}\n\n\tprivate boolean bindsThis(BcelAdvice munger) {\n\t\tUsesThisVisitor utv = new UsesThisVisitor();\n\t\tmunger.getPointcut().accept(utv, null);\n\t\treturn utv.usesThis;\n\t}\n\n\tprivate boolean bindsTarget(BcelAdvice munger) {\n\t\tUsesTargetVisitor utv = new UsesTargetVisitor();\n\t\tmunger.getPointcut().accept(utv, null);\n\t\treturn utv.usesTarget;\n\t}\n\n\tprivate static class UsesThisVisitor extends AbstractPatternNodeVisitor {\n\t\tboolean usesThis = false;\n\n\t\t@Override\n\t\tpublic Object visit(ThisOrTargetPointcut node, Object data) {\n\t\t\tif (node.isThis() && node.isBinding()) {\n\t\t\t\tusesThis = true;\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object visit(AndPointcut node, Object data) {\n\t\t\tif (!usesThis) {\n\t\t\t\tnode.getLeft().accept(this, data);\n\t\t\t}\n\t\t\tif (!usesThis) {\n\t\t\t\tnode.getRight().accept(this, data);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object visit(NotPointcut node, Object data) {\n\t\t\tif (!usesThis) {\n\t\t\t\tnode.getNegatedPointcut().accept(this, data);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object visit(OrPointcut node, Object data) {\n\t\t\tif (!usesThis) {\n\t\t\t\tnode.getLeft().accept(this, data);\n\t\t\t}\n\t\t\tif (!usesThis) {\n\t\t\t\tnode.getRight().accept(this, data);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tprivate static class UsesTargetVisitor extends AbstractPatternNodeVisitor {\n\t\tboolean usesTarget = false;\n\n\t\t@Override\n\t\tpublic Object visit(ThisOrTargetPointcut node, Object data) {\n\t\t\tif (!node.isThis() && node.isBinding()) {\n\t\t\t\tusesTarget = true;\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object visit(AndPointcut node, Object data) {\n\t\t\tif (!usesTarget) {\n\t\t\t\tnode.getLeft().accept(this, data);\n\t\t\t}\n\t\t\tif (!usesTarget) {\n\t\t\t\tnode.getRight().accept(this, data);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object visit(NotPointcut node, Object data) {\n\t\t\tif (!usesTarget) {\n\t\t\t\tnode.getNegatedPointcut().accept(this, data);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object visit(OrPointcut node, Object data) {\n\t\t\tif (!usesTarget) {\n\t\t\t\tnode.getLeft().accept(this, data);\n\t\t\t}\n\t\t\tif (!usesTarget) {\n\t\t\t\tnode.getRight().accept(this, data);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\t}\n\n\tBcelVar aroundClosureInstance = null;\n\n\tpublic void weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest) {\n\t\tInstructionFactory fact = getFactory();\n\n\t\tenclosingMethod.setCanInline(false);\n\n\t\tint linenumber = getSourceLine();\n\t\t// MOVE OUT ALL THE INSTRUCTIONS IN MY SHADOW INTO ANOTHER METHOD!\n\n\t\t// callbackMethod will be something like: \"static final void m_aroundBody0(I)\"\n\t\tboolean shadowClassIsInterface = getEnclosingClass().isInterface();\n\t\tLazyMethodGen callbackMethod = extractShadowInstructionsIntoNewMethod(\n\t\t\t\tNameMangler.aroundShadowMethodName(getSignature(), getEnclosingClass().getNewGeneratedNameTag()), shadowClassIsInterface?Modifier.PUBLIC:0,\n\t\t\t\tmunger.getSourceLocation(), new ArrayList<>(),shadowClassIsInterface);\n\n\t\tBcelVar[] adviceVars = munger.getExposedStateAsBcelVars(true);\n\n\t\tString closureClassName = NameMangler.makeClosureClassName(getEnclosingClass().getType(), getEnclosingClass()\n\t\t\t\t.getNewGeneratedNameTag());\n\n\t\tMember constructorSig = new MemberImpl(Member.CONSTRUCTOR, UnresolvedType.forName(closureClassName), 0, \"<init>\",\n\t\t\t\t\"([Ljava/lang/Object;)V\");\n\n\t\tBcelVar closureHolder = null;\n\n\t\t// This is not being used currently since getKind() == preinitializaiton\n\t\t// cannot happen in around advice\n\t\tif (getKind() == PreInitialization) {\n\t\t\tclosureHolder = genTempVar(AjcMemberMaker.AROUND_CLOSURE_TYPE);\n\t\t}\n\n\t\tInstructionList closureInstantiation = makeClosureInstantiation(constructorSig, closureHolder);\n\n\t\t/* LazyMethodGen constructor = */\n\t\tmakeClosureClassAndReturnConstructor(closureClassName, callbackMethod, makeProceedArgumentMap(adviceVars));\n\n\t\tInstructionList returnConversionCode;\n\t\tif (getKind() == PreInitialization) {\n\t\t\treturnConversionCode = new InstructionList();\n\n\t\t\tBcelVar stateTempVar = genTempVar(UnresolvedType.OBJECTARRAY);\n\t\t\tclosureHolder.appendLoad(returnConversionCode, fact);\n\n\t\t\treturnConversionCode.append(Utility.createInvoke(fact, world, AjcMemberMaker.aroundClosurePreInitializationGetter()));\n\t\t\tstateTempVar.appendStore(returnConversionCode, fact);\n\n\t\t\tType[] stateTypes = getSuperConstructorParameterTypes();\n\n\t\t\treturnConversionCode.append(InstructionConstants.ALOAD_0); // put \"this\" back on the stack\n\t\t\tfor (int i = 0, len = stateTypes.length; i < len; i++) {\n\t\t\t\tUnresolvedType bcelTX = BcelWorld.fromBcel(stateTypes[i]);\n\t\t\t\tResolvedType stateRTX = world.resolve(bcelTX, true);\n\t\t\t\tif (stateRTX.isMissing()) {\n\t\t\t\t\tworld.getLint().cantFindType.signal(\n\t\t\t\t\t\t\tnew String[] { WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE_PREINIT,\n\t\t\t\t\t\t\t\t\tbcelTX.getClassName()) }, getSourceLocation(),\n\t\t\t\t\t\t\tnew ISourceLocation[] { munger.getSourceLocation() });\n\t\t\t\t\t// IMessage msg = new Message(\n\t\t\t\t\t// WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE_PREINIT,bcelTX.getClassName()),\n\t\t\t\t\t// \"\",IMessage.ERROR,getSourceLocation(),null,\n\t\t\t\t\t// new ISourceLocation[]{ munger.getSourceLocation()});\n\t\t\t\t\t// world.getMessageHandler().handleMessage(msg);\n\t\t\t\t}\n\t\t\t\tstateTempVar.appendConvertableArrayLoad(returnConversionCode, fact, i, stateRTX);\n\t\t\t}\n\t\t} else {\n\t\t\t// pr226201\n\t\t\tMember mungerSignature = munger.getSignature();\n\t\t\tif (munger.getSignature() instanceof ResolvedMember) {\n\t\t\t\tif (((ResolvedMember) mungerSignature).hasBackingGenericMember()) {\n\t\t\t\t\tmungerSignature = ((ResolvedMember) mungerSignature).getBackingGenericMember();\n\t\t\t\t}\n\t\t\t}\n\t\t\tUnresolvedType returnType = mungerSignature.getReturnType();\n\t\t\treturnConversionCode = Utility.createConversion(getFactory(), BcelWorld.makeBcelType(returnType),\n\t\t\t\t\tcallbackMethod.getReturnType(), world.isInJava5Mode());\n\t\t\tif (!isFallsThrough()) {\n\t\t\t\treturnConversionCode.append(InstructionFactory.createReturn(callbackMethod.getReturnType()));\n\t\t\t}\n\t\t}\n\n\t\t// initialize the bit flags for this shadow\n\t\tint bitflags = 0x000000;\n\t\tif (getKind().isTargetSameAsThis()) {\n\t\t\tbitflags |= 0x010000;\n\t\t}\n\t\tif (hasThis()) {\n\t\t\tbitflags |= 0x001000;\n\t\t}\n\t\tif (bindsThis(munger)) {\n\t\t\tbitflags |= 0x000100;\n\t\t}\n\t\tif (hasTarget()) {\n\t\t\tbitflags |= 0x000010;\n\t\t}\n\t\tif (bindsTarget(munger)) {\n\t\t\tbitflags |= 0x000001;\n\t\t}\n\n\t\tclosureVarInitialized = false;\n\n\t\t// ATAJ for @AJ aspect we need to link the closure with the joinpoint instance\n\t\tif (munger.getConcreteAspect() != null && munger.getConcreteAspect().isAnnotationStyleAspect()\n\t\t\t\t&& munger.getDeclaringAspect() != null && munger.getDeclaringAspect().resolve(world).isAnnotationStyleAspect()) {\n\n\t\t\taroundClosureInstance = genTempVar(AjcMemberMaker.AROUND_CLOSURE_TYPE);\n\t\t\tclosureInstantiation.append(fact.createDup(1));\n\t\t\taroundClosureInstance.appendStore(closureInstantiation, fact);\n\n\t\t\t// stick the bitflags on the stack and call the variant of linkClosureAndJoinPoint that takes an int\n\t\t\tclosureInstantiation.append(fact.createConstant(bitflags));\n\t\t\tif (needAroundClosureStacking) {\n\t\t\t\tclosureInstantiation.append(Utility.createInvoke(getFactory(), getWorld(),\n\t\t\t\t\t\tnew MemberImpl(Member.METHOD, UnresolvedType.forName(\"org.aspectj.runtime.internal.AroundClosure\"),\n\t\t\t\t\t\t\t\tModifier.PUBLIC, \"linkStackClosureAndJoinPoint\", String.format(\"%s%s\", \"(I)\", \"Lorg/aspectj/lang/ProceedingJoinPoint;\"))));\n\n\t\t\t} else {\n\t\t\t\tclosureInstantiation.append(Utility.createInvoke(getFactory(), getWorld(),\n\t\t\t\t\t\tnew MemberImpl(Member.METHOD, UnresolvedType.forName(\"org.aspectj.runtime.internal.AroundClosure\"),\n\t\t\t\t\t\t\t\tModifier.PUBLIC, \"linkClosureAndJoinPoint\", String.format(\"%s%s\", \"(I)\", \"Lorg/aspectj/lang/ProceedingJoinPoint;\"))));\n\t\t\t}\n\n\t\t}\n\n\t\tInstructionList advice = new InstructionList();\n\t\tadvice.append(munger.getAdviceArgSetup(this, null, closureInstantiation));\n\n\t\t// invoke the advice\n\t\tInstructionHandle tryUnlinkPosition  = advice.append(munger.getNonTestAdviceInstructions(this));\n\n\t\tif (needAroundClosureStacking) {\n\t\t\t// Call AroundClosure.unlink() in a 'finally' block\n\t\t\tif (munger.getConcreteAspect() != null && munger.getConcreteAspect().isAnnotationStyleAspect()\n\t\t\t\t\t&& munger.getDeclaringAspect() != null\n\t\t\t\t\t&& munger.getDeclaringAspect().resolve(world).isAnnotationStyleAspect()\n\t\t\t\t\t&& closureVarInitialized) {\n\n\t\t\t\t// Call unlink when 'normal' flow occurring\n\t\t\t\taroundClosureInstance.appendLoad(advice, fact);\n\t\t\t\tInstructionHandle unlinkInsn = advice.append(Utility.createInvoke(getFactory(), getWorld(), new MemberImpl(Member.METHOD, UnresolvedType\n\t\t\t\t\t\t.forName(\"org.aspectj.runtime.internal.AroundClosure\"), Modifier.PUBLIC, \"unlink\",\n\t\t\t\t\t\t\"()V\")));\n\n\t\t\t\tBranchHandle jumpOverHandler = advice.append(new InstructionBranch(Constants.GOTO, null));\n\t\t\t\t// Call unlink in finally block\n\n\t\t\t\t// Do not POP the exception off, we need to rethrow it\n\t\t\t\tInstructionHandle handlerStart = advice.append(aroundClosureInstance.createLoad(fact));\n\t\t\t\tadvice.append(Utility.createInvoke(getFactory(), getWorld(), new MemberImpl(Member.METHOD, UnresolvedType\n\t\t\t\t\t\t.forName(\"org.aspectj.runtime.internal.AroundClosure\"), Modifier.PUBLIC, \"unlink\",\n\t\t\t\t\t\t\"()V\")));\n\t\t\t\t// After that exception is on the top of the stack again\n\t\t\t\tadvice.append(InstructionConstants.ATHROW);\n\t\t\t\tInstructionHandle jumpTarget = advice.append(InstructionConstants.NOP);\n\t\t\t\tjumpOverHandler.setTarget(jumpTarget);\n\t\t\t\tenclosingMethod.addExceptionHandler(tryUnlinkPosition, unlinkInsn, handlerStart, null/* ==finally */, false);\n\t\t\t}\n\t\t}\n\n\t\tadvice.append(returnConversionCode);\n\t\tif (getKind() == Shadow.MethodExecution && linenumber > 0) {\n\t\t\tadvice.getStart().addTargeter(new LineNumberTag(linenumber));\n\t\t}\n\n\t\tif (!hasDynamicTest) {\n\t\t\trange.append(advice);\n\t\t} else {\n\t\t\tInstructionList callback = makeCallToCallback(callbackMethod);\n\t\t\tInstructionList postCallback = new InstructionList();\n\t\t\tif (terminatesWithReturn()) {\n\t\t\t\tcallback.append(InstructionFactory.createReturn(callbackMethod.getReturnType()));\n\t\t\t} else {\n\t\t\t\tadvice.append(InstructionFactory.createBranchInstruction(Constants.GOTO,\n\t\t\t\t\t\tpostCallback.append(InstructionConstants.NOP)));\n\t\t\t}\n\t\t\trange.append(munger.getTestInstructions(this, advice.getStart(), callback.getStart(), advice.getStart()));\n\t\t\trange.append(advice);\n\t\t\trange.append(callback);\n\t\t\trange.append(postCallback);\n\t\t}\n\t}\n\n\t// exposed for testing\n\tInstructionList makeCallToCallback(LazyMethodGen callbackMethod) {\n\t\tInstructionFactory fact = getFactory();\n\t\tInstructionList callback = new InstructionList();\n\t\tif (thisVar != null) {\n\t\t\tcallback.append(InstructionConstants.ALOAD_0);\n\t\t}\n\t\tif (targetVar != null && targetVar != thisVar) {\n\t\t\tcallback.append(BcelRenderer.renderExpr(fact, world, targetVar));\n\t\t}\n\t\tcallback.append(BcelRenderer.renderExprs(fact, world, argVars));\n\t\t// remember to render tjps\n\t\tif (thisJoinPointVar != null) {\n\t\t\tcallback.append(BcelRenderer.renderExpr(fact, world, thisJoinPointVar));\n\t\t}\n\t\tcallback.append(Utility.createInvoke(fact, callbackMethod));\n\t\treturn callback;\n\t}\n\n\t/** side-effect-free */\n\tprivate InstructionList makeClosureInstantiation(Member constructor, BcelVar holder) {\n\n\t\t// LazyMethodGen constructor) {\n\t\tInstructionFactory fact = getFactory();\n\t\tBcelVar arrayVar = genTempVar(UnresolvedType.OBJECTARRAY);\n\t\t// final Type objectArrayType = new ArrayType(Type.OBJECT, 1);\n\t\tfinal InstructionList il = new InstructionList();\n\t\tint alen = getArgCount() + (thisVar == null ? 0 : 1) + ((targetVar != null && targetVar != thisVar) ? 1 : 0)\n\t\t\t\t+ (thisJoinPointVar == null ? 0 : 1);\n\t\til.append(Utility.createConstant(fact, alen));\n\t\til.append(fact.createNewArray(Type.OBJECT, (short) 1));\n\t\tarrayVar.appendStore(il, fact);\n\n\t\tint stateIndex = 0;\n\t\tif (thisVar != null) {\n\t\t\tarrayVar.appendConvertableArrayStore(il, fact, stateIndex, thisVar);\n\t\t\tthisVar.setPositionInAroundState(stateIndex);\n\t\t\tstateIndex++;\n\t\t}\n\t\tif (targetVar != null && targetVar != thisVar) {\n\t\t\tarrayVar.appendConvertableArrayStore(il, fact, stateIndex, targetVar);\n\t\t\ttargetVar.setPositionInAroundState(stateIndex);\n\t\t\tstateIndex++;\n\t\t}\n\t\tfor (int i = 0, len = getArgCount(); i < len; i++) {\n\t\t\tarrayVar.appendConvertableArrayStore(il, fact, stateIndex, argVars[i]);\n\t\t\targVars[i].setPositionInAroundState(stateIndex);\n\t\t\tstateIndex++;\n\t\t}\n\t\tif (thisJoinPointVar != null) {\n\t\t\tarrayVar.appendConvertableArrayStore(il, fact, stateIndex, thisJoinPointVar);\n\t\t\tthisJoinPointVar.setPositionInAroundState(stateIndex);\n\t\t\tstateIndex++;\n\t\t}\n\t\til.append(fact.createNew(new ObjectType(constructor.getDeclaringType().getName())));\n\t\til.append(InstructionConstants.DUP);\n\t\tarrayVar.appendLoad(il, fact);\n\t\til.append(Utility.createInvoke(fact, world, constructor));\n\t\tif (getKind() == PreInitialization) {\n\t\t\til.append(InstructionConstants.DUP);\n\t\t\tholder.appendStore(il, fact);\n\t\t}\n\t\treturn il;\n\t}\n\n\tprivate IntMap makeProceedArgumentMap(BcelVar[] adviceArgs) {\n\t\t// System.err.println(\"coming in with \" + Arrays.asList(adviceArgs));\n\n\t\tIntMap ret = new IntMap();\n\t\tfor (int i = 0, len = adviceArgs.length; i < len; i++) {\n\t\t\tBcelVar v = adviceArgs[i];\n\t\t\tif (v == null) {\n\t\t\t\tcontinue; // XXX we don't know why this is required\n\t\t\t}\n\t\t\tint pos = v.getPositionInAroundState();\n\t\t\tif (pos >= 0) { // need this test to avoid args bound via cflow\n\t\t\t\tret.put(pos, i);\n\t\t\t}\n\t\t}\n\t\t// System.err.println(\"returning \" + ret);\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t *\n\t * @param callbackMethod the method we will call back to when our run method gets called.\n\t * @param proceedMap A map from state position to proceed argument position. May be non covering on state position.\n\t */\n\tprivate LazyMethodGen makeClosureClassAndReturnConstructor(String closureClassName, LazyMethodGen callbackMethod,\n\t\t\tIntMap proceedMap) {\n\t\tString superClassName = \"org.aspectj.runtime.internal.AroundClosure\";\n\t\tType objectArrayType = new ArrayType(Type.OBJECT, 1);\n\n\t\tLazyClassGen closureClass = new LazyClassGen(closureClassName, superClassName, getEnclosingClass().getFileName(),\n\t\t\t\tModifier.PUBLIC, new String[] {}, getWorld());\n\t\tclosureClass.setMajorMinor(getEnclosingClass().getMajor(), getEnclosingClass().getMinor());\n\t\tInstructionFactory fact = new InstructionFactory(closureClass.getConstantPool());\n\n\t\t// constructor\n\t\tLazyMethodGen constructor = new LazyMethodGen(Modifier.PUBLIC, Type.VOID, \"<init>\", new Type[] { objectArrayType },\n\t\t\t\tnew String[] {}, closureClass);\n\t\tInstructionList cbody = constructor.getBody();\n\t\tcbody.append(InstructionFactory.createLoad(Type.OBJECT, 0));\n\t\tcbody.append(InstructionFactory.createLoad(objectArrayType, 1));\n\t\tcbody.append(fact\n\t\t\t\t.createInvoke(superClassName, \"<init>\", Type.VOID, new Type[] { objectArrayType }, Constants.INVOKESPECIAL));\n\t\tcbody.append(InstructionFactory.createReturn(Type.VOID));\n\n\t\tclosureClass.addMethodGen(constructor);\n\n\t\t// Create the 'Object run(Object[])' method\n\t\tLazyMethodGen runMethod = new LazyMethodGen(Modifier.PUBLIC, Type.OBJECT, \"run\", new Type[] { objectArrayType },\n\t\t\t\tnew String[] {}, closureClass);\n\t\tInstructionList mbody = runMethod.getBody();\n\t\tBcelVar proceedVar = new BcelVar(UnresolvedType.OBJECTARRAY.resolve(world), 1);\n\t\t// int proceedVarIndex = 1;\n\t\tBcelVar stateVar = new BcelVar(UnresolvedType.OBJECTARRAY.resolve(world), runMethod.allocateLocal(1));\n\t\t// int stateVarIndex = runMethod.allocateLocal(1);\n\t\tmbody.append(InstructionFactory.createThis());\n\t\tmbody.append(fact.createGetField(superClassName, \"state\", objectArrayType));\n\t\tmbody.append(stateVar.createStore(fact));\n\t\t// mbody.append(fact.createStore(objectArrayType, stateVarIndex));\n\n\t\tType[] stateTypes = callbackMethod.getArgumentTypes();\n\n\t\tfor (int i = 0, len = stateTypes.length; i < len; i++) {\n\t\t\tResolvedType resolvedStateType = BcelWorld.fromBcel(stateTypes[i]).resolve(world);\n\t\t\tif (proceedMap.hasKey(i)) {\n\t\t\t\tmbody.append(proceedVar.createConvertableArrayLoad(fact, proceedMap.get(i), resolvedStateType));\n\t\t\t} else {\n\t\t\t\tmbody.append(stateVar.createConvertableArrayLoad(fact, i, resolvedStateType));\n\t\t\t}\n\t\t}\n\n\t\tmbody.append(Utility.createInvoke(fact, callbackMethod));\n\n\t\tif (getKind() == PreInitialization) {\n\t\t\tmbody.append(Utility.createSet(fact, AjcMemberMaker.aroundClosurePreInitializationField()));\n\t\t\tmbody.append(InstructionConstants.ACONST_NULL);\n\t\t} else {\n\t\t\tmbody.append(Utility.createConversion(fact, callbackMethod.getReturnType(), Type.OBJECT));\n\t\t}\n\t\tmbody.append(InstructionFactory.createReturn(Type.OBJECT));\n\n\t\tclosureClass.addMethodGen(runMethod);\n\n\t\t// class\n\t\tgetEnclosingClass().addGeneratedInner(closureClass);\n\n\t\treturn constructor;\n\t}\n\n\t// ---- extraction methods\n\n\t/**\n\t * Extract the instructions in the shadow to a new method.\n\t *\n\t * @param extractedMethodName name for the new method\n\t * @param extractedMethodVisibilityModifier visibility modifiers for the new method\n\t * @param adviceSourceLocation source location of the advice affecting the shadow\n\t * @param beingPlacedInInterface is this new method going into an interface\n\t */\n\tLazyMethodGen extractShadowInstructionsIntoNewMethod(String extractedMethodName, int extractedMethodVisibilityModifier,\n\t\t\tISourceLocation adviceSourceLocation, List<String> parameterNames, boolean beingPlacedInInterface) {\n\t\t// LazyMethodGen.assertGoodBody(range.getBody(), extractedMethodName);\n\t\tif (!getKind().allowsExtraction()) {\n\t\t\tthrow new BCException(\"Attempt to extract method from a shadow kind (\" + getKind()\n\t\t\t\t\t+ \") that does not support this operation\");\n\t\t}\n\t\tLazyMethodGen newMethod = createShadowMethodGen(extractedMethodName, extractedMethodVisibilityModifier, parameterNames, beingPlacedInInterface);\n\t\tIntMap remapper = makeRemap();\n\t\trange.extractInstructionsInto(newMethod, remapper, (getKind() != PreInitialization) && isFallsThrough());\n\t\tif (getKind() == PreInitialization) {\n\t\t\taddPreInitializationReturnCode(newMethod, getSuperConstructorParameterTypes());\n\t\t}\n\t\tgetEnclosingClass().addMethodGen(newMethod, adviceSourceLocation);\n\t\treturn newMethod;\n\t}\n\n\tprivate void addPreInitializationReturnCode(LazyMethodGen extractedMethod, Type[] superConstructorTypes) {\n\t\tInstructionList body = extractedMethod.getBody();\n\t\tfinal InstructionFactory fact = getFactory();\n\n\t\tBcelVar arrayVar = new BcelVar(world.getCoreType(UnresolvedType.OBJECTARRAY), extractedMethod.allocateLocal(1));\n\n\t\tint len = superConstructorTypes.length;\n\n\t\tbody.append(Utility.createConstant(fact, len));\n\n\t\tbody.append(fact.createNewArray(Type.OBJECT, (short) 1));\n\t\tarrayVar.appendStore(body, fact);\n\n\t\tfor (int i = len - 1; i >= 0; i++) {\n\t\t\t// convert thing on top of stack to object\n\t\t\tbody.append(Utility.createConversion(fact, superConstructorTypes[i], Type.OBJECT));\n\t\t\t// push object array\n\t\t\tarrayVar.appendLoad(body, fact);\n\t\t\t// swap\n\t\t\tbody.append(InstructionConstants.SWAP);\n\t\t\t// do object array store.\n\t\t\tbody.append(Utility.createConstant(fact, i));\n\t\t\tbody.append(InstructionConstants.SWAP);\n\t\t\tbody.append(InstructionFactory.createArrayStore(Type.OBJECT));\n\t\t}\n\t\tarrayVar.appendLoad(body, fact);\n\t\tbody.append(InstructionConstants.ARETURN);\n\t}\n\n\tprivate Type[] getSuperConstructorParameterTypes() {\n\t\t// assert getKind() == PreInitialization\n\t\tInstructionHandle superCallHandle = getRange().getEnd().getNext();\n\t\tInvokeInstruction superCallInstruction = (InvokeInstruction) superCallHandle.getInstruction();\n\t\treturn superCallInstruction.getArgumentTypes(getEnclosingClass().getConstantPool());\n\t}\n\n\t/**\n\t * make a map from old frame location to new frame location. Any unkeyed frame location picks out a copied local\n\t */\n\tprivate IntMap makeRemap() {\n\t\tIntMap ret = new IntMap(5);\n\t\tint reti = 0;\n\t\tif (thisVar != null) {\n\t\t\tret.put(0, reti++); // thisVar guaranteed to be 0\n\t\t}\n\t\tif (targetVar != null && targetVar != thisVar) {\n\t\t\tret.put(targetVar.getSlot(), reti++);\n\t\t}\n\t\tfor (BcelVar argVar : argVars) {\n\t\t\tret.put(argVar.getSlot(), reti);\n\t\t\treti += argVar.getType().getSize();\n\t\t}\n\t\tif (thisJoinPointVar != null) {\n\t\t\tret.put(thisJoinPointVar.getSlot(), reti++);\n\t\t}\n\t\t// we not only need to put the arguments, we also need to remap their\n\t\t// aliases, which we so helpfully put into temps at the beginning of this join\n\t\t// point.\n\t\tif (!getKind().argsOnStack()) {\n\t\t\tint oldi = 0;\n\t\t\tint newi = 0;\n\t\t\t// if we're passing in a this and we're not argsOnStack we're always\n\t\t\t// passing in a target too\n\t\t\tif (arg0HoldsThis()) {\n\t\t\t\tret.put(0, 0);\n\t\t\t\toldi++;\n\t\t\t\tnewi += 1;\n\t\t\t}\n\t\t\t// assert targetVar == thisVar\n\t\t\tfor (int i = 0; i < getArgCount(); i++) {\n\t\t\t\tUnresolvedType type = getArgType(i);\n\t\t\t\tret.put(oldi, newi);\n\t\t\t\toldi += type.getSize();\n\t\t\t\tnewi += type.getSize();\n\t\t\t}\n\t\t}\n\n\t\t// System.err.println(\"making remap for : \" + this);\n\t\t// if (targetVar != null) System.err.println(\"target slot : \" + targetVar.getSlot());\n\t\t// if (thisVar != null) System.err.println(\"  this slot : \" + thisVar.getSlot());\n\t\t// System.err.println(ret);\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * The new method always static. It may take some extra arguments: this, target. If it's argsOnStack, then it must take both\n\t * this/target If it's argsOnFrame, it shares this and target. ??? rewrite this to do less array munging, please\n\t */\n\tprivate LazyMethodGen createShadowMethodGen(String newMethodName, int visibilityModifier, List<String> parameterNames, boolean beingPlacedInInterface) {\n\t\tType[] shadowParameterTypes = BcelWorld.makeBcelTypes(getArgTypes());\n\t\tint modifiers = (world.useFinal() && !beingPlacedInInterface ? Modifier.FINAL : 0) | Modifier.STATIC | visibilityModifier;\n\t\tif (targetVar != null && targetVar != thisVar) {\n\t\t\tUnresolvedType targetType = getTargetType();\n\t\t\ttargetType = ensureTargetTypeIsCorrect(targetType);\n\t\t\t// see pr109728,pr229910 - this fixes the case when the declaring class is sometype 'X' but the (gs)etfield\n\t\t\t// in the bytecode refers to a subtype of 'X'. This makes sure we use the type originally\n\t\t\t// mentioned in the fieldget instruction as the method parameter and *not* the type upon which the\n\t\t\t// field is declared because when the instructions are extracted into the new around body,\n\t\t\t// they will still refer to the subtype.\n\t\t\tif ((getKind() == FieldGet || getKind() == FieldSet) && getActualTargetType() != null\n\t\t\t\t\t&& !getActualTargetType().equals(targetType.getName())) {\n\t\t\t\ttargetType = UnresolvedType.forName(getActualTargetType()).resolve(world);\n\t\t\t}\n\t\t\tResolvedMember resolvedMember = getSignature().resolve(world);\n\n\t\t\t// pr230075, pr197719\n\t\t\tif (resolvedMember != null && Modifier.isProtected(resolvedMember.getModifiers())\n\t\t\t\t\t&& !samePackage(resolvedMember.getDeclaringType().getPackageName(), getEnclosingType().getPackageName())\n\t\t\t\t\t&& !resolvedMember.getName().equals(\"clone\")) {\n\t\t\t\tif (!hasThis()) { // pr197719 - static accessor has been created to handle the call\n\t\t\t\t\tif (Modifier.isStatic(enclosingMethod.getAccessFlags()) && enclosingMethod.getName().startsWith(\"access$\")) {\n\t\t\t\t\t\ttargetType = BcelWorld.fromBcel(enclosingMethod.getArgumentTypes()[0]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!targetType.resolve(world).isAssignableFrom(getThisType().resolve(world))) {\n\t\t\t\t\t\tthrow new BCException(\"bad bytecode\");\n\t\t\t\t\t}\n\t\t\t\t\ttargetType = getThisType();\n\t\t\t\t}\n\t\t\t}\n\t\t\tparameterNames.add(\"target\");\n\t\t\t// There is a 'target' and it is not the same as 'this', so add it to the parameter list\n\t\t\tshadowParameterTypes = addTypeToFront(BcelWorld.makeBcelType(targetType), shadowParameterTypes);\n\t\t}\n\n\t\tif (thisVar != null) {\n\t\t\tUnresolvedType thisType = getThisType();\n\t\t\tparameterNames.add(0, \"ajc$this\");\n\t\t\tshadowParameterTypes = addTypeToFront(BcelWorld.makeBcelType(thisType), shadowParameterTypes);\n\t\t}\n\n\t\tif (this.getKind() == Shadow.FieldSet || this.getKind() == Shadow.FieldGet) {\n\t\t\tparameterNames.add(getSignature().getName());\n\t\t} else {\n\t\t\tString[] pnames = getSignature().getParameterNames(world);\n\t\t\tif (pnames != null) {\n\t\t\t\tfor (int i = 0; i < pnames.length; i++) {\n\t\t\t\t\tif (i == 0 && pnames[i].equals(\"this\")) {\n\t\t\t\t\t\tparameterNames.add(\"ajc$this\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparameterNames.add(pnames[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// We always want to pass down thisJoinPoint in case we have already woven\n\t\t// some advice in here. If we only have a single piece of around advice on a\n\t\t// join point, it is unnecessary to accept (and pass) tjp.\n\t\tif (thisJoinPointVar != null) {\n\t\t\tparameterNames.add(\"thisJoinPoint\");\n\t\t\tshadowParameterTypes = addTypeToEnd(LazyClassGen.tjpType, shadowParameterTypes);\n\t\t}\n\n\t\tUnresolvedType returnType;\n\t\tif (getKind() == PreInitialization) {\n\t\t\treturnType = UnresolvedType.OBJECTARRAY;\n\t\t} else {\n\t\t\tif (getKind() == ConstructorCall) {\n\t\t\t\treturnType = getSignature().getDeclaringType();\n\t\t\t} else if (getKind() == FieldSet) {\n\t\t\t\treturnType = UnresolvedType.VOID;\n\t\t\t} else {\n\t\t\t\treturnType = getSignature().getReturnType().resolve(world);\n\t\t\t\t// returnType = getReturnType(); // for this and above lines, see pr137496\n\t\t\t}\n\t\t}\n\t\treturn new LazyMethodGen(modifiers, BcelWorld.makeBcelType(returnType), newMethodName, shadowParameterTypes,\n\t\t\t\tNoDeclaredExceptions, getEnclosingClass());\n\t}\n\n\tprivate boolean samePackage(String p1, String p2) {\n\t\tif (p1 == null) {\n\t\t\treturn p2 == null;\n\t\t}\n\t\tif (p2 == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn p1.equals(p2);\n\t}\n\n\tprivate Type[] addTypeToFront(Type type, Type[] types) {\n\t\tint len = types.length;\n\t\tType[] ret = new Type[len + 1];\n\t\tret[0] = type;\n\t\tSystem.arraycopy(types, 0, ret, 1, len);\n\t\treturn ret;\n\t}\n\n\tprivate Type[] addTypeToEnd(Type type, Type[] types) {\n\t\tint len = types.length;\n\t\tType[] ret = new Type[len + 1];\n\t\tret[len] = type;\n\t\tSystem.arraycopy(types, 0, ret, 0, len);\n\t\treturn ret;\n\t}\n\n\tpublic BcelVar genTempVar(UnresolvedType utype) {\n\t\tResolvedType rtype = utype.resolve(world);\n\t\treturn new BcelVar(rtype, genTempVarIndex(rtype.getSize()));\n\t}\n\n\t// public static final boolean CREATE_TEMP_NAMES = true;\n\n\tpublic BcelVar genTempVar(UnresolvedType typeX, String localName) {\n\t\tBcelVar tv = genTempVar(typeX);\n\n\t\t// if (CREATE_TEMP_NAMES) {\n\t\t// for (InstructionHandle ih = range.getStart(); ih != range.getEnd(); ih = ih.getNext()) {\n\t\t// if (Range.isRangeHandle(ih)) continue;\n\t\t// ih.addTargeter(new LocalVariableTag(typeX, localName, tv.getSlot()));\n\t\t// }\n\t\t// }\n\t\treturn tv;\n\t}\n\n\t// eh doesn't think we need to garbage collect these (64K is a big number...)\n\tprivate int genTempVarIndex(int size) {\n\t\treturn enclosingMethod.allocateLocal(size);\n\t}\n\n\tpublic InstructionFactory getFactory() {\n\t\treturn getEnclosingClass().getFactory();\n\t}\n\n\t@Override\n\tpublic ISourceLocation getSourceLocation() {\n\t\tint sourceLine = getSourceLine();\n\t\tif (sourceLine == 0 || sourceLine == -1) {\n\t\t\t// Thread.currentThread().dumpStack();\n\t\t\t// System.err.println(this + \": \" + range);\n\t\t\treturn getEnclosingClass().getType().getSourceLocation();\n\t\t} else {\n\t\t\t// For staticinitialization, if we have a nice offset, don't build a new source loc\n\t\t\tif (getKind() == Shadow.StaticInitialization && getEnclosingClass().getType().getSourceLocation().getOffset() != 0) {\n\t\t\t\treturn getEnclosingClass().getType().getSourceLocation();\n\t\t\t} else {\n\t\t\t\tint offset = 0;\n\t\t\t\tKind kind = getKind();\n\t\t\t\tif ((kind == MethodExecution) || (kind == ConstructorExecution) || (kind == AdviceExecution)\n\t\t\t\t\t\t|| (kind == StaticInitialization) || (kind == PreInitialization) || (kind == Initialization)) {\n\t\t\t\t\tif (getEnclosingMethod().hasDeclaredLineNumberInfo()) {\n\t\t\t\t\t\toffset = getEnclosingMethod().getDeclarationOffset();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn getEnclosingClass().getType().getSourceContext().makeSourceLocation(sourceLine, offset);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Shadow getEnclosingShadow() {\n\t\treturn enclosingShadow;\n\t}\n\n\tpublic LazyMethodGen getEnclosingMethod() {\n\t\treturn enclosingMethod;\n\t}\n\n\tpublic boolean isFallsThrough() {\n\t\treturn !terminatesWithReturn();\n\t}\n\n\tpublic void setActualTargetType(String className) {\n\t\tthis.actualInstructionTargetType = className;\n\t}\n\n\tpublic String getActualTargetType() {\n\t\treturn actualInstructionTargetType;\n\t}\n}\n",
    "size": 140025
  },
  {
    "file_id": "F24",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelTypeMunger.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n *     Alexandre Vasseur    @AspectJ ITDs\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.ClassFormatException;\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.apache.bcel.classfile.Signature;\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.generic.FieldGen;\nimport org.aspectj.apache.bcel.generic.InstructionBranch;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.InvokeInstruction;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.asm.AsmManager;\nimport org.aspectj.asm.IProgramElement;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.bridge.Message;\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.bridge.WeaveMessage;\nimport org.aspectj.bridge.context.CompilationAndWeavingContext;\nimport org.aspectj.bridge.context.ContextToken;\nimport org.aspectj.weaver.AjcMemberMaker;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.AnnotationOnTypeMunger;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.ConcreteTypeMunger;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.MemberUtils;\nimport org.aspectj.weaver.MethodDelegateTypeMunger;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.NewConstructorTypeMunger;\nimport org.aspectj.weaver.NewFieldTypeMunger;\nimport org.aspectj.weaver.NewMemberClassTypeMunger;\nimport org.aspectj.weaver.NewMethodTypeMunger;\nimport org.aspectj.weaver.NewParentTypeMunger;\nimport org.aspectj.weaver.PerObjectInterfaceTypeMunger;\nimport org.aspectj.weaver.PrivilegedAccessMunger;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedMemberImpl;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ResolvedTypeMunger;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.TypeVariableReference;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeaverMessages;\nimport org.aspectj.weaver.WeaverStateInfo;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.model.AsmRelationshipProvider;\nimport org.aspectj.weaver.patterns.DeclareAnnotation;\nimport org.aspectj.weaver.patterns.Pointcut;\n\npublic class BcelTypeMunger extends ConcreteTypeMunger {\n\n\tpublic BcelTypeMunger(ResolvedTypeMunger munger, ResolvedType aspectType) {\n\t\tsuper(munger, aspectType);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(BcelTypeMunger \" + getMunger() + \")\";\n\t}\n\n\t@Override\n\tpublic boolean shouldOverwrite() {\n\t\treturn false;\n\t}\n\n\tpublic boolean munge(BcelClassWeaver weaver) {\n\t\tContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.MUNGING_WITH, this);\n\t\tboolean changed = false;\n\t\tboolean worthReporting = true;\n\n\t\tif (weaver.getWorld().isOverWeaving()) {\n\t\t\tWeaverStateInfo typeWeaverState = weaver.getLazyClassGen().getType().getWeaverState();\n\t\t\tif (typeWeaverState != null && typeWeaverState.isAspectAlreadyApplied(getAspectType())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (munger.getKind() == ResolvedTypeMunger.Field) {\n\t\t\tchanged = mungeNewField(weaver, (NewFieldTypeMunger) munger);\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.Method) {\n\t\t\tchanged = mungeNewMethod(weaver, (NewMethodTypeMunger) munger);\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.InnerClass) {\n\t\t\tchanged = mungeNewMemberType(weaver, (NewMemberClassTypeMunger) munger);\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.MethodDelegate2) {\n\t\t\tchanged = mungeMethodDelegate(weaver, (MethodDelegateTypeMunger) munger);\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.FieldHost) {\n\t\t\tchanged = mungeFieldHost(weaver, (MethodDelegateTypeMunger.FieldHostTypeMunger) munger);\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.PerObjectInterface) {\n\t\t\tchanged = mungePerObjectInterface(weaver, (PerObjectInterfaceTypeMunger) munger);\n\t\t\tworthReporting = false;\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.PerTypeWithinInterface) {\n\t\t\t// PTWIMPL Transform the target type (add the aspect instance field)\n\t\t\tchanged = mungePerTypeWithinTransformer(weaver);\n\t\t\tworthReporting = false;\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.PrivilegedAccess) {\n\t\t\tchanged = mungePrivilegedAccess(weaver, (PrivilegedAccessMunger) munger);\n\t\t\tworthReporting = false;\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.Constructor) {\n\t\t\tchanged = mungeNewConstructor(weaver, (NewConstructorTypeMunger) munger);\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.Parent) {\n\t\t\tchanged = mungeNewParent(weaver, (NewParentTypeMunger) munger);\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.AnnotationOnType) {\n\t\t\tchanged = mungeNewAnnotationOnType(weaver, (AnnotationOnTypeMunger) munger);\n\t\t\tworthReporting = false;\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"unimplemented\");\n\t\t}\n\n\t\tif (changed && munger.changesPublicSignature()) {\n\t\t\tWeaverStateInfo info = weaver.getLazyClassGen().getOrCreateWeaverStateInfo(weaver.getReweavableMode());\n\t\t\tinfo.addConcreteMunger(this);\n\t\t}\n\n\t\tif (changed && worthReporting) {\n\t\t\tResolvedType declaringAspect = null;\n\t\t\tAsmManager model = ((BcelWorld) getWorld()).getModelAsAsmManager();\n\t\t\tif (model != null) {\n\t\t\t\tif (munger instanceof NewParentTypeMunger) {\n\t\t\t\t\tNewParentTypeMunger nptMunger = (NewParentTypeMunger) munger;\n\t\t\t\t\tdeclaringAspect = nptMunger.getDeclaringType();\n\t\t\t\t\tif (declaringAspect.isParameterizedOrGenericType()) {\n\t\t\t\t\t\tdeclaringAspect = declaringAspect.getRawType();\n\t\t\t\t\t}\n\t\t\t\t\tResolvedType thisAspect = getAspectType();\n\t\t\t\t\tAsmRelationshipProvider.addRelationship(model, weaver.getLazyClassGen().getType(), munger, thisAspect);\n\n\t\t\t\t\t// Add a relationship on the actual declaring aspect too\n\t\t\t\t\tif (!thisAspect.equals(declaringAspect)) {\n\t\t\t\t\t\t// Might be the case the declaring aspect is generic and thisAspect is parameterizing it. In that case\n\t\t\t\t\t\t// record the actual parameterizations\n\n\t\t\t\t\t\tResolvedType target = weaver.getLazyClassGen().getType();\n\t\t\t\t\t\tResolvedType newParent = nptMunger.getNewParent();\n\t\t\t\t\t\tIProgramElement thisAspectNode = model.getHierarchy().findElementForType(thisAspect.getPackageName(),\n\t\t\t\t\t\t\t\tthisAspect.getClassName());\n\t\t\t\t\t\tMap<String, List<String>> declareParentsMap = thisAspectNode.getDeclareParentsMap();\n\t\t\t\t\t\tif (declareParentsMap == null) {\n\t\t\t\t\t\t\tdeclareParentsMap = new HashMap<>();\n\t\t\t\t\t\t\tthisAspectNode.setDeclareParentsMap(declareParentsMap);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString tname = target.getName();\n\t\t\t\t\t\tString pname = newParent.getName();\n\t\t\t\t\t\tList<String> newparents = declareParentsMap.computeIfAbsent(tname, k -> new ArrayList<>());\n\t\t\t\t\t\tnewparents.add(pname);\n\t\t\t\t\t\tAsmRelationshipProvider.addRelationship(model, weaver.getLazyClassGen().getType(), munger, declaringAspect);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdeclaringAspect = getAspectType();\n\t\t\t\t\tAsmRelationshipProvider.addRelationship(model, weaver.getLazyClassGen().getType(), munger, declaringAspect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TAG: WeavingMessage\n\t\tif (changed && worthReporting && munger != null && !weaver.getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {\n\t\t\tString tName = weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getName();\n\t\t\tif (tName.contains(\"no debug info available\")) {\n\t\t\t\ttName = \"no debug info available\";\n\t\t\t} else {\n\t\t\t\ttName = getShortname(weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getPath());\n\t\t\t}\n\t\t\tString fName = getShortname(getAspectType().getSourceLocation().getSourceFile().getPath());\n\t\t\tif (munger.getKind().equals(ResolvedTypeMunger.Parent)) {\n\t\t\t\t// This message could come out of AjLookupEnvironment.addParent\n\t\t\t\t// if doing parents munging at compile time only...\n\t\t\t\tNewParentTypeMunger parentTM = (NewParentTypeMunger) munger;\n\t\t\t\tif (parentTM.isMixin()) {\n\t\t\t\t\tweaver.getWorld()\n\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\tWeaveMessage.constructWeavingMessage(\n\t\t\t\t\t\t\t\tWeaveMessage.WEAVEMESSAGE_MIXIN,\n\t\t\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\t\t\tparentTM.getNewParent().getName(), fName,\n\t\t\t\t\t\t\t\t\tweaver.getLazyClassGen().getType().getName(), tName\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tweaver.getLazyClassGen().getClassName(), getAspectType().getName(),\n\t\t\t\t\t\t\t\tparentTM.getNewParent().getSourceLocation(), weaver.getLazyClassGen().getType().getSourceLocation()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (parentTM.getNewParent().isInterface()) {\n\t\t\t\t\t\tweaver.getWorld()\n\t\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\tWeaveMessage.constructWeavingMessage(\n\t\t\t\t\t\t\t\t\tWeaveMessage.WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS,\n\t\t\t\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\t\t\t\tweaver.getLazyClassGen().getType().getName(), tName,\n\t\t\t\t\t\t\t\t\t\tparentTM.getNewParent().getName(), fName\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tweaver.getLazyClassGen().getClassName(), getAspectType().getName(),\n\t\t\t\t\t\t\t\t\tparentTM.getNewParent().getSourceLocation(), weaver.getLazyClassGen().getType().getSourceLocation()\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tweaver.getWorld()\n\t\t\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\t\t\tWeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSEXTENDS,\n\t\t\t\t\t\t\t\t\t\t\t\tnew String[] { weaver.getLazyClassGen().getType().getName(), tName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparentTM.getNewParent().getName(), fName }));\n\t\t\t\t\t\t// TAG: WeavingMessage DECLARE PARENTS: EXTENDS\n\t\t\t\t\t\t// reportDeclareParentsMessage(WeaveMessage.\n\t\t\t\t\t\t// WEAVEMESSAGE_DECLAREPARENTSEXTENDS,sourceType,parent);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (munger.getKind().equals(ResolvedTypeMunger.FieldHost)) {\n\t\t\t\t// hidden\n\t\t\t} else {\n\t\t\t\tResolvedMember declaredSig = munger.getSignature();\n\t\t\t\tString fromString = fName + \":'\" + declaredSig + \"'\";\n\t\t\t\t// if (declaredSig==null) declaredSig= munger.getSignature();\n\t\t\t\tString kindString = munger.getKind().toString().toLowerCase();\n\t\t\t\tif (kindString.equals(\"innerclass\")) {\n\t\t\t\t\tkindString = \"member class\";\n\t\t\t\t\tfromString = fName;\n\t\t\t\t}\n\t\t\t\tweaver.getWorld()\n\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\tWeaveMessage.constructWeavingMessage(\n\t\t\t\t\t\t\tWeaveMessage.WEAVEMESSAGE_ITD,\n\t\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\t\tweaver.getLazyClassGen().getType().getName(), tName,\n\t\t\t\t\t\t\t\tkindString, getAspectType().getName(), fromString\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweaver.getLazyClassGen().getClassName(), getAspectType().getName(),\n\t\t\t\t\t\t\tweaver.getLazyClassGen().getType().getSourceLocation(), getAspectType().getSourceLocation()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tCompilationAndWeavingContext.leavingPhase(tok);\n\t\treturn changed;\n\t}\n\n\tprivate String getShortname(String path) {\n\t\tint takefrom = path.lastIndexOf('/');\n\t\tif (takefrom == -1) {\n\t\t\ttakefrom = path.lastIndexOf('\\\\');\n\t\t}\n\t\treturn path.substring(takefrom + 1);\n\t}\n\n\tprivate boolean mungeNewAnnotationOnType(BcelClassWeaver weaver, AnnotationOnTypeMunger munger) {\n\t\t// FIXME asc this has already been done up front, need to do it here too?\n\t\ttry {\n\t\t\tBcelAnnotation anno = (BcelAnnotation) munger.getNewAnnotation();\n\t\t\tweaver.getLazyClassGen().addAnnotation(anno.getBcelAnnotation());\n\t\t} catch (ClassCastException cce) {\n\t\t\tthrow new IllegalStateException(\"DiagnosticsFor318237: The typemunger \"+munger+\" contains an annotation of type \"+\n\t\t\t\t\tmunger.getNewAnnotation().getClass().getName()+\" when it should be a BcelAnnotation\",cce);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * For a long time, AspectJ did not allow binary weaving of declare parents. This restriction is now lifted but could do with\n\t * more testing!\n\t */\n\tprivate boolean mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger typeTransformer) {\n\t\tLazyClassGen newParentTarget = weaver.getLazyClassGen();\n\t\tResolvedType newParent = typeTransformer.getNewParent();\n\n\t\tboolean performChange = true;\n\t\tperformChange = enforceDecpRule1_abstractMethodsImplemented(weaver, typeTransformer.getSourceLocation(), newParentTarget,\n\t\t\t\tnewParent);\n\t\tperformChange = enforceDecpRule2_cantExtendFinalClass(weaver, typeTransformer.getSourceLocation(), newParentTarget,\n\t\t\t\tnewParent) && performChange;\n\n\t\tList<ResolvedMember> methods = newParent.getMethodsWithoutIterator(false, true, false);\n\t\tfor (ResolvedMember method : methods) {\n\t\t\tif (!method.getName().equals(\"<init>\")) {\n\t\t\t\tLazyMethodGen subMethod = findMatchingMethod(newParentTarget, method);\n\t\t\t\t// FIXME asc is this safe for all bridge methods?\n\t\t\t\tif (subMethod != null && !subMethod.isBridgeMethod()) {\n\t\t\t\t\tif (!(subMethod.isSynthetic() && method.isSynthetic())) {\n\t\t\t\t\t\tif (!(subMethod.isStatic() && subMethod.getName().startsWith(\"access$\"))) {\n\t\t\t\t\t\t\t// ignore generated accessors\n\t\t\t\t\t\t\tperformChange = enforceDecpRule3_visibilityChanges(weaver, newParent, method, subMethod)\n\t\t\t\t\t\t\t\t\t&& performChange;\n\t\t\t\t\t\t\tperformChange = enforceDecpRule4_compatibleReturnTypes(weaver, method, subMethod) && performChange;\n\t\t\t\t\t\t\tperformChange = enforceDecpRule5_cantChangeFromStaticToNonstatic(weaver,\n\t\t\t\t\t\t\t\t\ttypeTransformer.getSourceLocation(), method, subMethod)\n\t\t\t\t\t\t\t\t\t&& performChange;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!performChange) {\n\t\t\t// A rule was violated and an error message already reported\n\t\t\treturn false;\n\t\t}\n\n\t\tif (newParent.isClass()) {\n\t\t\t// Changing the supertype\n\t\t\tif (!attemptToModifySuperCalls(weaver, newParentTarget, newParent)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnewParentTarget.setSuperClass(newParent);\n\t\t} else {\n\t\t\t// Add a new interface\n\t\t\tnewParentTarget.addInterface(newParent, getSourceLocation());\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Rule 1: For the declare parents to be allowed, the target type must override and implement inherited abstract methods (if the\n\t * type is not declared abstract)\n\t */\n\tprivate boolean enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weaver, ISourceLocation mungerLoc,\n\t\t\tLazyClassGen newParentTarget, ResolvedType newParent) {\n\t\t// Ignore abstract classes or interfaces\n\t\tif (newParentTarget.isAbstract() || newParentTarget.isInterface()) {\n\t\t\treturn true;\n\t\t}\n\t\tboolean ruleCheckingSucceeded = true;\n\t\tList<ResolvedMember> newParentMethods = newParent.getMethodsWithoutIterator(false, true, false);\n\t\tfor (ResolvedMember newParentMethod : newParentMethods) {\n\t\t\tString newParentMethodName = newParentMethod.getName();\n\t\t\t// Ignore abstract ajc$interField prefixed methods\n\t\t\tif (newParentMethod.isAbstract() && !newParentMethodName.startsWith(\"ajc$interField\")) {\n\t\t\t\tResolvedMember discoveredImpl = null;\n\t\t\t\tList<ResolvedMember> targetMethods = newParentTarget.getType().getMethodsWithoutIterator(false, true, false);\n\t\t\t\tfor (ResolvedMember targetMethod : targetMethods) {\n\t\t\t\t\tif (!targetMethod.isAbstract() && targetMethod.getName().equals(newParentMethodName)) {\n\t\t\t\t\t\tString newParentMethodSig = newParentMethod.getParameterSignature(); // ([TT;)\n\t\t\t\t\t\tString targetMethodSignature = targetMethod.getParameterSignature(); // ([Ljava/lang/Object;)\n\t\t\t\t\t\t// could be a match\n\t\t\t\t\t\tif (targetMethodSignature.equals(newParentMethodSig)) {\n\t\t\t\t\t\t\tdiscoveredImpl = targetMethod;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Does the erasure match? In which case a bridge method will be created later to\n\t\t\t\t\t\t\t// satisfy the abstract method\n\t\t\t\t\t\t\tif (targetMethod.hasBackingGenericMember()\n\t\t\t\t\t\t\t\t\t&& targetMethod.getBackingGenericMember().getParameterSignature().equals(newParentMethodSig)) {\n\t\t\t\t\t\t\t\tdiscoveredImpl = targetMethod;\n\t\t\t\t\t\t\t} else if (newParentMethod.hasBackingGenericMember()) {\n \t\t\t\t\t\t\t\tif (newParentMethod.getBackingGenericMember().getParameterSignature().equals(targetMethodSignature)) { // newParentMethod.getBackingGenericMember().getParameterSignature gives: (Pjava/util/List<TI;>;)  targetMethodSignature= (Ljava/util/List;)\n\t\t\t\t\t\t\t\t\tdiscoveredImpl = targetMethod;\n\t\t\t\t\t\t\t\t} else if (targetMethod instanceof BcelMethod) {\n\t\t\t\t\t\t\t\t\t// BcelMethod does not have backing generic member set (need to investigate why). For now, special case here:\n\t\t\t\t\t\t\t\t\tUnresolvedType[] targetMethodGenericParameterTypes = targetMethod.getGenericParameterTypes();\n\t\t\t\t\t\t\t\t\tif (targetMethodGenericParameterTypes !=null) {\n\t\t\t\t\t\t\t\t\t\tStringBuilder b = new StringBuilder(\"(\");\n\t\t\t\t\t\t\t\t\t\tfor (UnresolvedType p: targetMethodGenericParameterTypes) {\n\t\t\t\t\t\t\t\t\t\t\tb.append(p.getSignature());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tb.append(')');\n\t\t\t\t\t\t\t\t\t\tif (b.toString().equals(newParentMethodSig)) {\n\t\t\t\t\t\t\t\t\t\t\tdiscoveredImpl = targetMethod;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (discoveredImpl != null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (discoveredImpl == null) {\n\t\t\t\t\t// didnt find a valid implementation, lets check the\n\t\t\t\t\t// ITDs on this type to see if they satisfy it\n\t\t\t\t\tboolean satisfiedByITD = false;\n\t\t\t\t\tfor (ConcreteTypeMunger m : newParentTarget.getType().getInterTypeMungersIncludingSupers()) {\n\t\t\t\t\t\tif (m.getMunger() != null && m.getMunger().getKind() == ResolvedTypeMunger.Method) {\n\t\t\t\t\t\t\tResolvedMember sig = m.getSignature();\n\t\t\t\t\t\t\tif (!Modifier.isAbstract(sig.getModifiers())) {\n\t\t\t\t\t\t\t\t// If the ITD shares a type variable with some target type, we need to tailor it\n\t\t\t\t\t\t\t\t// for that type\n\t\t\t\t\t\t\t\tif (m.isTargetTypeParameterized()) {\n\t\t\t\t\t\t\t\t\tResolvedType genericOnType = getWorld().resolve(sig.getDeclaringType()).getGenericType();\n\t\t\t\t\t\t\t\t\tResolvedType actualOccurrence = newParent.discoverActualOccurrenceOfTypeInHierarchy(genericOnType);\n\t\t\t\t\t\t\t\t\tif (actualOccurrence == null) {\n\t\t\t\t\t\t\t\t\t    // Handle the case where the ITD is onto the type targeted by the declare parents (PR478003)\n\t\t\t\t\t\t\t\t\t\tactualOccurrence = newParentTarget.getType().discoverActualOccurrenceOfTypeInHierarchy(genericOnType);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tm = m.parameterizedFor(actualOccurrence);\n\t\t\t\t\t\t\t\t\t// possible sig change when type parameters filled in\n\t\t\t\t\t\t\t\t\tsig = m.getSignature();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ResolvedType.matches(\n\t\t\t\t\t\t\t\t\t\tAjcMemberMaker.interMethod(sig, m.getAspectType(),\n\t\t\t\t\t\t\t\t\t\t\t\tsig.getDeclaringType().resolve(weaver.getWorld()).isInterface()), newParentMethod)) {\n\t\t\t\t\t\t\t\t\tsatisfiedByITD = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (m.getMunger() != null && m.getMunger().getKind() == ResolvedTypeMunger.MethodDelegate2) {\n\t\t\t\t\t\t\t// AV - that should be enough, no need to check more\n\t\t\t\t\t\t\tsatisfiedByITD = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!satisfiedByITD) {\n\t\t\t\t\t\terror(weaver,\n\t\t\t\t\t\t\t\t\"The type \" + newParentTarget.getName() + \" must implement the inherited abstract method \"\n\t\t\t\t\t\t\t\t\t\t+ newParentMethod.getDeclaringType() + \".\" + newParentMethodName\n\t\t\t\t\t\t\t\t\t\t+ newParentMethod.getParameterSignature(), newParentTarget.getType().getSourceLocation(),\n\t\t\t\t\t\t\t\tnew ISourceLocation[] { newParentMethod.getSourceLocation(), mungerLoc });\n\t\t\t\t\t\truleCheckingSucceeded = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ruleCheckingSucceeded;\n\t}\n\n\t/**\n\t * Rule 2. Can't extend final types\n\t */\n\tprivate boolean enforceDecpRule2_cantExtendFinalClass(BcelClassWeaver weaver, ISourceLocation transformerLoc,\n\t\t\tLazyClassGen targetType, ResolvedType newParent) {\n\t\tif (newParent.isFinal()) {\n\t\t\terror(weaver, \"Cannot make type \" + targetType.getName() + \" extend final class \" + newParent.getName(), targetType\n\t\t\t\t\t.getType().getSourceLocation(), new ISourceLocation[] { transformerLoc });\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Rule 3. Can't narrow visibility of methods when overriding\n\t */\n\tprivate boolean enforceDecpRule3_visibilityChanges(BcelClassWeaver weaver, ResolvedType newParent, ResolvedMember superMethod,\n\t\t\tLazyMethodGen subMethod) {\n\t\tboolean cont = true;\n\t\tif (Modifier.isPublic(superMethod.getModifiers())) {\n\t\t\tif (subMethod.isProtected() || subMethod.isDefault() || subMethod.isPrivate()) {\n\t\t\t\tweaver.getWorld()\n\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\tMessageUtil.error(\"Cannot reduce the visibility of the inherited method '\" + superMethod\n\t\t\t\t\t\t\t\t\t\t+ \"' from \" + newParent.getName(), superMethod.getSourceLocation()));\n\t\t\t\tcont = false;\n\t\t\t}\n\t\t} else if (Modifier.isProtected(superMethod.getModifiers())) {\n\t\t\tif (subMethod.isDefault() || subMethod.isPrivate()) {\n\t\t\t\tweaver.getWorld()\n\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\tMessageUtil.error(\"Cannot reduce the visibility of the inherited method '\" + superMethod\n\t\t\t\t\t\t\t\t\t\t+ \"' from \" + newParent.getName(), superMethod.getSourceLocation()));\n\t\t\t\tcont = false;\n\t\t\t}\n\t\t} else if (superMethod.isDefault()) {\n\t\t\tif (subMethod.isPrivate()) {\n\t\t\t\tweaver.getWorld()\n\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\tMessageUtil.error(\"Cannot reduce the visibility of the inherited method '\" + superMethod\n\t\t\t\t\t\t\t\t\t\t+ \"' from \" + newParent.getName(), superMethod.getSourceLocation()));\n\t\t\t\tcont = false;\n\t\t\t}\n\t\t}\n\t\treturn cont;\n\t}\n\n\t/**\n\t * Rule 4. Can't have incompatible return types\n\t */\n\tprivate boolean enforceDecpRule4_compatibleReturnTypes(BcelClassWeaver weaver, ResolvedMember superMethod,\n\t\t\tLazyMethodGen subMethod) {\n\t\tboolean cont = true;\n\t\tString superReturnTypeSig = superMethod.getGenericReturnType().getSignature(); // eg. Pjava/util/Collection<LFoo;>\n\t\tString subReturnTypeSig = subMethod.getGenericReturnTypeSignature();\n\t\tsuperReturnTypeSig = superReturnTypeSig.replace('.', '/');\n\t\tsubReturnTypeSig = subReturnTypeSig.replace('.', '/');\n\t\tif (!superReturnTypeSig.equals(subReturnTypeSig)) {\n\t\t\t// Check for covariance\n\t\t\tResolvedType subType = weaver.getWorld().resolve(subMethod.getReturnType());\n\t\t\tResolvedType superType = weaver.getWorld().resolve(superMethod.getReturnType());\n\n\t\t\tboolean isError = false;\n\t\t\t// Not compatible return types if looks like boxing\n\t\t\tif (weaver.getWorld().isInJava5Mode()) {\n\t\t\t\tif (superType.isPrimitiveType() && !subType.isPrimitiveType()) {\n\t\t\t\t\tisError = true;\n\t\t\t\t} else if (subType.isPrimitiveType() && !superType.isPrimitiveType()) {\n\t\t\t\t\tisError = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isError == false) {\n\t\t\t\tif (!superType.isAssignableFrom(subType)) {\n\t\t\t\t\tisError = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (isError) {\n\t\t\t\tweaver.getWorld()\n\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\tMessageUtil.error(\"The return type is incompatible with \" + superMethod.getDeclaringType() + \".\"\n\t\t\t\t\t\t\t\t\t\t+ superMethod.getName() + superMethod.getParameterSignature(),\n\t\t\t\t\t\t\t\t\t\tsubMethod.getSourceLocation()));\n\t\t\t\t// this just might be a better error message...\n\t\t\t\t// \"The return type '\"+subReturnTypeSig+\n\t\t\t\t// \"' is incompatible with the overridden method \"\n\t\t\t\t// +superMethod.getDeclaringType()+\".\"+\n\t\t\t\t// superMethod.getName()+superMethod.getParameterSignature()+\n\t\t\t\t// \" which returns '\"+superReturnTypeSig+\"'\",\n\t\t\t\tcont = false;\n\t\t\t}\n\t\t}\n\t\treturn cont;\n\t}\n\n\t/**\n\t * Rule5. Method overrides can't change the staticality (word?) - you can't override and make an instance method static or\n\t * override and make a static method an instance method.\n\t */\n\tprivate boolean enforceDecpRule5_cantChangeFromStaticToNonstatic(BcelClassWeaver weaver, ISourceLocation mungerLoc,\n\t\t\tResolvedMember superMethod, LazyMethodGen subMethod) {\n\t\tboolean superMethodStatic = Modifier.isStatic(superMethod.getModifiers());\n\t\tif (superMethodStatic && !subMethod.isStatic()) {\n\t\t\terror(weaver, \"This instance method \" + subMethod.getName() + subMethod.getParameterSignature()\n\t\t\t\t\t+ \" cannot override the static method from \" + superMethod.getDeclaringType().getName(),\n\t\t\t\t\tsubMethod.getSourceLocation(), new ISourceLocation[] { mungerLoc });\n\t\t\treturn false;\n\t\t} else if (!superMethodStatic && subMethod.isStatic()) {\n\t\t\terror(weaver, \"The static method \" + subMethod.getName() + subMethod.getParameterSignature()\n\t\t\t\t\t+ \" cannot hide the instance method from \" + superMethod.getDeclaringType().getName(),\n\t\t\t\t\tsubMethod.getSourceLocation(), new ISourceLocation[] { mungerLoc });\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic void error(BcelClassWeaver weaver, String text, ISourceLocation primaryLoc, ISourceLocation[] extraLocs) {\n\t\tIMessage msg = new Message(text, primaryLoc, true, extraLocs);\n\t\tweaver.getWorld().getMessageHandler().handleMessage(msg);\n\t}\n\n\t/**\n\t * Search the specified type for a particular method - do not use the return value in the comparison as it is not considered for\n\t * overriding.\n\t */\n\tprivate LazyMethodGen findMatchingMethod(LazyClassGen type, ResolvedMember searchMethod) {\n\t\tString searchName = searchMethod.getName();\n\t\tString searchSig = searchMethod.getParameterSignature();\n\t\tfor (LazyMethodGen method : type.getMethodGens()) {\n\t\t\tif (method.getName().equals(searchName) && method.getParameterSignature().equals(searchSig)) {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * The main part of implementing declare parents extends. Modify super ctor calls to target the new type.\n\t */\n\tpublic boolean attemptToModifySuperCalls(BcelClassWeaver weaver, LazyClassGen newParentTarget, ResolvedType newParent) {\n\t\tResolvedType currentParentType = newParentTarget.getSuperClass();\n\t\tif (currentParentType.getGenericType() != null) {\n\t\t\tcurrentParentType = currentParentType.getGenericType();\n\t\t}\n\t\tString currentParent = currentParentType.getName();\n\t\tif (newParent.getGenericType() != null) {\n\t\t\tnewParent = newParent.getGenericType(); // target new super calls at\n\t\t}\n\t\t// the generic type if its raw or parameterized\n\t\tList<LazyMethodGen> mgs = newParentTarget.getMethodGens();\n\n\t\t// Look for ctors to modify\n\t\tfor (LazyMethodGen aMethod : mgs) {\n\t\t\tif (LazyMethodGen.isConstructor(aMethod)) {\n\t\t\t\tInstructionList insList = aMethod.getBody();\n\t\t\t\tInstructionHandle handle = insList.getStart();\n\t\t\t\twhile (handle != null) {\n\t\t\t\t\tif (handle.getInstruction().opcode == Constants.INVOKESPECIAL) {\n\t\t\t\t\t\tConstantPool cpg = newParentTarget.getConstantPool();\n\t\t\t\t\t\tInvokeInstruction invokeSpecial = (InvokeInstruction) handle.getInstruction();\n\t\t\t\t\t\tif (invokeSpecial.getClassName(cpg).equals(currentParent)\n\t\t\t\t\t\t\t\t&& invokeSpecial.getMethodName(cpg).equals(\"<init>\")) {\n\t\t\t\t\t\t\t// System.err.println(\"Transforming super call '<init>\" + invokeSpecial.getSignature(cpg) + \"'\");\n\n\t\t\t\t\t\t\t// 1. Check there is a ctor in the new parent with\n\t\t\t\t\t\t\t// the same signature\n\t\t\t\t\t\t\tResolvedMember newCtor = getConstructorWithSignature(newParent, invokeSpecial.getSignature(cpg));\n\n\t\t\t\t\t\t\tif (newCtor == null) {\n\n\t\t\t\t\t\t\t\t// 2. Check ITDCs to see if the necessary ctor is provided that way\n\t\t\t\t\t\t\t\tboolean satisfiedByITDC = false;\n\t\t\t\t\t\t\t\tfor (Iterator<ConcreteTypeMunger> ii = newParentTarget.getType()\n\t\t\t\t\t\t\t\t\t\t.getInterTypeMungersIncludingSupers().iterator(); ii.hasNext() && !satisfiedByITDC;) {\n\t\t\t\t\t\t\t\t\tConcreteTypeMunger m = ii.next();\n\t\t\t\t\t\t\t\t\tif (m.getMunger() instanceof NewConstructorTypeMunger) {\n\t\t\t\t\t\t\t\t\t\tif (m.getSignature().getSignature().equals(invokeSpecial.getSignature(cpg))) {\n\t\t\t\t\t\t\t\t\t\t\tsatisfiedByITDC = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (!satisfiedByITDC) {\n\t\t\t\t\t\t\t\t\tString csig = createReadableCtorSig(newParent, cpg, invokeSpecial);\n\t\t\t\t\t\t\t\t\tweaver.getWorld()\n\t\t\t\t\t\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\t\t\t\t\t\tMessageUtil.error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Unable to modify hierarchy for \" + newParentTarget.getClassName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" - the constructor \" + csig + \" is missing\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.getSourceLocation()));\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tint idx = cpg.addMethodref(newParent.getName(), invokeSpecial.getMethodName(cpg),\n\t\t\t\t\t\t\t\t\tinvokeSpecial.getSignature(cpg));\n\t\t\t\t\t\t\tinvokeSpecial.setIndex(idx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thandle = handle.getNext();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a nice signature for the ctor, something like \"(int,Integer,String)\"\n\t */\n\tprivate String createReadableCtorSig(ResolvedType newParent, ConstantPool cpg, InvokeInstruction invokeSpecial) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tType[] ctorArgs = invokeSpecial.getArgumentTypes(cpg);\n\t\tsb.append(newParent.getClassName());\n\t\tsb.append(\"(\");\n\t\tfor (int i = 0; i < ctorArgs.length; i++) {\n\t\t\tString argtype = ctorArgs[i].toString();\n\t\t\tif (argtype.lastIndexOf(\".\") != -1) {\n\t\t\t\tsb.append(argtype.substring(argtype.lastIndexOf(\".\") + 1));\n\t\t\t} else {\n\t\t\t\tsb.append(argtype);\n\t\t\t}\n\t\t\tif (i + 1 < ctorArgs.length) {\n\t\t\t\tsb.append(\",\");\n\t\t\t}\n\t\t}\n\t\tsb.append(\")\");\n\t\treturn sb.toString();\n\t}\n\n\tprivate ResolvedMember getConstructorWithSignature(ResolvedType type, String searchSig) {\n\t\tfor (ResolvedMember method : type.getDeclaredJavaMethods()) {\n\t\t\tif (MemberUtils.isConstructor(method)) {\n\t\t\t\tif (method.getSignature().equals(searchSig)) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate boolean mungePrivilegedAccess(BcelClassWeaver weaver, PrivilegedAccessMunger munger) {\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\t\tResolvedMember member = munger.getMember();\n\n\t\tResolvedType onType = weaver.getWorld().resolve(member.getDeclaringType(), munger.getSourceLocation());\n\t\tif (onType.isRawType()) {\n\t\t\tonType = onType.getGenericType();\n\t\t}\n\n\t\t// System.out.println(\"munging: \" + gen + \" with \" + member);\n\t\tif (onType.equals(gen.getType())) {\n\t\t\tif (member.getKind() == Member.FIELD) {\n\t\t\t\t// System.out.println(\"matched: \" + gen);\n\t\t\t\taddFieldGetter(gen, member,\n\t\t\t\t\t\tAjcMemberMaker.privilegedAccessMethodForFieldGet(aspectType, member, munger.shortSyntax));\n\t\t\t\taddFieldSetter(gen, member,\n\t\t\t\t\t\tAjcMemberMaker.privilegedAccessMethodForFieldSet(aspectType, member, munger.shortSyntax));\n\t\t\t\treturn true;\n\t\t\t} else if (member.getKind() == Member.METHOD) {\n\t\t\t\taddMethodDispatch(gen, member, AjcMemberMaker.privilegedAccessMethodForMethod(aspectType, member));\n\t\t\t\treturn true;\n\t\t\t} else if (member.getKind() == Member.CONSTRUCTOR) {\n\t\t\t\tfor (LazyMethodGen m : gen.getMethodGens()) {\n\t\t\t\t\tif (m.getMemberView() != null && m.getMemberView().getKind() == Member.CONSTRUCTOR) {\n\t\t\t\t\t\t// m.getMemberView().equals(member)) {\n\t\t\t\t\t\tm.forcePublic();\n\t\t\t\t\t\t// return true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t\t// throw new BCException(\"no match for \" + member + \" in \" +\n\t\t\t\t// gen);\n\t\t\t} else if (member.getKind() == Member.STATIC_INITIALIZATION) {\n\t\t\t\tgen.forcePublic();\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"unimplemented\");\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void addFieldGetter(LazyClassGen gen, ResolvedMember field, ResolvedMember accessMethod) {\n\t\tLazyMethodGen mg = makeMethodGen(gen, accessMethod);\n\t\tInstructionList il = new InstructionList();\n\t\tInstructionFactory fact = gen.getFactory();\n\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\til.append(fact.createFieldAccess(gen.getClassName(), field.getName(), BcelWorld.makeBcelType(field.getType()),\n\t\t\t\t\tConstants.GETSTATIC));\n\t\t} else {\n\t\t\til.append(InstructionConstants.ALOAD_0);\n\t\t\til.append(fact.createFieldAccess(gen.getClassName(), field.getName(), BcelWorld.makeBcelType(field.getType()),\n\t\t\t\t\tConstants.GETFIELD));\n\t\t}\n\t\til.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(field.getType())));\n\t\tmg.getBody().insert(il);\n\n\t\tgen.addMethodGen(mg, getSignature().getSourceLocation());\n\t}\n\n\tprivate void addFieldSetter(LazyClassGen gen, ResolvedMember field, ResolvedMember accessMethod) {\n\t\tLazyMethodGen mg = makeMethodGen(gen, accessMethod);\n\t\tInstructionList il = new InstructionList();\n\t\tInstructionFactory fact = gen.getFactory();\n\t\tType fieldType = BcelWorld.makeBcelType(field.getType());\n\n\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\til.append(InstructionFactory.createLoad(fieldType, 0));\n\t\t\til.append(fact.createFieldAccess(gen.getClassName(), field.getName(), fieldType, Constants.PUTSTATIC));\n\t\t} else {\n\t\t\til.append(InstructionConstants.ALOAD_0);\n\t\t\til.append(InstructionFactory.createLoad(fieldType, 1));\n\t\t\til.append(fact.createFieldAccess(gen.getClassName(), field.getName(), fieldType, Constants.PUTFIELD));\n\t\t}\n\t\til.append(InstructionFactory.createReturn(Type.VOID));\n\t\tmg.getBody().insert(il);\n\n\t\tgen.addMethodGen(mg, getSignature().getSourceLocation());\n\t}\n\n\tprivate void addMethodDispatch(LazyClassGen gen, ResolvedMember method, ResolvedMember accessMethod) {\n\t\tLazyMethodGen mg = makeMethodGen(gen, accessMethod);\n\t\tInstructionList il = new InstructionList();\n\t\tInstructionFactory fact = gen.getFactory();\n\t\tType[] paramTypes = BcelWorld.makeBcelTypes(method.getParameterTypes());\n\n\t\tint pos = 0;\n\n\t\tif (!Modifier.isStatic(method.getModifiers())) {\n\t\t\til.append(InstructionConstants.ALOAD_0);\n\t\t\tpos++;\n\t\t}\n\t\tfor (Type paramType : paramTypes) {\n\t\t\til.append(InstructionFactory.createLoad(paramType, pos));\n\t\t\tpos += paramType.getSize();\n\t\t}\n\t\til.append(Utility.createInvoke(fact, (BcelWorld) aspectType.getWorld(), method));\n\t\til.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(method.getReturnType())));\n\n\t\tmg.getBody().insert(il);\n\n\t\tgen.addMethodGen(mg);\n\t}\n\n\tprotected LazyMethodGen makeMethodGen(LazyClassGen gen, ResolvedMember member) {\n\t\ttry {\n\t\t\tType returnType = BcelWorld.makeBcelType(member.getReturnType());\n\t\t\tType[] parameterTypes = BcelWorld.makeBcelTypes(member.getParameterTypes());\n\t\t\tLazyMethodGen ret = new LazyMethodGen(member.getModifiers(), returnType,\n\t\t\t\t\tmember.getName(), parameterTypes, UnresolvedType.getNames(member\n\t\t\t\t\t\t\t.getExceptions()), gen);\n\n\t\t\t// 43972 : Static crosscutting makes interfaces unusable for javac\n\t\t\t// ret.makeSynthetic();\n\t\t\treturn ret;\n\t\t} catch (ClassFormatException cfe) {\n\t\t\tthrow new RuntimeException(\"Problem with makeMethodGen for method \"+member.getName()+\" in type \"+gen.getName()+\"  ret=\"+member.getReturnType(),cfe);\n\t\t}\n\t}\n\n\tprotected FieldGen makeFieldGen(LazyClassGen gen, ResolvedMember member) {\n\t\treturn new FieldGen(member.getModifiers(), BcelWorld.makeBcelType(member.getReturnType()), member.getName(),\n\t\t\t\tgen.getConstantPool());\n\t}\n\n\tprivate boolean mungePerObjectInterface(BcelClassWeaver weaver, PerObjectInterfaceTypeMunger munger) {\n\t\t// System.err.println(\"Munging perobject [\"+munger+\"] onto \"+weaver.\n\t\t// getLazyClassGen().getClassName());\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\n\t\tif (couldMatch(gen.getBcelObjectType(), munger.getTestPointcut())) {\n\t\t\tFieldGen fg = makeFieldGen(gen, AjcMemberMaker.perObjectField(gen.getType(), aspectType));\n\n\t\t\tgen.addField(fg, getSourceLocation());\n\n\t\t\tType fieldType = BcelWorld.makeBcelType(aspectType);\n\t\t\tLazyMethodGen mg = new LazyMethodGen(Modifier.PUBLIC, fieldType, NameMangler.perObjectInterfaceGet(aspectType),\n\t\t\t\t\tType.NO_ARGS, new String[0], gen);\n\t\t\tInstructionList il = new InstructionList();\n\t\t\tInstructionFactory fact = gen.getFactory();\n\t\t\til.append(InstructionConstants.ALOAD_0);\n\t\t\til.append(fact.createFieldAccess(gen.getClassName(), fg.getName(), fieldType, Constants.GETFIELD));\n\t\t\til.append(InstructionFactory.createReturn(fieldType));\n\t\t\tmg.getBody().insert(il);\n\n\t\t\tgen.addMethodGen(mg);\n\n\t\t\tLazyMethodGen mg1 = new LazyMethodGen(Modifier.PUBLIC, Type.VOID, NameMangler.perObjectInterfaceSet(aspectType),\n\n\t\t\tnew Type[] { fieldType, }, new String[0], gen);\n\t\t\tInstructionList il1 = new InstructionList();\n\t\t\til1.append(InstructionConstants.ALOAD_0);\n\t\t\til1.append(InstructionFactory.createLoad(fieldType, 1));\n\t\t\til1.append(fact.createFieldAccess(gen.getClassName(), fg.getName(), fieldType, Constants.PUTFIELD));\n\t\t\til1.append(InstructionFactory.createReturn(Type.VOID));\n\t\t\tmg1.getBody().insert(il1);\n\n\t\t\tgen.addMethodGen(mg1);\n\n\t\t\tgen.addInterface(munger.getInterfaceType().resolve(weaver.getWorld()), getSourceLocation());\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// PTWIMPL Add field to hold aspect instance and an accessor\n\tprivate boolean mungePerTypeWithinTransformer(BcelClassWeaver weaver) {\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\n\t\t// if (couldMatch(gen.getBcelObjectType(), munger.getTestPointcut())) {\n\n\t\t// Add (to the target type) the field that will hold the aspect instance\n\t\t// e.g ajc$com_blah_SecurityAspect$ptwAspectInstance\n\t\tFieldGen fg = makeFieldGen(gen, AjcMemberMaker.perTypeWithinField(gen.getType(), aspectType));\n\t\tgen.addField(fg, getSourceLocation());\n\t\tif (!gen.getType().canBeSeenBy(aspectType) && aspectType.isPrivilegedAspect()) {\n\t\t\tgen.forcePublic();\n\t\t}\n\t\t// Add an accessor for this new field, the\n\t\t// ajc$<aspectname>$localAspectOf() method\n\t\t// e.g.\n\t\t// \"public com_blah_SecurityAspect ajc$com_blah_SecurityAspect$localAspectOf()\"\n\t\tType fieldType = BcelWorld.makeBcelType(aspectType);\n\t\tLazyMethodGen mg = new LazyMethodGen(Modifier.PUBLIC | Modifier.STATIC, fieldType,\n\t\t\t\tNameMangler.perTypeWithinLocalAspectOf(aspectType), Type.NO_ARGS, new String[0], gen);\n\t\tInstructionList il = new InstructionList();\n\t\t// PTWIMPL ?? Should check if it is null and throw\n\t\t// NoAspectBoundException\n\t\tInstructionFactory fact = gen.getFactory();\n\t\til.append(fact.createFieldAccess(gen.getClassName(), fg.getName(), fieldType, Constants.GETSTATIC));\n\t\til.append(InstructionFactory.createReturn(fieldType));\n\t\tmg.getBody().insert(il);\n\t\tgen.addMethodGen(mg);\n\t\treturn true;\n\t\t// } else {\n\t\t// return false;\n\t\t// }\n\t}\n\n\t// ??? Why do we have this method? I thought by now we would know if it\n\t// matched or not\n\tprivate boolean couldMatch(BcelObjectType bcelObjectType, Pointcut pointcut) {\n\t\treturn !bcelObjectType.isInterface();\n\t}\n\n\tprivate boolean mungeNewMemberType(BcelClassWeaver classWeaver, NewMemberClassTypeMunger munger) {\n\t\tWorld world = classWeaver.getWorld();\n\t\tResolvedType onType = world.resolve(munger.getTargetType());\n\t\tif (onType.isRawType()) {\n\t\t\tonType = onType.getGenericType();\n\t\t}\n\t\treturn onType.equals(classWeaver.getLazyClassGen().getType());\n\t}\n\n\tprivate boolean mungeNewMethod(BcelClassWeaver classWeaver, NewMethodTypeMunger munger) {\n\t\tWorld world = classWeaver.getWorld();\n\n\t\t// Resolving it will sort out the tvars\n\t\tResolvedMember unMangledInterMethod = munger.getSignature().resolve(world);\n\n\t\t// do matching on the unMangled one, but actually add them to the mangled method\n\t\tResolvedMember interMethodBody = munger.getDeclaredInterMethodBody(aspectType, world);\n\t\tResolvedMember interMethodDispatcher = munger.getDeclaredInterMethodDispatcher(aspectType, world);\n\t\tResolvedMember memberHoldingAnyAnnotations = interMethodDispatcher;\n\t\tLazyClassGen classGen = classWeaver.getLazyClassGen();\n\n\t\tResolvedType onType = world.resolve(unMangledInterMethod.getDeclaringType(), munger.getSourceLocation());\n\t\tif (onType.isRawType()) {\n\t\t\tonType = onType.getGenericType();\n\t\t}\n\n\t\t// Simple checks, can't ITD on annotations or enums\n\t\tif (onType.isAnnotation()) {\n\t\t\tsignalError(WeaverMessages.ITDM_ON_ANNOTATION_NOT_ALLOWED, classWeaver, onType);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (onType.isEnum()) {\n\t\t\tsignalError(WeaverMessages.ITDM_ON_ENUM_NOT_ALLOWED, classWeaver, onType);\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean mungingInterface = classGen.isInterface();\n\t\tboolean onInterface = onType.isInterface();\n\n\t\tif (onInterface\n\t\t\t\t&& classGen.getLazyMethodGen(unMangledInterMethod.getName(), unMangledInterMethod.getSignature(), true) != null) {\n\t\t\t// this is ok, we could be providing the default implementation of a\n\t\t\t// method\n\t\t\t// that the target has already declared\n\t\t\treturn false;\n\t\t}\n\n\t\t// If we are processing the intended ITD target type (might be an interface)\n\t\tif (onType.equals(classGen.getType())) {\n\t\t\tResolvedMember mangledInterMethod = AjcMemberMaker.interMethod(unMangledInterMethod, aspectType, onInterface);\n\n\t\t\tLazyMethodGen newMethod = makeMethodGen(classGen, mangledInterMethod);\n\t\t\tif (mungingInterface) {\n\t\t\t\t// we want the modifiers of the ITD to be used for all *implementors* of the\n\t\t\t\t// interface, but the method itself we add to the interface must be public abstract\n\t\t\t\tnewMethod.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);\n\t\t\t}\n\n\t\t\t// pr98901\n\t\t\t// For copying the annotations across, we have to discover the real\n\t\t\t// member in the aspect which is holding them.\n\t\t\tif (classWeaver.getWorld().isInJava5Mode()) {\n\t\t\t\tAnnotationAJ annotationsOnRealMember[] = null;\n\t\t\t\tResolvedType toLookOn = aspectType;\n\t\t\t\tif (aspectType.isRawType()) {\n\t\t\t\t\ttoLookOn = aspectType.getGenericType();\n\t\t\t\t}\n\t\t\t\tResolvedMember realMember = getRealMemberForITDFromAspect(toLookOn, memberHoldingAnyAnnotations, false);\n\t\t\t\t// 266602 - consider it missing to mean that the corresponding aspect had errors\n\t\t\t\tif (realMember == null) {\n\t\t\t\t\t// signalWarning(\"Unable to apply any annotations attached to \" + munger.getSignature(), weaver);\n\t\t\t\t\t// throw new BCException(\"Couldn't find ITD init member '\" + interMethodBody + \"' on aspect \" + aspectType);\n\t\t\t\t} else {\n\t\t\t\t\tannotationsOnRealMember = realMember.getAnnotations();\n\t\t\t\t}\n\t\t\t\tSet<ResolvedType> addedAnnotations = new HashSet<>();\n\t\t\t\tif (annotationsOnRealMember != null) {\n\t\t\t\t\tfor (AnnotationAJ anno : annotationsOnRealMember) {\n\t\t\t\t\t\tAnnotationGen a = ((BcelAnnotation) anno).getBcelAnnotation();\n\t\t\t\t\t\tAnnotationGen ag = new AnnotationGen(a, classGen.getConstantPool(), true);\n\t\t\t\t\t\tnewMethod.addAnnotation(new BcelAnnotation(ag, classWeaver.getWorld()));\n\t\t\t\t\t\taddedAnnotations.add(anno.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (realMember != null) {\n\t\t\t\t\tcopyOverParameterAnnotations(newMethod, realMember);\n\t\t\t\t}\n\t\t\t\t// the code below was originally added to cope with the case where an aspect declares an annotation on an ITD\n\t\t\t\t// declared within itself (an unusual situation). However, it also addresses the case where we may not find the\n\t\t\t\t// annotation on the real representation of the ITD. This can happen in a load-time weaving situation where\n\t\t\t\t// we couldn't add the annotation in time - and so here we recheck the declare annotations. Not quite ideal but\n\t\t\t\t// works. pr288635\n\t\t\t\tList<DeclareAnnotation> allDecams = world.getDeclareAnnotationOnMethods();\n\t\t\t\tfor (DeclareAnnotation declareAnnotationMC : allDecams) {\n\t\t\t\t\tif (declareAnnotationMC.matches(unMangledInterMethod, world)) {\n\t\t\t\t\t\t// && newMethod.getEnclosingClass().getType() == aspectType) {\n\t\t\t\t\t\tAnnotationAJ annotation = declareAnnotationMC.getAnnotation();\n\t\t\t\t\t\tif (!addedAnnotations.contains(annotation.getType())) {\n\t\t\t\t\t\t\tnewMethod.addAnnotation(annotation);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If it doesn't target an interface and there is a body (i.e. it isnt abstract)\n\t\t\tif (!onInterface && !Modifier.isAbstract(mangledInterMethod.getModifiers())) {\n\t\t\t\tInstructionList body = newMethod.getBody();\n\t\t\t\tInstructionFactory fact = classGen.getFactory();\n\t\t\t\tint pos = 0;\n\n\t\t\t\tif (!Modifier.isStatic(unMangledInterMethod.getModifiers())) {\n\t\t\t\t\tbody.append(InstructionFactory.createThis());\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tType[] paramTypes = BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());\n\t\t\t\tfor (Type paramType : paramTypes) {\n\t\t\t\t\tbody.append(InstructionFactory.createLoad(paramType, pos));\n\t\t\t\t\tpos += paramType.getSize();\n\t\t\t\t}\n\t\t\t\tbody.append(Utility.createInvoke(fact, classWeaver.getWorld(), interMethodBody));\n\t\t\t\tbody.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(mangledInterMethod.getReturnType())));\n\n\t\t\t\tif (classWeaver.getWorld().isInJava5Mode()) { // Don't need bridge\n\t\t\t\t\t// methods if not in\n\t\t\t\t\t// 1.5 mode.\n\t\t\t\t\tcreateAnyBridgeMethodsForCovariance(classWeaver, munger, unMangledInterMethod, onType, classGen, paramTypes);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// ??? this is okay\n\t\t\t\t// if (!(mg.getBody() == null)) throw new\n\t\t\t\t// RuntimeException(\"bas\");\n\t\t\t}\n\n\t\t\tif (world.isInJava5Mode()) {\n\t\t\t\tString basicSignature = mangledInterMethod.getSignature();\n\t\t\t\tString genericSignature = ((ResolvedMemberImpl) mangledInterMethod).getSignatureForAttribute();\n\t\t\t\tif (!basicSignature.equals(genericSignature)) {\n\t\t\t\t\t// Add a signature attribute to it\n\t\t\t\t\tnewMethod.addAttribute(createSignatureAttribute(classGen.getConstantPool(), genericSignature));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// XXX make sure to check that we set exceptions properly on this\n\t\t\t// guy.\n\t\t\tclassWeaver.addLazyMethodGen(newMethod);\n\t\t\tclassWeaver.getLazyClassGen().warnOnAddedMethod(newMethod.getMethod(), getSignature().getSourceLocation());\n\n\t\t\taddNeededSuperCallMethods(classWeaver, onType, munger.getSuperMethodsCalled());\n\n\t\t\treturn true;\n\n\t\t} else if (onInterface && !Modifier.isAbstract(unMangledInterMethod.getModifiers())) {\n\n\t\t\t// This means the 'gen' should be the top most implementor\n\t\t\t// - if it is *not* then something went wrong after we worked\n\t\t\t// out that it was the top most implementor (see pr49657)\n\t\t\tif (!classGen.getType().isTopmostImplementor(onType)) {\n\t\t\t\tResolvedType rtx = classGen.getType().getTopmostImplementor(onType);\n\t\t\t\tif (rtx == null) {\n\t\t\t\t\t// pr302460\n\t\t\t\t\t// null means there is something wrong with what we are looking at\n\t\t\t\t\tResolvedType rt = classGen.getType();\n\t\t\t\t\tif (rt.isInterface()) {\n\t\t\t\t\t\tISourceLocation sloc = munger.getSourceLocation();\n\t\t\t\t\t\tclassWeaver\n\t\t\t\t\t\t\t\t.getWorld()\n\t\t\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\t\t\tMessageUtil.error(\n\t\t\t\t\t\t\t\t\t\t\t\t\"ITD target \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ rt.getName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" is an interface but has been incorrectly determined to be the topmost implementor of \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ onType.getName() + \". ITD is \" + this.getSignature(), sloc));\n\t\t\t\t\t}\n\t\t\t\t\tif (!onType.isAssignableFrom(rt)) {\n\t\t\t\t\t\tISourceLocation sloc = munger.getSourceLocation();\n\t\t\t\t\t\tclassWeaver\n\t\t\t\t\t\t\t\t.getWorld()\n\t\t\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\t\t\tMessageUtil.error(\n\t\t\t\t\t\t\t\t\t\t\t\t\"ITD target \" + rt.getName() + \" doesn't appear to implement \" + onType.getName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" why did we consider it the top most implementor? ITD is \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ this.getSignature(), sloc));\n\t\t\t\t\t}\n\t\t\t\t} else if (!rtx.isExposedToWeaver()) {\n\t\t\t\t\tISourceLocation sLoc = munger.getSourceLocation();\n\t\t\t\t\tclassWeaver\n\t\t\t\t\t\t\t.getWorld()\n\t\t\t\t\t\t\t.getMessageHandler()\n\t\t\t\t\t\t\t.handleMessage(\n\t\t\t\t\t\t\t\t\tMessageUtil.error(WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR, rtx,\n\t\t\t\t\t\t\t\t\t\t\tgetAspectType().getName()), (sLoc == null ? getAspectType().getSourceLocation() : sLoc)));\n\t\t\t\t} else {\n\t\t\t\t\t// XXX what does this state mean?\n\t\t\t\t\t// We have incorrectly identified what is the top most\n\t\t\t\t\t// implementor and its not because\n\t\t\t\t\t// a type wasn't exposed to the weaver\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\n\t\t\t\tResolvedMember mangledInterMethod = AjcMemberMaker.interMethod(unMangledInterMethod, aspectType, false);\n\n\t\t\t\tLazyMethodGen mg = makeMethodGen(classGen, mangledInterMethod);\n\n\t\t\t\t// From 98901#29 - need to copy annotations across\n\t\t\t\tif (classWeaver.getWorld().isInJava5Mode()) {\n\t\t\t\t\tAnnotationAJ annotationsOnRealMember[] = null;\n\t\t\t\t\tResolvedType toLookOn = aspectType;\n\t\t\t\t\tif (aspectType.isRawType()) {\n\t\t\t\t\t\ttoLookOn = aspectType.getGenericType();\n\t\t\t\t\t}\n\t\t\t\t\tResolvedMember realMember = getRealMemberForITDFromAspect(toLookOn, memberHoldingAnyAnnotations, false);\n\t\t\t\t\tif (realMember == null) {\n\t\t\t\t\t\tthrow new BCException(\"Couldn't find ITD holder member '\" + memberHoldingAnyAnnotations + \"' on aspect \"\n\t\t\t\t\t\t\t\t+ aspectType);\n\t\t\t\t\t}\n\t\t\t\t\tannotationsOnRealMember = realMember.getAnnotations();\n\n\t\t\t\t\tif (annotationsOnRealMember != null) {\n\t\t\t\t\t\tfor (AnnotationAJ annotationX : annotationsOnRealMember) {\n\t\t\t\t\t\t\tAnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();\n\t\t\t\t\t\t\tAnnotationGen ag = new AnnotationGen(a, classWeaver.getLazyClassGen().getConstantPool(), true);\n\t\t\t\t\t\t\tmg.addAnnotation(new BcelAnnotation(ag, classWeaver.getWorld()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcopyOverParameterAnnotations(mg, realMember);\n\t\t\t\t}\n\n\t\t\t\tif (mungingInterface) {\n\t\t\t\t\t// we want the modifiers of the ITD to be used for all\n\t\t\t\t\t// *implementors* of the\n\t\t\t\t\t// interface, but the method itself we add to the interface\n\t\t\t\t\t// must be public abstract\n\t\t\t\t\tmg.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);\n\t\t\t\t}\n\n\t\t\t\tType[] paramTypes = BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());\n\t\t\t\tType returnType = BcelWorld.makeBcelType(mangledInterMethod.getReturnType());\n\n\t\t\t\tInstructionList body = mg.getBody();\n\t\t\t\tInstructionFactory fact = classGen.getFactory();\n\t\t\t\tint pos = 0;\n\n\t\t\t\tif (!Modifier.isStatic(mangledInterMethod.getModifiers())) {\n\t\t\t\t\tbody.append(InstructionFactory.createThis());\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tfor (Type paramType : paramTypes) {\n\t\t\t\t\tbody.append(InstructionFactory.createLoad(paramType, pos));\n\t\t\t\t\tpos += paramType.getSize();\n\t\t\t\t}\n\n\t\t\t\tbody.append(Utility.createInvoke(fact, classWeaver.getWorld(), interMethodBody));\n\t\t\t\tType t = BcelWorld.makeBcelType(interMethodBody.getReturnType());\n\t\t\t\tif (!t.equals(returnType)) {\n\t\t\t\t\tbody.append(fact.createCast(t, returnType));\n\t\t\t\t}\n\t\t\t\tbody.append(InstructionFactory.createReturn(returnType));\n\t\t\t\tmg.definingType = onType;\n\n\t\t\t\tif (world.isInJava5Mode()) {\n\t\t\t\t\tString basicSignature = mangledInterMethod.getSignature();\n\t\t\t\t\tString genericSignature = ((ResolvedMemberImpl) mangledInterMethod).getSignatureForAttribute();\n\t\t\t\t\tif (!basicSignature.equals(genericSignature)) {\n\t\t\t\t\t\t// Add a signature attribute to it\n\t\t\t\t\t\tmg.addAttribute(createSignatureAttribute(classGen.getConstantPool(), genericSignature));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclassWeaver.addOrReplaceLazyMethodGen(mg);\n\n\t\t\t\taddNeededSuperCallMethods(classWeaver, onType, munger.getSuperMethodsCalled());\n\n\t\t\t\t// Work out if we need a bridge method for the new method added to the topmostimplementor.\n\n\t\t\t\t// Check if the munger being processed is a parameterized form of the original munger\n\t\t\t\tcreateBridgeIfNecessary(classWeaver, munger, unMangledInterMethod, classGen);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate void createBridgeIfNecessary(BcelClassWeaver classWeaver, NewMethodTypeMunger munger,\n\t\t\tResolvedMember unMangledInterMethod, LazyClassGen classGen) {\n\t\tif (munger.getDeclaredSignature() != null) {\n\t\t\tboolean needsbridging = false;\n\t\t\tResolvedMember mungerSignature = munger.getSignature();\n\t\t\tResolvedMember toBridgeTo = munger.getDeclaredSignature().parameterizedWith(null,\n\t\t\t\t\tmungerSignature.getDeclaringType().resolve(getWorld()), false, munger.getTypeVariableAliases());\n\t\t\tif (!toBridgeTo.getReturnType().getErasureSignature().equals(mungerSignature.getReturnType().getErasureSignature())) {\n\t\t\t\tneedsbridging = true;\n\t\t\t}\n\t\t\tUnresolvedType[] originalParams = toBridgeTo.getParameterTypes();\n\t\t\tUnresolvedType[] newParams = mungerSignature.getParameterTypes();\n\t\t\tfor (int ii = 0; ii < originalParams.length; ii++) {\n\t\t\t\tif (!originalParams[ii].getErasureSignature().equals(newParams[ii].getErasureSignature())) {\n\t\t\t\t\tneedsbridging = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (needsbridging) {\n\t\t\t\tcreateBridge(classWeaver, unMangledInterMethod, classGen, toBridgeTo);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void copyOverParameterAnnotations(LazyMethodGen receiverMethod, ResolvedMember donorMethod) {\n\t\tAnnotationAJ[][] pAnnos = donorMethod.getParameterAnnotations();\n\t\tif (pAnnos != null) {\n\t\t\tint offset = receiverMethod.isStatic() ? 0 : 1;\n\t\t\tint param = 0;\n\t\t\tfor (int i = offset; i < pAnnos.length; i++) {\n\t\t\t\tAnnotationAJ[] annosOnParam = pAnnos[i];\n\t\t\t\tif (annosOnParam != null) {\n\t\t\t\t\tfor (AnnotationAJ anno : annosOnParam) {\n\t\t\t\t\t\treceiverMethod.addParameterAnnotation(param, anno);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparam++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void createBridge(BcelClassWeaver weaver, ResolvedMember unMangledInterMethod, LazyClassGen classGen,\n\t\t\tResolvedMember toBridgeTo) {\n\t\tType[] paramTypes;\n\t\tType returnType;\n\t\tInstructionList body;\n\t\tInstructionFactory fact;\n\t\tint pos;\n\t\tResolvedMember bridgerMethod = AjcMemberMaker.bridgerToInterMethod(unMangledInterMethod, classGen.getType());\n\t\tResolvedMember bridgingSetter = AjcMemberMaker.interMethodBridger(toBridgeTo, aspectType, false); // pr250493\n\n\t\tLazyMethodGen bridgeMethod = makeMethodGen(classGen, bridgingSetter);\n\t\tparamTypes = BcelWorld.makeBcelTypes(bridgingSetter.getParameterTypes());\n\t\tType[] bridgingToParms = BcelWorld.makeBcelTypes(unMangledInterMethod.getParameterTypes());\n\t\treturnType = BcelWorld.makeBcelType(bridgingSetter.getReturnType());\n\t\tbody = bridgeMethod.getBody();\n\t\tfact = classGen.getFactory();\n\t\tpos = 0;\n\t\tif (!Modifier.isStatic(bridgingSetter.getModifiers())) {\n\t\t\tbody.append(InstructionFactory.createThis());\n\t\t\tpos++;\n\t\t}\n\t\tfor (int i = 0, len = paramTypes.length; i < len; i++) {\n\t\t\tType paramType = paramTypes[i];\n\t\t\tbody.append(InstructionFactory.createLoad(paramType, pos));\n\t\t\tif (!bridgingSetter.getParameterTypes()[i].getErasureSignature().equals(\n\t\t\t\t\tunMangledInterMethod.getParameterTypes()[i].getErasureSignature())) {\n\t\t\t\t// System.err.println(\"Putting in cast from \"+\n\t\t\t\t// paramType+\" to \"+bridgingToParms[i]);\n\t\t\t\tbody.append(fact.createCast(paramType, bridgingToParms[i]));\n\t\t\t}\n\t\t\tpos += paramType.getSize();\n\t\t}\n\n\t\tbody.append(Utility.createInvoke(fact, weaver.getWorld(), bridgerMethod));\n\t\tbody.append(InstructionFactory.createReturn(returnType));\n\t\tclassGen.addMethodGen(bridgeMethod);\n\t\t// mg.definingType = onType;\n\t}\n\n\t/**\n\t * Helper method to create a signature attribute based on a string signature: e.g. \"Ljava/lang/Object;LI<Ljava/lang/Double;>;\"\n\t */\n\tprivate Signature createSignatureAttribute(ConstantPool cp, String signature) {\n\t\tint nameIndex = cp.addUtf8(\"Signature\");\n\t\tint sigIndex = cp.addUtf8(signature);\n\t\treturn new Signature(nameIndex, 2, sigIndex, cp);\n\t}\n\n\t/**\n\t * Create any bridge method required because of covariant returns being used. This method is used in the case where an ITD is\n\t * applied to some type and it may be in an override relationship with a method from the supertype - but due to covariance there\n\t * is a mismatch in return values. Example of when required: Super defines: Object m(String s) Sub defines: String m(String s)\n\t * then we need a bridge method in Sub called 'Object m(String s)' that forwards to 'String m(String s)'\n\t */\n\tprivate void createAnyBridgeMethodsForCovariance(BcelClassWeaver weaver, NewMethodTypeMunger munger,\n\t\t\tResolvedMember unMangledInterMethod, ResolvedType onType, LazyClassGen gen, Type[] paramTypes) {\n\t\t// PERFORMANCE BOTTLENECK? Might need investigating, method analysis\n\t\t// between types in a hierarchy just seems expensive...\n\t\t// COVARIANCE BRIDGING\n\t\t// Algorithm: Step1. Check in this type - has someone already created\n\t\t// the bridge method?\n\t\t// Step2. Look above us - do we 'override' a method and yet differ in\n\t\t// return type (i.e. covariance)\n\t\t// Step3. Create a forwarding bridge method\n\t\t// ResolvedType superclass = onType.getSuperclass();\n\t\tboolean quitRightNow = false;\n\n\t\tString localMethodName = unMangledInterMethod.getName();\n\t\tString erasedSig = unMangledInterMethod.getSignatureErased(); // will be something like (LSuperB;)LFoo;\n\t\tString localParameterSig = erasedSig.substring(0,erasedSig.lastIndexOf(')')+1);//unMangledInterMethod.getParameterSignature();\n\t\t// getParameterSignatureErased() does not include parens, which we do need.\n\t\tString localReturnTypeESig = unMangledInterMethod.getReturnType().getErasureSignature();\n\n\t\t// Step1\n\t\tboolean alreadyDone = false; // Compiler might have done it\n\t\tResolvedMember[] localMethods = onType.getDeclaredMethods();\n\t\tfor (ResolvedMember member : localMethods) {\n\t\t\tif (member.getName().equals(localMethodName)) {\n\t\t\t\t// Check the params\n\t\t\t\tif (member.getParameterSignature().equals(localParameterSig)) {\n\t\t\t\t\talreadyDone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Step2\n\t\tif (!alreadyDone) {\n\t\t\t// Use the iterator form of 'getMethods()' so we do as little work as necessary\n\t\t\tResolvedType supertype = onType.getSuperclass();\n\t\t\tif (supertype != null) {\n\t\t\t\tfor (Iterator<ResolvedMember> iter = supertype.getMethods(true, true); iter.hasNext() && !quitRightNow;) {\n\t\t\t\t\tResolvedMember aMethod = iter.next();\n\t\t\t\t\tif (aMethod.getName().equals(localMethodName) && aMethod.getParameterSignature().equals(localParameterSig)) {\n\t\t\t\t\t\t// check the return types, if they are different we need a\n\t\t\t\t\t\t// bridging method.\n\t\t\t\t\t\tif (!aMethod.getReturnType().getErasureSignature().equals(localReturnTypeESig)\n\t\t\t\t\t\t\t\t&& !Modifier.isPrivate(aMethod.getModifiers())) {\n\t\t\t\t\t\t\t// Step3\n\t\t\t\t\t\t\tcreateBridgeMethod(weaver.getWorld(), munger, unMangledInterMethod, gen, paramTypes, aMethod);\n\t\t\t\t\t\t\tquitRightNow = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Create a bridge method for a particular munger.\n\t *\n\t * @param world\n\t * @param munger\n\t * @param unMangledInterMethod the method to bridge 'to' that we have already created in the 'subtype'\n\t * @param clazz the class in which to put the bridge method\n\t * @param paramTypes Parameter types for the bridge method, passed in as an optimization since the caller is likely to have\n\t *        already created them.\n\t * @param theBridgeMethod\n\t */\n\tprivate void createBridgeMethod(BcelWorld world, NewMethodTypeMunger munger, ResolvedMember unMangledInterMethod,\n\t\t\tLazyClassGen clazz, Type[] paramTypes, ResolvedMember theBridgeMethod) {\n\t\tInstructionList body;\n\t\tInstructionFactory fact;\n\t\tint pos = 0;\n\n\t\t// The bridge method in this type will have the same signature as the one in the supertype\n\t\tLazyMethodGen bridgeMethod = makeMethodGen(clazz, theBridgeMethod);\n\t\tbridgeMethod.setAccessFlags(bridgeMethod.getAccessFlags() | 0x00000040 /* BRIDGE = 0x00000040 */);\n\t\t// UnresolvedType[] newParams = munger.getSignature().getParameterTypes();\n\t\tType returnType = BcelWorld.makeBcelType(theBridgeMethod.getReturnType());\n\t\tbody = bridgeMethod.getBody();\n\t\tfact = clazz.getFactory();\n\n\t\tif (!Modifier.isStatic(unMangledInterMethod.getModifiers())) {\n\t\t\tbody.append(InstructionFactory.createThis());\n\t\t\tpos++;\n\t\t}\n\t\tfor (Type paramType : paramTypes) {\n\t\t\tbody.append(InstructionFactory.createLoad(paramType, pos));\n\t\t\t// if (!bridgingSetter.getParameterTypes()[i].getErasureSignature().\n\t\t\t// equals\n\t\t\t// (unMangledInterMethod.getParameterTypes()[i].getErasureSignature\n\t\t\t// ())) {\n\t\t\t// System.err.println(\"Putting in cast from \"+paramType+\" to \"+\n\t\t\t// bridgingToParms[i]);\n\t\t\t// body.append(fact.createCast(paramType,bridgingToParms[i]));\n\t\t\t// }\n\t\t\tpos += paramType.getSize();\n\t\t}\n\n\t\tbody.append(Utility.createInvoke(fact, world, unMangledInterMethod));\n\t\tbody.append(InstructionFactory.createReturn(returnType));\n\t\tclazz.addMethodGen(bridgeMethod);\n\t}\n\n\t// Unlike toString() on a member, this does not include the declaring type\n\tprivate String stringifyMember(ResolvedMember member) {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tbuf.append(member.getReturnType().getName());\n\t\tbuf.append(' ');\n\t\tbuf.append(member.getName());\n\t\tif (member.getKind() != Member.FIELD) {\n\t\t\tbuf.append(\"(\");\n\t\t\tUnresolvedType[] params = member.getParameterTypes();\n\t\t\tif (params.length != 0) {\n\t\t\t\tbuf.append(params[0]);\n\t\t\t\tfor (int i = 1, len = params.length; i < len; i++) {\n\t\t\t\t\tbuf.append(\", \");\n\t\t\t\t\tbuf.append(params[i].getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf.append(\")\");\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tprivate boolean mungeMethodDelegate(BcelClassWeaver weaver, MethodDelegateTypeMunger munger) {\n\t\tWorld world = weaver.getWorld();\n\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\t\tif (gen.getType().isAnnotation() || gen.getType().isEnum()) {\n\t\t\t// don't signal error as it could be a consequence of a wild type pattern\n\t\t\treturn false;\n\t\t}\n\n\t\tResolvedMember introduced = munger.getSignature();\n\n\t\tResolvedType fromType = world.resolve(introduced.getDeclaringType(), munger.getSourceLocation());\n\t\tif (fromType.isRawType()) {\n\t\t\tfromType = fromType.getGenericType();\n\t\t}\n\n\t\tboolean shouldApply = munger.matches(weaver.getLazyClassGen().getType(), aspectType);\n\n\t\tif (shouldApply) {\n\t\t\tType bcelReturnType = BcelWorld.makeBcelType(introduced.getReturnType());\n\n\t\t\t// If no implementation class was specified, the intention was that\n\t\t\t// the types matching the pattern\n\t\t\t// already implemented the interface, let's check that now!\n\t\t\tif (munger.getImplClassName() == null && !munger.specifiesDelegateFactoryMethod()) {\n\t\t\t\tboolean isOK = false;\n\t\t\t\tList<LazyMethodGen> existingMethods = gen.getMethodGens();\n\t\t\t\tfor (LazyMethodGen m : existingMethods) {\n\t\t\t\t\tif (m.getName().equals(introduced.getName())\n\t\t\t\t\t\t\t&& m.getParameterSignature().equals(introduced.getParameterSignature())\n\t\t\t\t\t\t\t&& m.getReturnType().equals(bcelReturnType)) {\n\t\t\t\t\t\tisOK = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isOK) {\n\t\t\t\t\t// the class does not implement this method, they needed to\n\t\t\t\t\t// supply a default impl class\n\t\t\t\t\tIMessage msg = new Message(\"@DeclareParents: No defaultImpl was specified but the type '\" + gen.getName()\n\t\t\t\t\t\t\t+ \"' does not implement the method '\" + stringifyMember(introduced) + \"' defined on the interface '\"\n\t\t\t\t\t\t\t+ introduced.getDeclaringType() + \"'\", weaver.getLazyClassGen().getType().getSourceLocation(), true,\n\t\t\t\t\t\t\tnew ISourceLocation[] { munger.getSourceLocation() });\n\t\t\t\t\tweaver.getWorld().getMessageHandler().handleMessage(msg);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tLazyMethodGen mg = new LazyMethodGen(introduced.getModifiers() - Modifier.ABSTRACT, bcelReturnType,\n\t\t\t\t\tintroduced.getName(), BcelWorld.makeBcelTypes(introduced.getParameterTypes()),\n\t\t\t\t\tBcelWorld.makeBcelTypesAsClassNames(introduced.getExceptions()), gen);\n\n\t\t\t// annotation copy from annotation on ITD interface\n\t\t\tif (weaver.getWorld().isInJava5Mode()) {\n\t\t\t\tAnnotationAJ annotationsOnRealMember[] = null;\n\t\t\t\tResolvedType toLookOn = weaver.getWorld().lookupOrCreateName(introduced.getDeclaringType());\n\t\t\t\tif (fromType.isRawType()) {\n\t\t\t\t\ttoLookOn = fromType.getGenericType();\n\t\t\t\t}\n\t\t\t\t// lookup the method\n\t\t\t\tResolvedMember[] ms = toLookOn.getDeclaredJavaMethods();\n\t\t\t\tfor (ResolvedMember m : ms) {\n\t\t\t\t\tif (introduced.getName().equals(m.getName()) && introduced.getSignature().equals(m.getSignature())) {\n\t\t\t\t\t\tannotationsOnRealMember = m.getAnnotations();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (annotationsOnRealMember != null) {\n\t\t\t\t\tfor (AnnotationAJ anno : annotationsOnRealMember) {\n\t\t\t\t\t\tAnnotationGen a = ((BcelAnnotation) anno).getBcelAnnotation();\n\t\t\t\t\t\tAnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPool(), true);\n\t\t\t\t\t\tmg.addAnnotation(new BcelAnnotation(ag, weaver.getWorld()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInstructionList body = new InstructionList();\n\t\t\tInstructionFactory fact = gen.getFactory();\n\n\t\t\t// Create a delegate method body which basically looks as follows:\n\t\t\t//\n\t\t\t// public void methodOne() {\n\t\t\t//   if (this.ajc$instance$MyAspect$MyMixin == null) {\n\t\t\t//     synchronized(this) {\n\t\t\t//       if (this.ajc$instance$MyAspect$MyMixin == null) {\n\t\t\t//         this.ajc$instance$MyAspect$MyMixin = MyAspect.aspectOf().createImplementation(this);\n\t\t\t//       }\n\t\t\t//     }\n\t\t\t//   }\n\t\t\t//   this.ajc$instance$MyAspect$MyMixin.methodOne();\n\t\t\t// }\n\n\t\t\t// Before synchronising on 'this', perform a preliminary null check on the delegate field. Only if it is null,\n\t\t\t// it makes sense to synchronise, then check for null again and initialise the delegate, if null.\n\t\t\tbody.append(InstructionConstants.ALOAD_0);\n\t\t\tbody.append(Utility.createGet(fact, munger.getDelegate(weaver.getLazyClassGen().getType())));\n\t\t\tInstructionBranch outerIfNonNull = InstructionFactory.createBranchInstruction(Constants.IFNONNULL, null);\n\t\t\tbody.append(outerIfNonNull);\n\n\t\t\t// Wrap delegate field initialisation in 'synchronized(this)' block - MONITORENTER (beginning of 'try')\n\t\t\tbody.append(InstructionConstants.ALOAD_0);\n\t\t\tbody.append(InstructionConstants.MONITORENTER);\n\n\t\t\t// The JVM spec requires us add an exception handler ensuring MONITOREXIT in case of an exception inside the\n\t\t\t// synchronized block, see https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-3.html#jvms-3.14.\n\t\t\tInstructionHandle tryStart = body.append(InstructionConstants.ALOAD_0);\n\t\t\tbody.append(Utility.createGet(fact, munger.getDelegate(weaver.getLazyClassGen().getType())));\n\t\t\tInstructionBranch innerIfNonNull = InstructionFactory.createBranchInstruction(Constants.IFNONNULL, null);\n\t\t\tbody.append(innerIfNonNull);\n\n\t\t\t// Create and store a new instance\n\t\t\tbody.append(InstructionConstants.ALOAD_0); // 'this' is where we'll store the field value\n\n\t\t\t// TODO for non-static case, call aspectOf() then call the factory method on the retval\n\t\t\t// TODO decide whether the value can really be cached\n\n\t\t\t// locate the aspect and call the static method in it\n\t\t\tif (munger.specifiesDelegateFactoryMethod()) {\n\t\t\t\tResolvedMember rm = munger.getDelegateFactoryMethod(weaver.getWorld());\n\n\t\t\t\t// Check the method parameter is compatible with the type of the instance to be passed\n\t\t\t\tif (rm.getArity() != 0) {\n\t\t\t\t\tResolvedType parameterType = rm.getParameterTypes()[0].resolve(weaver.getWorld());\n\t\t\t\t\tif (!parameterType.isAssignableFrom(weaver.getLazyClassGen().getType())) {\n\t\t\t\t\t\tsignalError(\"For mixin factory method '\" + rm + \"': Instance type '\" + weaver.getLazyClassGen().getType()\n\t\t\t\t\t\t\t\t+ \"' is not compatible with factory parameter type '\" + parameterType + \"'\", weaver);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (Modifier.isStatic(rm.getModifiers())) {\n\t\t\t\t\tif (rm.getArity() != 0) {\n\t\t\t\t\t\tbody.append(InstructionConstants.ALOAD_0);\n\t\t\t\t\t}\n\t\t\t\t\tbody.append(fact.createInvoke(rm.getDeclaringType().getName(), rm.getName(), rm.getSignature(),\n\t\t\t\t\t\t\tConstants.INVOKESTATIC));\n\t\t\t\t\tbody.append(Utility.createSet(fact, munger.getDelegate(weaver.getLazyClassGen().getType())));\n\t\t\t\t} else {\n\t\t\t\t\t// Need to call aspectOf() to obtain the aspect instance then call the factory method upon that\n\t\t\t\t\tUnresolvedType theAspect = munger.getAspect();\n\t\t\t\t\tbody.append(fact.createInvoke(theAspect.getName(), \"aspectOf\", \"()\" + theAspect.getSignature(),\n\t\t\t\t\t\t\tConstants.INVOKESTATIC));\n\t\t\t\t\tif (rm.getArity() != 0) {\n\t\t\t\t\t\tbody.append(InstructionConstants.ALOAD_0);\n\t\t\t\t\t}\n\t\t\t\t\tbody.append(fact.createInvoke(rm.getDeclaringType().getName(), rm.getName(), rm.getSignature(),\n\t\t\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t\t\t\tbody.append(Utility.createSet(fact, munger.getDelegate(weaver.getLazyClassGen().getType())));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbody.append(fact.createNew(munger.getImplClassName()));\n\t\t\t\tbody.append(InstructionConstants.DUP);\n\t\t\t\tbody.append(fact.createInvoke(munger.getImplClassName(), \"<init>\", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));\n\t\t\t\tbody.append(Utility.createSet(fact, munger.getDelegate(weaver.getLazyClassGen().getType())));\n\t\t\t}\n\n\t\t\t// Wrap delegate field initialisation in 'synchronized(this)' block - MONITOREXIT (end of 'try')\n\t\t\tInstructionHandle ifNonNullElse = body.append(InstructionConstants.ALOAD_0);\n\t\t\tinnerIfNonNull.setTarget(ifNonNullElse);\n\t\t\tbody.append(InstructionConstants.MONITOREXIT);\n\n\t\t\t// There was no error in the 'synchronized(this)' block -> jump to first instruction after exception handler\n\t\t\tInstructionBranch gotoAfterTryCatch = new InstructionBranch(Constants.GOTO, null);\n\t\t\tInstructionHandle tryEnd = body.append(gotoAfterTryCatch);\n\n\t\t\t// Exception handler (logical 'catch') for the 'synchronized(this)' block ensures that MONITOREXIT is also called\n\t\t\t// in case of an error\n\t\t\tInstructionHandle catchStart = body.append(InstructionConstants.ALOAD_0);\n\t\t\tbody.append(InstructionConstants.MONITOREXIT);\n\t\t\tInstructionHandle catchEnd = body.append(InstructionConstants.ATHROW);\n\n\t\t\t// Add exception handler for 'synchronized(this)' block\n\t\t\tmg.addExceptionHandler(tryStart, tryEnd.getPrev(), catchStart, null, false);\n\n\t\t\t// CAVEAT: Add an extra, self-referential exception handler entry. I.e., the handler handles its own exceptions.\n\t\t\t// According to https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-3.html#jvms-3.14, this is required, and\n\t\t\t// Javac also creates code like this, which is why we are mimicking it.\n\t\t\tmg.addExceptionHandler(catchStart, catchEnd.getPrev(), catchStart, null, false);\n\n\t\t\t// if not null use the instance we've got\n\t\t\tInstructionHandle afterTryCatch = body.append(InstructionConstants.ALOAD_0);\n\t\t\t// Tell 'gotoAfterTryCatch' where to find the first statement after the exception handler\n\t\t\tgotoAfterTryCatch.setTarget(afterTryCatch);\n\t\t\t// The outer delegate field null check should also jump to the same place, if the delegate field is not null\n\t\t\touterIfNonNull.setTarget(afterTryCatch);\n\t\t\tbody.append(Utility.createGet(fact, munger.getDelegate(weaver.getLazyClassGen().getType())));\n\n\t\t\t// args\n\t\t\tint pos = 0;\n\t\t\tif (!Modifier.isStatic(introduced.getModifiers())) { // skip 'this' (?? can this really\n\t\t\t\t// happen)\n\t\t\t\t// body.append(InstructionFactory.createThis());\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tType[] paramTypes = BcelWorld.makeBcelTypes(introduced.getParameterTypes());\n\t\t\tfor (Type paramType : paramTypes) {\n\t\t\t\tbody.append(InstructionFactory.createLoad(paramType, pos));\n\t\t\t\tpos += paramType.getSize();\n\t\t\t}\n\t\t\tbody.append(Utility.createInvoke(fact, Constants.INVOKEINTERFACE, introduced));\n\t\t\tbody.append(InstructionFactory.createReturn(bcelReturnType));\n\n\t\t\tmg.getBody().append(body);\n\t\t\tweaver.addLazyMethodGen(mg);\n\t\t\tweaver.getLazyClassGen().warnOnAddedMethod(mg.getMethod(), getSignature().getSourceLocation());\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean mungeFieldHost(BcelClassWeaver weaver, MethodDelegateTypeMunger.FieldHostTypeMunger munger) {\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\t\tif (gen.getType().isAnnotation() || gen.getType().isEnum()) {\n\t\t\t// don't signal error as it could be a consequence of a wild type\n\t\t\t// pattern\n\t\t\treturn false;\n\t\t}\n\t\t// boolean shouldApply =\n\t\tmunger.matches(weaver.getLazyClassGen().getType(), aspectType); // why\n\t\t// do\n\t\t// this?\n\t\tResolvedMember host = AjcMemberMaker.itdAtDeclareParentsField(weaver.getLazyClassGen().getType(), munger.getSignature()\n\t\t\t\t.getType(), aspectType);\n\t\tFieldGen field = makeFieldGen(weaver.getLazyClassGen(), host);\n\t\tfield.setModifiers(field.getModifiers() | BcelField.AccSynthetic);\n\t\tweaver.getLazyClassGen().addField(field, null);\n\t\treturn true;\n\t}\n\n\tprivate ResolvedMember getRealMemberForITDFromAspect(ResolvedType aspectType, ResolvedMember lookingFor, boolean isCtorRelated) {\n\t\tWorld world = aspectType.getWorld();\n\t\tboolean debug = false;\n\t\tif (debug) {\n\t\t\tSystem.err.println(\"Searching for a member on type: \" + aspectType);\n\t\t\tSystem.err.println(\"Member we are looking for: \" + lookingFor);\n\t\t}\n\n\t\tResolvedMember[] aspectMethods = aspectType.getDeclaredMethods();\n\t\tUnresolvedType[] lookingForParams = lookingFor.getParameterTypes();\n\n\t\tResolvedMember realMember = null;\n\t\tfor (int i = 0; realMember == null && i < aspectMethods.length; i++) {\n\t\t\tResolvedMember member = aspectMethods[i];\n\t\t\tif (member.getName().equals(lookingFor.getName())) {\n\t\t\t\tUnresolvedType[] memberParams = member.getGenericParameterTypes();\n\t\t\t\tif (memberParams.length == lookingForParams.length) {\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\tSystem.err.println(\"Reviewing potential candidates: \" + member);\n\t\t\t\t\tboolean matchOK = true;\n\n\t\t\t\t\t// Check that all method/ctor params all match, although only the erasure\n\t\t\t\t\tfor (int j = 0; j < memberParams.length && matchOK; j++) {\n\t\t\t\t\t\tResolvedType pMember = memberParams[j].resolve(world);\n\t\t\t\t\t\tResolvedType pLookingFor = lookingForParams[j].resolve(world);\n\n\t\t\t\t\t\tif (pMember.isTypeVariableReference())\n\t\t\t\t\t\t\tpMember = ((TypeVariableReference) pMember).getTypeVariable().getFirstBound().resolve(world);\n\t\t\t\t\t\tif (pMember.isParameterizedType() || pMember.isGenericType())\n\t\t\t\t\t\t\tpMember = pMember.getRawType().resolve(aspectType.getWorld());\n\n\t\t\t\t\t\tif (pLookingFor.isTypeVariableReference())\n\t\t\t\t\t\t\tpLookingFor = ((TypeVariableReference) pLookingFor).getTypeVariable().getFirstBound().resolve(world);\n\t\t\t\t\t\tif (pLookingFor.isParameterizedType() || pLookingFor.isGenericType())\n\t\t\t\t\t\t\tpLookingFor = pLookingFor.getRawType().resolve(world);\n\n\t\t\t\t\t\tif (debug)\n\t\t\t\t\t\t\tSystem.err.println(\"Comparing parameter \" + j + \"   member=\" + pMember + \"   lookingFor=\" + pLookingFor);\n\t\t\t\t\t\tif (!pMember.equals(pLookingFor))\n\t\t\t\t\t\t\tmatchOK = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (matchOK)\n\t\t\t\t\t\trealMember = member;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (debug && realMember == null)\n\t\t\tSystem.err.println(\"Didn't find a match\");\n\t\treturn realMember;\n\t}\n\n\tprivate void addNeededSuperCallMethods(BcelClassWeaver weaver, ResolvedType onType, Set<ResolvedMember> neededSuperCalls) {\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\t\tfor (ResolvedMember superMethod: neededSuperCalls) {\n\t\t\tif (weaver.addDispatchTarget(superMethod)) {\n\t\t\t\t// System.err.println(\"super type: \" + superMethod.getDeclaringType() + \", \" + gen.getType());\n\t\t\t\tboolean isSuper = !superMethod.getDeclaringType().equals(gen.getType());\n\t\t\t\tString dispatchName;\n\t\t\t\tif (isSuper) {\n\t\t\t\t\tdispatchName = NameMangler.superDispatchMethod(onType, superMethod.getName());\n\t\t\t\t} else {\n\t\t\t\t\tdispatchName = NameMangler.protectedDispatchMethod(onType, superMethod.getName());\n\t\t\t\t}\n\t\t\t\tsuperMethod = superMethod.resolve(weaver.getWorld());\n\t\t\t\tLazyMethodGen dispatcher = makeDispatcher(gen, dispatchName, superMethod, weaver.getWorld(), isSuper);\n\t\t\t\tweaver.addLazyMethodGen(dispatcher);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void signalError(String msgid, BcelClassWeaver weaver, UnresolvedType onType) {\n\t\tIMessage msg = MessageUtil.error(WeaverMessages.format(msgid, onType.getName()), getSourceLocation());\n\t\tweaver.getWorld().getMessageHandler().handleMessage(msg);\n\t}\n\n\t// private void signalWarning(String msgString, BcelClassWeaver weaver) {\n\t// IMessage msg = MessageUtil.warn(msgString, getSourceLocation());\n\t// weaver.getWorld().getMessageHandler().handleMessage(msg);\n\t// }\n\n\tprivate void signalError(String msgString, BcelClassWeaver weaver) {\n\t\tIMessage msg = MessageUtil.error(msgString, getSourceLocation());\n\t\tweaver.getWorld().getMessageHandler().handleMessage(msg);\n\t}\n\n\tprivate boolean mungeNewConstructor(BcelClassWeaver weaver, NewConstructorTypeMunger newConstructorTypeMunger) {\n\n\t\tfinal LazyClassGen currentClass = weaver.getLazyClassGen();\n\t\tfinal InstructionFactory fact = currentClass.getFactory();\n\n\t\tResolvedMember newConstructorMember = newConstructorTypeMunger.getSyntheticConstructor();\n\t\tResolvedType onType = newConstructorMember.getDeclaringType().resolve(weaver.getWorld());\n\t\tif (onType.isRawType()) {\n\t\t\tonType = onType.getGenericType();\n\t\t}\n\n\t\tif (onType.isAnnotation()) {\n\t\t\tsignalError(WeaverMessages.ITDC_ON_ANNOTATION_NOT_ALLOWED, weaver, onType);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (onType.isEnum()) {\n\t\t\tsignalError(WeaverMessages.ITDC_ON_ENUM_NOT_ALLOWED, weaver, onType);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!onType.equals(currentClass.getType())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tResolvedMember explicitConstructor = newConstructorTypeMunger.getExplicitConstructor();\n\t\t// int declaredParameterCount =\n\t\t// newConstructorTypeMunger.getDeclaredParameterCount();\n\t\tLazyMethodGen mg = makeMethodGen(currentClass, newConstructorMember);\n\t\tmg.setEffectiveSignature(newConstructorTypeMunger.getSignature(), Shadow.ConstructorExecution, true);\n\n\t\t// pr98901\n\t\t// For copying the annotations across, we have to discover the real\n\t\t// member in the aspect\n\t\t// which is holding them.\n\t\tif (weaver.getWorld().isInJava5Mode()) {\n\n\t\t\tResolvedMember interMethodDispatcher = AjcMemberMaker.postIntroducedConstructor(aspectType, onType,\n\t\t\t\t\tnewConstructorTypeMunger.getSignature().getParameterTypes());\n\t\t\tAnnotationAJ annotationsOnRealMember[] = null;\n\t\t\tResolvedMember realMember = getRealMemberForITDFromAspect(aspectType, interMethodDispatcher, true);\n\t\t\t// 266602 - consider it missing to mean that the corresponding aspect had errors\n\t\t\tif (realMember == null) {\n\t\t\t\t// signalWarning(\"Unable to apply any annotations attached to \" + munger.getSignature(), weaver);\n\t\t\t\t// throw new BCException(\"Couldn't find ITD init member '\" + interMethodBody + \"' on aspect \" + aspectType);\n\t\t\t} else {\n\t\t\t\tannotationsOnRealMember = realMember.getAnnotations();\n\t\t\t}\n\t\t\tif (annotationsOnRealMember != null) {\n\t\t\t\tfor (AnnotationAJ annotationX : annotationsOnRealMember) {\n\t\t\t\t\tAnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();\n\t\t\t\t\tAnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPool(), true);\n\t\t\t\t\tmg.addAnnotation(new BcelAnnotation(ag, weaver.getWorld()));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// the below loop fixes the very special (and very stupid)\n\t\t\t// case where an aspect declares an annotation\n\t\t\t// on an ITD it declared on itself.\n\t\t\tList<DeclareAnnotation> allDecams = weaver.getWorld().getDeclareAnnotationOnMethods();\n\t\t\tfor (DeclareAnnotation decaMC : allDecams) {\n\t\t\t\tif (decaMC.matches(explicitConstructor, weaver.getWorld()) && mg.getEnclosingClass().getType() == aspectType) {\n\t\t\t\t\tmg.addAnnotation(decaMC.getAnnotation());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Might have to remove the default constructor - b275032\n\t\t// TODO could have tagged the type munger when the fact we needed to do this was detected earlier\n\t\tif (mg.getArgumentTypes().length == 0) {\n\t\t\tLazyMethodGen toRemove = null;\n\t\t\tfor (LazyMethodGen object : currentClass.getMethodGens()) {\n\t\t\t\tif (object.getName().equals(\"<init>\") && object.getArgumentTypes().length == 0) {\n\t\t\t\t\ttoRemove = object;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (toRemove != null) {\n\t\t\t\tcurrentClass.removeMethodGen(toRemove);\n\t\t\t}\n\t\t}\n\n\t\tcurrentClass.addMethodGen(mg);\n\t\t// weaver.addLazyMethodGen(freshConstructor);\n\n\t\tInstructionList body = mg.getBody();\n\n\t\t// add to body: push arts for call to pre, from actual args starting at\n\t\t// 1 (skipping this), going to\n\t\t// declared argcount + 1\n\t\tUnresolvedType[] declaredParams = newConstructorTypeMunger.getSignature().getParameterTypes();\n\t\tType[] paramTypes = mg.getArgumentTypes();\n\t\tint frameIndex = 1;\n\t\tfor (int i = 0, len = declaredParams.length; i < len; i++) {\n\t\t\tbody.append(InstructionFactory.createLoad(paramTypes[i], frameIndex));\n\t\t\tframeIndex += paramTypes[i].getSize();\n\t\t}\n\t\t// do call to pre\n\t\tMember preMethod = AjcMemberMaker.preIntroducedConstructor(aspectType, onType, declaredParams);\n\t\tbody.append(Utility.createInvoke(fact, null, preMethod));\n\n\t\t// create a local, and store return pre stuff into it.\n\t\tint arraySlot = mg.allocateLocal(1);\n\t\tbody.append(InstructionFactory.createStore(Type.OBJECT, arraySlot));\n\n\t\t// put this on the stack\n\t\tbody.append(InstructionConstants.ALOAD_0);\n\n\t\t// unpack pre args onto stack\n\t\tUnresolvedType[] superParamTypes = explicitConstructor.getParameterTypes();\n\n\t\tfor (int i = 0, len = superParamTypes.length; i < len; i++) {\n\t\t\tbody.append(InstructionFactory.createLoad(Type.OBJECT, arraySlot));\n\t\t\tbody.append(Utility.createConstant(fact, i));\n\t\t\tbody.append(InstructionFactory.createArrayLoad(Type.OBJECT));\n\t\t\tbody.append(Utility.createConversion(fact, Type.OBJECT, BcelWorld.makeBcelType(superParamTypes[i])));\n\t\t}\n\n\t\t// call super/this\n\n\t\tbody.append(Utility.createInvoke(fact, null, explicitConstructor));\n\n\t\t// put this back on the stack\n\n\t\tbody.append(InstructionConstants.ALOAD_0);\n\n\t\t// unpack params onto stack\n\t\tMember postMethod = AjcMemberMaker.postIntroducedConstructor(aspectType, onType, declaredParams);\n\t\tUnresolvedType[] postParamTypes = postMethod.getParameterTypes();\n\n\t\tfor (int i = 1, len = postParamTypes.length; i < len; i++) {\n\t\t\tbody.append(InstructionFactory.createLoad(Type.OBJECT, arraySlot));\n\t\t\tbody.append(Utility.createConstant(fact, superParamTypes.length + i - 1));\n\t\t\tbody.append(InstructionFactory.createArrayLoad(Type.OBJECT));\n\t\t\tbody.append(Utility.createConversion(fact, Type.OBJECT, BcelWorld.makeBcelType(postParamTypes[i])));\n\t\t}\n\n\t\t// call post\n\t\tbody.append(Utility.createInvoke(fact, null, postMethod));\n\n\t\t// don't forget to return!!\n\t\tbody.append(InstructionConstants.RETURN);\n\n\t\taddNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());\n\n\t\treturn true;\n\t}\n\n\tprivate static LazyMethodGen makeDispatcher(LazyClassGen onGen, String dispatchName, ResolvedMember superMethod,\n\t\t\tBcelWorld world, boolean isSuper) {\n\t\tType[] paramTypes = BcelWorld.makeBcelTypes(superMethod.getParameterTypes());\n\t\tType returnType = BcelWorld.makeBcelType(superMethod.getReturnType());\n\n\t\tint modifiers = Modifier.PUBLIC;\n\t\tif (onGen.isInterface()) {\n\t\t\tmodifiers |= Modifier.ABSTRACT;\n\t\t}\n\n\t\tLazyMethodGen mg = new LazyMethodGen(modifiers, returnType, dispatchName, paramTypes, UnresolvedType.getNames(superMethod\n\t\t\t\t.getExceptions()), onGen);\n\t\tInstructionList body = mg.getBody();\n\n\t\tif (onGen.isInterface()) {\n\t\t\treturn mg;\n\t\t}\n\n\t\t// assert (!superMethod.isStatic())\n\t\tInstructionFactory fact = onGen.getFactory();\n\t\tint pos = 0;\n\n\t\tbody.append(InstructionFactory.createThis());\n\t\tpos++;\n\t\tfor (Type paramType : paramTypes) {\n\t\t\tbody.append(InstructionFactory.createLoad(paramType, pos));\n\t\t\tpos += paramType.getSize();\n\t\t}\n\t\tif (isSuper) {\n\t\t\tbody.append(Utility.createSuperInvoke(fact, world, superMethod));\n\t\t} else {\n\t\t\tbody.append(Utility.createInvoke(fact, world, superMethod));\n\t\t}\n\t\tbody.append(InstructionFactory.createReturn(returnType));\n\n\t\treturn mg;\n\t}\n\n\tprivate boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger) {\n\t\t/* ResolvedMember initMethod = */munger.getInitMethod(aspectType);\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\n\t\tResolvedMember field = munger.getSignature();\n\n\t\tResolvedType onType = weaver.getWorld().resolve(field.getDeclaringType(), munger.getSourceLocation());\n\t\tif (onType.isRawType()) {\n\t\t\tonType = onType.getGenericType();\n\t\t}\n\n\t\tboolean onInterface = onType.isInterface();\n\n\t\tif (onType.isAnnotation()) {\n\t\t\tsignalError(WeaverMessages.ITDF_ON_ANNOTATION_NOT_ALLOWED, weaver, onType);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (onType.isEnum()) {\n\t\t\tsignalError(WeaverMessages.ITDF_ON_ENUM_NOT_ALLOWED, weaver, onType);\n\t\t\treturn false;\n\t\t}\n\n\t\tResolvedMember interMethodBody = munger.getInitMethod(aspectType);\n\n\t\tAnnotationAJ annotationsOnRealMember[] = null;\n\t\t// pr98901\n\t\t// For copying the annotations across, we have to discover the real\n\t\t// member in the aspect\n\t\t// which is holding them.\n\t\tif (weaver.getWorld().isInJava5Mode()) {\n\t\t\t// the below line just gets the method with the same name in\n\t\t\t// aspectType.getDeclaredMethods();\n\t\t\tResolvedType toLookOn = aspectType;\n\t\t\tif (aspectType.isRawType()) {\n\t\t\t\ttoLookOn = aspectType.getGenericType();\n\t\t\t}\n\t\t\tResolvedMember realMember = getRealMemberForITDFromAspect(toLookOn, interMethodBody, false);\n\t\t\tif (realMember == null) {\n\t\t\t\t// signalWarning(\"Unable to apply any annotations attached to \" + munger.getSignature(), weaver);\n\t\t\t\t// throw new BCException(\"Couldn't find ITD init member '\" + interMethodBody + \"' on aspect \" + aspectType);\n\t\t\t} else {\n\t\t\t\tannotationsOnRealMember = realMember.getAnnotations();\n\t\t\t}\n\t\t}\n\n\t\tif (onType.equals(gen.getType())) {\n\t\t\tif (onInterface) {\n\t\t\t\tResolvedMember itdfieldGetter = AjcMemberMaker.interFieldInterfaceGetter(field, onType, aspectType);\n\t\t\t\tLazyMethodGen mg = makeMethodGen(gen, itdfieldGetter);\n\t\t\t\tgen.addMethodGen(mg);\n\n\t\t\t\tLazyMethodGen mg1 = makeMethodGen(gen, AjcMemberMaker.interFieldInterfaceSetter(field, onType, aspectType));\n\t\t\t\tgen.addMethodGen(mg1);\n\t\t\t} else {\n\t\t\t\tweaver.addInitializer(this);\n\t\t\t\tResolvedMember newField = AjcMemberMaker.interFieldClassField(field, aspectType,\n\t\t\t\t\t\tmunger.version == NewFieldTypeMunger.VersionTwo);\n\t\t\t\tFieldGen fg = makeFieldGen(gen, newField);\n\n\t\t\t\tif (annotationsOnRealMember != null) {\n\t\t\t\t\tfor (AnnotationAJ annotationX : annotationsOnRealMember) {\n\t\t\t\t\t\tAnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();\n\t\t\t\t\t\tAnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPool(), true);\n\t\t\t\t\t\tfg.addAnnotation(ag);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (weaver.getWorld().isInJava5Mode()) {\n\t\t\t\t\tString basicSignature = field.getSignature();\n\t\t\t\t\tString genericSignature = field.getReturnType().resolve(weaver.getWorld()).getSignatureForAttribute();\n\t\t\t\t\t// String genericSignature =\n\t\t\t\t\t// ((ResolvedMemberImpl)field).getSignatureForAttribute();\n\t\t\t\t\tif (!basicSignature.equals(genericSignature)) {\n\t\t\t\t\t\t// Add a signature attribute to it\n\t\t\t\t\t\tfg.addAttribute(createSignatureAttribute(gen.getConstantPool(), genericSignature));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgen.addField(fg, getSourceLocation());\n\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (onInterface && gen.getType().isTopmostImplementor(onType)) {\n\t\t\t// we know that we can't be static since we don't allow statics on interfaces\n\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\tthrow new RuntimeException(\"unimplemented\");\n\t\t\t}\n\n\t\t\tboolean alreadyExists = false;\n\t\t\t// only need to check for version 2 style mungers\n\t\t\tif (munger.version==NewFieldTypeMunger.VersionTwo) {\n\t\t\t\tfor (BcelField fieldgen: gen.getFieldGens()) {\n\t\t\t\t\tif (fieldgen.getName().equals(field.getName())) {\n\t\t\t\t\t\talreadyExists=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// FieldGen fg = makeFieldGen(gen, AjcMemberMaker.interFieldInterfaceField(field, onType, aspectType));\n\t\t\tResolvedMember newField = AjcMemberMaker.interFieldInterfaceField(field, onType, aspectType, munger.version == NewFieldTypeMunger.VersionTwo);\n\t\t\tString fieldName = newField.getName();\n\n\t\t\tType fieldType = BcelWorld.makeBcelType(field.getType());\n\t\t\tif (!alreadyExists) {\n\t\t\t\tweaver.addInitializer(this);\n\t\t\t\tFieldGen fg = makeFieldGen(gen,newField);\n\t\t\t\tif (annotationsOnRealMember != null) {\n\t\t\t\t\tfor (AnnotationAJ annotationX : annotationsOnRealMember) {\n\t\t\t\t\t\tAnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();\n\t\t\t\t\t\tAnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPool(), true);\n\t\t\t\t\t\tfg.addAnnotation(ag);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (weaver.getWorld().isInJava5Mode()) {\n\t\t\t\t\tString basicSignature = field.getSignature();\n\t\t\t\t\tString genericSignature = field.getReturnType().resolve(weaver.getWorld()).getSignatureForAttribute();\n\t\t\t\t\t// String genericSignature =\n\t\t\t\t\t// ((ResolvedMemberImpl)field).getSignatureForAttribute();\n\t\t\t\t\tif (!basicSignature.equals(genericSignature)) {\n\t\t\t\t\t\t// Add a signature attribute to it\n\t\t\t\t\t\tfg.addAttribute(createSignatureAttribute(gen.getConstantPool(), genericSignature));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgen.addField(fg, getSourceLocation());\n\t\t\t}\n\t\t\t// this uses a shadow munger to add init method to constructors\n\t\t\t// weaver.getShadowMungers().add(makeInitCallShadowMunger(initMethod)\n\t\t\t// );\n\n\t\t\tResolvedMember itdfieldGetter = AjcMemberMaker.interFieldInterfaceGetter(field, gen.getType()/* onType */, aspectType);\n\t\t\tLazyMethodGen mg = makeMethodGen(gen, itdfieldGetter);\n\t\t\tInstructionList il = new InstructionList();\n\t\t\tInstructionFactory fact = gen.getFactory();\n\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\til.append(fact.createFieldAccess(gen.getClassName(), fieldName, fieldType, Constants.GETSTATIC));\n\t\t\t} else {\n\t\t\t\til.append(InstructionConstants.ALOAD_0);\n\t\t\t\til.append(fact.createFieldAccess(gen.getClassName(), fieldName, fieldType, Constants.GETFIELD));\n\t\t\t}\n\t\t\til.append(InstructionFactory.createReturn(fieldType));\n\t\t\tmg.getBody().insert(il);\n\n\t\t\tgen.addMethodGen(mg);\n\n\t\t\t// Check if we need bridge methods for the field getter and setter\n\t\t\tif (munger.getDeclaredSignature() != null) { // is this munger a\n\t\t\t\t// parameterized\n\t\t\t\t// form of some\n\t\t\t\t// original munger?\n\t\t\t\tResolvedMember toBridgeTo = munger.getDeclaredSignature().parameterizedWith(null,\n\t\t\t\t\t\tmunger.getSignature().getDeclaringType().resolve(getWorld()), false, munger.getTypeVariableAliases());\n\t\t\t\tboolean needsbridging = false;\n\t\t\t\tif (!toBridgeTo.getReturnType().getErasureSignature()\n\t\t\t\t\t\t.equals(munger.getSignature().getReturnType().getErasureSignature())) {\n\t\t\t\t\tneedsbridging = true;\n\t\t\t\t}\n\t\t\t\tif (needsbridging) {\n\t\t\t\t\tResolvedMember bridgingGetter = AjcMemberMaker.interFieldInterfaceGetter(toBridgeTo, gen.getType(), aspectType);\n\t\t\t\t\tcreateBridgeMethodForITDF(weaver, gen, itdfieldGetter, bridgingGetter);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tResolvedMember itdfieldSetter = AjcMemberMaker.interFieldInterfaceSetter(field, gen.getType(), aspectType);\n\t\t\tLazyMethodGen mg1 = makeMethodGen(gen, itdfieldSetter);\n\t\t\tInstructionList il1 = new InstructionList();\n\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\til1.append(InstructionFactory.createLoad(fieldType, 0));\n\t\t\t\til1.append(fact.createFieldAccess(gen.getClassName(), fieldName, fieldType, Constants.PUTSTATIC));\n\t\t\t} else {\n\t\t\t\til1.append(InstructionConstants.ALOAD_0);\n\t\t\t\til1.append(InstructionFactory.createLoad(fieldType, 1));\n\t\t\t\til1.append(fact.createFieldAccess(gen.getClassName(), fieldName, fieldType, Constants.PUTFIELD));\n\t\t\t}\n\t\t\til1.append(InstructionFactory.createReturn(Type.VOID));\n\t\t\tmg1.getBody().insert(il1);\n\n\t\t\tgen.addMethodGen(mg1);\n\n\t\t\tif (munger.getDeclaredSignature() != null) {\n\t\t\t\tResolvedMember toBridgeTo = munger.getDeclaredSignature().parameterizedWith(null,\n\t\t\t\t\t\tmunger.getSignature().getDeclaringType().resolve(getWorld()), false, munger.getTypeVariableAliases());\n\t\t\t\tboolean needsbridging = false;\n\t\t\t\tif (!toBridgeTo.getReturnType().getErasureSignature()\n\t\t\t\t\t\t.equals(munger.getSignature().getReturnType().getErasureSignature())) {\n\t\t\t\t\tneedsbridging = true;\n\t\t\t\t}\n\t\t\t\tif (needsbridging) {\n\t\t\t\t\tResolvedMember bridgingSetter = AjcMemberMaker.interFieldInterfaceSetter(toBridgeTo, gen.getType(), aspectType);\n\t\t\t\t\tcreateBridgeMethodForITDF(weaver, gen, itdfieldSetter, bridgingSetter);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// FIXME asc combine with other createBridge.. method in this class, avoid\n\t// the duplication...\n\tprivate void createBridgeMethodForITDF(BcelClassWeaver weaver, LazyClassGen gen, ResolvedMember itdfieldSetter,\n\t\t\tResolvedMember bridgingSetter) {\n\t\tInstructionFactory fact;\n\t\tLazyMethodGen bridgeMethod = makeMethodGen(gen, bridgingSetter);\n\t\tbridgeMethod.setAccessFlags(bridgeMethod.getAccessFlags() | 0x00000040); // BRIDGE = 0x00000040\n\t\tType[] paramTypes = BcelWorld.makeBcelTypes(bridgingSetter.getParameterTypes());\n\t\tType[] bridgingToParms = BcelWorld.makeBcelTypes(itdfieldSetter.getParameterTypes());\n\t\tType returnType = BcelWorld.makeBcelType(bridgingSetter.getReturnType());\n\t\tInstructionList body = bridgeMethod.getBody();\n\t\tfact = gen.getFactory();\n\t\tint pos = 0;\n\n\t\tif (!Modifier.isStatic(bridgingSetter.getModifiers())) {\n\t\t\tbody.append(InstructionFactory.createThis());\n\t\t\tpos++;\n\t\t}\n\t\tfor (int i = 0, len = paramTypes.length; i < len; i++) {\n\t\t\tType paramType = paramTypes[i];\n\t\t\tbody.append(InstructionFactory.createLoad(paramType, pos));\n\t\t\tif (!bridgingSetter.getParameterTypes()[i].getErasureSignature().equals(\n\t\t\t\t\titdfieldSetter.getParameterTypes()[i].getErasureSignature())) {\n\t\t\t\tbody.append(fact.createCast(paramType, bridgingToParms[i]));\n\t\t\t}\n\t\t\tpos += paramType.getSize();\n\t\t}\n\n\t\tbody.append(Utility.createInvoke(fact, weaver.getWorld(), itdfieldSetter));\n\t\tbody.append(InstructionFactory.createReturn(returnType));\n\t\tgen.addMethodGen(bridgeMethod);\n\t}\n\n\t@Override\n\tpublic ConcreteTypeMunger parameterizedFor(ResolvedType target) {\n\t\treturn new BcelTypeMunger(munger.parameterizedFor(target), aspectType);\n\t}\n\n\t@Override\n\tpublic ConcreteTypeMunger parameterizeWith(Map<String, UnresolvedType> m, World w) {\n\t\treturn new BcelTypeMunger(munger.parameterizeWith(m, w), aspectType);\n\t}\n\n\t/**\n\t * Returns a list of type variable aliases used in this munger. For example, if the ITD is 'int I&lt;A,B&gt;.m(List&lt;A&gt; las,List&lt;B&gt;\n\t * lbs) {}' then this returns a list containing the strings \"A\" and \"B\".\n\t */\n\tpublic List<String> getTypeVariableAliases() {\n\t\treturn munger.getTypeVariableAliases();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\tif (!(other instanceof BcelTypeMunger)) {\n\t\t\treturn false;\n\t\t}\n\t\tBcelTypeMunger o = (BcelTypeMunger) other;\n\t\treturn ((o.getMunger() == null) ? (getMunger() == null) : o.getMunger().equals(getMunger()))\n\t\t\t\t&& ((o.getAspectType() == null) ? (getAspectType() == null) : o.getAspectType().equals(getAspectType()));\n\t\t// && (AsmManager.getDefault().getHandleProvider().dependsOnLocation() ? ((o.getSourceLocation() == null) ?\n\t\t// (getSourceLocation() == null)\n\t\t// : o.getSourceLocation().equals(getSourceLocation()))\n\t\t// : true); // pr134471 - remove when handles are improved\n\t\t// to be independent of location\n\n\t}\n\n\tprivate volatile int hashCode = 0;\n\n\t@Override\n\tpublic int hashCode() {\n\t\tif (hashCode == 0) {\n\t\t\tint result = 17;\n\t\t\tresult = 37 * result + ((getMunger() == null) ? 0 : getMunger().hashCode());\n\t\t\tresult = 37 * result + ((getAspectType() == null) ? 0 : getAspectType().hashCode());\n\t\t\thashCode = result;\n\t\t}\n\t\treturn hashCode;\n\t}\n}\n",
    "size": 92058
  },
  {
    "file_id": "F25",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelVar.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ast.Var;\n\npublic class BcelVar extends Var {\n\n\tprivate int positionInAroundState = -1;\n\n\tprivate int slot;\n\n\tpublic BcelVar(ResolvedType type, int slot) {\n\t\tsuper(type);\n\t\tthis.slot = slot;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"BcelVar(\" + getType() + \" \" + slot + ((positionInAroundState != -1) ? (\" \" + positionInAroundState) : \"\") +\n\n\t\t\")\";\n\t}\n\n\tpublic int getSlot() {\n\t\treturn slot;\n\t}\n\n\t// fact is used in the subtypes\n\tpublic Instruction createLoad(InstructionFactory fact) {\n\t\treturn InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), slot);\n\t}\n\n\tpublic Instruction createStore(InstructionFactory fact) {\n\t\treturn InstructionFactory.createStore(BcelWorld.makeBcelType(getType()), slot);\n\t}\n\n\tpublic void appendStore(InstructionList il, InstructionFactory fact) {\n\t\til.append(createStore(fact));\n\t}\n\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\n\t\til.append(createLoad(fact));\n\t}\n\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\n\t\til.append(createLoad(fact));\n\t\tUtility.appendConversion(il, fact, getType(), toType);\n\t}\n\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\n\t\til.insert(createLoad(fact));\n\t}\n\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\n\t\tInstructionList il = new InstructionList();\n\t\til.append(InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), oldSlot));\n\t\til.append(createStore(fact));\n\t\treturn il;\n\t}\n\n\t// this is an array var\n\tvoid appendConvertableArrayLoad(InstructionList il, InstructionFactory fact, int index, ResolvedType convertTo) {\n\t\tResolvedType convertFromType = getType().getResolvedComponentType();\n\t\tappendLoad(il, fact);\n\t\til.append(Utility.createConstant(fact, index));\n\t\til.append(InstructionFactory.createArrayLoad(BcelWorld.makeBcelType(convertFromType)));\n\t\tUtility.appendConversion(il, fact, convertFromType, convertTo);\n\t}\n\n\tvoid appendConvertableArrayStore(InstructionList il, InstructionFactory fact, int index, BcelVar storee) {\n\t\tResolvedType convertToType = getType().getResolvedComponentType();\n\t\tappendLoad(il, fact);\n\t\til.append(Utility.createConstant(fact, index));\n\t\tstoree.appendLoad(il, fact);\n\t\tUtility.appendConversion(il, fact, storee.getType(), convertToType);\n\t\til.append(InstructionFactory.createArrayStore(BcelWorld.makeBcelType(convertToType)));\n\t}\n\n\tInstructionList createConvertableArrayStore(InstructionFactory fact, int index, BcelVar storee) {\n\t\tInstructionList il = new InstructionList();\n\t\tappendConvertableArrayStore(il, fact, index, storee);\n\t\treturn il;\n\t}\n\n\tInstructionList createConvertableArrayLoad(InstructionFactory fact, int index, ResolvedType convertTo) {\n\t\tInstructionList il = new InstructionList();\n\t\tappendConvertableArrayLoad(il, fact, index, convertTo);\n\t\treturn il;\n\t}\n\n\tpublic int getPositionInAroundState() {\n\t\treturn positionInAroundState;\n\t}\n\n\tpublic void setPositionInAroundState(int positionInAroundState) {\n\t\tthis.positionInAroundState = positionInAroundState;\n\t}\n\n\t// random useful fields\n\n\tpublic static final BcelVar[] NONE = new BcelVar[] {};\n\n}\n",
    "size": 3919
  },
  {
    "file_id": "F26",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelWeakClassLoaderReference.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Andy Clement     initial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.util.ClassLoaderReference;\nimport org.aspectj.weaver.WeakClassLoaderReference;\n\n/**\n * Wraps a reference to a classloader inside a WeakReference. This should be used where we do not want the existence of a\n * classloader reference to prevent garbage collection of that classloader (and possibly an associated weaver instance in the case\n * of load time weaving).\n * <p>\n * In more detail:<br>\n * When load time weaving, the class Aj maintains a WeakHashMap from the classloader instance to a weaver instance. The aim is that\n * the weaver is around as long as the classloader is and should the classloader be dereferenced then the weaver can also be garbage\n * collected. The problem is that if there are many references to the classloader from within the weaver, these are considered hard\n * references and cause the classloader to be long lived - even if the user of the classloader has dereferenced it in their code.\n * The solution is that the weaver should use instances of WeakClassLoaderReference objects - so that when the users hard reference\n * to the classloader goes, nothing in the weaver will cause it to hang around. There is a big assertion here that the\n * WeakClassLoaderReference instances will not 'lose' their ClassLoader references until the top level ClassLoader reference is\n * null'd. This means there is no need to check for the null case on get() in this WeakReference logic below, because we shouldn't\n * be using this weaver if its associated ClassLoader has been collected. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=210470\n *\n *\n * @author Andy Clement\n */\npublic class BcelWeakClassLoaderReference extends WeakClassLoaderReference implements ClassLoaderReference {\n\n\tpublic BcelWeakClassLoaderReference(ClassLoader loader) {\n\t\tsuper(loader);\n\t}\n\n\tpublic boolean equals(Object obj) {\n\t\tif (!(obj instanceof BcelWeakClassLoaderReference))\n\t\t\treturn false;\n\t\tBcelWeakClassLoaderReference other = (BcelWeakClassLoaderReference) obj;\n\t\treturn (other.hashcode == hashcode);\n\t}\n\n}\n",
    "size": 2587
  },
  {
    "file_id": "F27",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelWeaver.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002-2010 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.jar.Attributes;\nimport java.util.jar.Attributes.Name;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.jar.Manifest;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\n\nimport org.aspectj.apache.bcel.classfile.ClassParser;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.asm.AsmManager;\nimport org.aspectj.asm.IProgramElement;\nimport org.aspectj.asm.internal.AspectJElementHierarchy;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.bridge.Message;\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.bridge.SourceLocation;\nimport org.aspectj.bridge.WeaveMessage;\nimport org.aspectj.bridge.context.CompilationAndWeavingContext;\nimport org.aspectj.bridge.context.ContextToken;\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.util.FuzzyBoolean;\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.AnnotationOnTypeMunger;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.CompressingDataOutputStream;\nimport org.aspectj.weaver.ConcreteTypeMunger;\nimport org.aspectj.weaver.CrosscuttingMembersSet;\nimport org.aspectj.weaver.CustomMungerFactory;\nimport org.aspectj.weaver.IClassFileProvider;\nimport org.aspectj.weaver.IUnwovenClassFile;\nimport org.aspectj.weaver.IWeaveRequestor;\nimport org.aspectj.weaver.NewParentTypeMunger;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ReferenceTypeDelegate;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ResolvedTypeMunger;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeaverMessages;\nimport org.aspectj.weaver.WeaverStateInfo;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.model.AsmRelationshipProvider;\nimport org.aspectj.weaver.patterns.AndPointcut;\nimport org.aspectj.weaver.patterns.BindingPattern;\nimport org.aspectj.weaver.patterns.BindingTypePattern;\nimport org.aspectj.weaver.patterns.ConcreteCflowPointcut;\nimport org.aspectj.weaver.patterns.DeclareAnnotation;\nimport org.aspectj.weaver.patterns.DeclareParents;\nimport org.aspectj.weaver.patterns.DeclareTypeErrorOrWarning;\nimport org.aspectj.weaver.patterns.FastMatchInfo;\nimport org.aspectj.weaver.patterns.IfPointcut;\nimport org.aspectj.weaver.patterns.KindedPointcut;\nimport org.aspectj.weaver.patterns.NameBindingPointcut;\nimport org.aspectj.weaver.patterns.NotPointcut;\nimport org.aspectj.weaver.patterns.OrPointcut;\nimport org.aspectj.weaver.patterns.Pointcut;\nimport org.aspectj.weaver.patterns.PointcutRewriter;\nimport org.aspectj.weaver.patterns.WithinPointcut;\nimport org.aspectj.weaver.tools.Trace;\nimport org.aspectj.weaver.tools.TraceFactory;\n\n/**\n *\n * @author PARC\n * @author Andy Clement\n * @author Alexandre Vasseur\n */\npublic class BcelWeaver {\n\n\tpublic static final String CLOSURE_CLASS_PREFIX = \"$Ajc\";\n\tpublic static final String SYNTHETIC_CLASS_POSTFIX = \"$ajc\";\n\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelWeaver.class);\n\n\tprivate transient final BcelWorld world;\n\tprivate final CrosscuttingMembersSet xcutSet;\n\n\tprivate boolean inReweavableMode = false;\n\n\tprivate transient List<UnwovenClassFile> addedClasses = new ArrayList<>();\n\tprivate transient List<String> deletedTypenames = new ArrayList<>();\n\n\t// These four are setup by prepareForWeave\n\tprivate transient List<ShadowMunger> shadowMungerList = null;\n\tprivate transient List<ConcreteTypeMunger> typeMungerList = null;\n\tprivate transient List<ConcreteTypeMunger> lateTypeMungerList = null;\n\tprivate transient List<DeclareParents> declareParentsList = null;\n\n\tprivate Manifest manifest = null;\n\tprivate boolean needToReweaveWorld = false;\n\n\tprivate boolean isBatchWeave = true;\n\n\tprivate ZipOutputStream zipOutputStream;\n\tprivate CustomMungerFactory customMungerFactory;\n\n\tpublic BcelWeaver(BcelWorld world) {\n\t\tsuper();\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.enter(\"<init>\", this, world);\n\t\t}\n\t\tthis.world = world;\n\t\tthis.xcutSet = world.getCrosscuttingMembersSet();\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.exit(\"<init>\");\n\t\t}\n\t}\n\n\t/**\n\t * Add the given aspect to the weaver. The type is resolved to support DOT for static inner classes as well as DOLLAR\n\t *\n\t * @param aspectName\n\t * @return aspect\n\t */\n\tpublic ResolvedType addLibraryAspect(String aspectName) {\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.enter(\"addLibraryAspect\", this, aspectName);\n\t\t}\n\n\t\t// 1 - resolve as is\n\t\tUnresolvedType unresolvedT = UnresolvedType.forName(aspectName);\n\t\tunresolvedT.setNeedsModifiableDelegate(true);\n\t\tResolvedType type = world.resolve(unresolvedT, true);\n\t\tif (type.isMissing()) {\n\t\t\t// fallback on inner class lookup mechanism\n\t\t\tString fixedName = aspectName;\n\t\t\tint hasDot = fixedName.lastIndexOf('.');\n\t\t\twhile (hasDot > 0) {\n\t\t\t\t// System.out.println(\"BcelWeaver.addLibraryAspect \" + fixedName);\n\t\t\t\tchar[] fixedNameChars = fixedName.toCharArray();\n\t\t\t\tfixedNameChars[hasDot] = '$';\n\t\t\t\tfixedName = new String(fixedNameChars);\n\t\t\t\thasDot = fixedName.lastIndexOf('.');\n\t\t\t\tUnresolvedType ut = UnresolvedType.forName(fixedName);\n\t\t\t\tut.setNeedsModifiableDelegate(true);\n\t\t\t\ttype = world.resolve(ut, true);\n\t\t\t\tif (!type.isMissing()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// System.out.println(\"type: \" + type + \" for \" + aspectName);\n\t\tif (type.isAspect()) {\n\t\t\t// Bug 119657 ensure we use the unwoven aspect\n\t\t\tWeaverStateInfo wsi = type.getWeaverState();\n\t\t\tif (wsi != null && wsi.isReweavable()) {\n\t\t\t\tBcelObjectType classType = getClassType(type.getName());\n\t\t\t\tJavaClass wovenJavaClass = classType.getJavaClass();\n\t\t\t\tbyte[] bytes = wsi.getUnwovenClassFileData(wovenJavaClass.getBytes());\n\t\t\t\tJavaClass unwovenJavaClass = Utility.makeJavaClass(wovenJavaClass.getFileName(), bytes);\n\t\t\t\tworld.storeClass(unwovenJavaClass);\n\t\t\t\tclassType.setJavaClass(unwovenJavaClass, true);\n\t\t\t\t// classType.setJavaClass(Utility.makeJavaClass(classType.\n\t\t\t\t// getJavaClass().getFileName(),\n\t\t\t\t// wsi.getUnwovenClassFileData(classType.getJavaClass().getBytes(\n\t\t\t\t// ))));\n\t\t\t}\n\n\t\t\t// TODO AV - happens to reach that a lot of time: for each type\n\t\t\t// flagged reweavable X for each aspect in the weaverstate\n\t\t\t// => mainly for nothing for LTW - pbly for something in incremental\n\t\t\t// build...\n\t\t\txcutSet.addOrReplaceAspect(type);\n\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\ttrace.exit(\"addLibraryAspect\", type);\n\t\t\t}\n\t\t\tif (type.getSuperclass().isAspect()) {\n\t\t\t\t// If the supertype includes ITDs and the user has not included\n\t\t\t\t// that aspect in the aop.xml, they will\n\t\t\t\t// not get picked up, which can give unusual behaviour! See bug\n\t\t\t\t// 223094\n\t\t\t\t// This change causes us to pick up the super aspect regardless\n\t\t\t\t// of what was said in the aop.xml - giving\n\t\t\t\t// predictable behaviour. If the user also supplied it, there\n\t\t\t\t// will be no problem other than the second\n\t\t\t\t// addition overriding the first\n\t\t\t\taddLibraryAspect(type.getSuperclass().getName());\n\t\t\t}\n\t\t\treturn type;\n\t\t} else {\n\t\t\tif (type.isMissing()) {\n\t\t\t\t// May not be found if not visible to the classloader that can see the aop.xml during LTW\n\t\t\t\tIMessage message = new Message(\"The specified aspect '\"+aspectName+\"' cannot be found\", null, true);\n\t\t\t\tworld.getMessageHandler().handleMessage(message);\n\t\t\t} else {\n\t\t\t\tIMessage message = new Message(\"Cannot register '\"+aspectName+\"' because the type found with that name is not an aspect\", null, true);\n\t\t\t\tworld.getMessageHandler().handleMessage(message);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param inFile directory containing classes or zip/jar class archive\n\t */\n\tpublic void addLibraryJarFile(File inFile) throws IOException {\n\t\tList<ResolvedType> addedAspects = null;\n\t\tif (inFile.isDirectory()) {\n\t\t\taddedAspects = addAspectsFromDirectory(inFile);\n\t\t} else {\n\t\t\taddedAspects = addAspectsFromJarFile(inFile);\n\t\t}\n\t\tfor (ResolvedType addedAspect : addedAspects) {\n\t\t\txcutSet.addOrReplaceAspect(addedAspect);\n\t\t}\n\t}\n\n\tprivate List<ResolvedType> addAspectsFromJarFile(File inFile) throws FileNotFoundException, IOException {\n\t\tZipInputStream inStream = new ZipInputStream(new FileInputStream(inFile)); // ??? buffered\n\t\tList<ResolvedType> addedAspects = new ArrayList<>();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tZipEntry entry = inStream.getNextEntry();\n\t\t\t\tif (entry == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (entry.isDirectory() || !entry.getName().endsWith(\".class\")) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// FIXME ASC performance? of this alternative soln.\n\t\t\t\tint size = (int) entry.getSize();\n\t\t\t\tClassParser parser = new ClassParser(new ByteArrayInputStream(FileUtil.readAsByteArray(inStream)), entry.getName());\n\t\t\t\tJavaClass jc = parser.parse();\n\t\t\t\tinStream.closeEntry();\n\n\t\t\t\tResolvedType type = world.addSourceObjectType(jc, false).getResolvedTypeX();\n\t\t\t\ttype.setBinaryPath(inFile.getAbsolutePath());\n\t\t\t\tif (type.isAspect()) {\n\t\t\t\t\taddedAspects.add(type);\n\t\t\t\t} else {\n\t\t\t\t\tworld.demote(type);\n\t\t\t\t}\n\n\t\t\t}\n\t\t} finally {\n\t\t\tinStream.close();\n\t\t}\n\t\treturn addedAspects;\n\t}\n\n\t/**\n\t * Look for .class files that represent aspects in the supplied directory - return the list of accumulated aspects.\n\t *\n\t * @param directory the directory in which to look for Aspect .class files\n\t * @return the list of discovered aspects\n\t * @throws FileNotFoundException\n\t * @throws IOException\n\t */\n\tprivate List<ResolvedType> addAspectsFromDirectory(File directory) throws FileNotFoundException, IOException {\n\t\tList<ResolvedType> addedAspects = new ArrayList<>();\n\t\tFile[] classFiles = FileUtil.listFiles(directory, new FileFilter() {\n\t\t\tpublic boolean accept(File pathname) {\n\t\t\t\treturn pathname.getName().endsWith(\".class\");\n\t\t\t}\n\t\t});\n\t\tfor (File classFile : classFiles) {\n\t\t\tFileInputStream fis = new FileInputStream(classFile);\n\t\t\tbyte[] classBytes = FileUtil.readAsByteArray(fis);\n\t\t\tResolvedType aspectType = isAspect(classBytes, classFile.getAbsolutePath(), directory);\n\t\t\tif (aspectType != null) {\n\t\t\t\taddedAspects.add(aspectType);\n\t\t\t}\n\t\t\tfis.close();\n\t\t}\n\t\treturn addedAspects;\n\t}\n\n\t/**\n\t * Determine if the supplied bytes represent an aspect, if they do then create a ResolvedType instance for the aspect and return\n\t * it, otherwise return null\n\t *\n\t * @param classbytes the classbytes that might represent an aspect\n\t * @param name the name of the class\n\t * @param directory directory which contained the class file\n\t * @return a ResolvedType if the classbytes represent an aspect, otherwise null\n\t */\n\tprivate ResolvedType isAspect(byte[] classbytes, String name, File dir) throws IOException {\n\t\tClassParser parser = new ClassParser(new ByteArrayInputStream(classbytes), name);\n\t\tJavaClass jc = parser.parse();\n\t\tResolvedType type = world.addSourceObjectType(jc, false).getResolvedTypeX();\n\t\tString typeName = type.getName().replace('.', File.separatorChar);\n\t\tint end = name.lastIndexOf(typeName + \".class\");\n\t\tString binaryPath = null;\n\t\t// if end is -1 then something weird happened, the class file is not in\n\t\t// the correct place, something like\n\t\t// bin/A.class when the declaration for A specifies it is in a package.\n\t\tif (end == -1) {\n\t\t\tbinaryPath = dir.getAbsolutePath();\n\t\t} else {\n\t\t\tbinaryPath = name.substring(0, end - 1);\n\t\t}\n\t\ttype.setBinaryPath(binaryPath);\n\t\tif (type.isAspect()) {\n\t\t\treturn type;\n\t\t} else {\n\t\t\t// immediately demote the type we just added since it will have\n\t\t\t// have been stuffed into the permanent map (assumed to be\n\t\t\t// an aspect)\n\t\t\tworld.demote(type);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// // The ANT copy task should be used to copy resources across.\n\t// private final static boolean\n\t// CopyResourcesFromInpathDirectoriesToOutput=false;\n\n\t/**\n\t * Add any .class files in the directory to the outdir. Anything other than .class files in the directory (or its\n\t * subdirectories) are considered resources and are also copied.\n\t *\n\t */\n\tpublic List<UnwovenClassFile> addDirectoryContents(File inFile, File outDir) throws IOException {\n\t\tList<UnwovenClassFile> addedClassFiles = new ArrayList<>();\n\n\t\t// Get a list of all files (i.e. everything that isnt a directory)\n\t\tFile[] files = FileUtil.listFiles(inFile, new FileFilter() {\n\t\t\tpublic boolean accept(File f) {\n\t\t\t\tboolean accept = !f.isDirectory();\n\t\t\t\treturn accept;\n\t\t\t}\n\t\t});\n\n\t\t// For each file, add it either as a real .class file or as a resource\n\t\tfor (File file : files) {\n\t\t\taddedClassFiles.add(addClassFile(file, inFile, outDir));\n\t\t}\n\n\t\treturn addedClassFiles;\n\t}\n\n\t/**\n\t * Adds all class files in the jar\n\t */\n\tpublic List<UnwovenClassFile> addJarFile(File inFile, File outDir, boolean canBeDirectory) {\n\t\t// System.err.println(\"? addJarFile(\" + inFile + \", \" + outDir + \")\");\n\t\tList<UnwovenClassFile> addedClassFiles = new ArrayList<>();\n\t\tneedToReweaveWorld = true;\n\t\tJarFile inJar = null;\n\n\t\ttry {\n\t\t\t// Is this a directory we are looking at?\n\t\t\tif (inFile.isDirectory() && canBeDirectory) {\n\t\t\t\taddedClassFiles.addAll(addDirectoryContents(inFile, outDir));\n\t\t\t} else {\n\n\t\t\t\tinJar = new JarFile(inFile);\n\t\t\t\ttry {\n\t\t\t\t\taddManifest(inJar.getManifest());\n\t\t\t\t\tEnumeration<JarEntry> entries = inJar.entries();\n\n\t\t\t\t\twhile (entries.hasMoreElements()) {\n\t\t\t\t\t\tJarEntry entry = entries.nextElement();\n\t\t\t\t\t\tInputStream inStream = inJar.getInputStream(entry);\n\n\t\t\t\t\t\tbyte[] bytes = FileUtil.readAsByteArray(inStream);\n\t\t\t\t\t\tString filename = entry.getName();\n\t\t\t\t\t\t// System.out.println(\"? addJarFile() filename='\" + filename\n\t\t\t\t\t\t// + \"'\");\n\t\t\t\t\t\tUnwovenClassFile classFile = new UnwovenClassFile(new File(outDir, filename).getAbsolutePath(), bytes);\n\n\t\t\t\t\t\tif (filename.endsWith(\".class\")) {\n\t\t\t\t\t\t\tReferenceType type = this.addClassFile(classFile, false);\n\t\t\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\t\t\tsb.append(inFile.getAbsolutePath());\n\t\t\t\t\t\t\tsb.append(\"!\");\n\t\t\t\t\t\t\tsb.append(entry.getName());\n\t\t\t\t\t\t\ttype.setBinaryPath(sb.toString());\n\t\t\t\t\t\t\taddedClassFiles.add(classFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// else if (!entry.isDirectory()) {\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// /* bug-44190 Copy meta-data */\n\t\t\t\t\t\t// addResource(filename,classFile);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tinStream.close();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tinJar.close();\n\t\t\t\t}\n\t\t\t\tinJar.close();\n\t\t\t}\n\t\t} catch (FileNotFoundException ex) {\n\t\t\tIMessage message = new Message(\"Could not find input jar file \" + inFile.getPath() + \", ignoring\", new SourceLocation(\n\t\t\t\t\tinFile, 0), false);\n\t\t\tworld.getMessageHandler().handleMessage(message);\n\t\t} catch (IOException ex) {\n\t\t\tIMessage message = new Message(\"Could not read input jar file \" + inFile.getPath() + \"(\" + ex.getMessage() + \")\",\n\t\t\t\t\tnew SourceLocation(inFile, 0), true);\n\t\t\tworld.getMessageHandler().handleMessage(message);\n\t\t} finally {\n\t\t\tif (inJar != null) {\n\t\t\t\ttry {\n\t\t\t\t\tinJar.close();\n\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\tIMessage message = new Message(\"Could not close input jar file \" + inFile.getPath() + \"(\" + ex.getMessage()\n\t\t\t\t\t\t\t+ \")\", new SourceLocation(inFile, 0), true);\n\t\t\t\t\tworld.getMessageHandler().handleMessage(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn addedClassFiles;\n\t}\n\n\tpublic boolean needToReweaveWorld() {\n\t\treturn needToReweaveWorld;\n\t}\n\n\t/**\n\t * Should be addOrReplace\n\t */\n\tpublic ReferenceType addClassFile(UnwovenClassFile classFile, boolean fromInpath) {\n\t\taddedClasses.add(classFile);\n\t\tReferenceType type = world.addSourceObjectType(classFile.getJavaClass(), false).getResolvedTypeX();\n\t\tif (fromInpath) {\n\t\t\ttype.setBinaryPath(classFile.getFilename());\n\t\t}\n\t\treturn type;\n\t}\n\n\tpublic UnwovenClassFile addClassFile(File classFile, File inPathDir, File outDir) throws IOException {\n\t\tFileInputStream fis = new FileInputStream(classFile);\n\t\tbyte[] bytes = FileUtil.readAsByteArray(fis);\n\t\t// String relativePath = files[i].getPath();\n\n\t\t// ASSERT:\n\t\t// files[i].getAbsolutePath().startsWith(inFile.getAbsolutePath()\n\t\t// or we are in trouble...\n\t\tString filename = classFile.getAbsolutePath().substring(inPathDir.getAbsolutePath().length() + 1);\n\t\tUnwovenClassFile ucf = new UnwovenClassFile(new File(outDir, filename).getAbsolutePath(), bytes);\n\t\tif (filename.endsWith(\".class\")) {\n\t\t\t// System.err.println(\n\t\t\t// \"BCELWeaver: processing class from input directory \"+classFile);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(inPathDir.getAbsolutePath());\n\t\t\tsb.append(\"!\");\n\t\t\tsb.append(filename);\n\t\t\tReferenceType type = this.addClassFile(ucf, false);\n\t\t\ttype.setBinaryPath(sb.toString());\n\t\t}\n\t\tfis.close();\n\t\treturn ucf;\n\t}\n\n\tpublic void deleteClassFile(String typename) {\n\t\tdeletedTypenames.add(typename);\n\t\tworld.deleteSourceObjectType(UnresolvedType.forName(typename));\n\t}\n\n\t// ---- weave preparation\n\n\tpublic void setIsBatchWeave(boolean b) {\n\t\tisBatchWeave = b;\n\t}\n\n\tpublic void prepareForWeave() {\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.enter(\"prepareForWeave\", this);\n\t\t}\n\t\tneedToReweaveWorld = xcutSet.hasChangedSinceLastReset();\n\n\t\t// update mungers\n\t\tfor (UnwovenClassFile jc : addedClasses) {\n\t\t\tString name = jc.getClassName();\n\t\t\tResolvedType type = world.resolve(name);\n\t\t\t// No overweaving guard. If you have one then when overweaving is on the\n\t\t\t// addOrReplaceAspect will not be called when the aspect delegate changes from\n\t\t\t// EclipseSourceType to BcelObjectType. This will mean the mungers\n\t\t\t// are not picked up.\n\t\t\tif (type.isAspect()) {\n\t\t\t\tneedToReweaveWorld |= xcutSet.addOrReplaceAspect(type);\n\t\t\t}\n\t\t}\n\n\t\tfor (String name : deletedTypenames) {\n\t\t\tif (xcutSet.deleteAspect(UnresolvedType.forName(name))) {\n\t\t\t\tneedToReweaveWorld = true;\n\t\t\t}\n\t\t}\n\n\t\tshadowMungerList = xcutSet.getShadowMungers();\n\t\t// world.debug(\"shadow mungers=\" + shadowMungerList);\n\t\trewritePointcuts(shadowMungerList);\n\t\t// Sometimes an error occurs during rewriting pointcuts (for example, if\n\t\t// ambiguous bindings\n\t\t// are detected) - we ought to fail the prepare when this happens\n\t\t// because continuing with\n\t\t// inconsistent pointcuts could lead to problems\n\t\ttypeMungerList = xcutSet.getTypeMungers();\n\t\tlateTypeMungerList = xcutSet.getLateTypeMungers();\n\t\tdeclareParentsList = xcutSet.getDeclareParents();\n\n\t\taddCustomMungers();\n\n\t\t// The ordering here used to be based on a string compare on toString()\n\t\t// for the two mungers -\n\t\t// that breaks for the @AJ style where advice names aren't\n\t\t// programmatically generated. So we\n\t\t// have changed the sorting to be based on source location in the file -\n\t\t// this is reliable, in\n\t\t// the case of source locations missing, we assume they are 'sorted' -\n\t\t// i.e. the order in\n\t\t// which they were added to the collection is correct, this enables the\n\t\t// @AJ stuff to work properly.\n\n\t\t// When @AJ processing starts filling in source locations for mungers,\n\t\t// this code may need\n\t\t// a bit of alteration...\n\n\t\tshadowMungerList.sort(new Comparator<ShadowMunger>() {\n\t\t\tpublic int compare(ShadowMunger sm1, ShadowMunger sm2) {\n\t\t\t\tif (sm1.getSourceLocation() == null) {\n\t\t\t\t\treturn (sm2.getSourceLocation() == null ? 0 : 1);\n\t\t\t\t}\n\t\t\t\tif (sm2.getSourceLocation() == null) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\treturn (sm2.getSourceLocation().getOffset() - sm1.getSourceLocation().getOffset());\n\t\t\t}\n\t\t});\n\n\t\tif (inReweavableMode) {\n\t\t\tworld.showMessage(IMessage.INFO, WeaverMessages.format(WeaverMessages.REWEAVABLE_MODE), null, null);\n\t\t}\n\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.exit(\"prepareForWeave\");\n\t\t}\n\t}\n\n\tprivate void addCustomMungers() {\n\t\tif (customMungerFactory != null) {\n\t\t\tfor (UnwovenClassFile jc : addedClasses) {\n\t\t\t\tString name = jc.getClassName();\n\t\t\t\tResolvedType type = world.resolve(name);\n\t\t\t\tif (type.isAspect()) {\n\t\t\t\t\tCollection<ShadowMunger> shadowMungers = customMungerFactory.createCustomShadowMungers(type);\n\t\t\t\t\tif (shadowMungers != null) {\n\t\t\t\t\t\tshadowMungerList.addAll(shadowMungers);\n\t\t\t\t\t}\n\t\t\t\t\tCollection<ConcreteTypeMunger> typeMungers = customMungerFactory.createCustomTypeMungers(type);\n\t\t\t\t\tif (typeMungers != null) {\n\t\t\t\t\t\ttypeMungerList.addAll(typeMungers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setCustomMungerFactory(CustomMungerFactory factory) {\n\t\tcustomMungerFactory = factory;\n\t}\n\n\t/*\n\t * Rewrite all of the pointcuts in the world into their most efficient form for subsequent matching. Also ensure that if\n\t * pc1.equals(pc2) then pc1 == pc2 (for non-binding pcds) by making references all point to the same instance. Since pointcuts\n\t * remember their match decision on the last shadow, this makes matching faster when many pointcuts share common elements, or\n\t * even when one single pointcut has one common element (which can be a side-effect of DNF rewriting).\n\t */\n\tprivate void rewritePointcuts(List<ShadowMunger> shadowMungers) {\n\t\tPointcutRewriter rewriter = new PointcutRewriter();\n\t\tfor (ShadowMunger munger : shadowMungers) {\n\t\t\tPointcut p = munger.getPointcut();\n\t\t\tPointcut newP = rewriter.rewrite(p);\n\t\t\t// validateBindings now whilst we still have around the pointcut\n\t\t\t// that resembles what the user actually wrote in their program\n\t\t\t// text.\n\t\t\tif (munger instanceof Advice) {\n\t\t\t\tAdvice advice = (Advice) munger;\n\t\t\t\tif (advice.getSignature() != null) {\n\t\t\t\t\tfinal int numFormals;\n\t\t\t\t\tfinal String names[];\n\t\t\t\t\t// If the advice is being concretized in a @AJ aspect *and*\n\t\t\t\t\t// the advice was declared in\n\t\t\t\t\t// an @AJ aspect (it could have been inherited from a code\n\t\t\t\t\t// style aspect) then\n\t\t\t\t\t// evaluate the alternative set of formals. pr125699\n\t\t\t\t\tif ((advice.getConcreteAspect().isAnnotationStyleAspect() && advice.getDeclaringAspect() != null && advice\n\t\t\t\t\t\t\t.getDeclaringAspect().resolve(world).isAnnotationStyleAspect())\n\t\t\t\t\t\t\t|| advice.isAnnotationStyle()) {\n\t\t\t\t\t\tnumFormals = advice.getBaseParameterCount();\n\t\t\t\t\t\tint numArgs = advice.getSignature().getParameterTypes().length;\n\t\t\t\t\t\tif (numFormals > 0) {\n\t\t\t\t\t\t\tnames = advice.getSignature().getParameterNames(world);\n\t\t\t\t\t\t\tvalidateBindings(newP, p, numArgs, names);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnumFormals = advice.getBaseParameterCount();\n\t\t\t\t\t\tif (numFormals > 0) {\n\t\t\t\t\t\t\tnames = advice.getBaseParameterNames(world);\n\t\t\t\t\t\t\tvalidateBindings(newP, p, numFormals, names);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewP.m_ignoreUnboundBindingForNames = p.m_ignoreUnboundBindingForNames;\n\t\t\tmunger.setPointcut(newP);\n\t\t}\n\t\t// now that we have optimized individual pointcuts, optimize\n\t\t// across the set of pointcuts....\n\t\t// Use a map from key based on pc equality, to value based on\n\t\t// pc identity.\n\t\tMap<Pointcut, Pointcut> pcMap = new HashMap<>();\n\t\tfor (ShadowMunger munger: shadowMungers) {\n\t\t\tPointcut p = munger.getPointcut();\n\t\t\tPointcut newP = shareEntriesFromMap(p, pcMap);\n\t\t\tnewP.m_ignoreUnboundBindingForNames = p.m_ignoreUnboundBindingForNames;\n\t\t\tmunger.setPointcut(newP);\n\t\t}\n\t}\n\n\tprivate Pointcut shareEntriesFromMap(Pointcut p, Map<Pointcut, Pointcut> pcMap) {\n\t\t// some things cant be shared...\n\t\tif (p instanceof NameBindingPointcut) {\n\t\t\treturn p;\n\t\t}\n\t\tif (p instanceof IfPointcut) {\n\t\t\treturn p;\n\t\t}\n\t\tif (p instanceof ConcreteCflowPointcut) {\n\t\t\treturn p;\n\t\t}\n\t\tif (p instanceof AndPointcut) {\n\t\t\tAndPointcut apc = (AndPointcut) p;\n\t\t\tPointcut left = shareEntriesFromMap(apc.getLeft(), pcMap);\n\t\t\tPointcut right = shareEntriesFromMap(apc.getRight(), pcMap);\n\t\t\treturn new AndPointcut(left, right);\n\t\t} else if (p instanceof OrPointcut) {\n\t\t\tOrPointcut opc = (OrPointcut) p;\n\t\t\tPointcut left = shareEntriesFromMap(opc.getLeft(), pcMap);\n\t\t\tPointcut right = shareEntriesFromMap(opc.getRight(), pcMap);\n\t\t\treturn new OrPointcut(left, right);\n\t\t} else if (p instanceof NotPointcut) {\n\t\t\tNotPointcut npc = (NotPointcut) p;\n\t\t\tPointcut not = shareEntriesFromMap(npc.getNegatedPointcut(), pcMap);\n\t\t\treturn new NotPointcut(not);\n\t\t} else {\n\t\t\t// primitive pcd\n\t\t\tif (pcMap.containsKey(p)) { // based on equality\n\t\t\t\treturn pcMap.get(p); // same instance (identity)\n\t\t\t} else {\n\t\t\t\tpcMap.put(p, p);\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t}\n\n\t// userPointcut is the pointcut that the user wrote in the program text.\n\t// dnfPointcut is the same pointcut rewritten in DNF\n\t// numFormals is the number of formal parameters in the pointcut\n\t// if numFormals > 0 then every branch of a disjunction must bind each\n\t// formal once and only once.\n\t// in addition, the left and right branches of a disjunction must hold on\n\t// join point kinds in common.\n\tprivate void validateBindings(Pointcut dnfPointcut, Pointcut userPointcut, int numFormals, String[] names) {\n\t\tif (numFormals == 0) {\n\t\t\treturn; // nothing to check\n\t\t}\n\t\tif (dnfPointcut.couldMatchKinds() == Shadow.NO_SHADOW_KINDS_BITS) {\n\t\t\treturn; // cant have problems if you dont match!\n\t\t}\n\t\tif (dnfPointcut instanceof OrPointcut) {\n\t\t\tOrPointcut orBasedDNFPointcut = (OrPointcut) dnfPointcut;\n\t\t\tPointcut[] leftBindings = new Pointcut[numFormals];\n\t\t\tPointcut[] rightBindings = new Pointcut[numFormals];\n\t\t\tvalidateOrBranch(orBasedDNFPointcut, userPointcut, numFormals, names, leftBindings, rightBindings);\n\t\t} else {\n\t\t\tPointcut[] bindings = new Pointcut[numFormals];\n\t\t\tvalidateSingleBranch(dnfPointcut, userPointcut, numFormals, names, bindings);\n\t\t}\n\t}\n\n\tprivate void validateOrBranch(OrPointcut pc, Pointcut userPointcut, int numFormals, String[] names, Pointcut[] leftBindings,\n\t\t\tPointcut[] rightBindings) {\n\t\tPointcut left = pc.getLeft();\n\t\tPointcut right = pc.getRight();\n\t\tif (left instanceof OrPointcut) {\n\t\t\tPointcut[] newRightBindings = new Pointcut[numFormals];\n\t\t\tvalidateOrBranch((OrPointcut) left, userPointcut, numFormals, names, leftBindings, newRightBindings);\n\t\t} else {\n\t\t\tif (left.couldMatchKinds() != Shadow.NO_SHADOW_KINDS_BITS) {\n\t\t\t\tvalidateSingleBranch(left, userPointcut, numFormals, names, leftBindings);\n\t\t\t}\n\t\t}\n\t\tif (right instanceof OrPointcut) {\n\t\t\tPointcut[] newLeftBindings = new Pointcut[numFormals];\n\t\t\tvalidateOrBranch((OrPointcut) right, userPointcut, numFormals, names, newLeftBindings, rightBindings);\n\t\t} else {\n\t\t\tif (right.couldMatchKinds() != Shadow.NO_SHADOW_KINDS_BITS) {\n\t\t\t\tvalidateSingleBranch(right, userPointcut, numFormals, names, rightBindings);\n\t\t\t}\n\t\t}\n\t\tint kindsInCommon = left.couldMatchKinds() & right.couldMatchKinds();\n\t\tif (kindsInCommon != Shadow.NO_SHADOW_KINDS_BITS && couldEverMatchSameJoinPoints(left, right)) {\n\t\t\t// we know that every branch binds every formal, so there is no\n\t\t\t// ambiguity if each branch binds it in exactly the same way...\n\t\t\tList<String> ambiguousNames = new ArrayList<>();\n\t\t\tfor (int i = 0; i < numFormals; i++) {\n\t\t\t\tif (leftBindings[i] == null) {\n\t\t\t\t\tif (rightBindings[i] != null) {\n\t\t\t\t\t\tambiguousNames.add(names[i]);\n\t\t\t\t\t}\n\t\t\t\t} else if (!leftBindings[i].equals(rightBindings[i])) {\n\t\t\t\t\tambiguousNames.add(names[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ambiguousNames.isEmpty()) {\n\t\t\t\traiseAmbiguityInDisjunctionError(userPointcut, ambiguousNames);\n\t\t\t}\n\t\t}\n\t}\n\n\t// pc is a pointcut that does not contain any disjunctions\n\t// check that every formal is bound (negation doesn't count).\n\t// we know that numFormals > 0 or else we would not be called\n\tprivate void validateSingleBranch(Pointcut pc, Pointcut userPointcut, int numFormals, String[] names, Pointcut[] bindings) {\n\t\tboolean[] foundFormals = new boolean[numFormals];\n\t\tfor (int i = 0; i < foundFormals.length; i++) {\n\t\t\tfoundFormals[i] = false;\n\t\t}\n\t\tvalidateSingleBranchRecursion(pc, userPointcut, foundFormals, names, bindings);\n\t\tfor (int i = 0; i < foundFormals.length; i++) {\n\t\t\tif (!foundFormals[i]) {\n\t\t\t\tboolean ignore = false;\n\t\t\t\t// ATAJ soften the unbound error for implicit bindings like\n\t\t\t\t// JoinPoint in @AJ style\n\t\t\t\tfor (int j = 0; j < userPointcut.m_ignoreUnboundBindingForNames.length; j++) {\n\t\t\t\t\tif (names[i] != null && names[i].equals(userPointcut.m_ignoreUnboundBindingForNames[j])) {\n\t\t\t\t\t\tignore = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!ignore) {\n\t\t\t\t\traiseUnboundFormalError(names[i], userPointcut);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// each formal must appear exactly once\n\tprivate void validateSingleBranchRecursion(Pointcut pc, Pointcut userPointcut, boolean[] foundFormals, String[] names,\n\t\t\tPointcut[] bindings) {\n\t\tif (pc instanceof NotPointcut) {\n\t\t\t// nots can only appear at leaves in DNF\n\t\t\tNotPointcut not = (NotPointcut) pc;\n\t\t\tif (not.getNegatedPointcut() instanceof NameBindingPointcut) {\n\t\t\t\tNameBindingPointcut nnbp = (NameBindingPointcut) not.getNegatedPointcut();\n\t\t\t\tif (!nnbp.getBindingAnnotationTypePatterns().isEmpty() && !nnbp.getBindingTypePatterns().isEmpty()) {\n\t\t\t\t\traiseNegationBindingError(userPointcut);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pc instanceof AndPointcut) {\n\t\t\tAndPointcut and = (AndPointcut) pc;\n\t\t\tvalidateSingleBranchRecursion(and.getLeft(), userPointcut, foundFormals, names, bindings);\n\t\t\tvalidateSingleBranchRecursion(and.getRight(), userPointcut, foundFormals, names, bindings);\n\t\t} else if (pc instanceof NameBindingPointcut) {\n\t\t\tList<BindingTypePattern> bindingTypePatterns = ((NameBindingPointcut) pc).getBindingTypePatterns();\n\t\t\tfor (BindingTypePattern bindingTypePattern: bindingTypePatterns) {\n\t\t\t\tint index = bindingTypePattern.getFormalIndex();\n\t\t\t\tbindings[index] = pc;\n\t\t\t\tif (foundFormals[index]) {\n\t\t\t\t\traiseAmbiguousBindingError(names[index], userPointcut);\n\t\t\t\t} else {\n\t\t\t\t\tfoundFormals[index] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tList<BindingPattern> bindingAnnotationTypePatterns = ((NameBindingPointcut) pc).getBindingAnnotationTypePatterns();\n\t\t\tfor (BindingPattern bindingAnnotationTypePattern: bindingAnnotationTypePatterns) {\n\t\t\t\tint index = bindingAnnotationTypePattern.getFormalIndex();\n\t\t\t\tbindings[index] = pc;\n\t\t\t\tif (foundFormals[index]) {\n\t\t\t\t\traiseAmbiguousBindingError(names[index], userPointcut);\n\t\t\t\t} else {\n\t\t\t\t\tfoundFormals[index] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (pc instanceof ConcreteCflowPointcut) {\n\t\t\tConcreteCflowPointcut cfp = (ConcreteCflowPointcut) pc;\n\t\t\tint[] slots = cfp.getUsedFormalSlots();\n\t\t\tfor (int slot : slots) {\n\t\t\t\tbindings[slot] = cfp;\n\t\t\t\tif (foundFormals[slot]) {\n\t\t\t\t\traiseAmbiguousBindingError(names[slot], userPointcut);\n\t\t\t\t} else {\n\t\t\t\t\tfoundFormals[slot] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// By returning false from this method, we are allowing binding of the same\n\t// variable on either side of an or.\n\t// Be conservative :- have to consider overriding, varargs, autoboxing,\n\t// the effects of itds (on within for example), interfaces, the fact that\n\t// join points can have multiple signatures and so on.\n\tprivate boolean couldEverMatchSameJoinPoints(Pointcut left, Pointcut right) {\n\n\t\tif (left instanceof OrPointcut) {\n\t\t\tOrPointcut leftOrPointcut = (OrPointcut) left;\n\t\t\tif (couldEverMatchSameJoinPoints(leftOrPointcut.getLeft(), right)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (couldEverMatchSameJoinPoints(leftOrPointcut.getRight(), right)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (right instanceof OrPointcut) {\n\t\t\tOrPointcut rightOrPointcut = (OrPointcut) right;\n\t\t\tif (couldEverMatchSameJoinPoints(left, rightOrPointcut.getLeft())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (couldEverMatchSameJoinPoints(left, rightOrPointcut.getRight())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// look for withins\n\t\tWithinPointcut leftWithin = (WithinPointcut) findFirstPointcutIn(left, WithinPointcut.class);\n\t\tWithinPointcut rightWithin = (WithinPointcut) findFirstPointcutIn(right, WithinPointcut.class);\n\t\tif ((leftWithin != null) && (rightWithin != null)) {\n\t\t\tif (!leftWithin.couldEverMatchSameJoinPointsAs(rightWithin)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t// look for kinded\n\t\tKindedPointcut leftKind = (KindedPointcut) findFirstPointcutIn(left, KindedPointcut.class);\n\t\tKindedPointcut rightKind = (KindedPointcut) findFirstPointcutIn(right, KindedPointcut.class);\n\t\tif ((leftKind != null) && (rightKind != null)) {\n\t\t\tif (!leftKind.couldEverMatchSameJoinPointsAs(rightKind)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate Pointcut findFirstPointcutIn(Pointcut toSearch, Class<?> toLookFor) {\n\t\tif (toSearch instanceof NotPointcut) {\n\t\t\treturn null;\n\t\t}\n\t\tif (toLookFor.isInstance(toSearch)) {\n\t\t\treturn toSearch;\n\t\t}\n\t\tif (toSearch instanceof AndPointcut) {\n\t\t\tAndPointcut apc = (AndPointcut) toSearch;\n\t\t\tPointcut left = findFirstPointcutIn(apc.getLeft(), toLookFor);\n\t\t\tif (left != null) {\n\t\t\t\treturn left;\n\t\t\t}\n\t\t\treturn findFirstPointcutIn(apc.getRight(), toLookFor);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param userPointcut\n\t */\n\tprivate void raiseNegationBindingError(Pointcut userPointcut) {\n\t\tworld.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.NEGATION_DOESNT_ALLOW_BINDING), userPointcut\n\t\t\t\t.getSourceContext().makeSourceLocation(userPointcut), null);\n\t}\n\n\tprivate void raiseAmbiguousBindingError(String name, Pointcut pointcut) {\n\t\tworld.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.AMBIGUOUS_BINDING, name), pointcut\n\t\t\t\t.getSourceContext().makeSourceLocation(pointcut), null);\n\t}\n\n\t/**\n\t * @param userPointcut\n\t */\n\tprivate void raiseAmbiguityInDisjunctionError(Pointcut userPointcut, List<String> names) {\n\t\tStringBuffer formalNames = new StringBuffer(names.get(0).toString());\n\t\tfor (int i = 1; i < names.size(); i++) {\n\t\t\tformalNames.append(\", \");\n\t\t\tformalNames.append(names.get(i));\n\t\t}\n\t\tworld.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.AMBIGUOUS_BINDING_IN_OR, formalNames), userPointcut\n\t\t\t\t.getSourceContext().makeSourceLocation(userPointcut), null);\n\t}\n\n\t/**\n\t * @param name\n\t * @param userPointcut\n\t */\n\tprivate void raiseUnboundFormalError(String name, Pointcut userPointcut) {\n\t\tworld.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.UNBOUND_FORMAL, name),\n\t\t\t\tuserPointcut.getSourceLocation(), null);\n\t}\n\n\tpublic void addManifest(Manifest newManifest) {\n\t\t// System.out.println(\"? addManifest() newManifest=\" + newManifest);\n\t\tif (manifest == null) {\n\t\t\tmanifest = newManifest;\n\t\t}\n\t}\n\n\tpublic Manifest getManifest(boolean shouldCreate) {\n\t\tif (manifest == null && shouldCreate) {\n\t\t\tString WEAVER_MANIFEST_VERSION = \"1.0\";\n\t\t\tAttributes.Name CREATED_BY = new Name(\"Created-By\");\n\t\t\tString WEAVER_CREATED_BY = \"AspectJ Compiler\";\n\n\t\t\tmanifest = new Manifest();\n\n\t\t\tAttributes attributes = manifest.getMainAttributes();\n\t\t\tattributes.put(Name.MANIFEST_VERSION, WEAVER_MANIFEST_VERSION);\n\t\t\tattributes.put(CREATED_BY, WEAVER_CREATED_BY);\n\t\t}\n\n\t\treturn manifest;\n\t}\n\n\t// ---- weaving\n\n\t// FOR TESTING\n\tpublic Collection<String> weave(File file) throws IOException {\n\t\tOutputStream os = FileUtil.makeOutputStream(file);\n\t\tthis.zipOutputStream = new ZipOutputStream(os);\n\t\tprepareForWeave();\n\t\tCollection<String> c = weave(new IClassFileProvider() {\n\n\t\t\tpublic boolean isApplyAtAspectJMungersOnly() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpublic Iterator<UnwovenClassFile> getClassFileIterator() {\n\t\t\t\treturn addedClasses.iterator();\n\t\t\t}\n\n\t\t\tpublic IWeaveRequestor getRequestor() {\n\t\t\t\treturn new WeaveRequestor();\n\t\t\t}\n\t\t});\n\t\t// /* BUG 40943*/\n\t\t// dumpResourcesToOutJar();\n\t\tzipOutputStream.close(); // this flushes and closes the acutal file\n\t\treturn c;\n\t}\n\n\tprivate class WeaveRequestor implements IWeaveRequestor {\n\t\tpublic void acceptResult(IUnwovenClassFile result) {\n\t\t\ttry {\n\t\t\t\twriteZipEntry(result.getFilename(), result.getBytes());\n\t\t\t} catch (IOException ex) {\n\t\t\t}\n\t\t}\n\n\t\tpublic void processingReweavableState() {}\n\n\t\tpublic void addingTypeMungers() {}\n\n\t\tpublic void weavingAspects() {}\n\n\t\tpublic void weavingClasses() {}\n\n\t\tpublic void weaveCompleted() {}\n\t}\n\n\tprivate Set<IProgramElement> candidatesForRemoval = null;\n\n\t// variation of \"weave\" that sources class files from an external source.\n\tpublic Collection<String> weave(IClassFileProvider input) throws IOException {\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.enter(\"weave\", this, input);\n\t\t}\n\t\tContextToken weaveToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING, \"\");\n\t\tCollection<String> wovenClassNames = new ArrayList<>();\n\t\tIWeaveRequestor requestor = input.getRequestor();\n\n\t\tif (world.getModel() != null && world.isMinimalModel()) {\n\t\t\tcandidatesForRemoval = new HashSet<>();\n\t\t}\n\t\tif (world.getModel() != null && !isBatchWeave) {\n\t\t\tAsmManager manager = world.getModelAsAsmManager();\n\t\t\tfor (Iterator<UnwovenClassFile> i = input.getClassFileIterator(); i.hasNext();) {\n\t\t\t\tUnwovenClassFile classFile = i.next();\n\t\t\t\t// remove all relationships where this file being woven is\n\t\t\t\t// the target of the relationship\n\t\t\t\tmanager.removeRelationshipsTargettingThisType(classFile.getClassName());\n\t\t\t}\n\t\t}\n\n\t\t// Go through the types and ensure any 'damaged' during compile time are\n\t\t// repaired prior to weaving\n\t\tfor (Iterator<UnwovenClassFile> i = input.getClassFileIterator(); i.hasNext();) {\n\t\t\tUnwovenClassFile classFile = i.next();\n\t\t\tif (classFile.shouldBeWoven()) {\n\t\t\t\tString className = classFile.getClassName();\n\t\t\t\tResolvedType theType = world.resolve(className);\n\t\t\t\tif (theType != null) {\n\t\t\t\t\ttheType.ensureConsistent();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// special case for AtAspectJMungerOnly - see #113587\n\t\tif (input.isApplyAtAspectJMungersOnly()) {\n\t\t\tContextToken atAspectJMungersOnly = CompilationAndWeavingContext.enteringPhase(\n\t\t\t\t\tCompilationAndWeavingContext.PROCESSING_ATASPECTJTYPE_MUNGERS_ONLY, \"\");\n\t\t\trequestor.weavingAspects();\n\t\t\t// ContextToken aspectToken =\n\t\t\tCompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_ASPECTS, \"\");\n\t\t\tfor (Iterator<UnwovenClassFile> i = input.getClassFileIterator(); i.hasNext();) {\n\t\t\t\tUnwovenClassFile classFile = i.next();\n\t\t\t\tif (classFile.shouldBeWoven()) {\n\t\t\t\t\tString className = classFile.getClassName();\n\t\t\t\t\tResolvedType theType = world.resolve(className);\n\t\t\t\t\tif (theType.isAnnotationStyleAspect()) {\n\t\t\t\t\t\tBcelObjectType classType = BcelWorld.getBcelObjectType(theType);\n\t\t\t\t\t\tif (classType == null) {\n\t\t\t\t\t\t\tthrow new BCException(\"Can't find bcel delegate for \" + className + \" type=\" + theType.getClass());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLazyClassGen clazz = classType.getLazyClassGen();\n\t\t\t\t\t\tBcelPerClauseAspectAdder selfMunger = new BcelPerClauseAspectAdder(theType, theType.getPerClause().getKind());\n\t\t\t\t\t\tselfMunger.forceMunge(clazz, true);\n\t\t\t\t\t\tclassType.finishedWith();\n\t\t\t\t\t\tUnwovenClassFile[] newClasses = getClassFilesFor(clazz);\n\t\t\t\t\t\tfor (UnwovenClassFile newClass : newClasses) {\n\t\t\t\t\t\t\trequestor.acceptResult(newClass);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twovenClassNames.add(classFile.getClassName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trequestor.weaveCompleted();\n\t\t\tCompilationAndWeavingContext.leavingPhase(atAspectJMungersOnly);\n\t\t\treturn wovenClassNames;\n\t\t}\n\n\t\trequestor.processingReweavableState();\n\t\tContextToken reweaveToken = CompilationAndWeavingContext.enteringPhase(\n\t\t\t\tCompilationAndWeavingContext.PROCESSING_REWEAVABLE_STATE, \"\");\n\t\tprepareToProcessReweavableState();\n\t\t// clear all state from files we'll be reweaving\n\t\tfor (Iterator<UnwovenClassFile> i = input.getClassFileIterator(); i.hasNext();) {\n\t\t\tUnwovenClassFile classFile = i.next();\n\t\t\tif (classFile.shouldBeWoven()) {\n\t\t\t\tString className = classFile.getClassName();\n\t\t\t\tBcelObjectType classType = getClassType(className);\n\n\t\t\t\t// null return from getClassType() means the delegate is an eclipse\n\t\t\t\t// source type - so\n\t\t\t\t// there *cant* be any reweavable state... (he bravely claimed...)\n\t\t\t\tif (classType != null) {\n\t\t\t\t\tContextToken tok = CompilationAndWeavingContext.enteringPhase(\n\t\t\t\t\t\t\tCompilationAndWeavingContext.PROCESSING_REWEAVABLE_STATE, className);\n\t\t\t\t\tprocessReweavableStateIfPresent(className, classType);\n\t\t\t\t\tCompilationAndWeavingContext.leavingPhase(tok);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCompilationAndWeavingContext.leavingPhase(reweaveToken);\n\n\t\tContextToken typeMungingToken = CompilationAndWeavingContext.enteringPhase(\n\t\t\t\tCompilationAndWeavingContext.PROCESSING_TYPE_MUNGERS, \"\");\n\t\trequestor.addingTypeMungers();\n\n\t\t// We process type mungers in two groups, first mungers that change the\n\t\t// type\n\t\t// hierarchy, then 'normal' ITD type mungers.\n\n\t\t// Process the types in a predictable order (rather than the order\n\t\t// encountered).\n\t\t// For class A, the order is superclasses of A then superinterfaces of A\n\t\t// (and this mechanism is applied recursively)\n\t\tList<String> typesToProcess = new ArrayList<>();\n\t\tfor (Iterator<UnwovenClassFile> iter = input.getClassFileIterator(); iter.hasNext();) {\n\t\t\tUnwovenClassFile clf = iter.next();\n\t\t\tif (clf.shouldBeWoven()) {\n\t\t\t\ttypesToProcess.add(clf.getClassName());\n\t\t\t}\n\t\t}\n\t\twhile (typesToProcess.size() > 0) {\n\t\t\tweaveParentsFor(typesToProcess, typesToProcess.get(0), null);\n\t\t}\n\n\t\tfor (Iterator<UnwovenClassFile> i = input.getClassFileIterator(); i.hasNext();) {\n\t\t\tUnwovenClassFile classFile = i.next();\n\t\t\tif (classFile.shouldBeWoven()) {\n\t\t\t\tString className = classFile.getClassName();\n\t\t\t\taddNormalTypeMungers(className);\n\t\t\t}\n\t\t}\n\n\t\tCompilationAndWeavingContext.leavingPhase(typeMungingToken);\n\n\t\trequestor.weavingAspects();\n\t\tContextToken aspectToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_ASPECTS, \"\");\n\t\t// first weave into aspects\n\t\tfor (Iterator<UnwovenClassFile> i = input.getClassFileIterator(); i.hasNext();) {\n\t\t\tUnwovenClassFile classFile = i.next();\n\t\t\tif (classFile.shouldBeWoven()) {\n\t\t\t\tString className = classFile.getClassName();\n\t\t\t\tResolvedType theType = world.resolve(className);\n\t\t\t\tif (theType.isAspect()) {\n\t\t\t\t\tBcelObjectType classType = BcelWorld.getBcelObjectType(theType);\n\t\t\t\t\tif (classType == null) {\n\n\t\t\t\t\t\t// Sometimes.. if the Bcel Delegate couldn't be found then a\n\t\t\t\t\t\t// problem occurred at compile time - on\n\t\t\t\t\t\t// a previous compiler run. In this case I assert the\n\t\t\t\t\t\t// delegate will still be an EclipseSourceType\n\t\t\t\t\t\t// and we can ignore the problem here (the original compile\n\t\t\t\t\t\t// error will be reported again from\n\t\t\t\t\t\t// the eclipse source type) - pr113531\n\t\t\t\t\t\tReferenceTypeDelegate theDelegate = ((ReferenceType) theType).getDelegate();\n\t\t\t\t\t\tif (theDelegate.getClass().getName().endsWith(\"EclipseSourceType\")) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new BCException(\"Can't find bcel delegate for \" + className + \" type=\" + theType.getClass());\n\t\t\t\t\t}\n\t\t\t\t\tweaveAndNotify(classFile, classType, requestor);\n\t\t\t\t\twovenClassNames.add(className);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCompilationAndWeavingContext.leavingPhase(aspectToken);\n\n\t\trequestor.weavingClasses();\n\t\tContextToken classToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_CLASSES, \"\");\n\t\t// then weave into non-aspects\n\t\tfor (Iterator<UnwovenClassFile> i = input.getClassFileIterator(); i.hasNext();) {\n\t\t\tUnwovenClassFile classFile = i.next();\n\t\t\tif (classFile.shouldBeWoven()) {\n\t\t\t\tString className = classFile.getClassName();\n\t\t\t\tResolvedType theType = world.resolve(className);\n\t\t\t\tif (!theType.isAspect()) {\n\t\t\t\t\tBcelObjectType classType = BcelWorld.getBcelObjectType(theType);\n\t\t\t\t\tif (classType == null) {\n\n\t\t\t\t\t\t// bug 119882 - see above comment for bug 113531\n\t\t\t\t\t\tReferenceTypeDelegate theDelegate = ((ReferenceType) theType).getDelegate();\n\n\t\t\t\t\t\t// TODO urgh - put a method on the interface to check this,\n\t\t\t\t\t\t// string compare is hideous\n\t\t\t\t\t\tif (theDelegate.getClass().getName().endsWith(\"EclipseSourceType\")) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new BCException(\"Can't find bcel delegate for \" + className + \" type=\" + theType.getClass());\n\t\t\t\t\t}\n\t\t\t\t\tweaveAndNotify(classFile, classType, requestor);\n\t\t\t\t\twovenClassNames.add(className);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCompilationAndWeavingContext.leavingPhase(classToken);\n\n\t\taddedClasses.clear();\n\t\tdeletedTypenames.clear();\n\n\t\trequestor.weaveCompleted();\n\t\tCompilationAndWeavingContext.leavingPhase(weaveToken);\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.exit(\"weave\", wovenClassNames);\n\t\t}\n\t\tif (world.getModel() != null && world.isMinimalModel()) {\n\t\t\tcandidatesForRemoval.clear();\n\t\t}\n\t\treturn wovenClassNames;\n\t}\n\n\tpublic void allWeavingComplete() {\n\t\twarnOnUnmatchedAdvice();\n\t}\n\n\t/**\n\t * In 1.5 mode and with XLint:adviceDidNotMatch enabled, put out messages for any mungers that did not match anything.\n\t */\n\tprivate void warnOnUnmatchedAdvice() {\n\n\t\tclass AdviceLocation {\n\t\t\tprivate final int lineNo;\n\t\t\tprivate final UnresolvedType inAspect;\n\n\t\t\tpublic AdviceLocation(BcelAdvice advice) {\n\t\t\t\tthis.lineNo = advice.getSourceLocation().getLine();\n\t\t\t\tthis.inAspect = advice.getDeclaringAspect();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif (!(obj instanceof AdviceLocation)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tAdviceLocation other = (AdviceLocation) obj;\n\t\t\t\tif (this.lineNo != other.lineNo) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!this.inAspect.equals(other.inAspect)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int hashCode() {\n\t\t\t\treturn 37 + 17 * lineNo + 17 * inAspect.hashCode();\n\t\t\t}\n\t\t}\n\n\t\t// FIXME asc Should be factored out into Xlint code and done\n\t\t// automatically for all xlint messages, ideally.\n\t\t// if a piece of advice hasn't matched anywhere and we are in -1.5 mode,\n\t\t// put out a warning\n\t\tif (world.isInJava5Mode() && world.getLint().adviceDidNotMatch.isEnabled()) {\n\t\t\tList<ShadowMunger> l = world.getCrosscuttingMembersSet().getShadowMungers();\n\t\t\tSet<AdviceLocation> alreadyWarnedLocations = new HashSet<>();\n\n\t\t\tfor (ShadowMunger element : l) {\n\t\t\t\t// This will stop us incorrectly reporting deow checkers:\n\t\t\t\tif (element instanceof BcelAdvice) {\n\t\t\t\t\tBcelAdvice ba = (BcelAdvice) element;\n\t\t\t\t\tif (ba.getKind() == AdviceKind.CflowEntry || ba.getKind() == AdviceKind.CflowBelowEntry) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (ba.getKind() == AdviceKind.PerCflowEntry || ba.getKind() == AdviceKind.PerTargetEntry ||\n\t\t\t\t\t\tba.getKind() == AdviceKind.PerCflowBelowEntry || ba.getKind() == AdviceKind.PerThisEntry ||\n\t\t\t\t\t\tba.getKind() == AdviceKind.PerTypeWithinEntry) {\n\t\t\t\t\t\t// Unclear if we want advice did not match warnings for per clauses...\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ba.hasMatchedSomething()) {\n\t\t\t\t\t\t// Because we implement some features of AJ itself by\n\t\t\t\t\t\t// creating our own kind of mungers, you sometimes\n\t\t\t\t\t\t// find that ba.getSignature() is not a BcelMethod - for\n\t\t\t\t\t\t// example it might be a cflow entry munger.\n\t\t\t\t\t\tif (ba.getSignature() != null) {\n\t\t\t\t\t\t\t// check we haven't already warned on this advice and line\n\t\t\t\t\t\t\t// (cflow creates multiple mungers for the same advice)\n\t\t\t\t\t\t\tAdviceLocation loc = new AdviceLocation(ba);\n\t\t\t\t\t\t\tif (alreadyWarnedLocations.contains(loc)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\talreadyWarnedLocations.add(loc);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!(ba.getSignature() instanceof BcelMethod)\n\t\t\t\t\t\t\t\t\t|| !Utility.isSuppressing(ba.getSignature(), \"adviceDidNotMatch\")) {\n\t\t\t\t\t\t\t\tworld.getLint().adviceDidNotMatch.signal(ba.getDeclaringAspect().toString(), new SourceLocation(\n\t\t\t\t\t\t\t\t\t\telement.getSourceLocation().getSourceFile(), element.getSourceLocation().getLine()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * 'typeToWeave' is one from the 'typesForWeaving' list. This routine ensures we process supertypes (classes/interfaces) of\n\t * 'typeToWeave' that are in the 'typesForWeaving' list before 'typeToWeave' itself. 'typesToWeave' is then removed from the\n\t * 'typesForWeaving' list.\n\t *\n\t * Note: Future gotcha in here ... when supplying partial hierarchies, this algorithm may break down. If you have a hierarchy\n\t * A>B>C and only give A and C to the weaver, it may choose to weave them in either order - but you'll probably have other\n\t * problems if you are supplying partial hierarchies like that !\n\t */\n\tprivate void weaveParentsFor(List<String> typesForWeaving, String typeToWeave, ResolvedType resolvedTypeToWeave) {\n\t\tif (resolvedTypeToWeave == null) {\n\t\t\t// resolve it if the caller could not pass in the resolved type\n\t\t\tresolvedTypeToWeave = world.resolve(typeToWeave);\n\t\t}\n\t\tResolvedType superclassType = resolvedTypeToWeave.getSuperclass();\n\t\tString superclassTypename = (superclassType == null ? null : superclassType.getName());\n\n\t\t// PR336654 added the 'typesForWeaving.contains(superclassTypename)' clause.\n\t\t// Without it we can delete all type mungers on the parents and yet we only\n\t\t// add back in the declare parents related ones, not the regular ITDs.\n\t\tif (superclassType != null && !superclassType.isTypeHierarchyComplete() && superclassType.isExposedToWeaver()\n\t\t\t\t&& typesForWeaving.contains(superclassTypename)) {\n\t\t\tweaveParentsFor(typesForWeaving, superclassTypename, superclassType);\n\t\t}\n\n\t\tResolvedType[] interfaceTypes = resolvedTypeToWeave.getDeclaredInterfaces();\n\t\tfor (ResolvedType resolvedSuperInterface : interfaceTypes) {\n\t\t\tif (!resolvedSuperInterface.isTypeHierarchyComplete()) {\n\t\t\t\tString interfaceTypename = resolvedSuperInterface.getName();\n\t\t\t\tif (resolvedSuperInterface.isExposedToWeaver()) { // typesForWeaving.contains(interfaceTypename)) {\n\t\t\t\t\tweaveParentsFor(typesForWeaving, interfaceTypename, resolvedSuperInterface);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.PROCESSING_DECLARE_PARENTS,\n\t\t\t\tresolvedTypeToWeave.getName());\n\t\t// If A was processed before B (and was declared 'class A implements B') then there is no need to complete B again, it\n\t\t// will have been done whilst processing A.\n\t\tif (!resolvedTypeToWeave.isTypeHierarchyComplete()) {\n\t\t\tweaveParentTypeMungers(resolvedTypeToWeave);\n\t\t}\n\t\tCompilationAndWeavingContext.leavingPhase(tok);\n\t\ttypesForWeaving.remove(typeToWeave);\n\t\tresolvedTypeToWeave.tagAsTypeHierarchyComplete();\n\t}\n\n\tpublic void prepareToProcessReweavableState() {\n\t}\n\n\tpublic void processReweavableStateIfPresent(String className, BcelObjectType classType) {\n\t\t// If the class is marked reweavable, check any aspects around when it\n\t\t// was built are in this world\n\t\tWeaverStateInfo wsi = classType.getWeaverState();\n\t\t// System.out.println(\">> processReweavableStateIfPresent \" + className + \" wsi=\" + wsi);\n\t\tif (wsi != null && wsi.isReweavable()) { // Check all necessary types\n\t\t\t// are around!\n\t\t\tworld.showMessage(IMessage.INFO, WeaverMessages.format(WeaverMessages.PROCESSING_REWEAVABLE, className, classType\n\t\t\t\t\t.getSourceLocation().getSourceFile()), null, null);\n\t\t\tSet<String> aspectsPreviouslyInWorld = wsi.getAspectsAffectingType();\n\t\t\t// keep track of them just to ensure unique missing aspect error\n\t\t\t// reporting\n\t\t\tSet<String> alreadyConfirmedReweavableState = new HashSet<>();\n\t\t\tfor (String requiredTypeSignature : aspectsPreviouslyInWorld) {\n\t\t\t\t// for (Iterator iter = aspectsPreviouslyInWorld.iterator(); iter.hasNext();) {\n\t\t\t\t// String requiredTypeName = (String) iter.next();\n\t\t\t\tif (!alreadyConfirmedReweavableState.contains(requiredTypeSignature)) {\n\t\t\t\t\tResolvedType rtx = world.resolve(UnresolvedType.forSignature(requiredTypeSignature), true);\n\t\t\t\t\tboolean exists = !rtx.isMissing();\n\t\t\t\t\tif (!world.isOverWeaving()) {\n\t\t\t\t\t\tif (!exists) {\n\t\t\t\t\t\t\tworld.getLint().missingAspectForReweaving.signal(new String[] { rtx.getName(), className },\n\t\t\t\t\t\t\t\tclassType.getSourceLocation(), null);\n\t\t\t\t\t\t\t// world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.MISSING_REWEAVABLE_TYPE,\n\t\t\t\t\t\t\t// requiredTypeName, className), classType.getSourceLocation(), null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// weaved in aspect that are not declared in aop.xml\n\t\t\t\t\t\t\t// trigger an error for now\n\t\t\t\t\t\t\t// may cause headhache for LTW and packaged lib\n\t\t\t\t\t\t\t// without aop.xml in\n\t\t\t\t\t\t\t// see #104218\n\t\t\t\t\t\t\tif (!xcutSet.containsAspect(rtx)) {\n\t\t\t\t\t\t\t\tworld.showMessage(IMessage.ERROR, WeaverMessages.format(\n\t\t\t\t\t\t\t\t\t\tWeaverMessages.REWEAVABLE_ASPECT_NOT_REGISTERED, rtx.getName(), className), null, null);\n\t\t\t\t\t\t\t} else if (!world.getMessageHandler().isIgnoring(IMessage.INFO)) {\n\t\t\t\t\t\t\t\tworld.showMessage(IMessage.INFO, WeaverMessages.format(WeaverMessages.VERIFIED_REWEAVABLE_TYPE,\n\t\t\t\t\t\t\t\t\t\trtx.getName(), rtx.getSourceLocation().getSourceFile()), null, null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\talreadyConfirmedReweavableState.add(requiredTypeSignature);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// old:\n\t\t\t// classType.setJavaClass(Utility.makeJavaClass(classType.getJavaClass\n\t\t\t// ().getFileName(), wsi.getUnwovenClassFileData()));\n\t\t\t// new: reweavable default with clever diff\n\t\t\tif (!world.isOverWeaving()) {\n\t\t\t\tbyte[] ucfd = wsi.getUnwovenClassFileData();\n\t\t\t\tif (ucfd.length == 0) {\n\t\t\t\t\t// Size 0 indicates the class was previously overwoven, so you need to be overweaving now!\n\t\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\t\tMessageUtil.error(\n\t\t\t\t\t\t\tWeaverMessages.format(WeaverMessages.MUST_KEEP_OVERWEAVING_ONCE_START,\n\t\t\t\t\t\t\t\t\tclassName)));\n//\t\t\t\t\t\t\t\t\tonType.getName(), annoX.getTypeName(), annoX.getValidTargets()),\n//\t\t\t\t\t\t\tdecA.getSourceLocation()));\n\t\t\t\t} else {\n\t\t\t\t\tbyte[] bytes = wsi.getUnwovenClassFileData(classType.getJavaClass().getBytes());\n\t\t\t\t\tJavaClass newJavaClass = Utility.makeJavaClass(classType.getJavaClass().getFileName(), bytes);\n\t\t\t\t\tclassType.setJavaClass(newJavaClass, true);\n\t\t\t\t\tclassType.getResolvedTypeX().ensureConsistent();\n\t\t\t\t}\n\t\t\t}\n\t\t\t// } else {\n\t\t\t// classType.resetState();\n\t\t}\n\t}\n\n\tprivate void weaveAndNotify(UnwovenClassFile classFile, BcelObjectType classType, IWeaveRequestor requestor) throws IOException {\n\t\ttrace.enter(\"weaveAndNotify\", this, new Object[] { classFile, classType, requestor });\n\n\t\tContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_TYPE, classType\n\t\t\t\t.getResolvedTypeX().getName());\n\t\tLazyClassGen clazz = weaveWithoutDump(classFile, classType);\n\t\tclassType.finishedWith();\n\t\t// clazz is null if the classfile was unchanged by weaving...\n\t\tif (clazz != null) {\n\t\t\tUnwovenClassFile[] newClasses = getClassFilesFor(clazz);\n\t\t\t// OPTIMIZE can we avoid using the string name at all in\n\t\t\t// UnwovenClassFile instances?\n\t\t\t// Copy the char[] across as it means the\n\t\t\t// WeaverAdapter.removeFromMap() can be fast!\n\t\t\tif (newClasses[0].getClassName().equals(classFile.getClassName())) {\n\t\t\t\tnewClasses[0].setClassNameAsChars(classFile.getClassNameAsChars());\n\t\t\t}\n\t\t\tfor (UnwovenClassFile newClass : newClasses) {\n\t\t\t\trequestor.acceptResult(newClass);\n\t\t\t}\n\t\t} else {\n\t\t\trequestor.acceptResult(classFile);\n\t\t}\n\t\tclassType.weavingCompleted();\n\t\tCompilationAndWeavingContext.leavingPhase(tok);\n\n\t\ttrace.exit(\"weaveAndNotify\");\n\t}\n\n\t/**\n\t * helper method - will return NULL if the underlying delegate is an EclipseSourceType and not a BcelObjectType\n\t */\n\tpublic BcelObjectType getClassType(String forClass) {\n\t\treturn BcelWorld.getBcelObjectType(world.resolve(forClass));\n\t}\n\n\tpublic void addParentTypeMungers(String typeName) {\n\t\tweaveParentTypeMungers(world.resolve(typeName));\n\t}\n\n\tpublic void addNormalTypeMungers(String typeName) {\n\t\tweaveNormalTypeMungers(world.resolve(typeName));\n\t}\n\n\tpublic UnwovenClassFile[] getClassFilesFor(LazyClassGen clazz) {\n\t\tList<UnwovenClassFile.ChildClass> childClasses = clazz.getChildClasses(world);\n\t\tUnwovenClassFile[] ret = new UnwovenClassFile[1 + childClasses.size()];\n\t\tret[0] = new UnwovenClassFile(clazz.getFileName(), clazz.getClassName(), clazz.getJavaClassBytesIncludingReweavable(world));\n\t\tint index = 1;\n\t\tfor (UnwovenClassFile.ChildClass element : childClasses) {\n\t\t\tUnwovenClassFile childClass = new UnwovenClassFile(clazz.getFileName() + \"$\" + element.name, element.bytes);\n\t\t\tret[index++] = childClass;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Weaves new parents and annotations onto a type (\"declare parents\" and \"declare @type\")\n\t *\n\t * Algorithm: 1. First pass, do parents then do annotations. During this pass record: - any parent mungers that don't match but\n\t * have a non-wild annotation type pattern - any annotation mungers that don't match 2. Multiple subsequent passes which go over\n\t * the munger lists constructed in the first pass, repeatedly applying them until nothing changes. FIXME asc confirm that\n\t * algorithm is optimal ??\n\t */\n\tpublic void weaveParentTypeMungers(ResolvedType onType) {\n\t\tif (onType.isRawType() || onType.isParameterizedType()) {\n\t\t\tonType = onType.getGenericType();\n\t\t}\n\t\tonType.clearInterTypeMungers();\n\n\t\tList<DeclareParents> decpToRepeat = new ArrayList<>();\n\n\t\tboolean aParentChangeOccurred = false;\n\t\tboolean anAnnotationChangeOccurred = false;\n\t\t// First pass - apply all decp mungers\n\t\tfor (DeclareParents decp : declareParentsList) {\n\t\t\tboolean typeChanged = applyDeclareParents(decp, onType);\n\t\t\tif (typeChanged) {\n\t\t\t\taParentChangeOccurred = true;\n\t\t\t} else {\n\t\t\t\tdecpToRepeat.add(decp);\n\t\t\t}\n\t\t}\n\n\t\t// Still first pass - apply all dec @type mungers\n\t\tfor (DeclareAnnotation decA : xcutSet.getDeclareAnnotationOnTypes()) {\n\t\t\tboolean typeChanged = applyDeclareAtType(decA, onType, true);\n\t\t\tif (typeChanged) {\n\t\t\t\tanAnnotationChangeOccurred = true;\n\t\t\t}\n\t\t}\n\n\t\twhile ((aParentChangeOccurred || anAnnotationChangeOccurred) && !decpToRepeat.isEmpty()) {\n\t\t\tanAnnotationChangeOccurred = aParentChangeOccurred = false;\n\t\t\tList<DeclareParents> decpToRepeatNextTime = new ArrayList<>();\n\t\t\tfor (DeclareParents decp : decpToRepeat) {\n\t\t\t\tboolean typeChanged = applyDeclareParents(decp, onType);\n\t\t\t\tif (typeChanged) {\n\t\t\t\t\taParentChangeOccurred = true;\n\t\t\t\t} else {\n\t\t\t\t\tdecpToRepeatNextTime.add(decp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (DeclareAnnotation decA : xcutSet.getDeclareAnnotationOnTypes()) {\n\t\t\t\tboolean typeChanged = applyDeclareAtType(decA, onType, false);\n\t\t\t\tif (typeChanged) {\n\t\t\t\t\tanAnnotationChangeOccurred = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecpToRepeat = decpToRepeatNextTime;\n\t\t}\n\t}\n\n\t/**\n\t * Apply a declare @type - return true if we change the type\n\t */\n\tprivate boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedType onType, boolean reportProblems) {\n\t\tboolean didSomething = false;\n\t\tif (decA.matches(onType)) {\n\t\t\tAnnotationAJ theAnnotation = decA.getAnnotation();\n\t\t\t// can be null for broken code!\n\t\t\tif (theAnnotation == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (onType.hasAnnotation(theAnnotation.getType())) {\n\t\t\t\t// Could put out a lint here for an already annotated type ...\n\t\t\t\t// if (reportProblems) {\n\t\t\t\t// world.getLint().elementAlreadyAnnotated.signal(\n\t\t\t\t// new\n\t\t\t\t// String[]{onType.toString(),decA.getAnnotationTypeX().toString\n\t\t\t\t// ()},\n\t\t\t\t// onType.getSourceLocation(),new\n\t\t\t\t// ISourceLocation[]{decA.getSourceLocation()});\n\t\t\t\t// }\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tAnnotationAJ annoX = decA.getAnnotation();\n\n\t\t\t// check the annotation is suitable for the target\n\t\t\tboolean problemReported = verifyTargetIsOK(decA, onType, annoX, reportProblems);\n\n\t\t\tif (!problemReported) {\n\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationRelationship(world.getModelAsAsmManager(), decA.getSourceLocation(),\n\t\t\t\t\t\tonType.getSourceLocation(), false);\n\t\t\t\t// TAG: WeavingMessage\n\t\t\t\tif (!getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {\n\t\t\t\t\tgetWorld().getMessageHandler().handleMessage(\n\t\t\t\t\t\t\tWeaveMessage.constructWeavingMessage(\n\t\t\t\t\t\t\t\t\tWeaveMessage.WEAVEMESSAGE_ANNOTATES,\n\t\t\t\t\t\t\t\t\tnew String[] { onType.toString(), Utility.beautifyLocation(onType.getSourceLocation()),\n\t\t\t\t\t\t\t\t\t\t\tdecA.getAnnotationString(), \"type\", decA.getAspect().toString(),\n\t\t\t\t\t\t\t\t\t\t\tUtility.beautifyLocation(decA.getSourceLocation()) }));\n\t\t\t\t}\n\t\t\t\tdidSomething = true;\n\t\t\t\tResolvedTypeMunger newAnnotationTM = new AnnotationOnTypeMunger(annoX);\n\t\t\t\tnewAnnotationTM.setSourceLocation(decA.getSourceLocation());\n\t\t\t\tonType.addInterTypeMunger(new BcelTypeMunger(newAnnotationTM, decA.getAspect().resolve(world)), false);\n\t\t\t\tdecA.copyAnnotationTo(onType);\n\t\t\t}\n\t\t}\n\t\treturn didSomething;\n\t}\n\n\t/**\n\t * Checks for an @target() on the annotation and if found ensures it allows the annotation to be attached to the target type\n\t * that matched.\n\t */\n\tprivate boolean verifyTargetIsOK(DeclareAnnotation decA, ResolvedType onType, AnnotationAJ annoX, boolean outputProblems) {\n\t\tboolean problemReported = false;\n\t\tif (annoX.specifiesTarget()) {\n\t\t\tif ((onType.isAnnotation() && !annoX.allowedOnAnnotationType()) || (!annoX.allowedOnRegularType())) {\n\t\t\t\tif (outputProblems) {\n\t\t\t\t\tif (decA.isExactPattern()) {\n\t\t\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\t\t\tMessageUtil.error(\n\t\t\t\t\t\t\t\t\t\tWeaverMessages.format(WeaverMessages.INCORRECT_TARGET_FOR_DECLARE_ANNOTATION,\n\t\t\t\t\t\t\t\t\t\t\t\tonType.getName(), annoX.getTypeName(), annoX.getValidTargets()),\n\t\t\t\t\t\t\t\t\t\tdecA.getSourceLocation()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (world.getLint().invalidTargetForAnnotation.isEnabled()) {\n\t\t\t\t\t\t\tworld.getLint().invalidTargetForAnnotation.signal(new String[] { onType.getName(), annoX.getTypeName(),\n\t\t\t\t\t\t\t\t\tannoX.getValidTargets() }, decA.getSourceLocation(),\n\t\t\t\t\t\t\t\t\tnew ISourceLocation[] { onType.getSourceLocation() });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tproblemReported = true;\n\t\t\t}\n\t\t}\n\t\treturn problemReported;\n\t}\n\n\t/**\n\t * Apply a single declare parents - return true if we change the type\n\t */\n\tprivate boolean applyDeclareParents(DeclareParents p, ResolvedType onType) {\n\t\tboolean didSomething = false;\n\t\tList<ResolvedType> newParents = p.findMatchingNewParents(onType, true);\n\t\tif (!newParents.isEmpty()) {\n\t\t\tdidSomething = true;\n\t\t\tBcelWorld.getBcelObjectType(onType);\n\t\t\t// System.err.println(\"need to do declare parents for: \" + onType);\n\t\t\tfor (ResolvedType newParent : newParents) {\n\t\t\t\t// We set it here so that the imminent matching for ITDs can\n\t\t\t\t// succeed - we still haven't done the necessary changes to the class file\n\t\t\t\t// itself (like transform super calls) - that is done in\n\t\t\t\t// BcelTypeMunger.mungeNewParent()\n\t\t\t\t// classType.addParent(newParent);\n\t\t\t\tonType.addParent(newParent);\n\t\t\t\tNewParentTypeMunger newParentMunger = new NewParentTypeMunger(newParent, p.getDeclaringType());\n\t\t\t\tif (p.isMixin()) {\n\t\t\t\t\tnewParentMunger.setIsMixin(true);\n\t\t\t\t}\n\t\t\t\tnewParentMunger.setSourceLocation(p.getSourceLocation());\n\t\t\t\tonType.addInterTypeMunger(new BcelTypeMunger(newParentMunger, xcutSet.findAspectDeclaringParents(p)), false);\n\t\t\t}\n\t\t}\n\t\treturn didSomething;\n\t}\n\n\tpublic void weaveNormalTypeMungers(ResolvedType onType) {\n\t\tContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.PROCESSING_TYPE_MUNGERS,\n\t\t\t\tonType.getName());\n\t\tif (onType.isRawType() || onType.isParameterizedType()) {\n\t\t\tonType = onType.getGenericType();\n\t\t}\n\t\tfor (ConcreteTypeMunger m : typeMungerList) {\n\t\t\tif (!m.isLateMunger() && m.matches(onType)) {\n\t\t\t\tonType.addInterTypeMunger(m, false);\n\t\t\t}\n\t\t}\n\t\tCompilationAndWeavingContext.leavingPhase(tok);\n\t}\n\n\t// exposed for ClassLoader dynamic weaving\n\tpublic LazyClassGen weaveWithoutDump(UnwovenClassFile classFile, BcelObjectType classType) throws IOException {\n\t\treturn weave(classFile, classType, false);\n\t}\n\n\t// FOR TESTING\n\tLazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType) throws IOException {\n\t\tLazyClassGen ret = weave(classFile, classType, true);\n\t\treturn ret;\n\t}\n\n\tprivate LazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType, boolean dump) throws IOException {\n\n\t\ttry {\n\t\t\tif (classType.isSynthetic()) { // Don't touch synthetic classes\n\t\t\t\tif (dump) {\n\t\t\t\t\tdumpUnchanged(classFile);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tReferenceType resolvedClassType = classType.getResolvedTypeX();\n\n\t\t\tif (world.isXmlConfigured() && world.getXmlConfiguration().excludesType(resolvedClassType)) {\n\t\t\t\tif (!world.getMessageHandler().isIgnoring(IMessage.INFO)) {\n\t\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\t\tMessageUtil.info(\"Type '\" + resolvedClassType.getName()\n\t\t\t\t\t\t\t\t\t+ \"' not woven due to exclusion via XML weaver exclude section\"));\n\n\t\t\t\t}\n\t\t\t\tif (dump) {\n\t\t\t\t\tdumpUnchanged(classFile);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tList<ShadowMunger> shadowMungers = fastMatch(shadowMungerList, resolvedClassType);\n\t\t\tList<ConcreteTypeMunger> typeMungers = classType.getResolvedTypeX().getInterTypeMungers();\n\n\t\t\tresolvedClassType.checkInterTypeMungers();\n\n\t\t\t// Decide if we need to do actual weaving for this class\n\t\t\tboolean mightNeedToWeave = shadowMungers.size() > 0 || typeMungers.size() > 0 || classType.isAspect()\n\t\t\t\t\t|| world.getDeclareAnnotationOnMethods().size() > 0 || world.getDeclareAnnotationOnFields().size() > 0;\n\n\t\t\t// May need bridge methods if on 1.5 and something in our hierarchy is\n\t\t\t// affected by ITDs\n\t\t\tboolean mightNeedBridgeMethods = world.isInJava5Mode() && !classType.isInterface()\n\t\t\t\t\t&& resolvedClassType.getInterTypeMungersIncludingSupers().size() > 0;\n\n\t\t\tLazyClassGen clazz = null;\n\t\t\tif (mightNeedToWeave || mightNeedBridgeMethods) {\n\t\t\t\tclazz = classType.getLazyClassGen();\n\t\t\t\t// System.err.println(\"got lazy gen: \" + clazz + \", \" +\n\t\t\t\t// clazz.getWeaverState());\n\t\t\t\ttry {\n\t\t\t\t\tboolean isChanged = false;\n\n\t\t\t\t\tif (mightNeedToWeave) {\n\t\t\t\t\t\tisChanged = BcelClassWeaver.weave(world, clazz, shadowMungers, typeMungers, lateTypeMungerList,\n\t\t\t\t\t\t\t\tinReweavableMode);\n\t\t\t\t\t}\n\n\t\t\t\t\tcheckDeclareTypeErrorOrWarning(world, classType);\n\n\t\t\t\t\tif (mightNeedBridgeMethods) {\n\t\t\t\t\t\tisChanged = BcelClassWeaver.calculateAnyRequiredBridgeMethods(world, clazz) || isChanged;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isChanged) {\n\t\t\t\t\t\tif (dump) {\n\t\t\t\t\t\t\tdump(classFile, clazz);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn clazz;\n\t\t\t\t\t}\n\t\t\t\t} catch (RuntimeException re) {\n\t\t\t\t\tString classDebugInfo = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclassDebugInfo = clazz.toLongString();\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tnew RuntimeException(\"Crashed whilst crashing with this exception: \" + e, e).printStackTrace();\n\t\t\t\t\t\t// recover from crash whilst producing debug string\n\t\t\t\t\t\tclassDebugInfo = clazz.getClassName();\n\t\t\t\t\t}\n\t\t\t\t\tString messageText = \"trouble in: \\n\" + classDebugInfo;\n\t\t\t\t\tgetWorld().getMessageHandler().handleMessage(new Message(messageText, IMessage.ABORT, re, null));\n\t\t\t\t} catch (Error re) {\n\t\t\t\t\tString classDebugInfo = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclassDebugInfo = clazz.toLongString();\n\t\t\t\t\t} catch (OutOfMemoryError oome) {\n\t\t\t\t\t\tSystem.err.println(\"Ran out of memory creating debug info for an error\");\n\t\t\t\t\t\tre.printStackTrace(System.err);\n\t\t\t\t\t\t// recover from crash whilst producing debug string\n\t\t\t\t\t\tclassDebugInfo = clazz.getClassName();\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\t// recover from crash whilst producing debug string\n\t\t\t\t\t\tclassDebugInfo = clazz.getClassName();\n\t\t\t\t\t}\n\t\t\t\t\tString messageText = \"trouble in: \\n\" + classDebugInfo;\n\t\t\t\t\tgetWorld().getMessageHandler().handleMessage(new Message(messageText, IMessage.ABORT, re, null));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcheckDeclareTypeErrorOrWarning(world, classType);\n\t\t\t}\n\t\t\t// this is very odd return behavior trying to keep everyone happy\n\n\t\t\t// can we remove it from the model now? we know it contains no relationship endpoints...\n\t\t\tAsmManager model = world.getModelAsAsmManager();\n\t\t\tif (world.isMinimalModel() && model != null && !classType.isAspect()) {\n\t\t\t\tAspectJElementHierarchy hierarchy = (AspectJElementHierarchy) model.getHierarchy();\n\t\t\t\tString pkgname = classType.getResolvedTypeX().getPackageName();\n\t\t\t\tString tname = classType.getResolvedTypeX().getSimpleBaseName();\n\t\t\t\tIProgramElement typeElement = hierarchy.findElementForType(pkgname, tname);\n\t\t\t\tif (typeElement != null && hasInnerType(typeElement)) {\n\t\t\t\t\t// Cannot remove it right now (has inner type), schedule it\n\t\t\t\t\t// for possible deletion later if all inner types are\n\t\t\t\t\t// removed\n\t\t\t\t\tcandidatesForRemoval.add(typeElement);\n\t\t\t\t}\n\t\t\t\tif (typeElement != null && !hasInnerType(typeElement)) {\n\t\t\t\t\tIProgramElement parent = typeElement.getParent();\n\t\t\t\t\t// parent may have children: PACKAGE DECL, IMPORT-REFERENCE, TYPE_DECL\n\t\t\t\t\tif (parent != null) {\n\t\t\t\t\t\t// if it was the only type we should probably remove\n\t\t\t\t\t\t// the others too.\n\t\t\t\t\t\tparent.removeChild(typeElement);\n\t\t\t\t\t\tif (parent.getKind().isSourceFile()) {\n\t\t\t\t\t\t\tremoveSourceFileIfNoMoreTypeDeclarationsInside(hierarchy, typeElement, parent);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thierarchy.forget(null, typeElement);\n\t\t\t\t\t\t\t// At this point, the child has been removed. We\n\t\t\t\t\t\t\t// should now check if the parent is in our\n\t\t\t\t\t\t\t// 'candidatesForRemoval' set. If it is then that\n\t\t\t\t\t\t\t// means we were going to remove it but it had a\n\t\t\t\t\t\t\t// child. Now we can check if it still has a child -\n\t\t\t\t\t\t\t// if it doesn't it can also be removed!\n\n\t\t\t\t\t\t\twalkUpRemovingEmptyTypesAndPossiblyEmptySourceFile(hierarchy, tname, parent);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dump) {\n\t\t\t\tdumpUnchanged(classFile);\n\t\t\t\treturn clazz;\n\t\t\t} else {\n\t\t\t\t// ATAJ: the class was not weaved, but since it gets there early it\n\t\t\t\t// may have new generated inner classes\n\t\t\t\t// attached to it to support LTW perX aspectOf support (see\n\t\t\t\t// BcelPerClauseAspectAdder)\n\t\t\t\t// that aggressively defines the inner <aspect>$mayHaveAspect\n\t\t\t\t// interface.\n\t\t\t\tif (clazz != null && !clazz.getChildClasses(world).isEmpty()) {\n\t\t\t\t\treturn clazz;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} finally {\n\t\t\tworld.demote();\n\t\t}\n\t}\n\n\tprivate void walkUpRemovingEmptyTypesAndPossiblyEmptySourceFile(AspectJElementHierarchy hierarchy, String tname,\n\t\t\tIProgramElement typeThatHasChildRemoved) {\n\t\t// typeThatHasChildRemoved might be a source file, type or a method/ctor\n\t\t// - for a method/ctor find the type/sourcefile\n\t\twhile (typeThatHasChildRemoved != null\n\t\t\t\t&& !(typeThatHasChildRemoved.getKind().isType() || typeThatHasChildRemoved.getKind().isSourceFile())) {\n\t\t\t// this will take us 'up' through methods that contain anonymous\n\t\t\t// inner classes\n\t\t\ttypeThatHasChildRemoved = typeThatHasChildRemoved.getParent();\n\t\t}\n\t\t// now typeThatHasChildRemoved points to the type or sourcefile that has\n\t\t// had something removed\n\t\tif (candidatesForRemoval.contains(typeThatHasChildRemoved) && !hasInnerType(typeThatHasChildRemoved)) {\n\t\t\t// now we can get rid of it\n\t\t\tIProgramElement parent = typeThatHasChildRemoved.getParent();\n\t\t\tif (parent != null) {\n\t\t\t\tparent.removeChild(typeThatHasChildRemoved);\n\t\t\t\tcandidatesForRemoval.remove(typeThatHasChildRemoved);\n\t\t\t\tif (parent.getKind().isSourceFile()) {\n\t\t\t\t\tremoveSourceFileIfNoMoreTypeDeclarationsInside(hierarchy, typeThatHasChildRemoved, parent);\n\t\t\t\t\t// System.out.println(\"Removed on second pass: \" +\n\t\t\t\t\t// typeThatHasChildRemoved.getName());\n\t\t\t\t} else {\n\t\t\t\t\t// System.out.println(\"On later pass, parent of type \" +\n\t\t\t\t\t// typeThatHasChildRemoved.getName()\n\t\t\t\t\t// + \" was found not to be a sourcefile, recursing up...\");\n\t\t\t\t\twalkUpRemovingEmptyTypesAndPossiblyEmptySourceFile(hierarchy, tname, parent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void removeSourceFileIfNoMoreTypeDeclarationsInside(AspectJElementHierarchy hierarchy, IProgramElement typeElement,\n\t\t\tIProgramElement sourceFileNode) {\n\t\tIProgramElement compilationUnit = sourceFileNode;\n\t\tboolean anyOtherTypeDeclarations = false;\n\t\tfor (IProgramElement child : compilationUnit.getChildren()) {\n\t\t\tIProgramElement.Kind k = child.getKind();\n\t\t\tif (k.isType()) {\n\t\t\t\tanyOtherTypeDeclarations = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// If the compilation unit node contained no\n\t\t// other types, there is no need to keep it\n\t\tif (!anyOtherTypeDeclarations) {\n\t\t\tIProgramElement cuParent = compilationUnit.getParent();\n\t\t\tif (cuParent != null) {\n\t\t\t\tcompilationUnit.setParent(null);\n\t\t\t\tcuParent.removeChild(compilationUnit);\n\t\t\t}\n\t\t\t// need to update some caches and structures too?\n\t\t\thierarchy.forget(sourceFileNode, typeElement);\n\t\t} else {\n\t\t\thierarchy.forget(null, typeElement);\n\t\t}\n\t}\n\n\t// ---- writing\n\n\t// TODO could be smarter - really only matters if inner type has been woven, but there is a chance we haven't woven it *yet*\n\tprivate boolean hasInnerType(IProgramElement typeNode) {\n\t\tfor (IProgramElement child : typeNode.getChildren()) {\n\t\t\tIProgramElement.Kind kind = child.getKind();\n\t\t\tif (kind.isType()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// if (kind == IProgramElement.Kind.ASPECT) {\n\t\t\t// return true;\n\t\t\t// }\n\t\t\tif (kind.isType() || kind == IProgramElement.Kind.METHOD || kind == IProgramElement.Kind.CONSTRUCTOR) {\n\t\t\t\tboolean b = hasInnerType(child);\n\t\t\t\tif (b) {\n\t\t\t\t\treturn b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void checkDeclareTypeErrorOrWarning(BcelWorld world2, BcelObjectType classType) {\n\t\tList<DeclareTypeErrorOrWarning> dteows = world.getDeclareTypeEows();\n\t\tfor (DeclareTypeErrorOrWarning dteow : dteows) {\n\t\t\tif (dteow.getTypePattern().matchesStatically(classType.getResolvedTypeX())) {\n\t\t\t\tif (dteow.isError()) {\n\t\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\t\tMessageUtil.error(dteow.getMessage(), classType.getResolvedTypeX().getSourceLocation()));\n\t\t\t\t} else {\n\t\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\t\tMessageUtil.warn(dteow.getMessage(), classType.getResolvedTypeX().getSourceLocation()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void dumpUnchanged(UnwovenClassFile classFile) throws IOException {\n\t\tif (zipOutputStream != null) {\n\t\t\twriteZipEntry(getEntryName(classFile.getJavaClass().getClassName()), classFile.getBytes());\n\t\t} else {\n\t\t\tclassFile.writeUnchangedBytes();\n\t\t}\n\t}\n\n\tprivate String getEntryName(String className) {\n\t\t// XXX what does bcel's getClassName do for inner names\n\t\treturn className.replace('.', '/') + \".class\";\n\t}\n\n\tprivate void dump(UnwovenClassFile classFile, LazyClassGen clazz) throws IOException {\n\t\tif (zipOutputStream != null) {\n\t\t\tString mainClassName = classFile.getJavaClass().getClassName();\n\t\t\twriteZipEntry(getEntryName(mainClassName), clazz.getJavaClass(world).getBytes());\n\t\t\tList<UnwovenClassFile.ChildClass> childClasses = clazz.getChildClasses(world);\n\t\t\tif (!childClasses.isEmpty()) {\n\t\t\t\tfor (UnwovenClassFile.ChildClass c : childClasses) {\n\t\t\t\t\twriteZipEntry(getEntryName(mainClassName + \"$\" + c.name), c.bytes);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tclassFile.writeWovenBytes(clazz.getJavaClass(world).getBytes(), clazz.getChildClasses(world));\n\t\t}\n\t}\n\n\tprivate void writeZipEntry(String name, byte[] bytes) throws IOException {\n\t\tZipEntry newEntry = new ZipEntry(name); // ??? get compression scheme\n\t\t// right\n\n\t\tzipOutputStream.putNextEntry(newEntry);\n\t\tzipOutputStream.write(bytes);\n\t\tzipOutputStream.closeEntry();\n\t}\n\n\t/**\n\t * Perform a fast match of the specified list of shadowmungers against the specified type. A subset of those that might match is\n\t * returned.\n\t *\n\t * @param list list of all shadow mungers that might match\n\t * @param type the target type\n\t * @return a list of shadow mungers that might match with those that cannot (according to fast match rules) removed\n\t */\n\tprivate List<ShadowMunger> fastMatch(List<ShadowMunger> list, ResolvedType type) {\n\t\tif (list == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tboolean isOverweaving = world.isOverWeaving();\n\t\tWeaverStateInfo typeWeaverState = (isOverweaving ? type.getWeaverState() : null);\n\n\t\t// here we do the coarsest grained fast match with no kind constraints\n\t\t// this will remove all obvious non-matches and see if we need to do any\n\t\t// weaving\n\t\tFastMatchInfo info = new FastMatchInfo(type, null, world);\n\n\t\tList<ShadowMunger> result = new ArrayList<>();\n\n\t\tif (world.areInfoMessagesEnabled() && world.isTimingEnabled()) {\n\t\t\tfor (ShadowMunger munger : list) {\n\t\t\t\tif (typeWeaverState != null) { // will only be null if overweaving is ON and there is weaverstate\n\t\t\t\t\tResolvedType declaringAspect = munger.getDeclaringType();\n\t\t\t\t\tif (typeWeaverState.isAspectAlreadyApplied(declaringAspect)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPointcut pointcut = munger.getPointcut();\n\t\t\t\tlong starttime = System.nanoTime();\n\t\t\t\tFuzzyBoolean fb = pointcut.fastMatch(info);\n\t\t\t\tlong endtime = System.nanoTime();\n\t\t\t\tworld.recordFastMatch(pointcut, endtime - starttime);\n\t\t\t\tif (fb.maybeTrue()) {\n\t\t\t\t\tresult.add(munger);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (ShadowMunger munger : list) {\n\t\t\t\tif (typeWeaverState != null) { // will only be null if overweaving is ON and there is weaverstate\n\t\t\t\t\tResolvedType declaringAspect = munger.getConcreteAspect();// getDeclaringType();\n\t\t\t\t\tif (typeWeaverState.isAspectAlreadyApplied(declaringAspect)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tPointcut pointcut = munger.getPointcut();\n\t\t\t\tFuzzyBoolean fb = pointcut.fastMatch(info);\n\t\t\t\tif (fb.maybeTrue()) {\n\t\t\t\t\tresult.add(munger);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic void setReweavableMode(boolean xNotReweavable) {\n\t\tinReweavableMode = !xNotReweavable;\n\t\tWeaverStateInfo.setReweavableModeDefaults(!xNotReweavable, false, true);\n\t}\n\n\tpublic boolean isReweavable() {\n\t\treturn inReweavableMode;\n\t}\n\n\tpublic World getWorld() {\n\t\treturn world;\n\t}\n\n\tpublic void tidyUp() {\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.enter(\"tidyUp\", this);\n\t\t}\n\t\tshadowMungerList = null; // setup by prepareForWeave\n\t\ttypeMungerList = null; // setup by prepareForWeave\n\t\tlateTypeMungerList = null; // setup by prepareForWeave\n\t\tdeclareParentsList = null; // setup by prepareForWeave\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.exit(\"tidyUp\");\n\t\t}\n\t}\n\n\tpublic void write(CompressingDataOutputStream dos) throws IOException {\n\t\txcutSet.write(dos);\n\t}\n\n\t// only called for testing\n\tpublic void setShadowMungers(List<ShadowMunger> shadowMungers) {\n\t\tshadowMungerList = shadowMungers;\n\t}\n}\n",
    "size": 77042
  },
  {
    "file_id": "F28",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelWeavingSupport.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Andy Clement     initial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.ConcreteTypeMunger;\nimport org.aspectj.weaver.IWeavingSupport;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ResolvedTypeMunger;\nimport org.aspectj.weaver.ast.Var;\nimport org.aspectj.weaver.patterns.PerClause;\nimport org.aspectj.weaver.patterns.Pointcut;\n\n/**\n * Bcel implementation of the weaving support required in a BcelWorld which will actually modify bytecode.\n *\n * @author Andy Clement\n */\npublic class BcelWeavingSupport implements IWeavingSupport {\n\n\tpublic Advice createAdviceMunger(AjAttribute.AdviceAttribute attribute, Pointcut pointcut, Member signature,\n\t\t\tResolvedType concreteAspect) {\n\t\t// System.err.println(\"concrete advice: \" + signature + \" context \" +\n\t\t// sourceContext);\n\t\treturn new BcelAdvice(attribute, pointcut, signature, concreteAspect);\n\t}\n\n\tpublic ConcreteTypeMunger makeCflowStackFieldAdder(ResolvedMember cflowField) {\n\t\treturn new BcelCflowStackFieldAdder(cflowField);\n\t}\n\n\tpublic ConcreteTypeMunger makeCflowCounterFieldAdder(ResolvedMember cflowField) {\n\t\treturn new BcelCflowCounterFieldAdder(cflowField);\n\t}\n\n\t/**\n\t * Register a munger for perclause @AJ aspect so that we add aspectOf(..) to them as needed\n\t *\n\t * @param aspect\n\t * @param kind\n\t * @return munger\n\t */\n\tpublic ConcreteTypeMunger makePerClauseAspect(ResolvedType aspect, PerClause.Kind kind) {\n\t\treturn new BcelPerClauseAspectAdder(aspect, kind);\n\t}\n\n\tpublic Var makeCflowAccessVar(ResolvedType formalType, Member cflowField, int arrayIndex) {\n\t\treturn new BcelCflowAccessVar(formalType, cflowField, arrayIndex);\n\t}\n\n\tpublic ConcreteTypeMunger concreteTypeMunger(ResolvedTypeMunger munger, ResolvedType aspectType) {\n\t\treturn new BcelTypeMunger(munger, aspectType);\n\t}\n\n\tpublic ConcreteTypeMunger createAccessForInlineMunger(ResolvedType aspect) {\n\t\treturn new BcelAccessForInlineMunger(aspect);\n\t}\n\n}\n",
    "size": 2547
  },
  {
    "file_id": "F29",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/BcelWorld.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n *     Alexandre Vasseur    perClause support for @AJ aspects\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Modifier;\nimport java.net.MalformedURLException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.ClassParser;\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.apache.bcel.generic.FieldInstruction;\nimport org.aspectj.apache.bcel.generic.INVOKEINTERFACE;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InvokeInstruction;\nimport org.aspectj.apache.bcel.generic.MULTIANEWARRAY;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.apache.bcel.util.ClassLoaderReference;\nimport org.aspectj.apache.bcel.util.ClassLoaderRepository;\nimport org.aspectj.apache.bcel.util.ClassPath;\nimport org.aspectj.apache.bcel.util.NonCachingClassLoaderRepository;\nimport org.aspectj.apache.bcel.util.Repository;\nimport org.aspectj.asm.AsmManager;\nimport org.aspectj.asm.IRelationship;\nimport org.aspectj.asm.internal.CharOperation;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.bridge.Message;\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.bridge.WeaveMessage;\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.AnnotationOnTypeMunger;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.Checker;\nimport org.aspectj.weaver.ICrossReferenceHandler;\nimport org.aspectj.weaver.IWeavingSupport;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.MemberImpl;\nimport org.aspectj.weaver.MemberKind;\nimport org.aspectj.weaver.NewParentTypeMunger;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ReferenceTypeDelegate;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedMemberImpl;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ResolvedTypeMunger;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.loadtime.definition.Definition;\nimport org.aspectj.weaver.loadtime.definition.DocumentParser;\nimport org.aspectj.weaver.model.AsmRelationshipProvider;\nimport org.aspectj.weaver.patterns.DeclareAnnotation;\nimport org.aspectj.weaver.patterns.DeclareParents;\nimport org.aspectj.weaver.patterns.ParserException;\nimport org.aspectj.weaver.patterns.PatternParser;\nimport org.aspectj.weaver.patterns.TypePattern;\nimport org.aspectj.weaver.tools.Trace;\nimport org.aspectj.weaver.tools.TraceFactory;\n\npublic class BcelWorld extends World implements Repository {\n\n\tprivate final ClassPathManager classPath;\n\tprotected Repository delegate;\n\tprivate BcelWeakClassLoaderReference loaderRef;\n\tprivate final BcelWeavingSupport bcelWeavingSupport = new BcelWeavingSupport();\n\tprivate boolean isXmlConfiguredWorld = false;\n\tprivate WeavingXmlConfig xmlConfiguration;\n\tprivate List<TypeDelegateResolver> typeDelegateResolvers;\n\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelWorld.class);\n\n\tpublic BcelWorld() {\n\t\tthis(\"\");\n\t}\n\n\tpublic BcelWorld(String cp) {\n\t\tthis(makeDefaultClasspath(cp), IMessageHandler.THROW, null);\n\t}\n\n\tpublic IRelationship.Kind determineRelKind(ShadowMunger munger) {\n\t\tAdviceKind ak = ((Advice) munger).getKind();\n\t\tif (ak.getKey() == AdviceKind.Before.getKey()) {\n\t\t\treturn IRelationship.Kind.ADVICE_BEFORE;\n\t\t} else if (ak.getKey() == AdviceKind.After.getKey()) {\n\t\t\treturn IRelationship.Kind.ADVICE_AFTER;\n\t\t} else if (ak.getKey() == AdviceKind.AfterThrowing.getKey()) {\n\t\t\treturn IRelationship.Kind.ADVICE_AFTERTHROWING;\n\t\t} else if (ak.getKey() == AdviceKind.AfterReturning.getKey()) {\n\t\t\treturn IRelationship.Kind.ADVICE_AFTERRETURNING;\n\t\t} else if (ak.getKey() == AdviceKind.Around.getKey()) {\n\t\t\treturn IRelationship.Kind.ADVICE_AROUND;\n\t\t} else if (ak.getKey() == AdviceKind.CflowEntry.getKey() || ak.getKey() == AdviceKind.CflowBelowEntry.getKey()\n\t\t\t\t|| ak.getKey() == AdviceKind.InterInitializer.getKey() || ak.getKey() == AdviceKind.PerCflowEntry.getKey()\n\t\t\t\t|| ak.getKey() == AdviceKind.PerCflowBelowEntry.getKey() || ak.getKey() == AdviceKind.PerThisEntry.getKey()\n\t\t\t\t|| ak.getKey() == AdviceKind.PerTargetEntry.getKey() || ak.getKey() == AdviceKind.Softener.getKey()\n\t\t\t\t|| ak.getKey() == AdviceKind.PerTypeWithinEntry.getKey()) {\n\t\t\t// System.err.println(\"Dont want a message about this: \"+ak);\n\t\t\treturn null;\n\t\t}\n\t\tthrow new RuntimeException(\"Shadow.determineRelKind: What the hell is it? \" + ak);\n\t}\n\n\t@Override\n\tpublic void reportMatch(ShadowMunger munger, Shadow shadow) {\n\t\tif (getCrossReferenceHandler() != null) {\n\t\t\tfinal IRelationship.Kind kind = determineRelKind(munger);\n\t\t\tgetCrossReferenceHandler().addCrossReference(\n\t\t\t\tmunger.getSourceLocation(),           // What is being applied?\n\t\t\t\tshadow.getSourceLocation(),           // Where is it being applied?\n\t\t\t\tkind == null ? null : kind.getName(), // What kind of advice?\n\t\t\t\t((Advice) munger).hasDynamicTests()   // Is a runtime test being stuffed in the code?\n\t\t\t);\n\t\t}\n\n\t\tif (!getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {\n\t\t\treportWeavingMessage(munger, shadow);\n\t\t}\n\n\t\tif (getModel() != null) {\n\t\t\tAsmRelationshipProvider.addAdvisedRelationship(getModelAsAsmManager(), shadow, munger);\n\t\t}\n\t}\n\n\t/*\n\t * Report a message about the advice weave that has occurred. Some messing about to make it pretty ! This code is just asking\n\t * for an NPE to occur ...\n\t */\n\tprivate void reportWeavingMessage(ShadowMunger munger, Shadow shadow) {\n\t\tAdvice advice = (Advice) munger;\n\t\tAdviceKind aKind = advice.getKind();\n\t\t// Only report on interesting advice kinds ...\n\t\tif (aKind == null || advice.getConcreteAspect() == null) {\n\t\t\t// We suspect someone is programmatically driving the weaver\n\t\t\t// (e.g. IdWeaveTestCase in the weaver testcases)\n\t\t\treturn;\n\t\t}\n\t\tif (!(aKind.equals(AdviceKind.Before) || aKind.equals(AdviceKind.After) || aKind.equals(AdviceKind.AfterReturning)\n\t\t\t\t|| aKind.equals(AdviceKind.AfterThrowing) || aKind.equals(AdviceKind.Around) || aKind.equals(AdviceKind.Softener))) {\n\t\t\treturn;\n\t\t}\n\n\t\t// synchronized blocks are implemented with multiple monitor_exit instructions in the bytecode\n\t\t// (one for normal exit from the method, one for abnormal exit), we only want to tell the user\n\t\t// once we have advised the end of the sync block, even though under the covers we will have\n\t\t// woven both exit points\n\t\tif (shadow.getKind() == Shadow.SynchronizationUnlock) {\n\t\t\tif (advice.lastReportedMonitorExitJoinpointLocation == null) {\n\t\t\t\t// this is the first time through, let's continue...\n\t\t\t\tadvice.lastReportedMonitorExitJoinpointLocation = shadow.getSourceLocation();\n\t\t\t} else {\n\t\t\t\tif (areTheSame(shadow.getSourceLocation(), advice.lastReportedMonitorExitJoinpointLocation)) {\n\t\t\t\t\t// Don't report it again!\n\t\t\t\t\tadvice.lastReportedMonitorExitJoinpointLocation = null;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// hmmm, this means some kind of nesting is going on, urgh\n\t\t\t\tadvice.lastReportedMonitorExitJoinpointLocation = shadow.getSourceLocation();\n\t\t\t}\n\t\t}\n\n\t\tString description = advice.getKind().toString();\n\t\tString advisedType = shadow.getEnclosingType().getName();\n\t\tString advisingType = advice.getConcreteAspect().getName();\n\t\tMessage msg = null;\n\t\tif (advice.getKind().equals(AdviceKind.Softener)) {\n\t\t\tmsg = WeaveMessage.constructWeavingMessage(\n\t\t\t\tWeaveMessage.WEAVEMESSAGE_SOFTENS,\n\t\t\t\tnew String[] {\n\t\t\t\t\tadvisedType, beautifyLocation(shadow.getSourceLocation()),\n\t\t\t\t\tadvisingType, beautifyLocation(munger.getSourceLocation())\n\t\t\t\t},\n\t\t\t\tadvisedType, advisingType,\n\t\t\t\tshadow.getSourceLocation(), munger.getSourceLocation()\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tboolean runtimeTest = advice.hasDynamicTests();\n\t\t\tString joinPointDescription = shadow.toString();\n\t\t\tmsg = WeaveMessage.constructWeavingMessage(\n\t\t\t\tWeaveMessage.WEAVEMESSAGE_ADVISES,\n\t\t\t\tnew String[] {\n\t\t\t\t\tjoinPointDescription,\n\t\t\t\t\tadvisedType, beautifyLocation(shadow.getSourceLocation()),\n\t\t\t\t\tdescription,\n\t\t\t\t\tadvisingType, beautifyLocation(munger.getSourceLocation()),\n\t\t\t\t\t(runtimeTest ? \" [with runtime test]\" : \"\")\n\t\t\t\t},\n\t\t\t\tadvisedType, advisingType,\n\t\t\t\tshadow.getSourceLocation(), munger.getSourceLocation()\n\t\t\t);\n\t\t\t// Boolean.toString(runtimeTest)});\n\t\t}\n\t\tgetMessageHandler().handleMessage(msg);\n\t}\n\n\tprivate boolean areTheSame(ISourceLocation locA, ISourceLocation locB) {\n\t\tif (locA == null) {\n\t\t\treturn locB == null;\n\t\t}\n\t\tif (locB == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (locA.getLine() != locB.getLine()) {\n\t\t\treturn false;\n\t\t}\n\t\tFile fA = locA.getSourceFile();\n\t\tFile fB = locA.getSourceFile();\n\t\tif (fA == null) {\n\t\t\treturn fB == null;\n\t\t}\n\t\tif (fB == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn fA.getName().equals(fB.getName());\n\t}\n\n\t/*\n\t * Ensure we report a nice source location - particular in the case where the source info is missing (binary weave).\n\t */\n\tprivate String beautifyLocation(ISourceLocation isl) {\n\t\tStringBuilder nice = new StringBuilder();\n\t\tif (isl == null || isl.getSourceFile() == null || isl.getSourceFile().getName().contains(\"no debug info available\")) {\n\t\t\tnice.append(\"no debug info available\");\n\t\t} else {\n\t\t\t// can't use File.getName() as this fails when a Linux box encounters a path created on Windows and vice-versa\n\t\t\tint takeFrom = isl.getSourceFile().getPath().lastIndexOf('/');\n\t\t\tif (takeFrom == -1) {\n\t\t\t\ttakeFrom = isl.getSourceFile().getPath().lastIndexOf('\\\\');\n\t\t\t}\n\t\t\tint binary = isl.getSourceFile().getPath().lastIndexOf('!');\n\t\t\tif (binary != -1 && binary < takeFrom) {\n\t\t\t\t// we have been woven by a binary aspect\n\t\t\t\tString pathToBinaryLoc = isl.getSourceFile().getPath().substring(0, binary + 1);\n\t\t\t\tif (pathToBinaryLoc.contains(\".jar\")) {\n\t\t\t\t\t// only want to add the extra info if we're from a jar file\n\t\t\t\t\tint lastSlash = pathToBinaryLoc.lastIndexOf('/');\n\t\t\t\t\tif (lastSlash == -1) {\n\t\t\t\t\t\tlastSlash = pathToBinaryLoc.lastIndexOf('\\\\');\n\t\t\t\t\t}\n\t\t\t\t\tnice.append(pathToBinaryLoc.substring(lastSlash + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tnice.append(isl.getSourceFile().getPath().substring(takeFrom + 1));\n\t\t\tif (isl.getLine() != 0) {\n\t\t\t\tnice.append(\":\").append(isl.getLine());\n\t\t\t}\n\t\t\t// if it's a binary file then also want to give the file name\n\t\t\tif (isl.getSourceFileName() != null) {\n\t\t\t\tnice.append(\"(from \").append(isl.getSourceFileName()).append(\")\");\n\t\t\t}\n\t\t}\n\t\treturn nice.toString();\n\t}\n\n\tprivate static List<String> makeDefaultClasspath(String cp) {\n\t\tList<String> classPath = new ArrayList<>();\n\t\tclassPath.addAll(getPathEntries(cp));\n\t\tclassPath.addAll(getPathEntries(ClassPath.getClassPath()));\n\t\treturn classPath;\n\n\t}\n\n\tprivate static List<String> getPathEntries(String s) {\n\t\tList<String> ret = new ArrayList<>();\n\t\tStringTokenizer tok = new StringTokenizer(s, File.pathSeparator);\n\t\twhile (tok.hasMoreTokens()) {\n\t\t\tret.add(tok.nextToken());\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic BcelWorld(List classPath, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {\n\t\t// this.aspectPath = new ClassPathManager(aspectPath, handler);\n\t\tthis.classPath = new ClassPathManager(classPath, handler);\n\t\tsetMessageHandler(handler);\n\t\tsetCrossReferenceHandler(xrefHandler);\n\t\t// Tell BCEL to use us for resolving any classes\n\t\tdelegate = this;\n\t}\n\n\tpublic BcelWorld(ClassPathManager cpm, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {\n\t\tclassPath = cpm;\n\t\tsetMessageHandler(handler);\n\t\tsetCrossReferenceHandler(xrefHandler);\n\t\t// Tell BCEL to use us for resolving any classes\n\t\tdelegate = this;\n\t}\n\n\t/**\n\t * Build a World from a ClassLoader, for LTW support\n\t *\n\t * @param loader\n\t * @param handler\n\t * @param xrefHandler\n\t */\n\tpublic BcelWorld(ClassLoader loader, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {\n\t\tclassPath = null;\n\t\tloaderRef = new BcelWeakClassLoaderReference(loader);\n\t\tsetMessageHandler(handler);\n\t\tsetCrossReferenceHandler(xrefHandler);\n\t\t// Tell BCEL to use us for resolving any classes\n\t\t// delegate = getClassLoaderRepositoryFor(loader);\n\t}\n\n\tpublic void ensureRepositorySetup() {\n\t\tif (delegate == null) {\n\t\t\tdelegate = getClassLoaderRepositoryFor(loaderRef);\n\t\t}\n\t}\n\n\tpublic Repository getClassLoaderRepositoryFor(ClassLoaderReference loader) {\n\t\tif (bcelRepositoryCaching) {\n\t\t\treturn new ClassLoaderRepository(loader);\n\t\t} else {\n\t\t\treturn new NonCachingClassLoaderRepository(loader);\n\t\t}\n\t}\n\n\tpublic void addPath(String name) {\n\t\tclassPath.addPath(name, this.getMessageHandler());\n\t}\n\n\t// ---- various interactions with bcel\n\n\tpublic static Type makeBcelType(UnresolvedType type) {\n\t\treturn Type.getType(type.getErasureSignature());\n\t}\n\n\tstatic Type[] makeBcelTypes(UnresolvedType[] types) {\n\t\tType[] ret = new Type[types.length];\n\t\tfor (int i = 0, len = types.length; i < len; i++) {\n\t\t\tret[i] = makeBcelType(types[i]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static Type[] makeBcelTypes(String[] types) {\n\t\tif (types == null || types.length==0 ) {\n\t\t\treturn null;\n\t\t}\n\t\tType[] ret = new Type[types.length];\n\t\tfor (int i=0, len=types.length; i<len; i++) {\n\t\t\tret[i] = makeBcelType(types[i]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static Type makeBcelType(String type) {\n\t\treturn Type.getType(type);\n\t}\n\n\n\tstatic String[] makeBcelTypesAsClassNames(UnresolvedType[] types) {\n\t\tString[] ret = new String[types.length];\n\t\tfor (int i = 0, len = types.length; i < len; i++) {\n\t\t\tret[i] = types[i].getName();\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static UnresolvedType fromBcel(Type t) {\n\t\treturn UnresolvedType.forSignature(t.getSignature());\n\t}\n\n\tstatic UnresolvedType[] fromBcel(Type[] ts) {\n\t\tUnresolvedType[] ret = new UnresolvedType[ts.length];\n\t\tfor (int i = 0, len = ts.length; i < len; i++) {\n\t\t\tret[i] = fromBcel(ts[i]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic ResolvedType resolve(Type t) {\n\t\treturn resolve(fromBcel(t));\n\t}\n\n\t@Override\n\tprotected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {\n\t\tString name = ty.getName();\n\t\tensureAdvancedConfigurationProcessed();\n\t\tJavaClass jc = lookupJavaClass(classPath, name);\n\t\tif (jc == null) {\n\t\t\t// Anyone else to ask?\n\t\t\tif (typeDelegateResolvers != null) {\n\t\t\t\tfor (TypeDelegateResolver tdr : typeDelegateResolvers) {\n\t\t\t\t\tReferenceTypeDelegate delegate = tdr.getDelegate(ty);\n\t\t\t\t\tif (delegate != null) {\n\t\t\t\t\t\treturn delegate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn buildBcelDelegate(ty, jc, false, false);\n\t\t}\n\t}\n\n\tpublic BcelObjectType buildBcelDelegate(ReferenceType type, JavaClass jc, boolean artificial, boolean exposedToWeaver) {\n\t\tBcelObjectType ret = new BcelObjectType(type, jc, artificial, exposedToWeaver);\n\t\treturn ret;\n\t}\n\n\tprivate JavaClass lookupJavaClass(ClassPathManager classPath, String name) {\n\t\tif (classPath == null) {\n\t\t\ttry {\n\t\t\t\tensureRepositorySetup();\n\t\t\t\tJavaClass jc = delegate.loadClass(name);\n\t\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\t\ttrace.event(\"lookupJavaClass\", this, new Object[] { name, jc });\n\t\t\t\t}\n\t\t\t\treturn jc;\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\t\ttrace.error(\"Unable to find class '\" + name + \"' in repository\", e);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tClassPathManager.ClassFile file = null;\n\t\ttry {\n\t\t\tfile = classPath.find(UnresolvedType.forName(name));\n\t\t\tif (file == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tClassParser parser = new ClassParser(file.getInputStream(), file.getPath());\n\t\t\tJavaClass jc = parser.parse();\n\t\t\treturn jc;\n\t\t} catch (IOException ioe) {\n\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\ttrace.error(\"IOException whilst processing class\",ioe);\n\t\t\t}\n\t\t\treturn null;\n\t\t} finally {\n\t\t\tif (file != null) {\n\t\t\t\tfile.close();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic BcelObjectType addSourceObjectType(JavaClass jc, boolean artificial) {\n\t\treturn addSourceObjectType(jc.getClassName(), jc, artificial);\n\t}\n\n\tpublic BcelObjectType addSourceObjectType(String classname, JavaClass jc, boolean artificial) {\n\t\tBcelObjectType ret = null;\n\t\tif (!jc.getClassName().equals(classname)) {\n\t\t\tthrow new RuntimeException(jc.getClassName() + \"!=\" + classname);\n\t\t}\n\t\tString signature = UnresolvedType.forName(jc.getClassName()).getSignature();\n\n\t\tResolvedType resolvedTypeFromTypeMap = typeMap.get(signature);\n\n\t\tif (resolvedTypeFromTypeMap != null && !(resolvedTypeFromTypeMap instanceof ReferenceType)) {\n\t\t\t// what on earth is it then? See pr 112243\n\t\t\tStringBuilder exceptionText = new StringBuilder();\n\t\t\texceptionText.append(\"Found invalid (not a ReferenceType) entry in the type map. \");\n\t\t\texceptionText.append(\"Signature=[\" + signature + \"] Found=[\" + resolvedTypeFromTypeMap + \"] Class=[\" + resolvedTypeFromTypeMap.getClass() + \"]\");\n\t\t\tthrow new BCException(exceptionText.toString());\n\t\t}\n\n\t\tReferenceType referenceTypeFromTypeMap = (ReferenceType) resolvedTypeFromTypeMap;\n\n\t\tif (referenceTypeFromTypeMap == null) {\n\t\t\tif (jc.isGeneric() && isInJava5Mode()) {\n\t\t\t\tReferenceType rawType = ReferenceType.fromTypeX(UnresolvedType.forRawTypeName(jc.getClassName()), this);\n\t\t\t\tret = buildBcelDelegate(rawType, jc, artificial, true);\n\t\t\t\tReferenceType genericRefType = new ReferenceType(UnresolvedType.forGenericTypeSignature(signature,\n\t\t\t\t\t\tret.getDeclaredGenericSignature()), this);\n\t\t\t\trawType.setDelegate(ret);\n\t\t\t\tgenericRefType.setDelegate(ret);\n\t\t\t\trawType.setGenericType(genericRefType);\n\t\t\t\ttypeMap.put(signature, rawType);\n\t\t\t} else {\n\t\t\t\treferenceTypeFromTypeMap = new ReferenceType(signature, this);\n\t\t\t\tret = buildBcelDelegate(referenceTypeFromTypeMap, jc, artificial, true);\n\t\t\t\ttypeMap.put(signature, referenceTypeFromTypeMap);\n\t\t\t}\n\t\t} else {\n\t\t\tret = buildBcelDelegate(referenceTypeFromTypeMap, jc, artificial, true);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic BcelObjectType addSourceObjectType(String classname, byte[] bytes, boolean artificial) {\n\t\tBcelObjectType retval = null;\n\t\tString signature = UnresolvedType.forName(classname).getSignature();\n\t\tResolvedType resolvedTypeFromTypeMap = typeMap.get(signature);\n\n\t\tif (resolvedTypeFromTypeMap != null && !(resolvedTypeFromTypeMap instanceof ReferenceType)) {\n\t\t\t// what on earth is it then? See pr 112243\n\t\t\tStringBuilder exceptionText = new StringBuilder();\n\t\t\texceptionText.append(\"Found invalid (not a ReferenceType) entry in the type map. \");\n\t\t\texceptionText.append(\"Signature=[\" + signature + \"] Found=[\" + resolvedTypeFromTypeMap + \"] Class=[\" + resolvedTypeFromTypeMap.getClass() + \"]\");\n\t\t\tthrow new BCException(exceptionText.toString());\n\t\t}\n\n\t\tReferenceType referenceTypeFromTypeMap = (ReferenceType) resolvedTypeFromTypeMap;\n\n\t\tif (referenceTypeFromTypeMap == null) {\n\t\t\tJavaClass jc = Utility.makeJavaClass(classname, bytes);\n\t\t\tif (jc.isGeneric() && isInJava5Mode()) {\n\t\t\t\treferenceTypeFromTypeMap = ReferenceType.fromTypeX(UnresolvedType.forRawTypeName(jc.getClassName()), this);\n\t\t\t\tretval = buildBcelDelegate(referenceTypeFromTypeMap, jc, artificial, true);\n\t\t\t\tReferenceType genericRefType = new ReferenceType(UnresolvedType.forGenericTypeSignature(signature,\n\t\t\t\t\t\tretval.getDeclaredGenericSignature()), this);\n\t\t\t\treferenceTypeFromTypeMap.setDelegate(retval);\n\t\t\t\tgenericRefType.setDelegate(retval);\n\t\t\t\treferenceTypeFromTypeMap.setGenericType(genericRefType);\n\t\t\t\ttypeMap.put(signature, referenceTypeFromTypeMap);\n\t\t\t} else {\n\t\t\t\treferenceTypeFromTypeMap = new ReferenceType(signature, this);\n\t\t\t\tretval = buildBcelDelegate(referenceTypeFromTypeMap, jc, artificial, true);\n\t\t\t\ttypeMap.put(signature, referenceTypeFromTypeMap);\n\t\t\t}\n\t\t} else {\n\t\t\tReferenceTypeDelegate existingDelegate = referenceTypeFromTypeMap.getDelegate();\n\t\t\tif (!(existingDelegate instanceof BcelObjectType)) {\n\t\t\t\tthrow new IllegalStateException(\"For \" + classname + \" should be BcelObjectType, but is \" + existingDelegate.getClass());\n\t\t\t}\n\t\t\tretval = (BcelObjectType) existingDelegate;\n\t\t\t// Note1: If the type is already exposed to the weaver (retval.isExposedToWeaver()) then this is likely\n\t\t\t// to be a hotswap reweave so build a new delegate, don't accidentally use the old data.\n\t\t\t// Note2: Also seen when LTW and another agent precedes the AspectJ agent.  Earlier in LTW\n\t\t\t// a type is resolved (and ends up in the typemap but not exposed to the weaver at that time)\n\t\t\t// then later LTW actually is attempted on this type. We end up here with different\n\t\t\t// bytes to the current delegate if the earlier agent has modified them. See PR488216\n//\t\t\tif (retval.isArtificial() || retval.isExposedToWeaver()) {\n\t\t\tretval = buildBcelDelegate(referenceTypeFromTypeMap, Utility.makeJavaClass(classname, bytes), artificial, true);\n//\t\t\t}\n\t\t}\n\t\treturn retval;\n\t}\n\n\tvoid deleteSourceObjectType(UnresolvedType ty) {\n\t\ttypeMap.remove(ty.getSignature());\n\t}\n\n\tpublic static Member makeFieldJoinPointSignature(LazyClassGen cg, FieldInstruction fi) {\n\t\tConstantPool cpg = cg.getConstantPool();\n\t\treturn MemberImpl.field(fi.getClassName(cpg),\n\t\t\t\t(fi.opcode == Constants.GETSTATIC || fi.opcode == Constants.PUTSTATIC) ? Modifier.STATIC : 0, fi.getName(cpg),\n\t\t\t\tfi.getSignature(cpg));\n\t}\n\n\tpublic Member makeJoinPointSignatureFromMethod(LazyMethodGen mg, MemberKind kind) {\n\t\tMember ret = mg.getMemberView();\n\t\tif (ret == null) {\n\t\t\tint mods = mg.getAccessFlags();\n\t\t\tif (mg.getEnclosingClass().isInterface()) {\n\t\t\t\tmods |= Modifier.INTERFACE;\n\t\t\t}\n\t\t\treturn new ResolvedMemberImpl(kind, UnresolvedType.forName(mg.getClassName()), mods, fromBcel(mg.getReturnType()),\n\t\t\t\t\tmg.getName(), fromBcel(mg.getArgumentTypes()));\n\t\t} else {\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tpublic Member makeJoinPointSignatureForMonitorEnter(LazyClassGen cg, InstructionHandle h) {\n\t\treturn MemberImpl.monitorEnter();\n\t}\n\n\tpublic Member makeJoinPointSignatureForMonitorExit(LazyClassGen cg, InstructionHandle h) {\n\t\treturn MemberImpl.monitorExit();\n\t}\n\n\tpublic Member makeJoinPointSignatureForArrayConstruction(LazyClassGen cg, InstructionHandle handle) {\n\t\tInstruction i = handle.getInstruction();\n\t\tConstantPool cpg = cg.getConstantPool();\n\t\tMember retval = null;\n\n\t\tif (i.opcode == Constants.ANEWARRAY) {\n\t\t\t// ANEWARRAY arrayInstruction = (ANEWARRAY)i;\n\t\t\tType ot = i.getType(cpg);\n\t\t\tUnresolvedType ut = fromBcel(ot);\n\t\t\tut = UnresolvedType.makeArray(ut, 1);\n\t\t\tretval = MemberImpl.method(ut, Modifier.PUBLIC, UnresolvedType.VOID, \"<init>\", new ResolvedType[] { INT });\n\t\t} else if (i instanceof MULTIANEWARRAY) {\n\t\t\tMULTIANEWARRAY arrayInstruction = (MULTIANEWARRAY) i;\n\t\t\tUnresolvedType ut = null;\n\t\t\tshort dimensions = arrayInstruction.getDimensions();\n\t\t\tObjectType ot = arrayInstruction.getLoadClassType(cpg);\n\t\t\tif (ot != null) {\n\t\t\t\tut = fromBcel(ot);\n\t\t\t\tut = UnresolvedType.makeArray(ut, dimensions);\n\t\t\t} else {\n\t\t\t\tType t = arrayInstruction.getType(cpg);\n\t\t\t\tut = fromBcel(t);\n\t\t\t}\n\t\t\tResolvedType[] parms = new ResolvedType[dimensions];\n\t\t\tfor (int ii = 0; ii < dimensions; ii++) {\n\t\t\t\tparms[ii] = INT;\n\t\t\t}\n\t\t\tretval = MemberImpl.method(ut, Modifier.PUBLIC, UnresolvedType.VOID, \"<init>\", parms);\n\n\t\t} else if (i.opcode == Constants.NEWARRAY) {\n\t\t\t// NEWARRAY arrayInstruction = (NEWARRAY)i;\n\t\t\tType ot = i.getType();\n\t\t\tUnresolvedType ut = fromBcel(ot);\n\t\t\tretval = MemberImpl.method(ut, Modifier.PUBLIC, UnresolvedType.VOID, \"<init>\", new ResolvedType[] { INT });\n\t\t} else {\n\t\t\tthrow new BCException(\"Cannot create array construction signature for this non-array instruction:\" + i);\n\t\t}\n\t\treturn retval;\n\t}\n\n\tpublic Member makeJoinPointSignatureForMethodInvocation(LazyClassGen cg, InvokeInstruction ii) {\n\t\tConstantPool cpg = cg.getConstantPool();\n\t\tString name = ii.getName(cpg);\n\t\tString declaring = ii.getClassName(cpg);\n\t\tUnresolvedType declaringType = null;\n\n\t\tString signature = ii.getSignature(cpg);\n\n\t\t// 307147\n\t\tif (name.startsWith(\"ajc$privMethod$\")) {\n\t\t\t// The invoke is on a privileged accessor. These may be created for different\n\t\t\t// kinds of target, not necessarily just private methods. In bug 307147 it is\n\t\t\t// for a private method. This code is identifying the particular case in 307147\n\t\t\ttry {\n\t\t\t\tdeclaringType = UnresolvedType.forName(declaring);\n\t\t\t\tString typeNameAsFoundInAccessorName = declaringType.getName().replace('.', '_');\n\t\t\t\tint indexInAccessorName = name.lastIndexOf(typeNameAsFoundInAccessorName);\n\t\t\t\tif (indexInAccessorName != -1) {\n\t\t\t\t\tString methodName = name.substring(indexInAccessorName+typeNameAsFoundInAccessorName.length()+1);\n\t\t\t\t\tResolvedType resolvedDeclaringType = declaringType.resolve(this);\n\t\t\t\t\tResolvedMember[] methods = resolvedDeclaringType.getDeclaredMethods();\n\t\t\t\t\tfor (ResolvedMember method: methods) {\n\t\t\t\t\t\tif (method.getName().equals(methodName) && method.getSignature().equals(signature) && Modifier.isPrivate(method.getModifiers())) {\n\t\t\t\t\t\t\treturn method;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\t// Remove this once confident above code isn't having unexpected side effects\n\t\t\t\t// Added 1.8.7\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tint modifier = (ii instanceof INVOKEINTERFACE) ? Modifier.INTERFACE\n\t\t\t\t: (ii.opcode == Constants.INVOKESTATIC) ? Modifier.STATIC : (ii.opcode == Constants.INVOKESPECIAL && !name\n\t\t\t\t\t\t.equals(\"<init>\")) ? Modifier.PRIVATE : 0;\n\n\t\t// in Java 1.4 and after, static method call of super class within\n\t\t// subclass method appears\n\t\t// as declared by the subclass in the bytecode - but they are not\n\t\t// see #104212\n\t\tif (ii.opcode == Constants.INVOKESTATIC) {\n\t\t\tResolvedType appearsDeclaredBy = resolve(declaring);\n\t\t\t// look for the method there\n\t\t\tfor (Iterator<ResolvedMember> iterator = appearsDeclaredBy.getMethods(true, true); iterator.hasNext();) {\n\t\t\t\tResolvedMember method = iterator.next();\n\t\t\t\tif (Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\tif (name.equals(method.getName()) && signature.equals(method.getSignature())) {\n\t\t\t\t\t\t// we found it\n\t\t\t\t\t\tdeclaringType = method.getDeclaringType();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (declaringType == null) {\n\t\t\tif (declaring.charAt(0) == '[') {\n\t\t\t\tdeclaringType = UnresolvedType.forSignature(declaring);\n\t\t\t} else {\n\t\t\t\tdeclaringType = UnresolvedType.forName(declaring);\n\t\t\t}\n\t\t}\n\t\treturn MemberImpl.method(declaringType, modifier, name, signature);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tbuf.append(\"BcelWorld(\");\n\t\t// buf.append(shadowMungerMap);\n\t\tbuf.append(\")\");\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t * Retrieve a bcel delegate for an aspect - this will return NULL if the delegate is an EclipseSourceType and not a\n\t * BcelObjectType - this happens quite often when incrementally compiling.\n\t */\n\tpublic static BcelObjectType getBcelObjectType(ResolvedType concreteAspect) {\n\t\tif (concreteAspect == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!(concreteAspect instanceof ReferenceType)) { // Might be Missing\n\t\t\treturn null;\n\t\t}\n\t\tReferenceTypeDelegate rtDelegate = ((ReferenceType) concreteAspect).getDelegate();\n\t\tif (rtDelegate instanceof BcelObjectType) {\n\t\t\treturn (BcelObjectType) rtDelegate;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic void tidyUp() {\n\t\t// At end of compile, close any open files so deletion of those archives\n\t\t// is possible\n\t\tclassPath.closeArchives();\n\t\ttypeMap.report();\n\t\ttypeMap.demote(true);\n\t\t// ResolvedType.resetPrimitives();\n\t}\n\n\t// / The repository interface methods\n\n\t@Override\n\tpublic JavaClass findClass(String className) {\n\t\treturn lookupJavaClass(classPath, className);\n\t}\n\n\t@Override\n\tpublic JavaClass loadClass(String className) throws ClassNotFoundException {\n\t\treturn lookupJavaClass(classPath, className);\n\t}\n\n\t@Override\n\tpublic void storeClass(JavaClass clazz) {\n\t\t// doesn't need to do anything\n\t}\n\n\t@Override\n\tpublic void removeClass(JavaClass clazz) {\n\t\tthrow new RuntimeException(\"Not implemented\");\n\t}\n\n\t@Override\n\tpublic JavaClass loadClass(Class clazz) throws ClassNotFoundException {\n\t\tthrow new RuntimeException(\"Not implemented\");\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tdelegate.clear();\n\t\t// throw new RuntimeException(\"Not implemented\");\n\t}\n\n\t/**\n\t * The aim of this method is to make sure a particular type is 'ok'. Some operations on the delegate for a type modify it and\n\t * this method is intended to undo that... see pr85132\n\t */\n\t@Override\n\tpublic void validateType(UnresolvedType type) {\n\t\tResolvedType result = typeMap.get(type.getSignature());\n\t\tif (result == null) {\n\t\t\treturn; // We haven't heard of it yet\n\t\t}\n\t\tif (!result.isExposedToWeaver()) {\n\t\t\treturn; // cant need resetting\n\t\t}\n\t\tresult.ensureConsistent();\n\t\t// If we want to rebuild it 'from scratch' then:\n\t\t// ClassParser cp = new ClassParser(new\n\t\t// ByteArrayInputStream(newbytes),new String(cs));\n\t\t// try {\n\t\t// rt.setDelegate(makeBcelObjectType(rt,cp.parse(),true));\n\t\t// } catch (ClassFormatException e) {\n\t\t// e.printStackTrace();\n\t\t// } catch (IOException e) {\n\t\t// e.printStackTrace();\n\t\t// }\n\t}\n\n\t/**\n\t * Apply a single declare parents - return true if we change the type\n\t */\n\tprivate boolean applyDeclareParents(DeclareParents p, ResolvedType onType) {\n\t\tboolean didSomething = false;\n\t\tList<ResolvedType> newParents = p.findMatchingNewParents(onType, true);\n\t\tif (!newParents.isEmpty()) {\n\t\t\tdidSomething = true;\n\t\t\tBcelObjectType classType = BcelWorld.getBcelObjectType(onType);\n\t\t\t// System.err.println(\"need to do declare parents for: \" + onType);\n\t\t\tfor (ResolvedType newParent : newParents) {\n\t\t\t\t// We set it here so that the imminent matching for ITDs can\n\t\t\t\t// succeed - we still haven't done the necessary changes to the class file\n\t\t\t\t// itself (like transform super calls) - that is done in\n\t\t\t\t// BcelTypeMunger.mungeNewParent()\n\t\t\t\t// classType.addParent(newParent);\n\t\t\t\tonType.addParent(newParent);\n\t\t\t\tResolvedTypeMunger newParentMunger = new NewParentTypeMunger(newParent, p.getDeclaringType());\n\t\t\t\tnewParentMunger.setSourceLocation(p.getSourceLocation());\n\t\t\t\tonType.addInterTypeMunger(new BcelTypeMunger(newParentMunger, getCrosscuttingMembersSet()\n\t\t\t\t\t\t.findAspectDeclaringParents(p)), false);\n\t\t\t}\n\t\t}\n\t\treturn didSomething;\n\t}\n\n\t/**\n\t * Apply a declare @type - return true if we change the type\n\t */\n\tprivate boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedType onType, boolean reportProblems) {\n\t\tboolean didSomething = false;\n\t\tif (decA.matches(onType)) {\n\n\t\t\tif (onType.hasAnnotation(decA.getAnnotation().getType())) {\n\t\t\t\t// already has it\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tAnnotationAJ annoX = decA.getAnnotation();\n\n\t\t\t// check the annotation is suitable for the target\n\t\t\tboolean isOK = checkTargetOK(decA, onType, annoX);\n\n\t\t\tif (isOK) {\n\t\t\t\tdidSomething = true;\n\t\t\t\tResolvedTypeMunger newAnnotationTM = new AnnotationOnTypeMunger(annoX);\n\t\t\t\tnewAnnotationTM.setSourceLocation(decA.getSourceLocation());\n\t\t\t\tonType.addInterTypeMunger(new BcelTypeMunger(newAnnotationTM, decA.getAspect().resolve(this)), false);\n\t\t\t\tdecA.copyAnnotationTo(onType);\n\t\t\t}\n\t\t}\n\t\treturn didSomething;\n\t}\n\n\t/**\n\t * Apply the specified declare @field construct to any matching fields in the specified type.\n\t * @param deca the declare annotation targeting fields\n\t * @param type the type to check for members matching the declare annotation\n\t * @return true if something matched and the type was modified\n\t */\n\tprivate boolean applyDeclareAtField(DeclareAnnotation deca, ResolvedType type) {\n\t\tboolean changedType = false;\n\t\tResolvedMember[] fields = type.getDeclaredFields();\n\t\tfor (ResolvedMember field: fields) {\n\t\t\tif (deca.matches(field, this)) {\n\t\t\t\tAnnotationAJ anno = deca.getAnnotation();\n\t\t\t\tif (!field.hasAnnotation(anno.getType())) {\n\t\t\t\t\tfield.addAnnotation(anno);\n\t\t\t\t\tchangedType=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn changedType;\n\t}\n\n\t/**\n\t * Checks for an @target() on the annotation and if found ensures it allows the annotation to be attached to the target type\n\t * that matched.\n\t */\n\tprivate boolean checkTargetOK(DeclareAnnotation decA, ResolvedType onType, AnnotationAJ annoX) {\n\t\tif (annoX.specifiesTarget()) {\n\t\t\tif ((onType.isAnnotation() && !annoX.allowedOnAnnotationType()) || (!annoX.allowedOnRegularType())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Hmmm - very similar to the code in BcelWeaver.weaveParentTypeMungers -\n\t// this code\n\t// doesn't need to produce errors/warnings though as it won't really be\n\t// weaving.\n\tprotected void weaveInterTypeDeclarations(ResolvedType onType) {\n\n\t\tList<DeclareParents> declareParentsList = getCrosscuttingMembersSet().getDeclareParents();\n\t\tif (onType.isRawType()) {\n\t\t\tonType = onType.getGenericType();\n\t\t}\n\t\tonType.clearInterTypeMungers();\n\n\t\tList<DeclareParents> decpToRepeat = new ArrayList<>();\n\n\t\tboolean aParentChangeOccurred = false;\n\t\tboolean anAnnotationChangeOccurred = false;\n\t\t// First pass - apply all decp mungers\n\t\tfor (DeclareParents decp : declareParentsList) {\n\t\t\tboolean typeChanged = applyDeclareParents(decp, onType);\n\t\t\tif (typeChanged) {\n\t\t\t\taParentChangeOccurred = true;\n\t\t\t} else { // Perhaps it would have matched if a 'dec @type' had\n\t\t\t\t// modified the type\n\t\t\t\tif (!decp.getChild().isStarAnnotation()) {\n\t\t\t\t\tdecpToRepeat.add(decp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Still first pass - apply all dec @type mungers\n\t\tfor (DeclareAnnotation decA : getCrosscuttingMembersSet().getDeclareAnnotationOnTypes()) {\n\t\t\tboolean typeChanged = applyDeclareAtType(decA, onType, true);\n\t\t\tif (typeChanged) {\n\t\t\t\tanAnnotationChangeOccurred = true;\n\t\t\t}\n\t\t}\n\n\t\t// apply declare @field\n\t\tfor (DeclareAnnotation deca: getCrosscuttingMembersSet().getDeclareAnnotationOnFields()) {\n\t\t\tif (applyDeclareAtField(deca,onType)) {\n\t\t\t\tanAnnotationChangeOccurred = true;\n\t\t\t}\n\t\t}\n\n\t\twhile ((aParentChangeOccurred || anAnnotationChangeOccurred) && !decpToRepeat.isEmpty()) {\n\t\t\tanAnnotationChangeOccurred = aParentChangeOccurred = false;\n\t\t\tList<DeclareParents> decpToRepeatNextTime = new ArrayList<>();\n\t\t\tfor (DeclareParents decp: decpToRepeat) {\n\t\t\t\tif (applyDeclareParents(decp, onType)) {\n\t\t\t\t\taParentChangeOccurred = true;\n\t\t\t\t} else {\n\t\t\t\t\tdecpToRepeatNextTime.add(decp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (DeclareAnnotation deca: getCrosscuttingMembersSet().getDeclareAnnotationOnTypes()) {\n\t\t\t\tif (applyDeclareAtType(deca, onType, false)) {\n\t\t\t\t\tanAnnotationChangeOccurred = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (DeclareAnnotation deca: getCrosscuttingMembersSet().getDeclareAnnotationOnFields()) {\n\t\t\t\tif (applyDeclareAtField(deca, onType)) {\n\t\t\t\t\tanAnnotationChangeOccurred = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecpToRepeat = decpToRepeatNextTime;\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic IWeavingSupport getWeavingSupport() {\n\t\treturn bcelWeavingSupport;\n\t}\n\n\t@Override\n\tpublic void reportCheckerMatch(Checker checker, Shadow shadow) {\n\t\tIMessage iMessage = new Message(checker.getMessage(shadow), shadow.toString(), checker.isError() ? IMessage.ERROR\n\t\t\t\t: IMessage.WARNING, shadow.getSourceLocation(), null, new ISourceLocation[] { checker.getSourceLocation() }, true,\n\t\t\t\t0, -1, -1);\n\n\t\tgetMessageHandler().handleMessage(iMessage);\n\n\t\tif (getCrossReferenceHandler() != null) {\n\t\t\tgetCrossReferenceHandler()\n\t\t\t\t\t.addCrossReference(\n\t\t\t\t\t\t\tchecker.getSourceLocation(),\n\t\t\t\t\t\t\tshadow.getSourceLocation(),\n\t\t\t\t\t\t\t(checker.isError() ? IRelationship.Kind.DECLARE_ERROR.getName() : IRelationship.Kind.DECLARE_WARNING\n\t\t\t\t\t\t\t\t\t.getName()), false);\n\n\t\t}\n\n\t\tif (getModel() != null) {\n\t\t\tAsmRelationshipProvider.addDeclareErrorOrWarningRelationship(getModelAsAsmManager(), shadow, checker);\n\t\t}\n\n\t}\n\n\tpublic AsmManager getModelAsAsmManager() {\n\t\treturn (AsmManager) getModel(); // For now... always an AsmManager in a bcel environment\n\t}\n\n\tvoid raiseError(String message) {\n\t\tgetMessageHandler().handleMessage(MessageUtil.error(message));\n\t}\n\n\t/**\n\t * These are aop.xml files that can be used to alter the aspects that actually apply from those passed in - and also their scope\n\t * of application to other files in the system.\n\t *\n\t * @param xmlFiles list of File objects representing any aop.xml files passed in to configure the build process\n\t */\n\tpublic void setXmlFiles(List<File> xmlFiles) {\n\t\tif (!isXmlConfiguredWorld && !xmlFiles.isEmpty()) {\n\t\t\traiseError(\"xml configuration files only supported by the compiler when -xmlConfigured option specified\");\n\t\t\treturn;\n\t\t}\n\t\tif (!xmlFiles.isEmpty()) {\n\t\t\txmlConfiguration = new WeavingXmlConfig(this, WeavingXmlConfig.MODE_COMPILE);\n\t\t}\n\t\tfor (File xmlfile : xmlFiles) {\n\t\t\ttry {\n\t\t\t\tDefinition d = DocumentParser.parse(xmlfile.toURI().toURL());\n\t\t\t\txmlConfiguration.add(d);\n\t\t\t} catch (MalformedURLException e) {\n\t\t\t\traiseError(\"Unexpected problem processing XML config file '\" + xmlfile.getName() + \"' :\" + e.getMessage());\n\t\t\t} catch (Exception e) {\n\t\t\t\traiseError(\"Unexpected problem processing XML config file '\" + xmlfile.getName() + \"' :\" + e.getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Add a scoped aspects where the scoping was defined in an aop.xml file and this world is being used in a LTW configuration\n\t */\n\tpublic void addScopedAspect(String name, String scope) {\n\t\tthis.isXmlConfiguredWorld = true;\n\t\tif (xmlConfiguration == null) {\n\t\t\txmlConfiguration = new WeavingXmlConfig(this, WeavingXmlConfig.MODE_LTW);\n\t\t}\n\t\txmlConfiguration.addScopedAspect(name, scope);\n\t}\n\n\tpublic void setXmlConfigured(boolean b) {\n\t\tthis.isXmlConfiguredWorld = b;\n\t}\n\n\t@Override\n\tpublic boolean isXmlConfigured() {\n\t\treturn isXmlConfiguredWorld && xmlConfiguration != null;\n\t}\n\n\tpublic WeavingXmlConfig getXmlConfiguration() {\n\t\treturn xmlConfiguration;\n\t}\n\n\t@Override\n\tpublic boolean isAspectIncluded(ResolvedType aspectType) {\n\t\tif (!isXmlConfigured()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn xmlConfiguration.specifiesInclusionOfAspect(aspectType.getName());\n\t}\n\n\t@Override\n\tpublic TypePattern getAspectScope(ResolvedType declaringType) {\n\t\treturn xmlConfiguration.getScopeFor(declaringType.getName());\n\t}\n\n\t@Override\n\tpublic boolean hasUnsatisfiedDependency(ResolvedType aspectType) {\n\t\tString aspectName = aspectType.getName();\n\n\t\tif (aspectType.hasAnnotations()) {\n\t\t\tAnnotationAJ[] annos = aspectType.getAnnotations();\n\t\t\tfor (AnnotationAJ anno: annos) {\n\t\t\t\tif (anno.getTypeName().equals(\"org.aspectj.lang.annotation.RequiredTypes\")) {\n\t\t\t\t\tString values = anno.getStringFormOfValue(\"value\"); // Example: \"[A,org.foo.Bar]\"\n\t\t\t\t\tif (values != null && values.length() > 2) {\n\t\t\t\t\t\tvalues = values.substring(1,values.length()-1);\n\t\t\t\t\t\tStringTokenizer tokenizer = new StringTokenizer(values,\",\");\n\t\t\t\t\t\tboolean anythingMissing = false;\n\t\t\t\t\t\twhile (tokenizer.hasMoreElements()) {\n\t\t\t\t\t\t\tString requiredTypeName = tokenizer.nextToken();\n\t\t\t\t\t\t\tResolvedType rt = resolve(UnresolvedType.forName(requiredTypeName));\n\t\t\t\t\t\t\tif (rt.isMissing()) {\n\t\t\t\t\t\t\t\tif (!getMessageHandler().isIgnoring(IMessage.INFO)) {\n\t\t\t\t\t\t\t\t\tgetMessageHandler().handleMessage(\n\t\t\t\t\t\t\t\t\t\t\tMessageUtil.info(\"deactivating aspect '\" + aspectName + \"' as it requires type '\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ requiredTypeName + \"' which cannot be found on the classpath\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tanythingMissing = true;\n\t\t\t\t\t\t\t\tif (aspectRequiredTypes == null) {\n\t\t\t\t\t\t\t\t\taspectRequiredTypes = new HashMap<>();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Record that it has an invalid type reference\n\t\t\t\t\t\t\t\taspectRequiredTypes.put(aspectName,requiredTypeName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (anythingMissing) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// no value specified for annotation\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (aspectRequiredTypes == null) {\n\t\t\t// no aspects require anything, so there can be no unsatisfied dependencies\n\t\t\treturn false;\n\t\t}\n\t\tif (!aspectRequiredTypesProcessed.contains(aspectName)) {\n\t\t\tString requiredTypeName = aspectRequiredTypes.get(aspectName);\n\t\t\tif (requiredTypeName==null) {\n\t\t\t\taspectRequiredTypesProcessed.add(aspectName);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tResolvedType rt = resolve(UnresolvedType.forName(requiredTypeName));\n\t\t\t\tif (!rt.isMissing()) {\n\t\t\t\t\taspectRequiredTypesProcessed.add(aspectName);\n\t\t\t\t\taspectRequiredTypes.remove(aspectName);\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tif (!getMessageHandler().isIgnoring(IMessage.INFO)) {\n\t\t\t\t\t\tgetMessageHandler().handleMessage(\n\t\t\t\t\t\t\t\tMessageUtil.info(\"deactivating aspect '\" + aspectName + \"' as it requires type '\"\n\t\t\t\t\t\t\t\t\t\t+ requiredTypeName + \"' which cannot be found on the classpath\"));\n\t\t\t\t\t}\n\t\t\t\t\taspectRequiredTypesProcessed.add(aspectName);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn aspectRequiredTypes.containsKey(aspectName);\n\t}\n\n\tprivate List<String> aspectRequiredTypesProcessed = new ArrayList<>();\n\tprivate Map<String, String> aspectRequiredTypes = null;\n\n\tpublic void addAspectRequires(String aspectClassName, String requiredType) {\n\t\tif (aspectRequiredTypes == null) {\n\t\t\taspectRequiredTypes = new HashMap<>();\n\t\t}\n\t\taspectRequiredTypes.put(aspectClassName,requiredType);\n\t}\n\n\t/**\n\t * A WeavingXmlConfig is initially a collection of definitions from XML files - once the world is ready and weaving is running\n\t * it will initialize and transform those definitions into an optimized set of values (eg. resolve type patterns and string\n\t * names to real entities). It can then answer questions quickly: (1) is this aspect included in the weaving? (2) Is there a\n\t * scope specified for this aspect and does it include type X?\n\t *\n\t */\n\tstatic class WeavingXmlConfig {\n\n\t\tfinal static int MODE_COMPILE = 1;\n\t\tfinal static int MODE_LTW = 2;\n\n\t\tprivate int mode;\n\n\t\tprivate boolean initialized = false; // Lazily done\n\t\tprivate List<Definition> definitions = new ArrayList<>();\n\n\t\tprivate List<String> resolvedIncludedAspects = new ArrayList<>();\n\t\tprivate Map<String, TypePattern> scopes = new HashMap<>();\n\n\t\t// these are not set for LTW mode (exclusion of these fast match patterns is handled before the weaver/world are used)\n\t\tprivate List<String> includedFastMatchPatterns = Collections.emptyList();\n\t\tprivate List<TypePattern> includedPatterns = Collections.emptyList();\n\t\tprivate List<String> excludedFastMatchPatterns = Collections.emptyList();\n\t\tprivate List<TypePattern> excludedPatterns = Collections.emptyList();\n\n\t\tprivate BcelWorld world;\n\n\t\tpublic WeavingXmlConfig(BcelWorld bcelWorld, int mode) {\n\t\t\tthis.world = bcelWorld;\n\t\t\tthis.mode = mode;\n\t\t}\n\n\t\tpublic void add(Definition d) {\n\t\t\tdefinitions.add(d);\n\t\t}\n\n\t\tpublic void addScopedAspect(String aspectName, String scope) {\n\t\t\tensureInitialized();\n\t\t\tresolvedIncludedAspects.add(aspectName);\n\t\t\ttry {\n\t\t\t\tTypePattern scopePattern = new PatternParser(scope).parseTypePattern();\n\t\t\t\tscopePattern.resolve(world);\n\t\t\t\tscopes.put(aspectName, scopePattern);\n\t\t\t\tif (!world.getMessageHandler().isIgnoring(IMessage.INFO)) {\n\t\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\t\tMessageUtil.info(\"Aspect '\" + aspectName + \"' is scoped to apply against types matching pattern '\"\n\t\t\t\t\t\t\t\t\t+ scopePattern + \"'\"));\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\tMessageUtil.error(\"Unable to parse scope as type pattern.  Scope was '\" + scope + \"': \" + e.getMessage()));\n\t\t\t}\n\t\t}\n\n\t\tpublic void ensureInitialized() {\n\t\t\tif (!initialized) {\n\t\t\t\ttry {\n\t\t\t\t\tresolvedIncludedAspects = new ArrayList<>();\n\t\t\t\t\t// Process the definitions into something more optimal\n\t\t\t\t\tfor (Definition definition : definitions) {\n\t\t\t\t\t\tList<String> aspectNames = definition.getAspectClassNames();\n\t\t\t\t\t\tfor (String name : aspectNames) {\n\t\t\t\t\t\t\tresolvedIncludedAspects.add(name);\n\t\t\t\t\t\t\t// TODO check for existence?\n\t\t\t\t\t\t\t// ResolvedType resolvedAspect = resolve(UnresolvedType.forName(name));\n\t\t\t\t\t\t\t// if (resolvedAspect.isMissing()) {\n\t\t\t\t\t\t\t// // ERROR\n\t\t\t\t\t\t\t// } else {\n\t\t\t\t\t\t\t// resolvedIncludedAspects.add(resolvedAspect);\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\tString scope = definition.getScopeForAspect(name);\n\t\t\t\t\t\t\tif (scope != null) {\n\t\t\t\t\t\t\t\t// Resolve the type pattern\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tTypePattern scopePattern = new PatternParser(scope).parseTypePattern();\n\t\t\t\t\t\t\t\t\tscopePattern.resolve(world);\n\t\t\t\t\t\t\t\t\tscopes.put(name, scopePattern);\n\t\t\t\t\t\t\t\t\tif (!world.getMessageHandler().isIgnoring(IMessage.INFO)) {\n\t\t\t\t\t\t\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\t\t\t\t\t\t\tMessageUtil.info(\"Aspect '\" + name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \"' is scoped to apply against types matching pattern '\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ scopePattern.toString() + \"'\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\t// TODO definitions should remember which file they came from, for inclusion in this message\n\t\t\t\t\t\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\t\t\t\t\t\tMessageUtil.error(\"Unable to parse scope as type pattern.  Scope was '\" + scope + \"': \"\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ e.getMessage()));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tList<String> includePatterns = definition.getIncludePatterns();\n\t\t\t\t\t\t\tif (includePatterns.size() > 0) {\n\t\t\t\t\t\t\t\tincludedPatterns = new ArrayList<>();\n\t\t\t\t\t\t\t\tincludedFastMatchPatterns = new ArrayList<>();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (String includePattern : includePatterns) {\n\t\t\t\t\t\t\t\tif (includePattern.endsWith(\"..*\")) {\n\t\t\t\t\t\t\t\t\t// from 'blah.blah.blah..*' leave the 'blah.blah.blah.'\n\t\t\t\t\t\t\t\t\tincludedFastMatchPatterns.add(includePattern.substring(0, includePattern.length() - 2));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tTypePattern includedPattern = new PatternParser(includePattern).parseTypePattern();\n\t\t\t\t\t\t\t\t\tincludedPatterns.add(includedPattern);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tList<String> excludePatterns = definition.getExcludePatterns();\n\t\t\t\t\t\t\tif (excludePatterns.size() > 0) {\n\t\t\t\t\t\t\t\texcludedPatterns = new ArrayList<>();\n\t\t\t\t\t\t\t\texcludedFastMatchPatterns = new ArrayList<>();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (String excludePattern : excludePatterns) {\n\t\t\t\t\t\t\t\tif (excludePattern.endsWith(\"..*\")) {\n\t\t\t\t\t\t\t\t\t// from 'blah.blah.blah..*' leave the 'blah.blah.blah.'\n\t\t\t\t\t\t\t\t\texcludedFastMatchPatterns.add(excludePattern.substring(0, excludePattern.length() - 2));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tTypePattern excludedPattern = new PatternParser(excludePattern).parseTypePattern();\n\t\t\t\t\t\t\t\t\texcludedPatterns.add(excludedPattern);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (ParserException pe) {\n\t\t\t\t\t\t\t// TODO definitions should remember which file they came from, for inclusion in this message\n\t\t\t\t\t\t\tworld.getMessageHandler().handleMessage(\n\t\t\t\t\t\t\t\t\tMessageUtil.error(\"Unable to parse type pattern: \" + pe.getMessage()));\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tinitialized = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean specifiesInclusionOfAspect(String name) {\n\t\t\tensureInitialized();\n\t\t\treturn resolvedIncludedAspects.contains(name);\n\t\t}\n\n\t\tpublic TypePattern getScopeFor(String name) {\n\t\t\treturn scopes.get(name);\n\t\t}\n\n\t\t/**\n\t\t * Checks if a given type is to be excluded from weaving.\n\t\t * <p>\n\t\t * For LTW, the development guide (<i>docs/devguide/ltw.adoc</i>) says:\n\t\t * <p>\n\t\t * <i>\"The set of types to be woven are those types matched by at least one weaver {@code include} element and not\n\t\t * matched by any weaver {@code exclude} element. If there are no weaver include statements, then all non-excluded\n\t\t * types are included.\"</i>\n\t\t * <p>\n\t\t * In CTW mode, we cannot quite follow the same rules for exclusion as used for LTW: If the weaver is seeing it\n\t\t * during this kind of build, the type is implicitly included. So all we should check for is exclusion.\n\t\t *\n\t\t * @param type resolved type to be checked\n\t\t *\n\t\t * @return Always false in LTW mode. In CTW mode true for excluded types, false otherwise.\n\t\t */\n\t\tpublic boolean excludesType(ResolvedType type) {\n\t\t\tif (mode == MODE_LTW) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tString typename = type.getName();\n\t\t\tboolean excluded = false;\n\t\t\tfor (String excludedPattern : excludedFastMatchPatterns) {\n\t\t\t\tif (typename.startsWith(excludedPattern)) {\n\t\t\t\t\texcluded = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!excluded) {\n\t\t\t\tfor (TypePattern excludedPattern : excludedPatterns) {\n\t\t\t\t\tif (excludedPattern.matchesStatically(type)) {\n\t\t\t\t\t\texcluded = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn excluded;\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic TypeMap getTypeMap() {\n\t\treturn typeMap;\n\t}\n\n\t@Override\n\tpublic boolean isLoadtimeWeaving() {\n\t\treturn false;\n\t}\n\n\tpublic void addTypeDelegateResolver(TypeDelegateResolver typeDelegateResolver) {\n\t\tif (typeDelegateResolvers == null) {\n\t\t\ttypeDelegateResolvers = new ArrayList<>();\n\t\t}\n\t\ttypeDelegateResolvers.add(typeDelegateResolver);\n\t}\n\n\t@Override\n\tpublic void classWriteEvent(char[][] compoundName) {\n\t\ttypeMap.classWriteEvent(new String(CharOperation.concatWith(compoundName, '.')));\n\t}\n\n\t/**\n\t * Force demote a type.\n\t */\n\tpublic void demote(ResolvedType type) {\n\t\ttypeMap.demote(type);\n\t}\n\n}\n",
    "size": 48827
  },
  {
    "file_id": "F30",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/ClassPathManager.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002, 2017 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n * Palo Alto Research Center, Incorporated (PARC).\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.util.SoftHashMap;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeaverMessages;\nimport org.aspectj.weaver.tools.Trace;\nimport org.aspectj.weaver.tools.TraceFactory;\n\n/**\n * @author Andy Clement\n * @author Mario Ivankovits\n */\npublic class ClassPathManager {\n\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(ClassPathManager.class);\n\n\tprivate static int maxOpenArchives = -1;\n\n\tprivate static URI JRT_URI = URI.create(\"jrt:/\"); //$NON-NLS-1$\n\n\tprivate static final int MAXOPEN_DEFAULT = 1000;\n\n\tprivate final List<Entry> entries;\n\n\tprivate final Set<String> notFound = new HashSet<>(100);\n\n\t// In order to control how many open files we have, we maintain a list.\n\t// The max number is configured through the property:\n\t// org.aspectj.weaver.openarchives\n\t// and it defaults to 1000\n\tprivate final List<ZipFile> openArchives = new ArrayList<>();\n\n\tstatic {\n\t\tString openzipsString = getSystemPropertyWithoutSecurityException(\"org.aspectj.weaver.openarchives\",\n\t\t\t\tInteger.toString(MAXOPEN_DEFAULT));\n\t\tmaxOpenArchives = Integer.parseInt(openzipsString);\n\t\tif (maxOpenArchives < 20) {\n\t\t\tmaxOpenArchives = MAXOPEN_DEFAULT;\n\t\t}\n\t}\n\n\tpublic ClassPathManager(List<String> classpath, IMessageHandler handler) {\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.enter(\"<init>\", this, new Object[] { classpath==null?\"null\":classpath.toString(), handler });\n\t\t}\n\t\tentries = new ArrayList<>(classpath == null ? 1 : classpath.size());\n\t\tfor (String classpathEntry: classpath) {\n\t\t\taddPath(classpathEntry,handler);\n\t\t}\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.exit(\"<init>\");\n\t\t}\n\t}\n\n\tprotected ClassPathManager() {\n\t\tentries = null;\n\t}\n\n\tpublic void addPath(String name, IMessageHandler handler) {\n\t\tFile f = new File(name);\n\t\tif (!f.isDirectory()) {\n\t\t\tif (!f.isFile()) {\n\t\t\t\tif (!name.toLowerCase().endsWith(\".jar\") || name.toLowerCase().endsWith(\".zip\")) {\n\t\t\t\t\t// heuristic-only: ending with .jar or .zip means probably a zip file\n\t\t\t\t\tMessageUtil.info(handler, WeaverMessages.format(WeaverMessages.ZIPFILE_ENTRY_MISSING, name));\n\t\t\t\t} else {\n\t\t\t\t\tMessageUtil.info(handler, WeaverMessages.format(WeaverMessages.DIRECTORY_ENTRY_MISSING, name));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (name.toLowerCase().endsWith(LangUtil.JRT_FS)) { // Java9+\n\t\t\t\t\tentries.add(new JImageEntry(name));\n\t\t\t\t} else {\n\t\t\t\t\tentries.add(new ZipFileEntry(f));\n\t\t\t\t}\n\t\t\t} catch (IOException ioe) {\n\t\t\t\tMessageUtil.warn(handler,\n\t\t\t\t\t\tWeaverMessages.format(WeaverMessages.ZIPFILE_ENTRY_INVALID, name, ioe.getMessage()));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tentries.add(new DirEntry(f));\n\t\t}\n\t}\n\n\tpublic ClassFile find(UnresolvedType type) {\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.enter(\"find\", this, type);\n\t\t}\n\t\tString name = type.getName();\n\t\tif (notFound.contains(name)) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (Iterator<Entry> i = entries.iterator(); i.hasNext();) {\n\t\t\tEntry entry = i.next();\n\t\t\ttry {\n\t\t\t\tClassFile ret = entry.find(name);\n\t\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\t\ttrace.event(\"searching for \"+type+\" in \"+entry.toString());\n\t\t\t\t}\n\t\t\t\tif (ret != null) {\n\t\t\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\t\t\ttrace.exit(\"find\", ret);\n\t\t\t\t\t}\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (IOException ioe) {\n\t\t\t\t// this is NOT an error: it's valid to have missing classpath entries\n\t\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\t\ttrace.error(\"Removing classpath entry for \"+entry,ioe);\n\t\t\t\t}\n\t\t\t\ti.remove();\n\t\t\t}\n\t\t}\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.exit(\"find\", null);\n\t\t}\n\t\tnotFound.add(name);\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tboolean start = true;\n\t\tfor (Entry entry : entries) {\n\t\t\tif (start) {\n\t\t\t\tstart = false;\n\t\t\t} else {\n\t\t\t\tbuf.append(File.pathSeparator);\n\t\t\t}\n\t\t\tbuf.append(entry);\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tpublic abstract static class ClassFile {\n\t\tpublic abstract InputStream getInputStream() throws IOException;\n\t\tpublic abstract String getPath();\n\t\tpublic abstract void close();\n\t}\n\n\tabstract static class Entry {\n\t\tpublic abstract ClassFile find(String name) throws IOException;\n\t}\n\n\tstatic class ByteBasedClassFile extends ClassFile {\n\n\t\tprivate final byte[] bytes;\n\t\tprivate ByteArrayInputStream bais;\n\t\tprivate final String path;\n\n\t\tpublic ByteBasedClassFile(byte[] bytes, String path) {\n\t\t\tthis.bytes = bytes;\n\t\t\tthis.path = path;\n\t\t}\n\n\t\t@Override\n\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\tthis.bais = new ByteArrayInputStream(bytes);\n\t\t\treturn this.bais;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getPath() {\n\t\t\treturn this.path;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\tif (this.bais!=null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.bais.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t\tthis.bais = null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class FileClassFile extends ClassFile {\n\t\tprivate final File file;\n\t\tprivate FileInputStream fis;\n\n\t\tpublic FileClassFile(File file) {\n\t\t\tthis.file = file;\n\t\t}\n\n\t\t@Override\n\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\tfis = new FileInputStream(file);\n\t\t\treturn fis;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\tif (fis != null)\n\t\t\t\t\tfis.close();\n\t\t\t} catch (IOException ioe) {\n\t\t\t\tthrow new BCException(\"Can't close class file : \" + file.getName(), ioe);\n\t\t\t} finally {\n\t\t\t\tfis = null;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String getPath() {\n\t\t\treturn file.getPath();\n\t\t}\n\t}\n\n\tclass DirEntry extends Entry {\n\t\tprivate final String dirPath;\n\n\t\tpublic DirEntry(File dir) {\n\t\t\tthis.dirPath = dir.getPath();\n\t\t}\n\n\t\tpublic DirEntry(String dirPath) {\n\t\t\tthis.dirPath = dirPath;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassFile find(String name) {\n\t\t\tFile f = new File(dirPath + File.separator + name.replace('.', File.separatorChar) + \".class\");\n\t\t\tif (f.isFile())\n\t\t\t\treturn new FileClassFile(f);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn dirPath;\n\t\t}\n\t}\n\n\tstatic class ZipEntryClassFile extends ClassFile {\n\t\tprivate final ZipEntry entry;\n\t\tprivate final ZipFileEntry zipFile;\n\t\tprivate InputStream is;\n\n\t\tpublic ZipEntryClassFile(ZipFileEntry zipFile, ZipEntry entry) {\n\t\t\tthis.zipFile = zipFile;\n\t\t\tthis.entry = entry;\n\t\t}\n\n\t\t@Override\n\t\tpublic InputStream getInputStream() throws IOException {\n\t\t\tis = zipFile.getZipFile().getInputStream(entry);\n\t\t\treturn is;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\tif (is != null)\n\t\t\t\t\tis.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} finally {\n\t\t\t\tis = null;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String getPath() {\n\t\t\treturn entry.getName();\n\t\t}\n\n\t}\n\n\t/**\n\t * Maintains a shared package cache for java runtime image. This maps packages (for example:\n\t * java/lang) to a starting root position in the filesystem (for example: /modules/java.base/java/lang).\n\t * When searching for a type we work out the package name, use it to find where in the filesystem\n\t * to start looking then run from there. Once found we do cache what we learn to make subsequent\n\t * lookups of that type even faster. Maintaining just a package cache rather than complete type cache\n\t * helps reduce memory usage but still gives reasonably fast lookup performance.\n\t */\n\tstatic class JImageEntry extends Entry {\n\n\t\t// Map from a JRT-FS file to the cache state for that file\n\t\tprivate static Map<String, JImageState> states = new HashMap<>();\n\n\t\tprivate JImageState state;\n\n\t\t// TODO memory management here - is it held onto too long when LTW?\n\t\tstatic class JImageState {\n\t\t\tprivate final String jrtFsPath;\n\t\t\tprivate final FileSystem fs;\n\t\t\tMap<String,Path> fileCache = new SoftHashMap<>();\n\t\t\tboolean packageCacheInitialized = false;\n\t\t\tMap<String,Path> packageCache = new HashMap<>();\n\n\t\t\tpublic JImageState(String jrtFsPath, FileSystem fs) {\n\t\t\t\tthis.jrtFsPath = jrtFsPath;\n\t\t\t\tthis.fs = fs;\n\t\t\t}\n\t\t}\n\n\t\tpublic JImageEntry(String jrtFsPath) {\n\t\t\tstate = states.get(jrtFsPath);\n\t\t\tif (state == null) {\n\t\t\t\tsynchronized (states) {\n\t\t\t\t\tif (state == null) {\n\t\t\t\t\t\tURL jrtPath = null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tjrtPath = new File(jrtFsPath).toPath().toUri().toURL();\n\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\tSystem.out.println(\"Unexpected problem processing \"+jrtFsPath+\" bad classpath entry? skipping:\"+e.getMessage());\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString jdkHome = new File(jrtFsPath).getParentFile().getParent();\n\t\t\t\t\t\tFileSystem fs = null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (LangUtil.isVMGreaterOrEqual(9)) {\n\t\t\t\t\t\t\t\tMap<String, String> env = new HashMap<>();\n\t\t\t\t\t\t\t\tenv.put(\"java.home\",  jdkHome);\n\t\t\t\t\t\t\t\tfs = FileSystems.newFileSystem(JRT_URI, env);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tURLClassLoader loader = new URLClassLoader(new URL[] { jrtPath });\n\t\t\t\t\t\t\t\tMap<String, ?> env = new HashMap<>();\n\t\t\t\t\t\t\t\tfs = FileSystems.newFileSystem(JRT_URI, env, loader);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstate = new JImageState(jrtFsPath, fs);\n\t\t\t\t\t\t\tstates.put(jrtFsPath, state);\n\t\t\t\t\t\t\tbuildPackageMap();\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Unexpectedly unable to initialize a JRT filesystem\", t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclass PackageCacheBuilderVisitor extends SimpleFileVisitor<Path> {\n\t\t\t@Override\n\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n\t\t\t\tif (file.getNameCount() > 3 && file.toString().endsWith(\".class\")) {\n\t\t\t\t\tint fnc = file.getNameCount();\n\t\t\t\t\tif (fnc > 3) { // There is a package name - e.g. /modules/java.base/java/lang/Object.class\n\t\t\t\t\t\tPath packagePath = file.subpath(2, fnc-1); // e.g. java/lang\n\t\t\t\t\t\tString packagePathString = packagePath.toString();\n\t\t\t\t\t\tstate.packageCache.put(packagePathString, file.subpath(0, fnc-1)); // java/lang -> /modules/java.base/java/lang\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Create a map from package names to the specific directory of the package members in the filesystem.\n\t\t */\n\t\tprivate synchronized void buildPackageMap() {\n\t\t\tif (!state.packageCacheInitialized) {\n\t\t\t\tstate.packageCacheInitialized = true;\n\t\t\t\tIterable<java.nio.file.Path> roots = state.fs.getRootDirectories();\n\t\t\t\tPackageCacheBuilderVisitor visitor = new PackageCacheBuilderVisitor();\n\t\t\t\ttry {\n\t\t\t\t\tfor (java.nio.file.Path path : roots) {\n\t\t\t\t\t\tFiles.walkFileTree(path, visitor);\n\t\t \t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclass TypeIdentifier extends SimpleFileVisitor<Path> {\n\n\t\t\t// What are we looking for?\n\t\t\tprivate final String name;\n\n\t\t\t// If set, where did we find it?\n\t\t\tpublic Path found;\n\n\t\t\t// Basic metric count of how many files we checked before finding it\n\t\t\tpublic int filesSearchedCount;\n\n\t\t\tpublic TypeIdentifier(String name) {\n\t\t\t\tthis.name = name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n\t\t\t\tfilesSearchedCount++;\n\t\t\t\tif (file.getNameCount() > 2 && file.toString().endsWith(\".class\")) {\n\t\t\t\t\tint fnc = file.getNameCount();\n\t\t\t\t\tPath filePath = file.subpath(2, fnc);\n\t\t\t\t\tString filePathString = filePath.toString();\n\t\t\t\t\tif (filePathString.equals(name)) {\n\t\t\t\t\t\tstate.fileCache.put(filePathString, file);\n\t\t\t\t\t\tfound = file;\n\t\t\t\t\t\treturn FileVisitResult.TERMINATE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t}\n\t\t}\n\n\t\tprivate Path searchForFileAndCache(final Path startPath, final String name) {\n\t\t\tTypeIdentifier locator = new TypeIdentifier(name);\n\t\t\ttry {\n\t\t\t\tFiles.walkFileTree(startPath, locator);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\treturn locator.found;\n \t\t}\n\n\t\t@Override\n\t\tpublic ClassFile find(String name) throws IOException {\n\t\t\tString fileName = name.replace('.', '/') + \".class\";\n\t\t\tPath file = state.fileCache.get(fileName);\n\t\t\tif (file == null) {\n\t\t\t\t// Check the packages map to see if we know about this package\n\t\t\t\tint idx = fileName.lastIndexOf('/');\n\t\t\t\tif (idx == -1) {\n\t\t\t\t\t// Package not here\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tPath packageStart = null;\n\t\t\t\tString packageName = null;\n\t\t\t\tif (idx !=-1 ) {\n\t\t\t\t\tpackageName = fileName.substring(0, idx);\n\t\t\t\t\tpackageStart = state.packageCache.get(packageName);\n\t\t\t\t\tif (packageStart != null) {\n\t\t\t\t\t\tfile = searchForFileAndCache(packageStart, fileName);\n\t\t\t\t\t}\n\t\t\t\t}\n \t\t\t}\n\t\t\tif (file == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbyte[] bs = Files.readAllBytes(file);\n\t\t\tClassFile cf = new ByteBasedClassFile(bs, fileName);\n\t\t\treturn cf;\n\t\t}\n\n\t\tMap<String, Path> getPackageCache() {\n\t\t\treturn state.packageCache;\n\t\t}\n\n\t\tMap<String, Path> getFileCache() {\n\t\t\treturn state.fileCache;\n\t\t}\n\n\t}\n\n\tclass ZipFileEntry extends Entry {\n\t\tprivate File file;\n\t\tprivate ZipFile zipFile;\n\n\t\tpublic ZipFileEntry(File file) throws IOException {\n\t\t\tthis.file = file;\n\t\t}\n\n\t\tpublic ZipFileEntry(ZipFile zipFile) {\n\t\t\tthis.zipFile = zipFile;\n\t\t}\n\n\t\tpublic ZipFile getZipFile() {\n\t\t\treturn zipFile;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassFile find(String name) throws IOException {\n\t\t\tensureOpen();\n\t\t\tString key = name.replace('.', '/') + \".class\";\n\t\t\tZipEntry entry = zipFile.getEntry(key);\n\t\t\tif (entry != null)\n\t\t\t\treturn new ZipEntryClassFile(this, entry);\n\t\t\telse\n\t\t\t\treturn null; // This zip will be closed when necessary...\n\t\t}\n\n\t\tpublic List<ZipEntryClassFile> getAllClassFiles() throws IOException {\n\t\t\tensureOpen();\n\t\t\tList<ZipEntryClassFile> ret = new ArrayList<>();\n\t\t\tfor (Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) {\n\t\t\t\tZipEntry entry = e.nextElement();\n\t\t\t\tString name = entry.getName();\n\t\t\t\tif (hasClassExtension(name))\n\t\t\t\t\tret.add(new ZipEntryClassFile(this, entry));\n\t\t\t}\n\t\t\t// if (ret.isEmpty()) close();\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void ensureOpen() throws IOException {\n\t\t\tif (zipFile != null && openArchives.contains(zipFile)) {\n\t\t\t\tif (isReallyOpen())\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (openArchives.size() >= maxOpenArchives) {\n\t\t\t\tcloseSomeArchives(openArchives.size() / 10); // Close 10% of\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// those open\n\t\t\t}\n\t\t\tzipFile = new ZipFile(file);\n\t\t\tif (!isReallyOpen()) {\n\t\t\t\tthrow new FileNotFoundException(\"Can't open archive: \" + file.getName() + \" (size() check failed)\");\n\t\t\t}\n\t\t\topenArchives.add(zipFile);\n\t\t}\n\n\t\tprivate boolean isReallyOpen() {\n\t\t\ttry {\n\t\t\t\tzipFile.size(); // this will fail if the file has been closed\n\t\t\t\t\t\t\t\t// for\n\t\t\t\t// some reason;\n\t\t\t\treturn true;\n\t\t\t} catch (IllegalStateException ex) {\n\t\t\t\t// this means the zip file is closed...\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t}\n\n\t\tpublic void closeSomeArchives(int n) {\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tZipFile zf = openArchives.get(i);\n\t\t\t\ttry {\n\t\t\t\t\tzf.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\topenArchives.remove(i);\n\t\t\t}\n\t\t}\n\n\t\tpublic void close() {\n\t\t\tif (zipFile == null)\n\t\t\t\treturn;\n\t\t\ttry {\n\t\t\t\topenArchives.remove(zipFile);\n\t\t\t\tzipFile.close();\n\t\t\t} catch (IOException ioe) {\n\t\t\t\tthrow new BCException(\"Can't close archive: \" + file.getName(), ioe);\n\t\t\t} finally {\n\t\t\t\tzipFile = null;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn file.getName();\n\t\t}\n\t}\n\n\t/* private */static boolean hasClassExtension(String name) {\n\t\treturn name.toLowerCase().endsWith(\".class\");\n\t}\n\n\tpublic void closeArchives() {\n\t\tfor (Entry entry : entries) {\n\t\t\tif (entry instanceof ZipFileEntry) {\n\t\t\t\t((ZipFileEntry) entry).close();\n\t\t\t}\n\t\t\topenArchives.clear();\n\t\t}\n\t}\n\n\t// Copes with the security manager\n\tprivate static String getSystemPropertyWithoutSecurityException(String aPropertyName, String aDefaultValue) {\n\t\ttry {\n\t\t\treturn System.getProperty(aPropertyName, aDefaultValue);\n\t\t} catch (SecurityException ex) {\n\t\t\treturn aDefaultValue;\n\t\t}\n\t}\n\n\t// Mainly exposed for testing\n\tpublic List<Entry> getEntries() {\n\t\treturn entries;\n\t}\n\n}\n",
    "size": 16976
  },
  {
    "file_id": "F31",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/ExceptionRange.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.weaver.UnresolvedType;\n\n/**\n * exceptionRanges are set initially to be low priority. The various setPriority methods should be used accordingly. The priority is\n * used when we pack the exception table into a method... the exception table should be sorted from high to low priority. Exceptions\n * we generate for advice is either high priority (higher than anything coming from the original method... most kinds of\n * non-execution advice) or low priority (lower than anything coming from the original method, for execution advice).\n *\n * <p>\n * ??? This does not account for handler, or any other \"statement-level\" advice. When such statement level advice happens, we may\n * want to go to a float level, so we can set the priority of advice to be lower than anything it encloses, and higher than anything\n * enclosing it.\n */\n\n/*\n * we're actually using the fact that we're an instruction targeter, for the handler\n */\npublic final class ExceptionRange extends Range {\n\n\tprivate InstructionHandle handler;\n\tprivate final UnresolvedType exceptionType;\n\tprivate final int priority;\n\n\t// ---- initialization\n\n\t/**\n\t * After this constructor is called, this range is not well situated unless {@link #associateWithTargets} is called\n\t *\n\t * XXX priority should be fixed\n\t */\n\tpublic ExceptionRange(InstructionList body, UnresolvedType exceptionType, int priority) {\n\t\tsuper(body);\n\t\tthis.exceptionType = exceptionType;\n\t\tthis.priority = priority;\n\t}\n\n\t/**\n\t * @param insideExisting\n\t */\n\tpublic ExceptionRange(InstructionList body, UnresolvedType exceptionType, boolean insideExisting) {\n\t\tthis(body, exceptionType, insideExisting ? Integer.MAX_VALUE : -1);\n\t}\n\n\tpublic void associateWithTargets(InstructionHandle start, InstructionHandle end, InstructionHandle handler) {\n\t\t// assert body.contains(start) && body.contains(end) && body.contains(handler)\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.handler = handler;\n\t\tstart.addTargeter(this);\n\t\tend.addTargeter(this);\n\t\thandler.addTargeter(this);\n\t}\n\n\t// ----\n\n\tpublic InstructionHandle getHandler() {\n\t\treturn handler;\n\t}\n\n\tpublic UnresolvedType getCatchType() {\n\t\treturn exceptionType;\n\t}\n\n\tpublic int getPriority() {\n\t\treturn priority;\n\t}\n\n\t// ---- from object\n\n\tpublic String toString() {\n\t\tString str;\n\t\tif (exceptionType == null) {\n\t\t\tstr = \"finally\";\n\t\t} else {\n\t\t\tstr = \"catch \" + exceptionType;\n\t\t}\n\t\t// if (priority >= 0 && priority < Integer.MAX_VALUE) {\n\t\t// str += \" (priority \" + priority + \")\";\n\t\t// }\n\t\treturn str;\n\t}\n\n\tpublic boolean equals(Object other) {\n\t\tif (!(other instanceof ExceptionRange))\n\t\t\treturn false;\n\t\tExceptionRange o = (ExceptionRange) other;\n\t\treturn o.getStart() == getStart() && o.getEnd() == getEnd() && o.handler == handler\n\t\t\t\t&& ((o.exceptionType == null) ? (exceptionType == null) : o.exceptionType.equals(exceptionType))\n\t\t\t\t&& o.priority == priority;\n\t}\n\n\tprivate volatile int hashCode = 0;\n\n\tpublic int hashCode() {\n\t\tif (hashCode == 0) {\n\t\t\tint ret = 17;\n\t\t\tret = 37 * ret + getStart().hashCode();\n\t\t\tret = 37 * ret + getEnd().hashCode();\n\t\t\tret = 37 * ret + handler.hashCode();\n\t\t\tret = 37 * ret + ((exceptionType == null) ? 0 : exceptionType.hashCode());\n\t\t\tret = 37 * ret + priority;\n\t\t\thashCode = ret;\n\t\t}\n\t\treturn hashCode;\n\t}\n\n\tpublic void updateTarget(InstructionHandle oldIh, InstructionHandle newIh, InstructionList newBody) {\n\t\tsuper.updateTarget(oldIh, newIh, newBody);\n\t\t// we're guaranteed that start, end, and handler are distinct instruction handles.\n\t\tif (oldIh == handler) {\n\t\t\thandler = newIh;\n\t\t}\n\t}\n\n\tpublic static boolean isExceptionStart(InstructionHandle ih) {\n\t\tif (!isRangeHandle(ih))\n\t\t\treturn false;\n\t\tRange r = getRange(ih);\n\t\tif (!(r instanceof ExceptionRange))\n\t\t\treturn false;\n\t\tExceptionRange er = (ExceptionRange) r;\n\t\treturn er.getStart() == ih;\n\t}\n\n\tpublic static boolean isExceptionEnd(InstructionHandle ih) {\n\t\tif (!isRangeHandle(ih))\n\t\t\treturn false;\n\t\tRange r = getRange(ih);\n\t\tif (!(r instanceof ExceptionRange))\n\t\t\treturn false;\n\t\tExceptionRange er = (ExceptionRange) r;\n\t\treturn er.getEnd() == ih;\n\t}\n\n}\n",
    "size": 4747
  },
  {
    "file_id": "F32",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/ExtensibleURLClassLoader.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2004 IBM Corporation\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster, Adrian Colyer,\n *     Martin Lippert     initial implementation\n *     Andy Clement\n *     Roy Varghese - Bug 473555\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.security.CodeSource;\n\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.UnresolvedType;\n\npublic abstract class ExtensibleURLClassLoader extends URLClassLoader {\n\n\tprivate ClassPathManager classPath;\n\n\tpublic ExtensibleURLClassLoader(URL[] urls, ClassLoader parent) {\n\t\tsuper(urls, parent);\n\n\t\t// System.err.println(\"? ExtensibleURLClassLoader.<init>() path=\" + WeavingAdaptor.makeClasspath(urls));\n\t\ttry {\n\t\t\tclassPath = new ClassPathManager(FileUtil.makeClasspath(urls), null);\n\t\t} catch (ExceptionInInitializerError ex) {\n\t\t\tex.printStackTrace(System.out);\n\t\t\tthrow ex;\n\t\t}\n\t}\n\n\tprotected void addURL(URL url) {\n\t\tsuper.addURL(url); // amc - this call was missing and is needed in\n\t\t// WeavingURLClassLoader chains\n\t\tclassPath.addPath(url.getPath(), null);\n\t}\n\n\tprotected Class findClass(String name) throws ClassNotFoundException {\n\t\t// System.err.println(\"? ExtensibleURLClassLoader.findClass(\" + name + \")\");\n\t\ttry {\n\t\t\tbyte[] bytes = getBytes(name);\n\t\t\tif (bytes != null) {\n\t\t\t\treturn defineClass(name, bytes);\n\t\t\t} else {\n\t\t\t\tthrow new ClassNotFoundException(name);\n\t\t\t}\n\t\t} catch (IOException ex) {\n\t\t\tthrow new ClassNotFoundException(name, ex);\n\t\t}\n\t}\n\n\tprotected Class defineClass(String name, byte[] b, CodeSource cs) throws IOException {\n\t\t// System.err.println(\"? ExtensibleURLClassLoader.defineClass(\" + name + \",[\" + b.length + \"])\");\n\t\treturn defineClass(name, b, 0, b.length, cs);\n\t}\n\n\tprotected byte[] getBytes(String name) throws IOException {\n\t\tbyte[] b = null;\n\t\tUnresolvedType unresolvedType = null;\n\t\ttry {\n\t\t\tunresolvedType = UnresolvedType.forName(name);\n\t\t} catch (BCException bce) {\n\t\t\tif (!bce.getMessage().contains(\"nameToSignature\")) {\n\t\t\t\tbce.printStackTrace(System.err);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tClassPathManager.ClassFile classFile = classPath.find(unresolvedType);\n\t\tif (classFile != null) {\n\t\t\ttry {\n\t\t\t\tb = FileUtil.readAsByteArray(classFile.getInputStream());\n\t\t\t} finally {\n\t\t\t\tclassFile.close();\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\n\tprivate Class<?> defineClass(String name, byte[] bytes /* ClassPathManager.ClassFile classFile */) throws IOException {\n\t\tString packageName = getPackageName(name);\n\t\tif (packageName != null) {\n\t\t\tPackage pakkage = getPackage(packageName);\n\t\t\tif (pakkage == null) {\n\t\t\t\tdefinePackage(packageName, null, null, null, null, null, null, null);\n\t\t\t}\n\t\t}\n\n\t\treturn defineClass(name, bytes, null);\n\t}\n\n\tprivate String getPackageName(String className) {\n\t\tint offset = className.lastIndexOf('.');\n\t\treturn (offset == -1) ? null : className.substring(0, offset);\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tsuper.close();\n\t\tclassPath.closeArchives();\n\t}\n\n}\n",
    "size": 3409
  },
  {
    "file_id": "F33",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/FakeAnnotation.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n * initial implementation              Andy Clement\n *******************************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.classfile.annotation.NameValuePair;\n\n/**\n * For implementing declare @type interacting with declare @parents during compilation - we need to be able to add an annotation to\n * 'binary type binding' (this is how types are seen during incremental compilation). Unlike a SourceTypeBinding - a\n * BinaryTypeBinding does not allow easy interaction with its annotations - so what we do is take the eclipse annotation, suck out\n * the name/signature and visibility and put that information in a 'FakeAnnotation'. The FakeAnnotation is attached to the BCEL\n * delegate for the binary type binding - this will allow type resolution to succeed correctly. The FakeAnnotation never makes it to\n * disk, since the weaver does the job properly, attaching a real annotation.\n */\npublic class FakeAnnotation extends AnnotationGen {\n\n\tprivate String name;\n\tprivate String sig;\n\tprivate boolean isRuntimeVisible;\n\n\tpublic FakeAnnotation(String name, String sig, boolean isRuntimeVisible) {\n\t\tsuper(null, null, true, null);\n\t\tthis.name = name;\n\t\tthis.sig = sig;\n\t\tthis.isRuntimeVisible = isRuntimeVisible;\n\t}\n\n\tpublic String getTypeName() {\n\t\treturn name;\n\t}\n\n\tpublic String getTypeSignature() {\n\t\treturn sig;\n\t}\n\n\tpublic void addElementNameValuePair(NameValuePair evp) {\n\t\t// doesnt need to know about name/value pairs\n\t}\n\n\tpublic void dump(DataOutputStream dos) throws IOException {\n\t\t// should be serialized\n\t}\n\n\tpublic int getTypeIndex() {\n\t\treturn 0;\n\t}\n\n\tpublic List getValues() {\n\t\treturn null;\n\t}\n\n\tpublic boolean isRuntimeVisible() {\n\t\treturn isRuntimeVisible;\n\t}\n\n\tprotected void setIsRuntimeVisible(boolean b) {\n\t}\n\n\tpublic String toShortString() {\n\t\treturn \"@\" + this.name;\n\t}\n\n\tpublic String toString() {\n\t\treturn this.name;\n\t}\n}\n",
    "size": 2477
  },
  {
    "file_id": "F34",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/IfFinder.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2006 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Andy Clement                 initial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.weaver.patterns.AbstractPatternNodeVisitor;\nimport org.aspectj.weaver.patterns.AndPointcut;\nimport org.aspectj.weaver.patterns.IfPointcut;\nimport org.aspectj.weaver.patterns.NotPointcut;\nimport org.aspectj.weaver.patterns.OrPointcut;\n\n/**\n * Look for an if() pointcut\n */\nclass IfFinder extends AbstractPatternNodeVisitor {\n\tboolean hasIf = false;\n\n\tpublic Object visit(IfPointcut node, Object data) {\n\t\tif (node.alwaysFalse() || node.alwaysTrue()) {\n\t\t\t// IfFalse / IfTrue\n\t\t} else {\n\t\t\thasIf = true;\n\t\t}\n\t\treturn node;\n\t}\n\n\tpublic Object visit(AndPointcut node, Object data) {\n\t\tif (!hasIf)\n\t\t\tnode.getLeft().accept(this, data);\n\t\tif (!hasIf)\n\t\t\tnode.getRight().accept(this, data);\n\t\treturn node;\n\t}\n\n\tpublic Object visit(NotPointcut node, Object data) {\n\t\tif (!hasIf)\n\t\t\tnode.getNegatedPointcut().accept(this, data);\n\t\treturn node;\n\t}\n\n\tpublic Object visit(OrPointcut node, Object data) {\n\t\tif (!hasIf)\n\t\t\tnode.getLeft().accept(this, data);\n\t\tif (!hasIf)\n\t\t\tnode.getRight().accept(this, data);\n\t\treturn node;\n\t}\n}\n",
    "size": 1591
  },
  {
    "file_id": "F35",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/LazyClassGen.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002-2010 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC                 initial implementation\n *     Andy Clement  6Jul05 generics - signature attribute\n *     Abraham Nevado\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Vector;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.Attribute;\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.apache.bcel.classfile.Field;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.apache.bcel.classfile.Method;\nimport org.aspectj.apache.bcel.classfile.Signature;\nimport org.aspectj.apache.bcel.classfile.Synthetic;\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.generic.BasicType;\nimport org.aspectj.apache.bcel.generic.ClassGen;\nimport org.aspectj.apache.bcel.generic.FieldGen;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.bridge.SourceLocation;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjAttribute.WeaverState;\nimport org.aspectj.weaver.AjAttribute.WeaverVersionInfo;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.MemberKind;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.RuntimeVersion;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.SignatureUtils;\nimport org.aspectj.weaver.TypeVariable;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.UnresolvedType.TypeKind;\nimport org.aspectj.weaver.WeaverMessages;\nimport org.aspectj.weaver.WeaverStateInfo;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.asm.AsmDetector;\nimport org.aspectj.weaver.bcel.asm.StackMapAdder;\n\n/**\n * Lazy lazy lazy. We don't unpack the underlying class unless necessary. Things like new methods and annotations accumulate in here\n * until they must be written out, don't add them to the underlying MethodGen! Things are slightly different if this represents an\n * Aspect.\n */\npublic final class LazyClassGen {\n\n\tprivate static final Type[] ARRAY_7STRING_INT = new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING,\n\t\t\tType.STRING, Type.STRING, Type.INT };\n\n\tprivate static final Type[] ARRAY_8STRING_INT = new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING,\n\t\t\tType.STRING, Type.STRING, Type.STRING, Type.INT };\n\n\tprivate static final Type[] PARAMSIGNATURE_MAKESJP_METHOD = new Type[] {\n\t\t\tType.STRING, Type.INT, Type.STRING, Type.CLASS, Type.CLASS_ARRAY, Type.STRING_ARRAY, Type.CLASS_ARRAY, Type.CLASS, Type.INT\n\t};\n\n\tprivate static final Type[] PARAMSIGNATURE_MAKESJP_CONSTRUCTOR = new Type[] {\n\t\t\tType.STRING, Type.INT, Type.CLASS, Type.CLASS_ARRAY, Type.STRING_ARRAY, Type.CLASS_ARRAY, Type.INT\n\t};\n\n\tprivate static final Type[] PARAMSIGNATURE_MAKESJP_CATCHCLAUSE = new Type[] {\n\t\t\tType.STRING, Type.CLASS, Type.CLASS, Type.STRING, Type.INT\n\t};\n\n\tprivate static final Type[] PARAMSIGNATURE_MAKESJP_FIELD = new Type[] {\n\t\t\tType.STRING, Type.INT, Type.STRING, Type.CLASS, Type.CLASS, Type.INT\n\t};\n\n\tprivate static final Type[] PARAMSIGNATURE_MAKESJP_INITIALIZER = new Type[] {\n\t\t\tType.STRING, Type.INT, Type.CLASS, Type.INT\n\t};\n\n\tprivate static final Type[] PARAMSIGNATURE_MAKESJP_MONITOR = new Type[] {\n\t\t\tType.STRING, Type.CLASS, Type.INT\n\t};\n\n\tprivate static final Type[] PARAMSIGNATURE_MAKESJP_ADVICE = new Type[] {\n\t\t\tType.STRING, Type.INT, Type.STRING, Type.CLASS, Type.CLASS_ARRAY, Type.STRING_ARRAY,\n\t\t\tType.CLASS_ARRAY, Type.CLASS, Type.INT\n\t};\n\n\n\n\n\n\tprivate static final int ACC_SYNTHETIC = 0x1000;\n\n\tprivate static final String[] NO_STRINGS = new String[0];\n\n\tint highestLineNumber = 0; // ---- JSR 45 info\n\n\tprivate final SortedMap<String, InlinedSourceFileInfo> inlinedFiles = new TreeMap<>();\n\n\tprivate boolean regenerateGenericSignatureAttribute = false;\n\n\tprivate BcelObjectType myType; // XXX is not set for types we create\n\tprivate ClassGen myGen;\n\tprivate final ConstantPool cp;\n\tprivate final World world;\n\tprivate final String packageName = null;\n\n\tprivate final List<BcelField> fields = new ArrayList<>();\n\tprivate final List<LazyMethodGen> methodGens = new ArrayList<>();\n\tprivate final List<LazyClassGen> classGens = new ArrayList<>();\n\tprivate final List<AnnotationGen> annotations = new ArrayList<>();\n\tprivate int childCounter = 0;\n\n\tprivate final InstructionFactory fact;\n\n\tprivate boolean isSerializable = false;\n\tprivate boolean hasSerialVersionUIDField = false;\n\tprivate boolean serialVersionUIDRequiresInitialization = false;\n\tprivate long calculatedSerialVersionUID;\n\tprivate boolean hasClinit = false;\n\n\tprivate ResolvedType[] extraSuperInterfaces = null;\n\tprivate ResolvedType superclass = null;\n\n\t// ---\n\n\tstatic class InlinedSourceFileInfo {\n\t\tint highestLineNumber;\n\t\tint offset; // calculated\n\n\t\tInlinedSourceFileInfo(int highestLineNumber) {\n\t\t\tthis.highestLineNumber = highestLineNumber;\n\t\t}\n\t}\n\n\tvoid addInlinedSourceFileInfo(String fullpath, int highestLineNumber) {\n\t\tInlinedSourceFileInfo info = inlinedFiles.get(fullpath);\n\t\tif (info != null) {\n\t\t\tif (info.highestLineNumber < highestLineNumber) {\n\t\t\t\tinfo.highestLineNumber = highestLineNumber;\n\t\t\t}\n\t\t} else {\n\t\t\tinlinedFiles.put(fullpath, new InlinedSourceFileInfo(highestLineNumber));\n\t\t}\n\t}\n\n\tvoid calculateSourceDebugExtensionOffsets() {\n\t\tint i = roundUpToHundreds(highestLineNumber);\n\t\tfor (InlinedSourceFileInfo element : inlinedFiles.values()) {\n\t\t\telement.offset = i;\n\t\t\ti = roundUpToHundreds(i + element.highestLineNumber);\n\t\t}\n\t}\n\n\tprivate static int roundUpToHundreds(int i) {\n\t\treturn ((i / 100) + 1) * 100;\n\t}\n\n\tint getSourceDebugExtensionOffset(String fullpath) {\n\t\treturn inlinedFiles.get(fullpath).offset;\n\t}\n\n\t// private Unknown getSourceDebugExtensionAttribute() {\n\t// int nameIndex = cp.addUtf8(\"SourceDebugExtension\");\n\t// String data = getSourceDebugExtensionString();\n\t// //System.err.println(data);\n\t// byte[] bytes = Utility.stringToUTF(data);\n\t// int length = bytes.length;\n\t//\n\t// return new Unknown(nameIndex, length, bytes, cp);\n\t// }\n\n\t// private LazyClassGen() {}\n\t// public static void main(String[] args) {\n\t// LazyClassGen m = new LazyClassGen();\n\t// m.highestLineNumber = 37;\n\t// m.inlinedFiles.put(\"boo/baz/foo.java\", new InlinedSourceFileInfo( 83));\n\t// m.inlinedFiles.put(\"boo/barz/foo.java\", new InlinedSourceFileInfo(292));\n\t// m.inlinedFiles.put(\"boo/baz/moo.java\", new InlinedSourceFileInfo(128));\n\t// m.calculateSourceDebugExtensionOffsets();\n\t// System.err.println(m.getSourceDebugExtensionString());\n\t// }\n\n\t// For the entire pathname, we're using package names. This is probably\n\t// wrong.\n\t// private String getSourceDebugExtensionString() {\n\t// StringBuffer out = new StringBuffer();\n\t// String myFileName = getFileName();\n\t// // header section\n\t// out.append(\"SMAP\\n\");\n\t// out.append(myFileName);\n\t// out.append(\"\\nAspectJ\\n\");\n\t// // stratum section\n\t// out.append(\"*S AspectJ\\n\");\n\t// // file section\n\t// out.append(\"*F\\n\");\n\t// out.append(\"1 \");\n\t// out.append(myFileName);\n\t// out.append(\"\\n\");\n\t// int i = 2;\n\t// for (Iterator iter = inlinedFiles.keySet().iterator(); iter.hasNext();) {\n\t// String element = (String) iter.next();\n\t// int ii = element.lastIndexOf('/');\n\t// if (ii == -1) {\n\t// out.append(i++); out.append(' ');\n\t// out.append(element); out.append('\\n');\n\t// } else {\n\t// out.append(\"+ \"); out.append(i++); out.append(' ');\n\t// out.append(element.substring(ii+1)); out.append('\\n');\n\t// out.append(element); out.append('\\n');\n\t// }\n\t// }\n\t// // emit line section\n\t// out.append(\"*L\\n\");\n\t// out.append(\"1#1,\");\n\t// out.append(highestLineNumber);\n\t// out.append(\":1,1\\n\");\n\t// i = 2;\n\t// for (Iterator iter = inlinedFiles.values().iterator(); iter.hasNext();) {\n\t// InlinedSourceFileInfo element = (InlinedSourceFileInfo) iter.next();\n\t// out.append(\"1#\");\n\t// out.append(i++); out.append(',');\n\t// out.append(element.highestLineNumber); out.append(\":\");\n\t// out.append(element.offset + 1); out.append(\",1\\n\");\n\t// }\n\t// // end section\n\t// out.append(\"*E\\n\");\n\t// // and finish up...\n\t// return out.toString();\n\t// }\n\n\t// ---- end JSR45-related stuff\n\n\t/** Emit disassembled class and newline to out */\n\tpublic static void disassemble(String path, String name, PrintStream out) throws IOException {\n\t\tif (null == out) {\n\t\t\treturn;\n\t\t}\n\t\t// out.println(\"classPath: \" + classPath);\n\n\t\tBcelWorld world = new BcelWorld(path);\n\n\t\tUnresolvedType ut = UnresolvedType.forName(name);\n\t\tut.setNeedsModifiableDelegate(true);\n\t\tLazyClassGen clazz = new LazyClassGen(BcelWorld.getBcelObjectType(world.resolve(ut)));\n\t\tclazz.print(out);\n\t\tout.println();\n\t}\n\n\tpublic String getNewGeneratedNameTag() {\n\t\treturn Integer.toString(childCounter++);\n\t}\n\n\t// ----\n\n\tpublic LazyClassGen(String class_name, String super_class_name, String file_name, int access_flags, String[] interfaces,\n\t\t\tWorld world) {\n\t\tmyGen = new ClassGen(class_name, super_class_name, file_name, access_flags, interfaces);\n\t\tcp = myGen.getConstantPool();\n\t\tfact = new InstructionFactory(myGen, cp);\n\t\tregenerateGenericSignatureAttribute = true;\n\t\tthis.world = world;\n\t}\n\n\tpublic void setMajorMinor(int major, int minor) {\n\t\tmyGen.setMajor(major);\n\t\tmyGen.setMinor(minor);\n\t}\n\n\tpublic int getMajor() {\n\t\treturn myGen.getMajor();\n\t}\n\n\tpublic int getMinor() {\n\t\treturn myGen.getMinor();\n\t}\n\n\t// Non child type, so it comes from a real type in the world.\n\tpublic LazyClassGen(BcelObjectType myType) {\n\t\tmyGen = new ClassGen(myType.getJavaClass());\n\t\tcp = myGen.getConstantPool();\n\t\tfact = new InstructionFactory(myGen, cp);\n\t\tthis.myType = myType;\n\t\tworld = myType.getResolvedTypeX().getWorld();\n\n\t\t/* Does this class support serialization */\n\t\tif (implementsSerializable(getType())) {\n\t\t\tisSerializable = true;\n\n\t\t\t// ResolvedMember[] fields = getType().getDeclaredFields();\n\t\t\t// for (int i = 0; i < fields.length; i++) {\n\t\t\t// ResolvedMember field = fields[i];\n\t\t\t// if (field.getName().equals(\"serialVersionUID\")\n\t\t\t// && field.isStatic() && field.getType().equals(UnresolvedType.LONG))\n\t\t\t// {\n\t\t\t// hasSerialVersionUIDField = true;\n\t\t\t// }\n\t\t\t// }\n\t\t\thasSerialVersionUIDField = hasSerialVersionUIDField(getType());\n\n\t\t\tResolvedMember[] methods = getType().getDeclaredMethods();\n\t\t\tfor (ResolvedMember method : methods) {\n\t\t\t\tif (method.getName().equals(\"<clinit>\")) {\n\t\t\t\t\tif (method.getKind() != Member.STATIC_INITIALIZATION) {\n\t\t\t\t\t\tthrow new RuntimeException(\"qui?\");\n\t\t\t\t\t}\n\t\t\t\t\thasClinit = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do we need to calculate an SUID and add it?\n\t\t\tif (!getType().isInterface() && !hasSerialVersionUIDField && world.isAddSerialVerUID()) {\n\t\t\t\tcalculatedSerialVersionUID = myGen.getSUID();\n\t\t\t\tFieldGen fg = new FieldGen(Constants.ACC_PRIVATE | Constants.ACC_FINAL | Constants.ACC_STATIC, BasicType.LONG,\n\t\t\t\t\t\t\"serialVersionUID\", getConstantPool());\n\t\t\t\taddField(fg);\n\t\t\t\thasSerialVersionUIDField = true;\n\t\t\t\tserialVersionUIDRequiresInitialization = true;\n\t\t\t\t// warn about what we've done?\n\t\t\t\tif (world.getLint().calculatingSerialVersionUID.isEnabled()) {\n\t\t\t\t\tworld.getLint().calculatingSerialVersionUID.signal(\n\t\t\t\t\t\t\tnew String[] { getClassName(), Long.toString(calculatedSerialVersionUID) + \"L\" }, null, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tResolvedMember[] methods = myType.getDeclaredMethods();\n\t\tfor (ResolvedMember method : methods) {\n\t\t\taddMethodGen(new LazyMethodGen((BcelMethod) method, this));\n\t\t}\n\n\t\t// Method[] methods = myGen.getMethods();\n\t\t// for (int i = 0; i < methods.length; i++) {\n\t\t// addMethodGen(new LazyMethodGen(methods[i], this));\n\t\t// }\n\n\t\tResolvedMember[] fields = myType.getDeclaredFields();\n\t\tfor (ResolvedMember field : fields) {\n\t\t\tthis.fields.add((BcelField) field);\n\t\t}\n\t}\n\n\tpublic static boolean hasSerialVersionUIDField(ResolvedType type) {\n\n\t\tResolvedMember[] fields = type.getDeclaredFields();\n\t\tfor (ResolvedMember field : fields) {\n\t\t\tif (field.getName().equals(\"serialVersionUID\") && Modifier.isStatic(field.getModifiers())\n\t\t\t\t\t&& field.getType().equals(UnresolvedType.LONG)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// public void addAttribute(Attribute i) {\n\t// myGen.addAttribute(i);\n\t// }\n\n\t// ----\n\n\tpublic String getInternalClassName() {\n\t\treturn getConstantPool().getConstantString_CONSTANTClass(myGen.getClassNameIndex());\n\t\t// getConstantPool().getConstantString(\n\t\t// myGen.getClassNameIndex(),\n\t\t// Constants.CONSTANT_Class);\n\n\t}\n\n\tpublic String getInternalFileName() {\n\t\tString str = getInternalClassName();\n\t\tint index = str.lastIndexOf('/');\n\t\tif (index == -1) {\n\t\t\treturn getFileName();\n\t\t} else {\n\t\t\treturn str.substring(0, index + 1) + getFileName();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the packagename - if its the default package we return an empty string\n\t */\n\tpublic String getPackageName() {\n\t\tif (packageName != null) {\n\t\t\treturn packageName;\n\t\t}\n\t\tString str = getInternalClassName();\n\t\tint index = str.indexOf(\"<\");\n\t\tif (index != -1) {\n\t\t\tstr = str.substring(0, index); // strip off the generics guff\n\t\t}\n\t\tindex = str.lastIndexOf(\"/\");\n\t\tif (index == -1) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn str.substring(0, index).replace('/', '.');\n\t}\n\n\tpublic void addMethodGen(LazyMethodGen gen) {\n\t\t// assert gen.getClassName() == super.getClassName();\n\t\tmethodGens.add(gen);\n\t\tif (highestLineNumber < gen.highestLineNumber) {\n\t\t\thighestLineNumber = gen.highestLineNumber;\n\t\t}\n\t}\n\n\tpublic boolean removeMethodGen(LazyMethodGen gen) {\n\t\treturn methodGens.remove(gen);\n\t}\n\n\tpublic void addMethodGen(LazyMethodGen gen, ISourceLocation sourceLocation) {\n\t\taddMethodGen(gen);\n\t\tif (!gen.getMethod().isPrivate()) {\n\t\t\twarnOnAddedMethod(gen.getMethod(), sourceLocation);\n\t\t}\n\t}\n\n\tpublic void errorOnAddedField(FieldGen field, ISourceLocation sourceLocation) {\n\t\tif (isSerializable && !hasSerialVersionUIDField) {\n\t\t\tgetWorld().getLint().serialVersionUIDBroken.signal(\n\t\t\t\t\tnew String[] { myType.getResolvedTypeX().getName(), field.getName() }, sourceLocation, null);\n\t\t}\n\t}\n\n\tpublic void warnOnAddedInterface(String name, ISourceLocation sourceLocation) {\n\t\twarnOnModifiedSerialVersionUID(sourceLocation, \"added interface \" + name);\n\t}\n\n\tpublic void warnOnAddedMethod(Method method, ISourceLocation sourceLocation) {\n\t\twarnOnModifiedSerialVersionUID(sourceLocation, \"added non-private method \" + method.getName());\n\t}\n\n\tpublic void warnOnAddedStaticInitializer(Shadow shadow, ISourceLocation sourceLocation) {\n\t\tif (!hasClinit) {\n\t\t\twarnOnModifiedSerialVersionUID(sourceLocation, \"added static initializer\");\n\t\t}\n\t}\n\n\tpublic void warnOnModifiedSerialVersionUID(ISourceLocation sourceLocation, String reason) {\n\t\tif (isSerializable && !hasSerialVersionUIDField) {\n\t\t\tgetWorld().getLint().needsSerialVersionUIDField.signal(new String[] { myType.getResolvedTypeX().getName().toString(),\n\t\t\t\t\treason }, sourceLocation, null);\n\t\t}\n\t}\n\n\tpublic World getWorld() {\n\t\treturn world;\n\t}\n\n\tpublic List<LazyMethodGen> getMethodGens() {\n\t\treturn methodGens; // ???Collections.unmodifiableList(methodGens);\n\t}\n\n\tpublic List<BcelField> getFieldGens() {\n\t\treturn fields;\n\t}\n\n\tpublic boolean fieldExists(String name) {\n\t\t//\t\tField[] allFields = myGen.getFields();\n\t\t//\t\tif (allFields!=null) {\n\t\t//\t\t\tfor (int i=0;i<allFields.length;i++) {\n\t\t//\t\t\t\tField f = allFields[i];\n\t\t//\t\t\t\tif (f.getName().equals(name)) {\n\t\t//\t\t\t\t\treturn f;\n\t\t//\t\t\t\t}\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\tfor (BcelField f: fields) {\n\t\t\tif (f.getName().equals(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void writeBack(BcelWorld world) {\n\t\tif (getConstantPool().getSize() > Short.MAX_VALUE) {\n\t\t\treportClassTooBigProblem();\n\t\t\treturn;\n\t\t}\n\n\t\tif (annotations.size() > 0) {\n\t\t\tfor (AnnotationGen element : annotations) {\n\t\t\t\tmyGen.addAnnotation(element);\n\t\t\t}\n\t\t\t// Attribute[] annAttributes =\n\t\t\t// org.aspectj.apache.bcel.classfile.Utility.getAnnotationAttributes(\n\t\t\t// getConstantPool(),annotations);\n\t\t\t// for (int i = 0; i < annAttributes.length; i++) {\n\t\t\t// Attribute attribute = annAttributes[i];\n\t\t\t// System.err.println(\"Adding attribute for \"+attribute);\n\t\t\t// myGen.addAttribute(attribute);\n\t\t\t// }\n\t\t}\n\n\t\t// Add a weaver version attribute to the file being produced (if\n\t\t// necessary...)\n\t\tif (!myGen.hasAttribute(\"org.aspectj.weaver.WeaverVersion\")) {\n\t\t\tmyGen.addAttribute(Utility.bcelAttribute(new AjAttribute.WeaverVersionInfo(), getConstantPool()));\n\t\t}\n\n\t\t// see 389678: TODO more finessing possible here?\n\t\tif (world.isOverWeaving()) {\n\t\t\tif (myGen.hasAttribute(WeaverState.AttributeName) && myType!=null && myType.getWeaverState() != null) {\n\t\t\t\tmyGen.removeAttribute(myGen.getAttribute(WeaverState.AttributeName));\n\t\t\t\tmyGen.addAttribute(Utility.bcelAttribute(new AjAttribute.WeaverState(myType.getWeaverState()), getConstantPool()));\n\t\t\t}\n\t\t} else {\n\t\t\tif (!myGen.hasAttribute(WeaverState.AttributeName) && myType != null && myType.getWeaverState() != null) {\n\t\t\t\tmyGen.addAttribute(Utility.bcelAttribute(new AjAttribute.WeaverState(myType.getWeaverState()), getConstantPool()));\n\t\t\t}\n\t\t}\n\n\t\t// FIXME ATAJ needed only for slow Aspects.aspectOf() - keep or remove\n\t\t// make a lot of test fail since the test compare weaved class file\n\t\t// based on some test data as text files...\n\t\t// if (!myGen.isInterface()) {\n\t\t// addAjClassField();\n\t\t// }\n\n\t\taddAjcInitializers();\n\n\t\t// 17Feb05 - ASC - Skip this for now - it crashes IBM 1.4.2 jvms\n\t\t// (pr80430). Will be revisited when contents\n\t\t// of attribute are confirmed to be correct.\n\t\tboolean sourceDebugExtensionSupportSwitchedOn = false;\n\n\t\tif (sourceDebugExtensionSupportSwitchedOn) {\n\t\t\tcalculateSourceDebugExtensionOffsets();\n\t\t}\n\n\t\tint len = methodGens.size();\n\t\tmyGen.setMethods(Method.NoMethods);\n\n\t\tfor (LazyMethodGen gen : methodGens) {\n\t\t\t// we skip empty clinits\n\t\t\tif (isEmptyClinit(gen)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmyGen.addMethod(gen.getMethod());\n\t\t}\n\n\t\tlen = fields.size();\n\t\tmyGen.setFields(Field.NoFields);\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tBcelField gen = fields.get(i);\n\t\t\tmyGen.addField(gen.getField(cp));\n\t\t}\n\n\t\tif (sourceDebugExtensionSupportSwitchedOn) {\n\t\t\tif (inlinedFiles.size() != 0) {\n\t\t\t\tif (hasSourceDebugExtensionAttribute(myGen)) {\n\t\t\t\t\tworld.showMessage(IMessage.WARNING, WeaverMessages.format(WeaverMessages.OVERWRITE_JSR45, getFileName()), null,\n\t\t\t\t\t\t\tnull);\n\t\t\t\t}\n\t\t\t\t// myGen.addAttribute(getSourceDebugExtensionAttribute());\n\t\t\t}\n\t\t}\n\n\t\tfixupGenericSignatureAttribute();\n\t}\n\n\t/**\n\t * When working with Java generics, a signature attribute is attached to the type which indicates how it was declared. This\n\t * routine ensures the signature attribute for the class we are about to write out is correct. Basically its responsibilities\n\t * are:\n\t * <ol>\n\t * <li>\n\t * Checking whether the attribute needs changing (ie. did weaving change the type hierarchy) - if it did, remove the old\n\t * attribute\n\t * <li>\n\t * Check if we need an attribute at all, are we generic? are our supertypes parameterized/generic?\n\t * <li>\n\t * Build the new attribute which includes all typevariable, supertype and superinterface information\n\t * </ol>\n\t */\n\tprivate void fixupGenericSignatureAttribute() {\n\n\t\tif (getWorld() != null && !getWorld().isInJava5Mode()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO asc generics Temporarily assume that types we generate dont need\n\t\t// a signature attribute (closure/etc).. will need\n\t\t// revisiting no doubt...\n\t\t// if (myType == null) {\n\t\t// return;\n\t\t// }\n\n\t\t// 1. Has anything changed that would require us to modify this\n\t\t// attribute?\n\t\tif (!regenerateGenericSignatureAttribute) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 2. Find the old attribute\n\t\tSignature sigAttr = null;\n\t\tif (myType != null) { // if null, this is a type built from scratch, it\n\t\t\t// won't already have a sig attribute\n\t\t\tsigAttr = (Signature) myGen.getAttribute(\"Signature\");\n\t\t}\n\n\t\t// 3. Do we need an attribute?\n\t\tboolean needAttribute = false;\n\t\t// If we had one before, we definetly still need one as types can't be\n\t\t// 'removed' from the hierarchy\n\t\tif (sigAttr != null) {\n\t\t\tneedAttribute = true;\n\t\t}\n\n\t\t// check the interfaces\n\t\tif (!needAttribute) {\n\t\t\tif (myType != null) {\n\t\t\t\tResolvedType[] interfaceRTXs = myType.getDeclaredInterfaces();\n\t\t\t\tfor (ResolvedType typeX : interfaceRTXs) {\n\t\t\t\t\tif (typeX.isGenericType() || typeX.isParameterizedType()) {\n\t\t\t\t\t\tneedAttribute = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (extraSuperInterfaces != null) {\n\t\t\t\t\tfor (ResolvedType interfaceType : extraSuperInterfaces) {\n\t\t\t\t\t\tif (interfaceType.isGenericType() || interfaceType.isParameterizedType()) {\n\t\t\t\t\t\t\tneedAttribute = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (myType == null) {\n\t\t\t\tResolvedType superclassRTX = superclass;\n\t\t\t\tif (superclassRTX != null) {\n\t\t\t\t\tif (superclassRTX.isGenericType() || superclassRTX.isParameterizedType()) {\n\t\t\t\t\t\tneedAttribute = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// check the supertype\n\t\t\t\tResolvedType superclassRTX = getSuperClass();\n\t\t\t\tif (superclassRTX.isGenericType() || superclassRTX.isParameterizedType()) {\n\t\t\t\t\tneedAttribute = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (needAttribute) {\n\t\t\tStringBuilder signature = new StringBuilder();\n\t\t\t// first, the type variables...\n\t\t\tif (myType != null) {\n\t\t\t\tTypeVariable[] tVars = myType.getTypeVariables();\n\t\t\t\tif (tVars.length > 0) {\n\t\t\t\t\tsignature.append(\"<\");\n\t\t\t\t\tfor (TypeVariable variable : tVars) {\n\t\t\t\t\t\tsignature.append(variable.getSignatureForAttribute());\n\t\t\t\t\t}\n\t\t\t\t\tsignature.append(\">\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// now the supertype\n\t\t\tString supersig = getSuperClass().getSignatureForAttribute();\n\t\t\tsignature.append(supersig);\n\t\t\tif (myType != null) {\n\t\t\t\tResolvedType[] interfaceRTXs = myType.getDeclaredInterfaces();\n\t\t\t\tfor (ResolvedType interfaceRTX : interfaceRTXs) {\n\t\t\t\t\tString s = interfaceRTX.getSignatureForAttribute();\n\t\t\t\t\tsignature.append(s);\n\t\t\t\t}\n\t\t\t\tif (extraSuperInterfaces != null) {\n\t\t\t\t\tfor (ResolvedType extraSuperInterface : extraSuperInterfaces) {\n\t\t\t\t\t\tString s = extraSuperInterface.getSignatureForAttribute();\n\t\t\t\t\t\tsignature.append(s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sigAttr != null) {\n\t\t\t\tmyGen.removeAttribute(sigAttr);\n\t\t\t}\n\t\t\tmyGen.addAttribute(createSignatureAttribute(signature.toString()));\n\t\t}\n\t}\n\n\t/**\n\t * Helper method to create a signature attribute based on a string signature: e.g. \"Ljava/lang/Object;LI<Ljava/lang/Double;>;\"\n\t */\n\tprivate Signature createSignatureAttribute(String signature) {\n\t\tint nameIndex = cp.addUtf8(\"Signature\");\n\t\tint sigIndex = cp.addUtf8(signature);\n\t\treturn new Signature(nameIndex, 2, sigIndex, cp);\n\t}\n\n\t/**\n\t *\n\t */\n\tprivate void reportClassTooBigProblem() {\n\t\t// PR 59208\n\t\t// we've generated a class that is just toooooooooo big (you've been\n\t\t// generating programs\n\t\t// again haven't you? come on, admit it, no-one writes classes this big\n\t\t// by hand).\n\t\t// create an empty myGen so that we can give back a return value that\n\t\t// doesn't upset the\n\t\t// rest of the process.\n\t\tmyGen = new ClassGen(myGen.getClassName(), myGen.getSuperclassName(), myGen.getFileName(), myGen.getModifiers(),\n\t\t\t\tmyGen.getInterfaceNames());\n\t\t// raise an error against this compilation unit.\n\t\tgetWorld().showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.CLASS_TOO_BIG, this.getClassName()),\n\t\t\t\tnew SourceLocation(new File(myGen.getFileName()), 0), null);\n\t}\n\n\tprivate static boolean hasSourceDebugExtensionAttribute(ClassGen gen) {\n\t\treturn gen.hasAttribute(\"SourceDebugExtension\");\n\t}\n\n\tpublic JavaClass getJavaClass(BcelWorld world) {\n\t\twriteBack(world);\n\t\treturn myGen.getJavaClass();\n\t}\n\n\tpublic byte[] getJavaClassBytesIncludingReweavable(BcelWorld world) {\n\t\twriteBack(world);\n\t\tbyte[] wovenClassFileData = myGen.getJavaClass().getBytes();\n\t\t// At 1.6 stackmaps are optional, whilst at 1.7 and later they\n\t\t// are required (unless turning off the verifier)\n\t\tif ((myGen.getMajor() == Constants.MAJOR_1_6 && world.shouldGenerateStackMaps()) || myGen.getMajor() > Constants.MAJOR_1_6) {\n\t\t\tif (!AsmDetector.isAsmAround) {\n\t\t\t\tif (\n\t\t\t\t\tAsmDetector.rootCause instanceof ClassNotFoundException ||\n\t\t\t\t\t\tAsmDetector.rootCause instanceof NoClassDefFoundError\n\t\t\t\t) {\n\t\t\t\t\t// Fix https://github.com/eclipse-aspectj/aspectj/issues/251, using \"replace('\u00c4', '\u00d6')\" to avoid\n\t\t\t\t\t// non-relocated class names to be embedded into the error message during compile time, making it end up in\n\t\t\t\t\t// the class constant pool unwantedly, as this clashes with post-compile ASM package relocation.\n\t\t\t\t\tString errorMessage = \"Unable to find ASM classes (\" +\n\t\t\t\t\t\tAsmDetector.CLASS_READER.replace('\u00c4', '\u00d6') + \", \" + AsmDetector.CLASS_VISITOR.replace('\u00c4', '\u00d6') + \") \" +\n\t\t\t\t\t\t\"for stackmap generation. Stackmap generation for woven code is required to avoid verify errors \" +\n\t\t\t\t\t\t\"on a Java 1.7 or higher runtime.\";\n\t\t\t\t\tthrow new BCException(errorMessage, AsmDetector.rootCause);\n\t\t\t\t}\n\t\t\t\tthrow new BCException(\"Error processing class file\", AsmDetector.rootCause);\n\t\t\t}\n\t\t\twovenClassFileData = StackMapAdder.addStackMaps(world, myGen.getClassName(), wovenClassFileData);\n\t\t}\n\n\t\tWeaverStateInfo wsi = myType.getWeaverState();// getOrCreateWeaverStateInfo();\n\t\tif (wsi != null && wsi.isReweavable() && !world.isOverWeaving()) { // && !reweavableDataInserted\n\t\t\t// reweavableDataInserted = true;\n\t\t\treturn wsi.replaceKeyWithDiff(wovenClassFileData);\n\t\t} else {\n\t\t\treturn wovenClassFileData;\n\t\t}\n\t}\n\n\tpublic void addGeneratedInner(LazyClassGen newClass) {\n\t\tclassGens.add(newClass);\n\t}\n\n\tpublic void addInterface(ResolvedType newInterface, ISourceLocation sourceLocation) {\n\t\tregenerateGenericSignatureAttribute = true;\n\n\t\tif (extraSuperInterfaces == null) {\n\t\t\textraSuperInterfaces = new ResolvedType[1];\n\t\t\textraSuperInterfaces[0] = newInterface;\n\t\t} else {\n\t\t\tResolvedType[] x = new ResolvedType[extraSuperInterfaces.length + 1];\n\t\t\tSystem.arraycopy(extraSuperInterfaces, 0, x, 1, extraSuperInterfaces.length);\n\t\t\tx[0] = newInterface;\n\t\t\textraSuperInterfaces = x;\n\t\t}\n\t\tmyGen.addInterface(newInterface.getRawName());\n\t\tif (!newInterface.equals(UnresolvedType.SERIALIZABLE)) {\n\t\t\twarnOnAddedInterface(newInterface.getName(), sourceLocation);\n\t\t}\n\t}\n\n\tpublic void setSuperClass(ResolvedType newSuperclass) {\n\t\tregenerateGenericSignatureAttribute = true;\n\t\tsuperclass = newSuperclass;\n\t\t// myType.addParent(typeX); // used for the attribute\n\t\tif (newSuperclass.getGenericType() != null) {\n\t\t\tnewSuperclass = newSuperclass.getGenericType();\n\t\t}\n\t\tmyGen.setSuperclassName(newSuperclass.getName()); // used in the real\n\t\t// class data\n\t}\n\n\t// public String getSuperClassname() {\n\t// return myGen.getSuperclassName();\n\t// }\n\n\tpublic ResolvedType getSuperClass() {\n\t\tif (superclass != null) {\n\t\t\treturn superclass;\n\t\t}\n\t\treturn myType.getSuperclass();\n\t}\n\n\tpublic String[] getInterfaceNames() {\n\t\treturn myGen.getInterfaceNames();\n\t}\n\n\t// non-recursive, may be a bug, ha ha.\n\tprivate List<LazyClassGen> getClassGens() {\n\t\tList<LazyClassGen> ret = new ArrayList<>();\n\t\tret.add(this);\n\t\tret.addAll(classGens);\n\t\treturn ret;\n\t}\n\n\tpublic List<UnwovenClassFile.ChildClass> getChildClasses(BcelWorld world) {\n\t\tif (classGens.isEmpty()) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tList<UnwovenClassFile.ChildClass> ret = new ArrayList<>();\n\t\tfor (LazyClassGen clazz : classGens) {\n\t\t\tbyte[] bytes = clazz.getJavaClass(world).getBytes();\n\t\t\tString name = clazz.getName();\n\t\t\tint index = name.lastIndexOf('$');\n\t\t\t// XXX this could be bad, check use of dollar signs.\n\t\t\tname = name.substring(index + 1);\n\t\t\tret.add(new UnwovenClassFile.ChildClass(name, bytes));\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn toShortString();\n\t}\n\n\tpublic String toShortString() {\n\t\tString s = org.aspectj.apache.bcel.classfile.Utility.accessToString(myGen.getModifiers(), true);\n\t\tif (!s.equals(\"\")) {\n\t\t\ts += \" \";\n\t\t}\n\t\ts += org.aspectj.apache.bcel.classfile.Utility.classOrInterface(myGen.getModifiers());\n\t\ts += \" \";\n\t\ts += myGen.getClassName();\n\t\treturn s;\n\t}\n\n\tpublic String toLongString() {\n\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\t\tprint(new PrintStream(s));\n\t\treturn new String(s.toByteArray());\n\t}\n\n\tpublic void print() {\n\t\tprint(System.out);\n\t}\n\n\tpublic void print(PrintStream out) {\n\t\tList<LazyClassGen> classGens = getClassGens();\n\t\tfor (Iterator<LazyClassGen> iter = classGens.iterator(); iter.hasNext();) {\n\t\t\tLazyClassGen element = iter.next();\n\t\t\telement.printOne(out);\n\t\t\tif (iter.hasNext()) {\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void printOne(PrintStream out) {\n\t\tout.print(toShortString());\n\t\tout.print(\" extends \");\n\t\tout.print(org.aspectj.apache.bcel.classfile.Utility.compactClassName(myGen.getSuperclassName(), false));\n\n\t\tint size = myGen.getInterfaces().length;\n\n\t\tif (size > 0) {\n\t\t\tout.print(\" implements \");\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tout.print(myGen.getInterfaceNames()[i]);\n\t\t\t\tif (i < size - 1) {\n\t\t\t\t\tout.print(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.print(\":\");\n\t\tout.println();\n\t\t// XXX make sure to pass types correctly around, so this doesn't happen.\n\t\tif (myType != null) {\n\t\t\tmyType.printWackyStuff(out);\n\t\t}\n\t\tField[] fields = myGen.getFields();\n\t\tfor (Field field : fields) {\n\t\t\tout.print(\"  \");\n\t\t\tout.println(field);\n\t\t}\n\t\tList<LazyMethodGen> methodGens = getMethodGens();\n\t\tfor (Iterator<LazyMethodGen> iter = methodGens.iterator(); iter.hasNext();) {\n\t\t\tLazyMethodGen gen = iter.next();\n\t\t\t// we skip empty clinits\n\t\t\tif (isEmptyClinit(gen)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgen.print(out, (myType != null ? myType.getWeaverVersionAttribute() : WeaverVersionInfo.UNKNOWN));\n\t\t\tif (iter.hasNext()) {\n\t\t\t\tout.println();\n\t\t\t}\n\t\t}\n\t\t// out.println(\"  ATTRIBS: \" + Arrays.asList(myGen.getAttributes()));\n\n\t\tout.println(\"end \" + toShortString());\n\t}\n\n\tprivate boolean isEmptyClinit(LazyMethodGen gen) {\n\n\t\tif (!gen.getName().equals(\"<clinit>\")) {\n\t\t\treturn false;\n\t\t}\n\t\t// System.err.println(\"checking clinig: \" + gen);\n\t\tInstructionHandle start = gen.getBody().getStart();\n\t\twhile (start != null) {\n\t\t\tif (Range.isRangeHandle(start) || (start.getInstruction().opcode == Constants.RETURN)) {\n\t\t\t\tstart = start.getNext();\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic ConstantPool getConstantPool() {\n\t\treturn cp;\n\t}\n\n\tpublic String getName() {\n\t\treturn myGen.getClassName();\n\t}\n\n\tpublic boolean isWoven() {\n\t\treturn myType.getWeaverState() != null;\n\t}\n\n\tpublic boolean isReweavable() {\n\t\tif (myType.getWeaverState() == null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn myType.getWeaverState().isReweavable();\n\t}\n\n\tpublic Set<String> getAspectsAffectingType() {\n\t\tif (myType.getWeaverState() == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn myType.getWeaverState().getAspectsAffectingType();\n\t}\n\n\tpublic WeaverStateInfo getOrCreateWeaverStateInfo(boolean inReweavableMode) {\n\t\tWeaverStateInfo ret = myType.getWeaverState();\n\t\tif (ret != null) {\n\t\t\treturn ret;\n\t\t}\n\t\tret = new WeaverStateInfo(inReweavableMode);\n\t\tmyType.setWeaverState(ret);\n\t\treturn ret;\n\t}\n\n\tpublic InstructionFactory getFactory() {\n\t\treturn fact;\n\t}\n\n\tpublic LazyMethodGen getStaticInitializer() {\n\t\tfor (LazyMethodGen gen : methodGens) {\n\t\t\t// OPTIMIZE persist kind of member into the gen object? for clinit\n\t\t\tif (gen.getName().equals(\"<clinit>\")) {\n\t\t\t\treturn gen;\n\t\t\t}\n\t\t}\n\t\tLazyMethodGen clinit = new LazyMethodGen(Modifier.STATIC, Type.VOID, \"<clinit>\", Type.NO_ARGS, NO_STRINGS, this);\n\t\tclinit.getBody().insert(InstructionConstants.RETURN);\n\t\tmethodGens.add(clinit);\n\t\treturn clinit;\n\t}\n\n\t/**\n\t * Retrieve the ajc$preClinit method - this method captures any initialization AspectJ wants to ensure happens in a class. It is\n\t * called from the static initializer. Maintaining this separation enables overweaving to ignore join points added due to\n\t * earlier weaves. If the ajc$preClinit method cannot be found, it is created and a call to it is placed in the real static\n\t * initializer (the call is placed at the start of the static initializer).\n\t *\n\t * @return the LazyMethodGen representing the ajc$ clinit\n\t */\n\tpublic LazyMethodGen getAjcPreClinit() {\n\t\tif (this.isInterface()) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\t\tfor (LazyMethodGen methodGen : methodGens) {\n\t\t\tif (methodGen.getName().equals(NameMangler.AJC_PRE_CLINIT_NAME)) {\n\t\t\t\treturn methodGen;\n\t\t\t}\n\t\t}\n\t\tLazyMethodGen ajcPreClinit = new LazyMethodGen(Modifier.PRIVATE | Modifier.STATIC, Type.VOID,\n\t\t\t\tNameMangler.AJC_PRE_CLINIT_NAME, Type.NO_ARGS, NO_STRINGS, this);\n\t\tajcPreClinit.getBody().insert(InstructionConstants.RETURN);\n\t\tmethodGens.add(ajcPreClinit);\n\t\tInstructionList clinitBody = getStaticInitializer().getBody();\n\t\tclinitBody.insert(Utility.createInvoke(fact, ajcPreClinit));\n\t\tif (serialVersionUIDRequiresInitialization) {\n\t\t\tInstructionList il = new InstructionList();\n\t\t\til.append(InstructionFactory.PUSH(getConstantPool(), calculatedSerialVersionUID));\n\t\t\til.append(getFactory().createFieldAccess(getClassName(), \"serialVersionUID\", BasicType.LONG,\n\t\t\t\t\tConstants.PUTSTATIC));\n\t\t\tclinitBody.insert(il);\n\t\t}\n\t\treturn ajcPreClinit;\n\t}\n\n\t/**\n\t * factory method for building multiple extended clinit methods. Constructs a new clinit method that invokes the previous one\n\t * and then returns it. The index is used as a name suffix.\n\t *\n\t * @param previousPreClinit\n\t * @param i\n\t */\n\tpublic LazyMethodGen createExtendedAjcPreClinit(LazyMethodGen previousPreClinit, int i) {\n\t\tLazyMethodGen ajcPreClinit = new LazyMethodGen(Modifier.PRIVATE | Modifier.STATIC, Type.VOID,\n\t\t\t\tNameMangler.AJC_PRE_CLINIT_NAME + i, Type.NO_ARGS, NO_STRINGS, this);\n\t\tajcPreClinit.getBody().insert(InstructionConstants.RETURN);\n\t\tmethodGens.add(ajcPreClinit);\n\t\tpreviousPreClinit.getBody().insert(Utility.createInvoke(fact, ajcPreClinit));\n\t\treturn ajcPreClinit;\n\t}\n\n\t//\n\n\t// reflective thisJoinPoint support\n\tprivate Map<BcelShadow, Field> tjpFields = new HashMap<>();\n\tMap<CacheKey, Field> annotationCachingFieldCache = new HashMap<>();\n\tprivate int tjpFieldsCounter = -1; // -1 means not yet initialized\n\tprivate int annoFieldsCounter = 0;\n\tpublic static final ObjectType proceedingTjpType = new ObjectType(\"org.aspectj.lang.ProceedingJoinPoint\");\n\tpublic static final ObjectType tjpType = new ObjectType(\"org.aspectj.lang.JoinPoint\");\n\tpublic static final ObjectType staticTjpType = new ObjectType(\"org.aspectj.lang.JoinPoint$StaticPart\");\n\tpublic static final ObjectType typeForAnnotation = new ObjectType(\"java.lang.annotation.Annotation\");\n\tpublic static final ObjectType enclosingStaticTjpType = new ObjectType(\"org.aspectj.lang.JoinPoint$EnclosingStaticPart\");\n\tprivate static final ObjectType sigType = new ObjectType(\"org.aspectj.lang.Signature\");\n\t// private static final ObjectType slType =\n\t// new ObjectType(\"org.aspectj.lang.reflect.SourceLocation\");\n\tprivate static final ObjectType factoryType = new ObjectType(\"org.aspectj.runtime.reflect.Factory\");\n\tprivate static final ObjectType classType = new ObjectType(\"java.lang.Class\");\n\n\tpublic Field getTjpField(BcelShadow shadow, final boolean isEnclosingJp) {\n\t\tField tjpField = tjpFields.get(shadow);\n\t\tif (tjpField != null) {\n\t\t\treturn tjpField;\n\t\t}\n\n\t\tint modifiers = Modifier.STATIC;\n\n\t\t// J9: Can't always be final on Java 9 because it is set outside of clinit\n\t\t// But must be final in interface\n\t\tif (shadow.getEnclosingClass().isInterface()) {\n\t\t\tmodifiers |= Modifier.FINAL;\n\t\t}\n\n\t\t// XXX - Do we ever inline before or after advice? If we do, then we\n\t\t// better include them in the check below. (or just change it to\n\t\t// shadow.getEnclosingMethod().getCanInline())\n\n\t\t// If the enclosing method is around advice, we could inline the join\n\t\t// point that has led to this shadow. If we do that then the TJP we are\n\t\t// creating here must be PUBLIC so it is visible to the type in which the\n\t\t// advice is inlined. (PR71377)\n\t\tLazyMethodGen encMethod = shadow.getEnclosingMethod();\n\t\tboolean shadowIsInAroundAdvice = false;\n\t\tif (encMethod != null && encMethod.getName().startsWith(NameMangler.PREFIX + \"around\")) {\n\t\t\tshadowIsInAroundAdvice = true;\n\t\t}\n\n\t\tif (getType().isInterface() || shadowIsInAroundAdvice) {\n\t\t\tmodifiers |= Modifier.PUBLIC;\n\t\t} else {\n\t\t\tmodifiers |= Modifier.PRIVATE;\n\t\t}\n\t\tObjectType jpType = null;\n\t\t// Did not have different static joinpoint types in 1.2\n\t\tif (world.isTargettingAspectJRuntime12()) {\n\t\t\tjpType = staticTjpType;\n\t\t} else {\n\t\t\tjpType = isEnclosingJp ? enclosingStaticTjpType : staticTjpType;\n\t\t}\n\t\tif (tjpFieldsCounter == -1) {\n\t\t\t// not yet initialized, do it now\n\t\t\tif (!world.isOverWeaving()) {\n\t\t\t\ttjpFieldsCounter = 0;\n\t\t\t} else {\n\t\t\t\tList<BcelField> existingFields = getFieldGens();\n\t\t\t\tif (existingFields == null) {\n\t\t\t\t\ttjpFieldsCounter = 0;\n\t\t\t\t} else {\n\t\t\t\t\tBcelField lastField = null;\n\t\t\t\t\t// OPTIMIZE: go from last to first?\n\t\t\t\t\tfor (BcelField field : existingFields) {\n\t\t\t\t\t\tif (field.getName().startsWith(\"ajc$tjp_\")) {\n\t\t\t\t\t\t\tlastField = field;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (lastField == null) {\n\t\t\t\t\t\ttjpFieldsCounter = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttjpFieldsCounter = Integer.parseInt(lastField.getName().substring(8)) + 1;\n\t\t\t\t\t\t// System.out.println(\"tjp counter starting at \" + tjpFieldsCounter);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!isInterface() && world.isTransientTjpFields()) {\n\t\t\tmodifiers|=Modifier.TRANSIENT;\n\t\t}\n\t\tFieldGen fGen = new FieldGen(modifiers, jpType, \"ajc$tjp_\" + tjpFieldsCounter++, getConstantPool());\n\t\taddField(fGen);\n\t\ttjpField = fGen.getField();\n\t\ttjpFields.put(shadow, tjpField);\n\t\treturn tjpField;\n\t}\n\n\t/**\n\t * Create a field in the type containing the shadow where the annotation retrieved during binding can be stored - for later fast\n\t * access.\n\t *\n\t * @param shadow the shadow at which the @annotation result is being cached\n\t * @return a field\n\t */\n\tpublic Field getAnnotationCachingField(BcelShadow shadow, ResolvedType toType, boolean isWithin) {\n\t\t// Multiple annotation types at a shadow. A different field would be required for each\n\t\tCacheKey cacheKey = new CacheKey(shadow, toType, isWithin);\n\t\tField field = annotationCachingFieldCache.get(cacheKey);\n\t\t// System.out.println(field + \" for shadow \" + shadow);\n\t\tif (field == null) {\n\t\t\t// private static Annotation ajc$anno$<nnn>\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(NameMangler.ANNOTATION_CACHE_FIELD_NAME);\n\t\t\tsb.append(annoFieldsCounter++);\n\t\t\tFieldGen annotationCacheField = new FieldGen(Modifier.PRIVATE | Modifier.STATIC, typeForAnnotation, sb.toString(), cp);\n\t\t\taddField(annotationCacheField);\n\t\t\tfield = annotationCacheField.getField();\n\t\t\tannotationCachingFieldCache.put(cacheKey, field);\n\t\t}\n\t\treturn field;\n\t}\n\n\tstatic class CacheKey {\n\t\tprivate Object key;\n\t\tprivate ResolvedType annotationType;\n\n\t\t// If the annotation is being accessed via @annotation on a shadow then we can use the shadows toString() (so two shadows\n\t\t// the same share a variable), but if it is @withincode() or @within() we can't share them (as the shadows may look the same\n\t\t// but be occurring 'within' different things). In the within cases we continue to use the shadow itself as the key.\n\t\tCacheKey(BcelShadow shadow, ResolvedType annotationType, boolean isWithin) {\n\t\t\tthis.key = isWithin ? shadow : shadow.toString();\n\t\t\tthis.annotationType = annotationType;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn key.hashCode() * 37 + annotationType.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (!(other instanceof CacheKey)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tCacheKey oCacheKey = (CacheKey) other;\n\t\t\treturn key.equals(oCacheKey.key) && annotationType.equals(oCacheKey.annotationType);\n\t\t}\n\t}\n\n\t// FIXME ATAJ needed only for slow Aspects.aspectOf - keep or remove\n\t// private void addAjClassField() {\n\t// // Andy: Why build it again??\n\t// Field ajClassField = new FieldGen(\n\t// Modifier.PRIVATE | Modifier.FINAL | Modifier.STATIC,\n\t// classType,\n\t// \"aj$class\",\n\t// getConstantPool()).getField();\n\t// addField(ajClassField);\n\t//\n\t// InstructionList il = new InstructionList();\n\t// il.append(new PUSH(getConstantPool(), getClassName()));\n\t// il.append(fact.createInvoke(\"java.lang.Class\", \"forName\", classType,\n\t// new Type[] {Type.STRING}, Constants.INVOKESTATIC));\n\t// il.append(fact.createFieldAccess(getClassName(), ajClassField.getName(),\n\t// classType, Constants.PUTSTATIC));\n\t//\n\t// getStaticInitializer().getBody().insert(il);\n\t// }\n\n\tprivate void addAjcInitializers() {\n\t\tif (tjpFields.size() == 0 && !serialVersionUIDRequiresInitialization) {\n\t\t\treturn;\n\t\t}\n\n\t\tInstructionList[] il = initializeAllTjps();\n\n\t\tLazyMethodGen prevMethod;\n\t\tLazyMethodGen nextMethod = null;\n\t\tif (this.isInterface()) { // Cannot sneak stuff into another static method in an interface\n\t\t\tprevMethod = getStaticInitializer();\n\t\t} else {\n\t\t\tprevMethod = getAjcPreClinit();\n\t\t}\n\t\tfor (int counter = 1; counter <= il.length; counter++) {\n\t\t\tif (il.length > counter) {\n\t\t\t\tnextMethod = createExtendedAjcPreClinit(prevMethod, counter);\n\t\t\t}\n\t\t\tprevMethod.getBody().insert(il[counter - 1]);\n\t\t\tprevMethod = nextMethod;\n\t\t}\n\t}\n\n\tprivate InstructionList initInstructionList() {\n\t\tInstructionList list = new InstructionList();\n\t\tInstructionFactory fact = getFactory();\n\n\t\t// make a new factory\n\t\tlist.append(fact.createNew(factoryType));\n\t\tlist.append(InstructionFactory.createDup(1));\n\n\t\tlist.append(InstructionFactory.PUSH(getConstantPool(), getFileName()));\n\n\t\t// load the current Class object\n\t\t// XXX check that this works correctly for inners/anonymous\n\t\tlist.append(fact.PUSHCLASS(cp, myGen.getClassName()));\n\t\t// XXX do we need to worry about the fact the theorectically this could\n\t\t// throw\n\t\t// a ClassNotFoundException\n\n\t\tlist.append(fact.createInvoke(factoryType.getClassName(), \"<init>\", Type.VOID, new Type[] { Type.STRING, classType },\n\t\t\t\tConstants.INVOKESPECIAL));\n\n\t\tlist.append(InstructionFactory.createStore(factoryType, 0));\n\t\treturn list;\n\t}\n\n\tprivate InstructionList[] initializeAllTjps() {\n\t\tVector<InstructionList> lists = new Vector<>();\n\n\t\tInstructionList list = initInstructionList();\n\t\tlists.add(list);\n\n\t\tList<Map.Entry<BcelShadow, Field>> entries = new ArrayList<>(tjpFields.entrySet());\n\t\tentries.sort(new Comparator<Map.Entry<BcelShadow, Field>>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Map.Entry<BcelShadow, Field> a, Map.Entry<BcelShadow, Field> b) {\n\t\t\t\treturn (a.getValue()).getName().compareTo((b.getValue()).getName());\n\t\t\t}\n\t\t});\n\n\t\tlong estimatedSize = 0;\n\t\tfor (Map.Entry<BcelShadow, Field> entry : entries) {\n\t\t\tif (estimatedSize > Constants.MAX_CODE_SIZE) {\n\t\t\t\testimatedSize = 0;\n\t\t\t\tlist = initInstructionList();\n\t\t\t\tlists.add(list);\n\t\t\t}\n\t\t\testimatedSize += entry.getValue().getSignature().getBytes().length;\n\t\t\tinitializeTjp(fact, list, entry.getValue(), entry.getKey());\n\t\t}\n\t\tInstructionList listArrayModel[] = new InstructionList[1];\n\t\treturn lists.toArray(listArrayModel);\n\t}\n\n\tprivate void initializeTjp(InstructionFactory fact, InstructionList list, Field field, BcelShadow shadow) {\n\t\tif (world.getTargetAspectjRuntimeLevel() == RuntimeVersion.V1_9) {\n\t\t\tinitializeTjpOptimal(fact, list, field, shadow);\n\t\t\treturn;\n\t\t}\n\t\tboolean fastSJP = false;\n\t\t// avoid fast SJP if it is for an enclosing joinpoint\n\t\tboolean isFastSJPAvailable = shadow.getWorld().isTargettingRuntime1_6_10()\n\t\t\t\t&& !enclosingStaticTjpType.equals(field.getType());\n\n\t\tMember sig = shadow.getSignature();\n\n\t\t// load the factory\n\t\tlist.append(InstructionFactory.createLoad(factoryType, 0));\n\n\t\t// load the kind\n\t\tlist.append(InstructionFactory.PUSH(getConstantPool(), shadow.getKind().getName()));\n\n\t\t// create the signature\n\t\tif (world.isTargettingAspectJRuntime12() || !isFastSJPAvailable || !sig.getKind().equals(Member.METHOD)) {\n\t\t\tlist.append(InstructionFactory.createLoad(factoryType, 0));\n\t\t}\n\n\t\tString signatureMakerName = SignatureUtils.getSignatureMakerName(sig);\n\t\tObjectType signatureType = new ObjectType(SignatureUtils.getSignatureType(sig));\n\t\tUnresolvedType[] exceptionTypes = null;\n\t\tif (world.isTargettingAspectJRuntime12()) { // TAG:SUPPORTING12: We didn't have optimized factory methods in 1.2\n\t\t\tlist.append(InstructionFactory.PUSH(cp, SignatureUtils.getSignatureString(sig, shadow.getWorld())));\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, Type.STRINGARRAY1,\n\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.METHOD)) {\n\t\t\tBcelWorld w = shadow.getWorld();\n\n\t\t\t// For methods, push the parts of the signature on.\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getModifiers(w))));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, sig.getName()));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getParameterTypes())));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getParameterNames(w))));\n\t\t\texceptionTypes = sig.getExceptions(w);\n\t\t\tif (isFastSJPAvailable && exceptionTypes.length == 0) {\n\t\t\t\tfastSJP = true;\n\t\t\t} else {\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(exceptionTypes)));\n\t\t\t}\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getReturnType())));\n\t\t\t// And generate a call to the variant of makeMethodSig() that takes the strings\n\t\t\tif (isFastSJPAvailable) {\n\t\t\t\tfastSJP = true;\n\t\t\t} else {\n\t\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, Type.STRINGARRAY7,\n\t\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t\t}\n\n\t\t} else if (sig.getKind().equals(Member.MONITORENTER)) {\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, Type.STRINGARRAY1,\n\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.MONITOREXIT)) {\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, Type.STRINGARRAY1,\n\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.HANDLER)) {\n\t\t\tBcelWorld w = shadow.getWorld();\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getParameterTypes())));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getParameterNames(w))));\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, Type.STRINGARRAY3,\n\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.CONSTRUCTOR)) {\n\t\t\tBcelWorld w = shadow.getWorld();\n\t\t\tif (w.isJoinpointArrayConstructionEnabled() && sig.getDeclaringType().isArray()) {\n\t\t\t\t// its the magical new jp\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(Modifier.PUBLIC)));\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getParameterTypes())));\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, \"\")); // sig.getParameterNames?\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, \"\"));// sig.getExceptions?\n\t\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, Type.STRINGARRAY5,\n\t\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t\t} else {\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getModifiers(w))));\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getParameterTypes())));\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getParameterNames(w))));\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getExceptions(w))));\n\t\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, Type.STRINGARRAY5,\n\t\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t\t}\n\t\t} else if (sig.getKind().equals(Member.FIELD)) {\n\t\t\tBcelWorld w = shadow.getWorld();\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getModifiers(w))));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, sig.getName()));\n\t\t\t// see pr227401\n\t\t\tUnresolvedType dType = sig.getDeclaringType();\n\t\t\tif (dType.getTypekind() == TypeKind.PARAMETERIZED || dType.getTypekind() == TypeKind.GENERIC) {\n\t\t\t\tdType = sig.getDeclaringType().resolve(world).getGenericType();\n\t\t\t}\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(dType)));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getReturnType())));\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, Type.STRINGARRAY4,\n\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.ADVICE)) {\n\t\t\tBcelWorld w = shadow.getWorld();\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getModifiers(w))));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, sig.getName()));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getParameterTypes())));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getParameterNames(w))));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getExceptions(w))));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString((sig.getReturnType()))));\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, new Type[] { Type.STRING,\n\t\t\t\t\tType.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING }, Constants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.STATIC_INITIALIZATION)) {\n\t\t\tBcelWorld w = shadow.getWorld();\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getModifiers(w))));\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, Type.STRINGARRAY2,\n\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t} else {\n\t\t\t// TODO looks like this block is unused code\n\t\t\tlist.append(InstructionFactory.PUSH(cp, SignatureUtils.getSignatureString(sig, shadow.getWorld())));\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), signatureMakerName, signatureType, Type.STRINGARRAY1,\n\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t}\n\n\t\t// XXX should load source location from shadow\n\t\tlist.append(Utility.createConstant(fact, shadow.getSourceLine()));\n\n\t\tfinal String factoryMethod;\n\n\t\t// TAG:SUPPORTING12: We didn't have makeESJP() in 1.2\n\t\tif (world.isTargettingAspectJRuntime12()) {\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), \"makeSJP\", staticTjpType, new Type[] { Type.STRING, sigType,\n\t\t\t\t\tType.INT }, Constants.INVOKEVIRTUAL));\n\n\t\t\t// put it in the field\n\t\t\tlist.append(fact.createFieldAccess(getClassName(), field.getName(), staticTjpType, Constants.PUTSTATIC));\n\n\t\t} else {\n\t\t\tif (staticTjpType.equals(field.getType())) {\n\t\t\t\tfactoryMethod = \"makeSJP\";\n\t\t\t} else if (enclosingStaticTjpType.equals(field.getType())) {\n\t\t\t\tfactoryMethod = \"makeESJP\";\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"should not happen\");\n\t\t\t}\n\n\t\t\tif (fastSJP) {\n\t\t\t\tif (exceptionTypes != null && exceptionTypes.length != 0) {\n\t\t\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(), ARRAY_8STRING_INT,\n\t\t\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t\t\t} else {\n\t\t\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(), ARRAY_7STRING_INT,\n\t\t\t\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(), new Type[] { Type.STRING,\n\t\t\t\t\t\tsigType, Type.INT }, Constants.INVOKEVIRTUAL));\n\t\t\t}\n\n\t\t\t// put it in the field\n\t\t\tlist.append(fact.createFieldAccess(getClassName(), field.getName(), field.getType(), Constants.PUTSTATIC));\n\t\t}\n\t}\n\n\tpublic String getFactoryMethod(Field field, BcelShadow shadow) {\n\t\tStringBuilder b = new StringBuilder();\n\t\tb.append(\"make\");\n\t\tMemberKind kind = shadow.getSignature().getKind();\n\t\tif (kind.equals(Member.METHOD)) {\n\t\t\tb.append(\"Method\");\n\t\t} else if (kind.equals(Member.CONSTRUCTOR)) {\n\t\t\tb.append(\"Constructor\");\n\t\t} else if (kind.equals(Member.HANDLER)) {\n\t\t\tb.append(\"CatchClause\");\n\t\t} else if (kind.equals(Member.FIELD)) {\n\t\t\tb.append(\"Field\");\n\t\t} else if (kind.equals(Member.STATIC_INITIALIZATION)) {\n\t\t\tb.append(\"Initializer\");\n\t\t} else if (kind.equals(Member.MONITORENTER)) {\n\t\t\tb.append(\"Lock\");\n\t\t} else if (kind.equals(Member.MONITOREXIT)) {\n\t\t\tb.append(\"Unlock\");\n\t\t} else if (kind.equals(Member.ADVICE)) {\n\t\t\tb.append(\"Advice\");\n\t\t} else {\n\t\t\tthrow new IllegalStateException(kind.toString());\n\t\t}\n\t\tif (staticTjpType.equals(field.getType())) {\n\t\t\tb.append(\"SJP\");\n\t\t} else if (enclosingStaticTjpType.equals(field.getType())) {\n\t\t\tb.append(\"ESJP\");\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\t/**\n\t * Generate optimal joinpoint initialization code.\n\t *\n\t * As of version 1.9.1 the runtime includes new factory methods for joinpoints that take classes, not strings\n\t * and using them requires different code generation. Using these instead of the old ones means we can avoid\n\t * deferred classloading for these types. By using the LDC instruction that loads classes, it also means\n\t * anything modifying woven code and changing type names will also pick up on these references.\n\t */\n\tprivate void initializeTjpOptimal(InstructionFactory fact, InstructionList list, Field field, BcelShadow shadow) {\n\t\tlist.append(InstructionFactory.createLoad(factoryType, 0));\n\t\tpushString(list, shadow.getKind().getName());\n\t\tString factoryMethod = getFactoryMethod(field, shadow);\n\t\tMember sig = shadow.getSignature();\n\t\tBcelWorld w = shadow.getWorld();\n\n\t\tif (sig.getKind().equals(Member.METHOD)) {\n\t\t\tpushInt(list, sig.getModifiers(w));\n\t\t\tpushString(list, sig.getName());\n\t\t\tpushClass(list, sig.getDeclaringType());\n\t\t\tpushClasses(list, sig.getParameterTypes());\n\t\t\tpushStrings(list, sig.getParameterNames(w));\n\t\t\tpushClasses(list, sig.getExceptions(w));\n\t\t\tpushClass(list, sig.getReturnType());\n\t\t\tpushInt(list, shadow.getSourceLine());\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(),\n\t\t\t\t\tPARAMSIGNATURE_MAKESJP_METHOD, Constants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.CONSTRUCTOR)) {\n\t\t\tif (w.isJoinpointArrayConstructionEnabled() && sig.getDeclaringType().isArray()) {\n\t\t\t\tpushInt(list, Modifier.PUBLIC);\n\t\t\t\tpushClass(list, sig.getDeclaringType());\n\t\t\t\tpushClasses(list, sig.getParameterTypes());\n\t\t\t\tpushStrings(list, null);\n\t\t\t\tpushClasses(list, null);\n\t\t\t} else {\n\t\t\t\tpushInt(list, sig.getModifiers(w));\n\t\t\t\tpushClass(list, sig.getDeclaringType());\n\t\t\t\tpushClasses(list, sig.getParameterTypes());\n\t\t\t\tpushStrings(list, sig.getParameterNames(w));\n\t\t\t\tpushClasses(list, sig.getExceptions(w));\n\t\t\t}\n\t\t\tpushInt(list, shadow.getSourceLine());\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(),\n\t\t\t\t\tPARAMSIGNATURE_MAKESJP_CONSTRUCTOR, Constants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.HANDLER)) {\n\t\t\tpushClass(list, sig.getDeclaringType());\n\t\t\tpushClass(list, sig.getParameterTypes()[0]);\n\t\t\tString pname = null;\n\t\t\tString[] pnames = sig.getParameterNames(w);\n\t\t\tif (pnames != null && pnames.length>0) {\n\t\t\t\tpname = pnames[0];\n\t\t\t}\n\t\t\tpushString(list, pname);\n\t\t\tpushInt(list, shadow.getSourceLine());\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(),\n\t\t\t\t\tPARAMSIGNATURE_MAKESJP_CATCHCLAUSE, Constants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.FIELD)) {\n\t\t\tpushInt(list, sig.getModifiers(w));\n\t\t\tpushString(list, sig.getName());\n\t\t\t// see pr227401\n\t\t\tUnresolvedType dType = sig.getDeclaringType();\n\t\t\tif (dType.getTypekind() == TypeKind.PARAMETERIZED || dType.getTypekind() == TypeKind.GENERIC) {\n\t\t\t\tdType = sig.getDeclaringType().resolve(world).getGenericType();\n\t\t\t}\n\t\t\tpushClass(list, dType);\n\t\t\tpushClass(list, sig.getReturnType());\n\t\t\tpushInt(list,shadow.getSourceLine());\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(),\n\t\t\t\t\tPARAMSIGNATURE_MAKESJP_FIELD, Constants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.STATIC_INITIALIZATION)) {\n\t\t\tpushInt(list, sig.getModifiers(w));\n\t\t\tpushClass(list, sig.getDeclaringType());\n\t\t\tpushInt(list, shadow.getSourceLine());\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(),\n\t\t\t\t\tPARAMSIGNATURE_MAKESJP_INITIALIZER, Constants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.MONITORENTER)) {\n\t\t\tpushClass(list, sig.getDeclaringType());\n\t\t\tpushInt(list, shadow.getSourceLine());\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(),\n\t\t\t\t\tPARAMSIGNATURE_MAKESJP_MONITOR, Constants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.MONITOREXIT)) {\n\t\t\tpushClass(list, sig.getDeclaringType());\n\t\t\tpushInt(list, shadow.getSourceLine());\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(),\n\t\t\t\t\tPARAMSIGNATURE_MAKESJP_MONITOR, Constants.INVOKEVIRTUAL));\n\t\t} else if (sig.getKind().equals(Member.ADVICE)) {\n\t\t\tpushInt(list, sig.getModifiers(w));\n\t\t\tpushString(list, sig.getName());\n\t\t\tpushClass(list, sig.getDeclaringType());\n\t\t\tpushClasses(list, sig.getParameterTypes());\n\t\t\tpushStrings(list, sig.getParameterNames(w));\n\t\t\tpushClasses(list, sig.getExceptions(w));\n\t\t\tpushClass(list, sig.getReturnType());\n\t\t\tpushInt(list, shadow.getSourceLine());\n\t\t\tlist.append(fact.createInvoke(factoryType.getClassName(), factoryMethod, field.getType(),\n\t\t\t\t\tPARAMSIGNATURE_MAKESJP_ADVICE, Constants.INVOKEVIRTUAL));\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"not sure what to do: \"+shadow);\n\t\t}\n\t\tlist.append(fact.createFieldAccess(getClassName(), field.getName(), field.getType(), Constants.PUTSTATIC));\n\t}\n\n\tprivate void pushStrings(InstructionList list, String[] strings) {\n\t\t// Build an array loaded with the strings\n\t\tif (strings == null || strings.length == 0) {\n\t\t\tlist.append(InstructionFactory.ACONST_NULL);\n\t\t} else {\n\t\t\tlist.append(InstructionFactory.PUSH(cp, strings.length));\n\t\t\tlist.append(fact.createNewArray(Type.STRING, (short)1));\n\t\t\tfor (int s=0;s<strings.length;s++) {\n\t\t\t\tlist.append(InstructionFactory.DUP);\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, s));\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, strings[s]));\n\t\t\t\tlist.append(InstructionFactory.AASTORE);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void pushClass(InstructionList list, UnresolvedType type) {\n\t\tif (type.isPrimitiveType()) {\n\t\t\tif (type.getSignature().equals(\"I\")) {\n\t\t\t\tlist.append(fact.createGetStatic(\"java/lang/Integer\",\"TYPE\", Type.CLASS));\n\t\t\t} else if (type.getSignature().equals(\"D\")) {\n\t\t\t\tlist.append(fact.createGetStatic(\"java/lang/Double\",\"TYPE\", Type.CLASS));\n\t\t\t} else if (type.getSignature().equals(\"S\")) {\n\t\t\t\tlist.append(fact.createGetStatic(\"java/lang/Short\",\"TYPE\", Type.CLASS));\n\t\t\t} else if (type.getSignature().equals(\"J\")) {\n\t\t\t\tlist.append(fact.createGetStatic(\"java/lang/Long\",\"TYPE\", Type.CLASS));\n\t\t\t} else if (type.getSignature().equals(\"F\")) {\n\t\t\t\tlist.append(fact.createGetStatic(\"java/lang/Float\",\"TYPE\", Type.CLASS));\n\t\t\t} else if (type.getSignature().equals(\"C\")) {\n\t\t\t\tlist.append(fact.createGetStatic(\"java/lang/Character\",\"TYPE\", Type.CLASS));\n\t\t\t} else if (type.getSignature().equals(\"B\")) {\n\t\t\t\tlist.append(fact.createGetStatic(\"java/lang/Byte\",\"TYPE\", Type.CLASS));\n\t\t\t} else if (type.getSignature().equals(\"Z\")) {\n\t\t\t\tlist.append(fact.createGetStatic(\"java/lang/Boolean\",\"TYPE\", Type.CLASS));\n\t\t\t} else if (type.getSignature().equals(\"V\")) {\n\t\t\t\tlist.append(InstructionFactory.ACONST_NULL);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tString classString = makeLdcClassString(type);\n\t\tif (classString == null) {\n\t\t\tlist.append(InstructionFactory.ACONST_NULL);\n\t\t} else {\n\t\t\tlist.append(fact.PUSHCLASS(cp, classString));\n\t\t}\n\t}\n\n\tprivate void pushClasses(InstructionList list, UnresolvedType[] types) {\n\t\t// Build an array loaded with the class objects\n\t\tif (types == null || types.length == 0) {\n\t\t\tlist.append(InstructionFactory.ACONST_NULL);\n\t\t} else {\n\t\t\tlist.append(InstructionFactory.PUSH(cp, types.length));\n\t\t\tlist.append(fact.createNewArray(Type.CLASS, (short)1));\n\t\t\tfor (int t=0;t<types.length;t++) {\n\t\t\t\tlist.append(InstructionFactory.DUP);\n\t\t\t\tlist.append(InstructionFactory.PUSH(cp, t));\n\t\t\t\tpushClass(list, types[t]);\n\t\t\t\tlist.append(InstructionFactory.AASTORE);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate final void pushString(InstructionList list, String string) {\n\t\tlist.append(InstructionFactory.PUSH(cp, string));\n\t}\n\n\tprivate final void pushInt(InstructionList list, int value) {\n\t\tlist.append(InstructionFactory.PUSH(cp, value));\n\t}\n\n\tprotected String makeString(int i) {\n\t\treturn Integer.toString(i, 16); // ??? expensive\n\t}\n\n\tprotected String makeString(UnresolvedType t) {\n\t\t// this is the inverse of the odd behavior for Class.forName w/ arrays\n\t\tif (t.isArray()) {\n\t\t\t// this behavior matches the string used by the eclipse compiler for\n\t\t\t// Foo.class literals\n\t\t\treturn t.getSignature().replace('/', '.');\n\t\t} else {\n\t\t\tif (t.isParameterizedType()) {\n\t\t\t\treturn t.getRawType().getName();\n\t\t\t} else {\n\t\t\t\treturn t.getName();\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected String makeLdcClassString(UnresolvedType type) {\n\t\tif (type.isVoid() || type.isPrimitiveType()) {\n\t\t\treturn null;\n\t\t}\n\t\tif (type.isArray()) {\n\t\t\treturn type.getSignature();\n\t\t} else {\n\t\t\tif (type.isParameterizedType()) {\n\t\t\t\ttype = type.getRawType();\n\t\t\t}\n\t\t\tString signature = type.getSignature();\n\t\t\tif (signature.length() ==1 ) {\n\t\t\t\treturn signature;\n\t\t\t}\n\t\t\treturn signature.substring(1,signature.length()-1);\n\t\t}\n\t}\n\n\tprotected String makeString(UnresolvedType[] types) {\n\t\tif (types == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tStringBuilder buf = new StringBuilder();\n\t\tfor (int i = 0, len = types.length; i < len; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tbuf.append(':');\n\t\t\t}\n\t\t\tbuf.append(makeString(types[i]));\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tprotected String makeString(String[] names) {\n\t\tif (names == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tStringBuilder buf = new StringBuilder();\n\t\tfor (int i = 0, len = names.length; i < len; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tbuf.append(':');\n\t\t\t}\n\t\t\tbuf.append(names[i]);\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tpublic ResolvedType getType() {\n\t\tif (myType == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn myType.getResolvedTypeX();\n\t}\n\n\tpublic BcelObjectType getBcelObjectType() {\n\t\treturn myType;\n\t}\n\n\tpublic String getFileName() {\n\t\treturn myGen.getFileName();\n\t}\n\n\t// for *new* fields\n\tprivate void addField(FieldGen field) {\n\t\tmakeSyntheticAndTransientIfNeeded(field);\n\t\tBcelField bcelField = null;\n\t\tif (getBcelObjectType() != null) {\n\t\t\tbcelField = new BcelField(getBcelObjectType(), field.getField());\n\t\t} else {\n\t\t\tbcelField = new BcelField(getName(), field.getField(), world);\n\t\t}\n\t\tfields.add(bcelField);\n\t\t// myGen.addField(field.getField());\n\t}\n\n\tprivate void makeSyntheticAndTransientIfNeeded(FieldGen field) {\n\t\tif (field.getName().startsWith(NameMangler.PREFIX) && !field.getName().startsWith(\"ajc$interField$\")\n\t\t\t\t&& !field.getName().startsWith(\"ajc$instance$\")) {\n\t\t\t// it's an aj added field\n\t\t\t// first do transient\n\t\t\tif (!field.isStatic()) {\n\t\t\t\tfield.setModifiers(field.getModifiers() | Constants.ACC_TRANSIENT);\n\t\t\t}\n\t\t\t// then do synthetic\n\t\t\tif (getWorld().isInJava5Mode()) {\n\t\t\t\t// add the synthetic modifier flag\n\t\t\t\tfield.setModifiers(field.getModifiers() | ACC_SYNTHETIC);\n\t\t\t}\n\t\t\tif (!hasSyntheticAttribute(field.getAttributes())) {\n\t\t\t\t// belt and braces, do the attribute even on Java 5 in addition\n\t\t\t\t// to the modifier flag\n\t\t\t\t// Attribute[] oldAttrs = field.getAttributes();\n\t\t\t\t// Attribute[] newAttrs = new Attribute[oldAttrs.length + 1];\n\t\t\t\t// System.arraycopy(oldAttrs, 0, newAttrs, 0, oldAttrs.length);\n\t\t\t\tConstantPool cpg = myGen.getConstantPool();\n\t\t\t\tint index = cpg.addUtf8(\"Synthetic\");\n\t\t\t\tAttribute synthetic = new Synthetic(index, 0, new byte[0], cpg);\n\t\t\t\tfield.addAttribute(synthetic);\n\t\t\t\t// newAttrs[newAttrs.length - 1] = synthetic;\n\t\t\t\t// field.setAttributes(newAttrs);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean hasSyntheticAttribute(List<Attribute> attributes) {\n\t\tfor (Attribute attribute : attributes) {\n\t\t\tif (attribute.getName().equals(\"Synthetic\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void addField(FieldGen field, ISourceLocation sourceLocation) {\n\t\taddField(field);\n\t\tif (!(field.isPrivate() && (field.isStatic() || field.isTransient()))) {\n\t\t\terrorOnAddedField(field, sourceLocation);\n\t\t}\n\t}\n\n\tpublic String getClassName() {\n\t\treturn myGen.getClassName();\n\t}\n\n\tpublic boolean isInterface() {\n\t\treturn myGen.isInterface();\n\t}\n\n\tpublic boolean isAbstract() {\n\t\treturn myGen.isAbstract();\n\t}\n\n\tpublic LazyMethodGen getLazyMethodGen(Member m) {\n\t\treturn getLazyMethodGen(m.getName(), m.getSignature(), false);\n\t}\n\n\tpublic LazyMethodGen getLazyMethodGen(String name, String signature) {\n\t\treturn getLazyMethodGen(name, signature, false);\n\t}\n\n\tpublic LazyMethodGen getLazyMethodGen(String name, String signature, boolean allowMissing) {\n\t\tfor (LazyMethodGen gen : methodGens) {\n\t\t\tif (gen.getName().equals(name) && gen.getSignature().equals(signature)) {\n\t\t\t\treturn gen;\n\t\t\t}\n\t\t}\n\n\t\tif (!allowMissing) {\n\t\t\tthrow new BCException(\"Class \" + this.getName() + \" does not have a method \" + name + \" with signature \" + signature);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic void forcePublic() {\n\t\tmyGen.setModifiers(Utility.makePublic(myGen.getModifiers()));\n\t}\n\n\tpublic boolean hasAnnotation(UnresolvedType t) {\n\n\t\t// annotations on the real thing\n\t\tAnnotationGen agens[] = myGen.getAnnotations();\n\t\tif (agens == null) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (AnnotationGen gen : agens) {\n\t\t\tif (t.equals(UnresolvedType.forSignature(gen.getTypeSignature()))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// annotations added during this weave\n\n\t\treturn false;\n\t}\n\n\tpublic void addAnnotation(AnnotationGen a) {\n\t\tif (!hasAnnotation(UnresolvedType.forSignature(a.getTypeSignature()))) {\n\t\t\tannotations.add(new AnnotationGen(a, getConstantPool(), true));\n\t\t}\n\t}\n\n\tpublic void addAttribute(AjAttribute attribute) {\n\t\tmyGen.addAttribute(Utility.bcelAttribute(attribute, getConstantPool()));\n\t}\n\n\tpublic void addAttribute(Attribute attribute) {\n\t\tmyGen.addAttribute(attribute);\n\t}\n\n\tpublic Collection<Attribute> getAttributes() {\n\t\treturn myGen.getAttributes();\n\t}\n\n\t// this test is like asking:\n\t// if\n\t// (UnresolvedType.SERIALIZABLE.resolve(getType().getWorld()).isAssignableFrom\n\t// (getType())) {\n\t// only we don't do that because this forces us to find all the supertypes\n\t// of the type,\n\t// and if one of them is missing we fail, and it's not worth failing just to\n\t// put out\n\t// a warning message!\n\tprivate boolean implementsSerializable(ResolvedType aType) {\n\t\tif (aType.getSignature().equals(UnresolvedType.SERIALIZABLE.getSignature())) {\n\t\t\treturn true;\n\t\t}\n\n\t\tResolvedType[] interfaces = aType.getDeclaredInterfaces();\n\t\tfor (ResolvedType anInterface : interfaces) {\n\t\t\tif (anInterface.isMissing()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (implementsSerializable(anInterface)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tResolvedType superType = aType.getSuperclass();\n\t\tif (superType != null && !superType.isMissing()) {\n\t\t\treturn implementsSerializable(superType);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isAtLeastJava5() {\n\t\treturn (myGen.getMajor() >= Constants.MAJOR_1_5);\n\t}\n\n\t/**\n\t * Return the next available field name with the specified 'prefix', e.g. for prefix 'class$' where class$0, class$1 exist then\n\t * return class$2\n\t */\n\tpublic String allocateField(String prefix) {\n\t\tint highestAllocated = -1;\n\t\tList<BcelField> fs = getFieldGens();\n\t\tfor (BcelField field : fs) {\n\t\t\tif (field.getName().startsWith(prefix)) {\n\t\t\t\ttry {\n\t\t\t\t\tint num = Integer.parseInt(field.getName().substring(prefix.length()));\n\t\t\t\t\tif (num > highestAllocated) {\n\t\t\t\t\t\thighestAllocated = num;\n\t\t\t\t\t}\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\t// something wrong with the number on the end of that\n\t\t\t\t\t// field...\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prefix + Integer.toString(highestAllocated + 1);\n\t}\n\n}\n",
    "size": 68487
  },
  {
    "file_id": "F36",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/LazyMethodGen.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.Attribute;\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.apache.bcel.classfile.Method;\nimport org.aspectj.apache.bcel.classfile.Synthetic;\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.generic.BranchHandle;\nimport org.aspectj.apache.bcel.generic.ClassGenException;\nimport org.aspectj.apache.bcel.generic.CodeExceptionGen;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionBranch;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.InstructionSelect;\nimport org.aspectj.apache.bcel.generic.InstructionTargeter;\nimport org.aspectj.apache.bcel.generic.LineNumberTag;\nimport org.aspectj.apache.bcel.generic.LocalVariableTag;\nimport org.aspectj.apache.bcel.generic.MethodGen;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.Tag;\nimport org.aspectj.apache.bcel.generic.TargetLostException;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjAttribute.WeaverVersionInfo;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.ISourceContext;\nimport org.aspectj.weaver.MemberImpl;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeaverMessages;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.tools.Traceable;\n\n/**\n * A LazyMethodGen should be treated as a MethodGen. It's our way of abstracting over the low-level Method objects. It converts\n * through {@link MethodGen} to create and to serialize, but that's it.\n *\n * <p>\n * At any rate, there are two ways to create LazyMethodGens. One is from a method, which does work through MethodGen to do the\n * correct thing. The other is the creation of a completely empty LazyMethodGen, and it is used when we're constructing code from\n * scratch.\n *\n * <p>\n * We stay away from targeters for rangey things like Shadows and Exceptions.\n */\npublic final class LazyMethodGen implements Traceable {\n\n\tprivate int modifiers;\n\tprivate Type returnType;\n\tprivate final String name;\n\tprivate Type[] argumentTypes;\n\t// private final String[] argumentNames;\n\tprivate String[] declaredExceptions;\n\tprivate InstructionList body;\n\tprivate List<Attribute> attributes;\n\tprivate List<AnnotationAJ> newAnnotations;\n\tprivate List<ResolvedType> annotationsForRemoval;\n\tprivate AnnotationAJ[][] newParameterAnnotations;\n\tprivate final LazyClassGen enclosingClass;\n\tprivate BcelMethod memberView;\n\tprivate AjAttribute.EffectiveSignatureAttribute effectiveSignature;\n\tint highestLineNumber = 0;\n\tboolean wasPackedOptimally = false;\n\tprivate Method savedMethod = null;\n\n\t// Some tools that may post process the output bytecode do not long local variable tables\n\t// to be generated as one reason the tables may be missing in the first place is because\n\t// the bytecode is odd. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=470658\n\tprivate final boolean originalMethodHasLocalVariableTable;\n\n\t/*\n\t * We use LineNumberTags and not Gens.\n\t *\n\t * This option specifies whether we let the BCEL classes create LineNumberGens and LocalVariableGens or if we make it create\n\t * LineNumberTags and LocalVariableTags. Up until 1.5.1 we always created Gens - then on return from the MethodGen ctor we took\n\t * them apart, reprocessed them all and created Tags. (see unpackLocals/unpackLineNumbers). As we have our own copy of Bcel, why\n\t * not create the right thing straightaway? So setting this to true will call the MethodGen ctor() in such a way that it creates\n\t * Tags - removing the need for unpackLocals/unpackLineNumbers - HOWEVER see the ensureAllLineNumberSetup() method for some\n\t * other relevant info.\n\t *\n\t * Whats the difference between a Tag and a Gen? A Tag is more lightweight, it doesn't know which instructions it targets, it\n\t * relies on the instructions targettingit - this reduces the amount of targeter manipulation we have to do.\n\t */\n\n\t/**\n\t * This is nonnull if this method is the result of an \"inlining\". We currently copy methods into other classes for around\n\t * advice. We add this field so we can get JSR45 information correct. If/when we do _actual_ inlining, we'll need to subtype\n\t * LineNumberTag to have external line numbers.\n\t */\n\tString fromFilename = null;\n\tprivate int maxLocals;\n\tprivate boolean canInline = true;\n\tprivate boolean isSynthetic = false;\n\tList<BcelShadow> matchedShadows;\n\t// Used for interface introduction - this is the type of the interface the method is technically on\n\tpublic ResolvedType definingType = null;\n\n\tstatic class LightweightBcelMethod extends BcelMethod {\n\n\t\tLightweightBcelMethod(BcelObjectType declaringType, Method method) {\n\t\t\tsuper(declaringType, method);\n\t\t\t// TODO Auto-generated constructor stub\n\t\t}\n\n\t}\n\n\tpublic LazyMethodGen(int modifiers, Type returnType, String name, Type[] paramTypes, String[] declaredExceptions,\n\t\t\tLazyClassGen enclosingClass) {\n\t\t// enclosingClass.getName() + \", \" + returnType);\n\t\tthis.memberView = null; // should be okay, since constructed ones aren't woven into\n\t\tthis.modifiers = modifiers;\n\t\tthis.returnType = returnType;\n\t\tthis.name = name;\n\t\tthis.argumentTypes = paramTypes;\n\t\t// this.argumentNames = Utility.makeArgNames(paramTypes.length);\n\t\tthis.declaredExceptions = declaredExceptions;\n\t\tif (!Modifier.isAbstract(modifiers)) {\n\t\t\tbody = new InstructionList();\n\t\t\tsetMaxLocals(calculateMaxLocals());\n\t\t} else {\n\t\t\tbody = null;\n\t\t}\n\t\tthis.attributes = new ArrayList<>();\n\t\tthis.enclosingClass = enclosingClass;\n\t\tassertGoodBody();\n\t\tthis.originalMethodHasLocalVariableTable = true; // it is a new method, we want an lvar table\n\n\t\t// @AJ advice are not inlined by default since requires further analysis and weaving ordering control\n\t\t// TODO AV - improve - note: no room for improvement as long as aspects are reweavable\n\t\t// since the inlined version with wrappers and an to be done annotation to keep\n\t\t// inline state will be garbaged due to reweavable impl\n\t\tif (memberView != null && isAdviceMethod()) {\n\t\t\tif (enclosingClass.getType().isAnnotationStyleAspect()) {\n\t\t\t\t// TODO we could check for @Around advice as well\n\t\t\t\tthis.canInline = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int calculateMaxLocals() {\n\t\tint ret = Modifier.isStatic(modifiers) ? 0 : 1; // will there be a 'this'?\n\t\tfor (Type type : argumentTypes) {\n\t\t\tret += type.getSize();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// build from an existing method, lazy build saves most work for\n\t// initialization\n\tpublic LazyMethodGen(Method m, LazyClassGen enclosingClass) {\n\t\tsavedMethod = m;\n\n\t\tthis.enclosingClass = enclosingClass;\n\t\tif (!(m.isAbstract() || m.isNative()) && m.getCode() == null) {\n\t\t\tthrow new RuntimeException(\"bad non-abstract method with no code: \" + m + \" on \" + enclosingClass);\n\t\t}\n\t\tif ((m.isAbstract() || m.isNative()) && m.getCode() != null) {\n\t\t\tthrow new RuntimeException(\"bad abstract method with code: \" + m + \" on \" + enclosingClass);\n\t\t}\n\t\tthis.memberView = new BcelMethod(enclosingClass.getBcelObjectType(), m);\n\t\tthis.originalMethodHasLocalVariableTable = savedMethod.getLocalVariableTable()!=null;\n\t\tthis.modifiers = m.getModifiers();\n\t\tthis.name = m.getName();\n\n\t\t// @AJ advice are not inlined by default since requires further analysis\n\t\t// and weaving ordering control\n\t\t// TODO AV - improve - note: no room for improvement as long as aspects\n\t\t// are reweavable\n\t\t// since the inlined version with wrappers and an to be done annotation\n\t\t// to keep\n\t\t// inline state will be garbaged due to reweavable impl\n\t\tif (memberView != null && isAdviceMethod()) {\n\t\t\tif (enclosingClass.getType().isAnnotationStyleAspect()) {\n\t\t\t\t// TODO we could check for @Around advice as well\n\t\t\t\tthis.canInline = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isAbstractOrNative(int modifiers) {\n\t\treturn Modifier.isAbstract(modifiers) || Modifier.isNative(modifiers);\n\t}\n\n\tpublic LazyMethodGen(BcelMethod m, LazyClassGen enclosingClass) {\n\t\tsavedMethod = m.getMethod();\n\t\tthis.enclosingClass = enclosingClass;\n\t\tif (!isAbstractOrNative(m.getModifiers()) && savedMethod.getCode() == null) {\n\t\t\tthrow new RuntimeException(\"bad non-abstract method with no code: \" + m + \" on \" + enclosingClass);\n\t\t}\n\t\tif (isAbstractOrNative(m.getModifiers()) && savedMethod.getCode() != null) {\n\t\t\tthrow new RuntimeException(\"bad abstract method with code: \" + m + \" on \" + enclosingClass);\n\t\t}\n\t\t// this.memberView = new BcelMethod(enclosingClass.getBcelObjectType(),\n\t\t// m);\n\t\tthis.memberView = m;\n\t\tthis.modifiers = savedMethod.getModifiers();\n\t\tthis.name = m.getName();\n\t\tthis.originalMethodHasLocalVariableTable = savedMethod.getLocalVariableTable() != null;\n\t\t// @AJ advice are not inlined by default since requires further analysis\n\t\t// and weaving ordering control\n\t\t// TODO AV - improve - note: no room for improvement as long as aspects\n\t\t// are reweavable\n\t\t// since the inlined version with wrappers and an to be done annotation\n\t\t// to keep\n\t\t// inline state will be garbaged due to reweavable impl\n\t\tif (memberView != null && isAdviceMethod()) {\n\t\t\tif (enclosingClass.getType().isAnnotationStyleAspect()) {\n\t\t\t\t// TODO we could check for @Around advice as well\n\t\t\t\tthis.canInline = false;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic boolean hasDeclaredLineNumberInfo() {\n\t\treturn (memberView != null && memberView.hasDeclarationLineNumberInfo());\n\t}\n\n\tpublic int getDeclarationLineNumber() {\n\t\tif (hasDeclaredLineNumberInfo()) {\n\t\t\treturn memberView.getDeclarationLineNumber();\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic int getDeclarationOffset() {\n\t\tif (hasDeclaredLineNumberInfo()) {\n\t\t\treturn memberView.getDeclarationOffset();\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic void addAnnotation(AnnotationAJ ax) {\n\t\tinitialize();\n\t\tif (memberView == null) {\n\t\t\t// If member view is null, we manage them in newAnnotations\n\t\t\tif (newAnnotations == null) {\n\t\t\t\tnewAnnotations = new ArrayList<>();\n\t\t\t}\n\t\t\tnewAnnotations.add(ax);\n\t\t} else {\n\t\t\tmemberView.addAnnotation(ax);\n\t\t}\n\t}\n\n\tpublic void removeAnnotation(ResolvedType annotationType) {\n\t\tinitialize();\n\t\tif (memberView == null) {\n\t\t\t// If member view is null, we manage them in newAnnotations\n\t\t\tif (annotationsForRemoval == null) {\n\t\t\t\tannotationsForRemoval = new ArrayList<>();\n\t\t\t}\n\t\t\tannotationsForRemoval.add(annotationType);\n\t\t} else {\n\t\t\tmemberView.removeAnnotation(annotationType);\n\t\t}\n\t}\n\n\tpublic void addParameterAnnotation(int parameterNumber, AnnotationAJ anno) {\n\t\tinitialize();\n\t\tif (memberView == null) {\n\t\t\tif (newParameterAnnotations == null) {\n\t\t\t\t// time to create it\n\t\t\t\tint pcount = getArgumentTypes().length;\n\t\t\t\tnewParameterAnnotations = new AnnotationAJ[pcount][];\n\t\t\t\tfor (int i = 0; i < pcount; i++) {\n\t\t\t\t\tif (i == parameterNumber) {\n\t\t\t\t\t\tnewParameterAnnotations[i] = new AnnotationAJ[1];\n\t\t\t\t\t\tnewParameterAnnotations[i][0] = anno;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewParameterAnnotations[i] = AnnotationAJ.EMPTY_ARRAY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tAnnotationAJ[] currentAnnoArray = newParameterAnnotations[parameterNumber];\n\t\t\t\tAnnotationAJ[] newAnnoArray = new AnnotationAJ[currentAnnoArray.length + 1];\n\t\t\t\tSystem.arraycopy(currentAnnoArray, 0, newAnnoArray, 0, currentAnnoArray.length);\n\t\t\t\tnewAnnoArray[currentAnnoArray.length] = anno;\n\t\t\t\tnewParameterAnnotations[parameterNumber] = newAnnoArray;\n\t\t\t}\n\t\t} else {\n\t\t\tmemberView.addParameterAnnotation(parameterNumber, anno);\n\t\t}\n\t}\n\n\tpublic ResolvedType[] getAnnotationTypes() {\n\t\tinitialize();\n\t\tif (memberView == null && newAnnotations!=null && newAnnotations.size()!=0) {\n\t\t\t// TODO Ignoring removed annotations for now\n\t\t\tResolvedType[] annotationTypes = new ResolvedType[newAnnotations.size()];\n\t\t\tfor (int a=0,len=newAnnotations.size();a<len;a++) {\n\t\t\t\tannotationTypes[a] = newAnnotations.get(a).getType();\n\t\t\t}\n\t\t\treturn annotationTypes;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic AnnotationAJ[] getAnnotations() {\n\t\tinitialize();\n\t\tif (memberView == null && newAnnotations!=null && newAnnotations.size()!=0) {\n\t\t\treturn newAnnotations.toArray(AnnotationAJ.EMPTY_ARRAY);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic boolean hasAnnotation(UnresolvedType annotationType) {\n\t\tinitialize();\n\t\tif (memberView == null) {\n\t\t\tif (annotationsForRemoval != null) {\n\t\t\t\tfor (ResolvedType at : annotationsForRemoval) {\n\t\t\t\t\tif (at.equals(annotationType)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check local annotations first\n\t\t\tif (newAnnotations != null) {\n\t\t\t\tfor (AnnotationAJ annotation : newAnnotations) {\n\t\t\t\t\tif (annotation.getTypeSignature().equals(annotationType.getSignature())) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemberView = new BcelMethod(getEnclosingClass().getBcelObjectType(), getMethod());\n\t\t\treturn memberView.hasAnnotation(annotationType);\n\t\t}\n\t\treturn memberView.hasAnnotation(annotationType);\n\t}\n\n\tprivate void initialize() {\n\t\tif (returnType != null) {\n\t\t\treturn;\n\t\t}\n\t\tMethodGen gen = new MethodGen(savedMethod, enclosingClass.getName(), enclosingClass.getConstantPool(), true);\n\n\t\tthis.returnType = gen.getReturnType();\n\t\tthis.argumentTypes = gen.getArgumentTypes();\n\t\tthis.declaredExceptions = gen.getExceptions();\n\t\tthis.attributes = gen.getAttributes();\n\t\t// this.annotations = gen.getAnnotations();\n\t\tthis.maxLocals = gen.getMaxLocals();\n\n\t\t// this.returnType = BcelWorld.makeBcelType(memberView.getReturnType());\n\t\t// this.argumentTypes =\n\t\t// BcelWorld.makeBcelTypes(memberView.getParameterTypes());\n\t\t//\n\t\t// this.declaredExceptions =\n\t\t// UnresolvedType.getNames(memberView.getExceptions());\n\t\t// //gen.getExceptions();\n\t\t// this.attributes = new Attribute[0]; //gen.getAttributes();\n\t\t// this.maxLocals = savedMethod.getCode().getMaxLocals();\n\n\t\tif (gen.isAbstract() || gen.isNative()) {\n\t\t\tbody = null;\n\t\t} else {\n\t\t\t// body = new InstructionList(savedMethod.getCode().getCode());\n\t\t\tbody = gen.getInstructionList();\n\t\t\tunpackHandlers(gen);\n\t\t\tensureAllLineNumberSetup();\n\t\t\thighestLineNumber = gen.getHighestlinenumber();\n\t\t}\n\t\tassertGoodBody();\n\t}\n\n\t// XXX we're relying on the javac promise I've just made up that we won't\n\t// have an early exception\n\t// in the list mask a later exception: That is, for two exceptions E and F,\n\t// if E preceeds F, then either E \\cup F = {}, or E \\nonstrictsubset F. So\n\t// when we add F,\n\t// we add it on the _OUTSIDE_ of any handlers that share starts or ends with\n\t// it.\n\n\t// with that in mind, we merrily go adding ranges for exceptions.\n\n\tprivate void unpackHandlers(MethodGen gen) {\n\t\tCodeExceptionGen[] exns = gen.getExceptionHandlers();\n\t\tif (exns != null) {\n\t\t\tint len = exns.length;\n\t\t\t// if (len > 0) hasExceptionHandlers = true;\n\t\t\tint priority = len - 1;\n\t\t\tfor (int i = 0; i < len; i++, priority--) {\n\t\t\t\tCodeExceptionGen exn = exns[i];\n\n\t\t\t\tInstructionHandle start = Range.genStart(body, getOutermostExceptionStart(exn.getStartPC()));\n\t\t\t\tInstructionHandle end = Range.genEnd(body, getOutermostExceptionEnd(exn.getEndPC()));\n\t\t\t\t// this doesn't necessarily handle overlapping correctly!!!\n\t\t\t\tExceptionRange er = new ExceptionRange(body, exn.getCatchType() == null ? null : BcelWorld.fromBcel(exn\n\t\t\t\t\t\t.getCatchType()), priority);\n\t\t\t\ter.associateWithTargets(start, end, exn.getHandlerPC());\n\t\t\t\texn.setStartPC(null); // also removes from target\n\t\t\t\texn.setEndPC(null); // also removes from target\n\t\t\t\texn.setHandlerPC(null); // also removes from target\n\t\t\t}\n\t\t\tgen.removeExceptionHandlers();\n\t\t}\n\t}\n\n\tprivate InstructionHandle getOutermostExceptionStart(InstructionHandle ih) {\n\t\twhile (true) {\n\t\t\tif (ExceptionRange.isExceptionStart(ih.getPrev())) {\n\t\t\t\tih = ih.getPrev();\n\t\t\t} else {\n\t\t\t\treturn ih;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate InstructionHandle getOutermostExceptionEnd(InstructionHandle ih) {\n\t\twhile (true) {\n\t\t\tif (ExceptionRange.isExceptionEnd(ih.getNext())) {\n\t\t\t\tih = ih.getNext();\n\t\t\t} else {\n\t\t\t\treturn ih;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * On entry to this method we have a method whose instruction stream contains a few instructions that have line numbers assigned\n\t * to them (LineNumberTags). The aim is to ensure every instruction has the right line number. This is necessary because some of\n\t * them may be extracted out into other methods - and it'd be useful for them to maintain the source line number for debugging.\n\t */\n\tpublic void ensureAllLineNumberSetup() {\n\t\tLineNumberTag lastKnownLineNumberTag = null;\n\t\tboolean skip = false;\n\t\tfor (InstructionHandle ih = body.getStart(); ih != null; ih = ih.getNext()) {\n\t\t\tskip = false;\n\t\t\tfor (InstructionTargeter targeter : ih.getTargeters()) {\n\t\t\t\tif (targeter instanceof LineNumberTag) {\n\t\t\t\t\tlastKnownLineNumberTag = (LineNumberTag) targeter;\n\t\t\t\t\tskip = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastKnownLineNumberTag != null && !skip) {\n\t\t\t\tih.addTargeter(lastKnownLineNumberTag);\n\t\t\t}\n\t\t}\n\t}\n\n\t// ===============\n\n\tpublic int allocateLocal(Type type) {\n\t\treturn allocateLocal(type.getSize());\n\t}\n\n\tpublic int allocateLocal(int slots) {\n\t\tint max = getMaxLocals();\n\t\tsetMaxLocals(max + slots);\n\t\treturn max;\n\t}\n\n\tpublic Method getMethod() {\n\t\tif (savedMethod != null) {\n\t\t\treturn savedMethod; // ??? this relies on gentle treatment of\n\t\t\t// constant pool\n\t\t}\n\n\t\ttry {\n\t\t\tMethodGen gen = pack();\n\t\t\tsavedMethod = gen.getMethod();\n\t\t\treturn savedMethod;\n\t\t} catch (ClassGenException e) {\n\t\t\tenclosingClass\n\t\t\t\t\t.getBcelObjectType()\n\t\t\t\t\t.getResolvedTypeX()\n\t\t\t\t\t.getWorld()\n\t\t\t\t\t.showMessage(\n\t\t\t\t\t\t\tIMessage.ERROR,\n\t\t\t\t\t\t\tWeaverMessages.format(WeaverMessages.PROBLEM_GENERATING_METHOD, this.getClassName(), this.getName(),\n\t\t\t\t\t\t\t\t\te.getMessage()),\n\t\t\t\t\t\t\tthis.getMemberView() == null ? null : this.getMemberView().getSourceLocation(), null);\n\t\t\t// throw e; PR 70201.... let the normal problem reporting\n\t\t\t// infrastructure deal with this rather than crashing.\n\t\t\tbody = null;\n\t\t\tMethodGen gen = pack();\n\t\t\treturn gen.getMethod();\n\t\t} catch (RuntimeException re) {\n\t\t\tif (re.getCause() instanceof ClassGenException) {\n\t\t\t\tenclosingClass\n\t\t\t\t\t\t.getBcelObjectType()\n\t\t\t\t\t\t.getResolvedTypeX()\n\t\t\t\t\t\t.getWorld()\n\t\t\t\t\t\t.showMessage(\n\t\t\t\t\t\t\t\tIMessage.ERROR,\n\t\t\t\t\t\t\t\tWeaverMessages.format(WeaverMessages.PROBLEM_GENERATING_METHOD, this.getClassName(),\n\t\t\t\t\t\t\t\t\t\tthis.getName(), re.getCause().getMessage()),\n\t\t\t\t\t\t\t\tthis.getMemberView() == null ? null : this.getMemberView().getSourceLocation(), null);\n\t\t\t\t// throw e; PR 70201.... let the normal problem reporting\n\t\t\t\t// infrastructure deal with this rather than crashing.\n\t\t\t\tbody = null;\n\t\t\t\tMethodGen gen = pack();\n\t\t\t\treturn gen.getMethod();\n\t\t\t}\n\t\t\tthrow re;\n\t\t}\n\t}\n\n\tpublic void markAsChanged() {\n\t\tif (wasPackedOptimally) {\n\t\t\tthrow new RuntimeException(\"Already packed method is being re-modified: \" + getClassName() + \" \" + toShortString());\n\t\t}\n\t\tinitialize();\n\t\tsavedMethod = null;\n\t}\n\n\t// =============================\n\n\t@Override\n\tpublic String toString() {\n\t\tBcelObjectType bot = enclosingClass.getBcelObjectType();\n\t\tWeaverVersionInfo weaverVersion = (bot == null ? WeaverVersionInfo.CURRENT : bot.getWeaverVersionAttribute());\n\t\treturn toLongString(weaverVersion);\n\t}\n\n\tpublic String toShortString() {\n\t\tString access = org.aspectj.apache.bcel.classfile.Utility.accessToString(getAccessFlags());\n\n\t\tStringBuilder buf = new StringBuilder();\n\n\t\tif (!access.equals(\"\")) {\n\t\t\tbuf.append(access);\n\t\t\tbuf.append(\" \");\n\t\t}\n\t\tbuf.append(org.aspectj.apache.bcel.classfile.Utility.signatureToString(getReturnType().getSignature(), true));\n\t\tbuf.append(\" \");\n\t\tbuf.append(getName());\n\t\tbuf.append(\"(\");\n\t\t{\n\t\t\tint len = argumentTypes.length;\n\t\t\tif (len > 0) {\n\t\t\t\tbuf.append(org.aspectj.apache.bcel.classfile.Utility.signatureToString(argumentTypes[0].getSignature(), true));\n\t\t\t\tfor (int i = 1; i < argumentTypes.length; i++) {\n\t\t\t\t\tbuf.append(\", \");\n\t\t\t\t\tbuf.append(org.aspectj.apache.bcel.classfile.Utility.signatureToString(argumentTypes[i].getSignature(), true));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbuf.append(\")\");\n\n\t\t{\n\t\t\tint len = declaredExceptions != null ? declaredExceptions.length : 0;\n\t\t\tif (len > 0) {\n\t\t\t\tbuf.append(\" throws \");\n\t\t\t\tbuf.append(declaredExceptions[0]);\n\t\t\t\tfor (int i = 1; i < declaredExceptions.length; i++) {\n\t\t\t\t\tbuf.append(\", \");\n\t\t\t\t\tbuf.append(declaredExceptions[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tpublic String toLongString(WeaverVersionInfo weaverVersion) {\n\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\n\t\tprint(new PrintStream(s), weaverVersion);\n\t\treturn new String(s.toByteArray());\n\t}\n\n\tpublic void print(WeaverVersionInfo weaverVersion) {\n\t\tprint(System.out, weaverVersion);\n\t}\n\n\tpublic void print(PrintStream out, WeaverVersionInfo weaverVersion) {\n\t\tout.print(\"  \" + toShortString());\n\t\tprintAspectAttributes(out, weaverVersion);\n\n\t\tInstructionList body = getBody();\n\t\tif (body == null) {\n\t\t\tout.println(\";\");\n\t\t\treturn;\n\t\t}\n\t\tout.println(\":\");\n\t\tnew BodyPrinter(out).run();\n\t\tout.println(\"  end \" + toShortString());\n\t}\n\n\tprivate void printAspectAttributes(PrintStream out, WeaverVersionInfo weaverVersion) {\n\t\tISourceContext context = null;\n\t\tif (enclosingClass != null && enclosingClass.getType() != null) {\n\t\t\tcontext = enclosingClass.getType().getSourceContext();\n\t\t}\n\t\tList<AjAttribute> as = Utility.readAjAttributes(getClassName(), attributes.toArray(Attribute.NoAttributes), context, null, weaverVersion,\n\t\t\t\tnew BcelConstantPoolReader(this.enclosingClass.getConstantPool()));\n\t\tif (!as.isEmpty()) {\n\t\t\tout.println(\"    \" + as.get(0)); // XXX assuming exactly one\n\t\t\t// attribute, munger...\n\t\t}\n\t}\n\n\tprivate class BodyPrinter {\n\t\tMap<InstructionHandle, String> labelMap = new HashMap<>();\n\n\t\tInstructionList body;\n\t\tPrintStream out;\n\t\tConstantPool pool;\n\n\t\tBodyPrinter(PrintStream out) {\n\t\t\tthis.pool = enclosingClass.getConstantPool();\n\t\t\tthis.body = getBodyForPrint();\n\t\t\tthis.out = out;\n\t\t}\n\n\t\tBodyPrinter(PrintStream out, InstructionList il) {\n\t\t\tthis.pool = enclosingClass.getConstantPool();\n\t\t\tthis.body = il;\n\t\t\tthis.out = out;\n\t\t}\n\n\t\tvoid run() {\n\t\t\t// killNops();\n\t\t\tassignLabels();\n\t\t\tprint();\n\t\t}\n\n\t\t// label assignment\n\t\tvoid assignLabels() {\n\t\t\tLinkedList<ExceptionRange> exnTable = new LinkedList<>();\n\t\t\tString pendingLabel = null;\n\t\t\t// boolean hasPendingTargeters = false;\n\t\t\tint lcounter = 0;\n\t\t\tfor (InstructionHandle ih = body.getStart(); ih != null; ih = ih.getNext()) {\n\t\t\t\t// targeters\n\t\t\t\tfor (InstructionTargeter t : ih.getTargeters()) {\n\t\t\t\t\t// [\n\t\t\t\t\t// i\n\t\t\t\t\t// ]\n\t\t\t\t\t// ;\n\t\t\t\t\tif (t instanceof ExceptionRange) {\n\t\t\t\t\t\t// assert isRangeHandle(h);\n\t\t\t\t\t\tExceptionRange r = (ExceptionRange) t;\n\t\t\t\t\t\tif (r.getStart() == ih) {\n\t\t\t\t\t\t\tinsertHandler(r, exnTable);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (t instanceof InstructionBranch) {\n\t\t\t\t\t\tif (pendingLabel == null) {\n\t\t\t\t\t\t\tpendingLabel = \"L\" + lcounter++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// assert isRangeHandle(h)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pendingLabel != null) {\n\t\t\t\t\tlabelMap.put(ih, pendingLabel);\n\t\t\t\t\tif (!Range.isRangeHandle(ih)) {\n\t\t\t\t\t\tpendingLabel = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ecounter = 0;\n\t\t\tfor (ExceptionRange er: exnTable) {\n\t\t\t\tString exceptionLabel = \"E\" + ecounter++;\n\t\t\t\tlabelMap.put(Range.getRealStart(er.getHandler()), exceptionLabel);\n\t\t\t\tlabelMap.put(er.getHandler(), exceptionLabel);\n\t\t\t}\n\t\t}\n\n\t\t// printing\n\n\t\tvoid print() {\n\t\t\tint depth = 0;\n\t\t\tint currLine = -1;\n\t\t\tbodyPrint: for (InstructionHandle ih = body.getStart(); ih != null; ih = ih.getNext()) {\n\t\t\t\tif (Range.isRangeHandle(ih)) {\n\t\t\t\t\tRange r = Range.getRange(ih);\n\t\t\t\t\t// don't print empty ranges, that is, ranges who contain no\n\t\t\t\t\t// actual instructions\n\t\t\t\t\tfor (InstructionHandle xx = r.getStart(); Range.isRangeHandle(xx); xx = xx.getNext()) {\n\t\t\t\t\t\tif (xx == r.getEnd()) {\n\t\t\t\t\t\t\tcontinue bodyPrint;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// doesn't handle nested: if (r.getStart().getNext() ==\n\t\t\t\t\t// r.getEnd()) continue;\n\t\t\t\t\tif (r.getStart() == ih) {\n\t\t\t\t\t\tprintRangeString(r, depth++);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (r.getEnd() != ih) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\"bad\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintRangeString(r, --depth);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprintInstruction(ih, depth);\n\t\t\t\t\tint line = getLineNumber(ih, currLine);\n\t\t\t\t\tif (line != currLine) {\n\t\t\t\t\t\tcurrLine = line;\n\t\t\t\t\t\tout.println(\"   (line \" + line + \")\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid printRangeString(Range r, int depth) {\n\t\t\tprintDepth(depth);\n\t\t\tout.println(getRangeString(r, labelMap));\n\t\t}\n\n\t\tString getRangeString(Range r, Map<InstructionHandle, String> labelMap) {\n\t\t\tif (r instanceof ExceptionRange) {\n\t\t\t\tExceptionRange er = (ExceptionRange) r;\n\t\t\t\treturn er.toString() + \" -> \" + labelMap.get(er.getHandler());\n\t\t\t\t//\n\t\t\t\t// + \" PRI \" + er.getPriority();\n\t\t\t} else {\n\t\t\t\treturn r.toString();\n\t\t\t}\n\t\t}\n\n\t\tvoid printDepth(int depth) {\n\t\t\tpad(BODY_INDENT);\n\t\t\twhile (depth > 0) {\n\t\t\t\tout.print(\"| \");\n\t\t\t\tdepth--;\n\t\t\t}\n\t\t}\n\n\t\tvoid printLabel(String s, int depth) {\n\t\t\tint space = Math.max(CODE_INDENT - depth * 2, 0);\n\t\t\tif (s == null) {\n\t\t\t\tpad(space);\n\t\t\t} else {\n\t\t\t\tspace = Math.max(space - (s.length() + 2), 0);\n\t\t\t\tpad(space);\n\t\t\t\tout.print(s);\n\t\t\t\tout.print(\": \");\n\t\t\t}\n\t\t}\n\n\t\tvoid printInstruction(InstructionHandle h, int depth) {\n\t\t\tprintDepth(depth);\n\t\t\tprintLabel(labelMap.get(h), depth);\n\n\t\t\tInstruction inst = h.getInstruction();\n\t\t\tif (inst.isConstantPoolInstruction()) {\n\t\t\t\tout.print(Constants.OPCODE_NAMES[inst.opcode].toUpperCase());\n\t\t\t\tout.print(\" \");\n\t\t\t\tout.print(pool.constantToString(pool.getConstant(inst.getIndex())));\n\t\t\t} else if (inst instanceof InstructionSelect) {\n\t\t\t\tInstructionSelect sinst = (InstructionSelect) inst;\n\t\t\t\tout.println(Constants.OPCODE_NAMES[sinst.opcode].toUpperCase());\n\t\t\t\tint[] matches = sinst.getMatchs();\n\t\t\t\tInstructionHandle[] targets = sinst.getTargets();\n\t\t\t\tInstructionHandle defaultTarget = sinst.getTarget();\n\t\t\t\tfor (int i = 0, len = matches.length; i < len; i++) {\n\t\t\t\t\tprintDepth(depth);\n\t\t\t\t\tprintLabel(null, depth);\n\t\t\t\t\tout.print(\"  \");\n\t\t\t\t\tout.print(matches[i]);\n\t\t\t\t\tout.print(\": \\t\");\n\t\t\t\t\tout.println(labelMap.get(targets[i]));\n\t\t\t\t}\n\t\t\t\tprintDepth(depth);\n\t\t\t\tprintLabel(null, depth);\n\t\t\t\tout.print(\"  \");\n\t\t\t\tout.print(\"default: \\t\");\n\t\t\t\tout.print(labelMap.get(defaultTarget));\n\t\t\t} else if (inst instanceof InstructionBranch) {\n\t\t\t\tInstructionBranch brinst = (InstructionBranch) inst;\n\t\t\t\tout.print(Constants.OPCODE_NAMES[brinst.getOpcode()].toUpperCase());\n\t\t\t\tout.print(\" \");\n\t\t\t\tout.print(labelMap.get(brinst.getTarget()));\n\t\t\t} else if (inst.isLocalVariableInstruction()) {\n\t\t\t\t// LocalVariableInstruction lvinst = (LocalVariableInstruction)\n\t\t\t\t// inst;\n\t\t\t\tout.print(inst.toString(false).toUpperCase());\n\t\t\t\tint index = inst.getIndex();\n\t\t\t\tLocalVariableTag tag = getLocalVariableTag(h, index);\n\t\t\t\tif (tag != null) {\n\t\t\t\t\tout.print(\"     // \");\n\t\t\t\t\tout.print(tag.getType());\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t\tout.print(tag.getName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tout.print(inst.toString(false).toUpperCase());\n\t\t\t}\n\t\t}\n\n\t\tstatic final int BODY_INDENT = 4;\n\t\tstatic final int CODE_INDENT = 16;\n\n\t\tvoid pad(int size) {\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tout.print(\" \");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic LocalVariableTag getLocalVariableTag(InstructionHandle ih, int index) {\n\t\tfor (InstructionTargeter t : ih.getTargeters()) {\n\t\t\tif (t instanceof LocalVariableTag) {\n\t\t\t\tLocalVariableTag lvt = (LocalVariableTag) t;\n\t\t\t\tif (lvt.getSlot() == index) {\n\t\t\t\t\treturn lvt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int getLineNumber(InstructionHandle ih, int prevLine) {\n\t\tfor (InstructionTargeter t : ih.getTargeters()) {\n\t\t\tif (t instanceof LineNumberTag) {\n\t\t\t\treturn ((LineNumberTag) t).getLineNumber();\n\t\t\t}\n\t\t}\n\t\treturn prevLine;\n\t}\n\n\tpublic boolean isStatic() {\n\t\treturn Modifier.isStatic(getAccessFlags());\n\t}\n\n\tpublic boolean isAbstract() {\n\t\treturn Modifier.isAbstract(getAccessFlags());\n\t}\n\n\tpublic boolean isBridgeMethod() {\n\t\treturn (getAccessFlags() & Constants.ACC_BRIDGE) != 0;\n\t}\n\n\tpublic void addExceptionHandler(InstructionHandle start, InstructionHandle end, InstructionHandle handlerStart,\n\t\t\tObjectType catchType, boolean highPriority) {\n\n\t\tInstructionHandle start1 = Range.genStart(body, start);\n\t\tInstructionHandle end1 = Range.genEnd(body, end);\n\n\t\tExceptionRange er = new ExceptionRange(body, (catchType == null ? null : BcelWorld.fromBcel(catchType)), highPriority);\n\t\ter.associateWithTargets(start1, end1, handlerStart);\n\t}\n\n\tpublic int getAccessFlags() {\n\t\treturn modifiers;\n\t}\n\n\tpublic int getAccessFlagsWithoutSynchronized() {\n\t\tif (isSynchronized()) {\n\t\t\treturn modifiers - Modifier.SYNCHRONIZED;\n\t\t}\n\t\treturn modifiers;\n\t}\n\n\tpublic boolean isSynchronized() {\n\t\treturn (modifiers & Modifier.SYNCHRONIZED) != 0;\n\t}\n\n\tpublic void setAccessFlags(int newFlags) {\n\t\tthis.modifiers = newFlags;\n\t}\n\n\tpublic Type[] getArgumentTypes() {\n\t\tinitialize();\n\t\treturn argumentTypes;\n\t}\n\n\tpublic LazyClassGen getEnclosingClass() {\n\t\treturn enclosingClass;\n\t}\n\n\tpublic int getMaxLocals() {\n\t\treturn maxLocals;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic String getGenericReturnTypeSignature() {\n\t\tif (memberView == null) {\n\t\t\treturn getReturnType().getSignature();\n\t\t} else {\n\t\t\treturn memberView.getGenericReturnType().getSignature();\n\t\t}\n\t}\n\n\tpublic Type getReturnType() {\n\t\tinitialize();\n\t\treturn returnType;\n\t}\n\n\tpublic void setMaxLocals(int maxLocals) {\n\t\tthis.maxLocals = maxLocals;\n\t}\n\n\tpublic InstructionList getBody() {\n\t\tmarkAsChanged();\n\t\treturn body;\n\t}\n\n\tpublic InstructionList getBodyForPrint() {\n\t\treturn body;\n\t}\n\n\tpublic boolean hasBody() {\n\t\tif (savedMethod != null) {\n\t\t\treturn savedMethod.getCode() != null;\n\t\t}\n\t\treturn body != null;\n\t}\n\n\tpublic List<Attribute> getAttributes() {\n\t\treturn attributes;\n\t}\n\n\tpublic String[] getDeclaredExceptions() {\n\t\treturn declaredExceptions;\n\t}\n\n\tpublic String getClassName() {\n\t\treturn enclosingClass.getName();\n\t}\n\n\t// ---- packing!\n\n\tpublic MethodGen pack() {\n\t\tforceSyntheticForAjcMagicMembers();\n\n\t\t// killNops();\n\t\tint flags = getAccessFlags();\n\t\tif (enclosingClass.getWorld().isJoinpointSynchronizationEnabled()\n\t\t\t\t&& enclosingClass.getWorld().areSynchronizationPointcutsInUse()) {\n\t\t\tflags = getAccessFlagsWithoutSynchronized();\n\t\t}\n\t\tMethodGen gen = new MethodGen(flags, getReturnType(), getArgumentTypes(), null, // getArgumentNames(),\n\t\t\t\tgetName(), getEnclosingClass().getName(), new InstructionList(), getEnclosingClass().getConstantPool());\n\t\tfor (String declaredException : declaredExceptions) {\n\t\t\tgen.addException(declaredException);\n\t\t}\n\n\t\tfor (Attribute attr : attributes) {\n\t\t\tgen.addAttribute(attr);\n\t\t}\n\n\t\tif (newAnnotations != null) {\n\t\t\tfor (AnnotationAJ element : newAnnotations) {\n\t\t\t\tgen.addAnnotation(new AnnotationGen(((BcelAnnotation) element).getBcelAnnotation(), gen.getConstantPool(), true));\n\t\t\t}\n\t\t}\n\n\t\tif (newParameterAnnotations != null) {\n\t\t\tfor (int i = 0; i < newParameterAnnotations.length; i++) {\n\t\t\t\tAnnotationAJ[] annos = newParameterAnnotations[i];\n\t\t\t\tfor (AnnotationAJ anno : annos) {\n\t\t\t\t\tgen.addParameterAnnotation(i,\n\t\t\t\t\t\t\tnew AnnotationGen(((BcelAnnotation) anno).getBcelAnnotation(), gen.getConstantPool(), true));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (memberView != null && memberView.getAnnotations() != null && memberView.getAnnotations().length != 0) {\n\t\t\tAnnotationAJ[] ans = memberView.getAnnotations();\n\t\t\tfor (AnnotationAJ an : ans) {\n\t\t\t\tAnnotationGen a = ((BcelAnnotation) an).getBcelAnnotation();\n\t\t\t\tgen.addAnnotation(new AnnotationGen(a, gen.getConstantPool(), true));\n\t\t\t}\n\t\t}\n\n\t\tif (isSynthetic) {\n\t\t\tif (enclosingClass.getWorld().isInJava5Mode()) {\n\t\t\t\tgen.setModifiers(gen.getModifiers() | Constants.ACC_SYNTHETIC);\n\t\t\t}\n\t\t\tif (!hasAttribute(\"Synthetic\")) {\n\t\t\t\t// belt and braces, do the attribute even on Java 5 in addition to the modifier flag\n\t\t\t\tConstantPool cpg = gen.getConstantPool();\n\t\t\t\tint index = cpg.addUtf8(\"Synthetic\");\n\t\t\t\tgen.addAttribute(new Synthetic(index, 0, new byte[0], cpg));\n\t\t\t}\n\t\t}\n\n\t\tif (hasBody()) {\n\t\t\tif (this.enclosingClass.getWorld().shouldFastPackMethods()) {\n\t\t\t\tif (isAdviceMethod() || getName().equals(\"<clinit>\")) {\n\t\t\t\t\tpackBody(gen);\n\t\t\t\t} else {\n\t\t\t\t\toptimizedPackBody(gen);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpackBody(gen);\n\t\t\t}\n\n\t\t\tgen.setMaxLocals(true);\n\t\t\tgen.setMaxStack();\n\t\t} else {\n\t\t\tgen.setInstructionList(null);\n\t\t}\n\t\treturn gen;\n\t}\n\n\tprivate boolean hasAttribute(String attributeName) {\n\t\tfor (Attribute attr: attributes) {\n\t\t\tif (attr.getName().equals(attributeName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void forceSyntheticForAjcMagicMembers() {\n\t\tif (NameMangler.isSyntheticMethod(getName(), inAspect())) {\n\t\t\tmakeSynthetic();\n\t\t}\n\t}\n\n\tprivate boolean inAspect() {\n\t\tBcelObjectType objectType = enclosingClass.getBcelObjectType();\n\t\treturn (objectType == null ? false : objectType.isAspect());\n\t}\n\n\tpublic void makeSynthetic() {\n\t\tisSynthetic = true;\n\t}\n\n\tprivate static class LVPosition {\n\t\tInstructionHandle start = null;\n\t\tInstructionHandle end = null;\n\t}\n\n\t/**\n\t * fill the newly created method gen with our body, inspired by InstructionList.copy()\n\t */\n\tpublic void packBody(MethodGen gen) {\n\t\tInstructionList fresh = gen.getInstructionList();\n\t\tMap<InstructionHandle, InstructionHandle> map = copyAllInstructionsExceptRangeInstructionsInto(fresh);\n\n\t\t// at this point, no rangeHandles are in fresh. Let's use that...\n\n\t\t/*\n\t\t * Update branch targets and insert various attributes. Insert our exceptionHandlers into a sorted list, so they can be\n\t\t * added in order later.\n\t\t */\n\t\tInstructionHandle oldInstructionHandle = getBody().getStart();\n\t\tInstructionHandle newInstructionHandle = fresh.getStart();\n\t\tLinkedList<ExceptionRange> exceptionList = new LinkedList<>();\n\n\t\tMap<LocalVariableTag, LVPosition> localVariables = new HashMap<>();\n\n\t\tint currLine = -1;\n\t\tint lineNumberOffset = (fromFilename == null) ? 0 : getEnclosingClass().getSourceDebugExtensionOffset(fromFilename);\n\n\t\twhile (oldInstructionHandle != null) {\n\t\t\tif (map.get(oldInstructionHandle) == null) {\n\t\t\t\t// must be a range instruction since they're the only things we\n\t\t\t\t// didn't copy across\n\t\t\t\thandleRangeInstruction(oldInstructionHandle, exceptionList);\n\t\t\t\t// just increment ih.\n\t\t\t\toldInstructionHandle = oldInstructionHandle.getNext();\n\t\t\t} else {\n\t\t\t\t// assert map.get(ih) == jh\n\t\t\t\tInstruction oldInstruction = oldInstructionHandle.getInstruction();\n\t\t\t\tInstruction newInstruction = newInstructionHandle.getInstruction();\n\n\t\t\t\tif (oldInstruction instanceof InstructionBranch) {\n\t\t\t\t\thandleBranchInstruction(map, oldInstruction, newInstruction);\n\t\t\t\t}\n\n\t\t\t\t// now deal with line numbers\n\t\t\t\t// and store up info for local variables\n\t\t\t\tfor (InstructionTargeter targeter : oldInstructionHandle.getTargeters()) {\n\t\t\t\t\tif (targeter instanceof LineNumberTag) {\n\t\t\t\t\t\tint line = ((LineNumberTag) targeter).getLineNumber();\n\t\t\t\t\t\tif (line != currLine) {\n\t\t\t\t\t\t\tgen.addLineNumber(newInstructionHandle, line + lineNumberOffset);\n\t\t\t\t\t\t\tcurrLine = line;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (targeter instanceof LocalVariableTag) {\n\t\t\t\t\t\tLocalVariableTag lvt = (LocalVariableTag) targeter;\n\t\t\t\t\t\tLVPosition p = localVariables.get(lvt);\n\t\t\t\t\t\t// If we don't know about it, create a new position and\n\t\t\t\t\t\t// store\n\t\t\t\t\t\t// If we do know about it - update its end position\n\t\t\t\t\t\tif (p == null) {\n\t\t\t\t\t\t\tLVPosition newp = new LVPosition();\n\t\t\t\t\t\t\tnewp.start = newp.end = newInstructionHandle;\n\t\t\t\t\t\t\tlocalVariables.put(lvt, newp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tp.end = newInstructionHandle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now continue\n\t\t\t\toldInstructionHandle = oldInstructionHandle.getNext();\n\t\t\t\tnewInstructionHandle = newInstructionHandle.getNext();\n\t\t\t}\n\t\t}\n\n\t\taddExceptionHandlers(gen, map, exceptionList);\n\t\tif (originalMethodHasLocalVariableTable || enclosingClass\n\t\t\t\t.getBcelObjectType()\n\t\t\t\t.getResolvedTypeX()\n\t\t\t\t.getWorld().generateNewLvts) {\n\t\t\tif (localVariables.size() == 0) {\n\t\t\t\t// Might be a case of 173978 where around advice on an execution join point\n\t\t\t\t// has caused everything to be extracted from the method and thus we\n\t\t\t\t// are left with no local variables, not even the ones for 'this' and\n\t\t\t\t// parameters passed to the method\n\t\t\t\tcreateNewLocalVariables(gen);\n\t\t\t} else {\n\t\t\t\taddLocalVariables(gen, localVariables);\n\t\t\t}\n\t\t}\n\n\t\t// JAVAC adds line number tables (with just one entry) to generated\n\t\t// accessor methods - this\n\t\t// keeps some tools that rely on finding at least some form of\n\t\t// linenumbertable happy.\n\t\t// Let's check if we have one - if we don't then let's add one.\n\t\t// TODO Could be made conditional on whether line debug info is being\n\t\t// produced\n\t\tif (gen.getLineNumbers().length == 0) {\n\t\t\tgen.addLineNumber(gen.getInstructionList().getStart(), 1);\n\t\t}\n\t}\n\n\tprivate void createNewLocalVariables(MethodGen gen) {\n\t\tgen.removeLocalVariables();\n\t\t// ignore <clinit> or <init> for now\n\t\tif (!getName().startsWith(\"<\")) {\n\t\t\tint slot = 0;\n\t\t\tInstructionHandle start = gen.getInstructionList().getStart();\n\t\t\tInstructionHandle end = gen.getInstructionList().getEnd();\n\t\t\t// Add a 'this' if non-static\n\t\t\tif (!isStatic()) {\n\t\t\t\tString cname = this.enclosingClass.getClassName();\n\t\t\t\tif (cname == null) {\n\t\t\t\t\treturn; // give up for now\n\t\t\t\t}\n\t\t\t\tType enclosingType = BcelWorld.makeBcelType(UnresolvedType.forName(cname));\n\t\t\t\tgen.addLocalVariable(\"this\", enclosingType, slot++, start, end);\n\t\t\t}\n\t\t\t// Add entries for the method arguments\n\t\t\tString[] paramNames = (memberView == null ? null : memberView.getParameterNames());\n\t\t\tif (paramNames != null) {\n\t\t\t\tfor (int i = 0; i < argumentTypes.length; i++) {\n\t\t\t\t\tString pname = paramNames[i];\n\t\t\t\t\tif (pname == null) {\n\t\t\t\t\t\tpname = \"arg\" + i;\n\t\t\t\t\t}\n\t\t\t\t\tgen.addLocalVariable(pname, argumentTypes[i], slot, start, end);\n\t\t\t\t\tslot += argumentTypes[i].getSize();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate World getWorld() {\n\t\treturn enclosingClass.getBcelObjectType().getResolvedTypeX().getWorld();\n\t}\n\t/*\n\t * Optimized packing that does a 'local packing' of the code rather than building a brand new method and packing into it. Only\n\t * usable when the packing is going to be done just once.\n\t */\n\tpublic void optimizedPackBody(MethodGen gen) {\n\t\tInstructionList theBody = getBody();\n\t\tInstructionHandle iHandle = theBody.getStart();\n\n\t\tint currLine = -1;\n\t\tint lineNumberOffset = (fromFilename == null) ? 0 : getEnclosingClass().getSourceDebugExtensionOffset(fromFilename);\n\t\tMap<LocalVariableTag, LVPosition> localVariables = new HashMap<>();\n\t\tLinkedList<ExceptionRange> exceptionList = new LinkedList<>();\n\t\tSet<InstructionHandle> forDeletion = new HashSet<>();\n\t\tSet<BranchHandle> branchInstructions = new HashSet<>();\n\t\t// OPTIMIZE sort out in here: getRange()/insertHandler() and type of\n\t\t// exceptionList\n\t\twhile (iHandle != null) {\n\t\t\tInstruction inst = iHandle.getInstruction();\n\t\t\t// InstructionHandle nextInst = iHandle.getNext();\n\t\t\t// OPTIMIZE remove this instructionhandle as it now points to\n\t\t\t// nowhere?\n\t\t\tif (inst == Range.RANGEINSTRUCTION) {\n\t\t\t\tRange r = Range.getRange(iHandle);\n\t\t\t\tif (r instanceof ExceptionRange) {\n\t\t\t\t\tExceptionRange er = (ExceptionRange) r;\n\t\t\t\t\tif (er.getStart() == iHandle) {\n\t\t\t\t\t\tif (!er.isEmpty()) {\n\t\t\t\t\t\t\t// order is important, insert handlers in order of start\n\t\t\t\t\t\t\tinsertHandler(er, exceptionList);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tforDeletion.add(iHandle);\n\t\t\t} else {\n\t\t\t\tif (inst instanceof InstructionBranch) {\n\t\t\t\t\tbranchInstructions.add((BranchHandle) iHandle);\n\t\t\t\t}\n\n\t\t\t\tfor (InstructionTargeter targeter : iHandle.getTargetersCopy()) {\n\t\t\t\t\tif (targeter instanceof LineNumberTag) {\n\t\t\t\t\t\tint line = ((LineNumberTag) targeter).getLineNumber();\n\t\t\t\t\t\tif (line != currLine) {\n\t\t\t\t\t\t\tgen.addLineNumber(iHandle, line + lineNumberOffset);\n\t\t\t\t\t\t\tcurrLine = line;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (targeter instanceof LocalVariableTag) {\n\t\t\t\t\t\tLocalVariableTag lvt = (LocalVariableTag) targeter;\n\t\t\t\t\t\tLVPosition p = localVariables.get(lvt);\n\t\t\t\t\t\t// If we don't know about it, create a new position\n\t\t\t\t\t\t// and store\n\t\t\t\t\t\t// If we do know about it - update its end position\n\t\t\t\t\t\tif (p == null) {\n\t\t\t\t\t\t\tLVPosition newp = new LVPosition();\n\t\t\t\t\t\t\tnewp.start = newp.end = iHandle;\n\t\t\t\t\t\t\tlocalVariables.put(lvt, newp);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tp.end = iHandle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tiHandle = iHandle.getNext();\n\t\t}\n\t\tfor (BranchHandle branchHandle : branchInstructions) {\n\t\t\thandleBranchInstruction(branchHandle, forDeletion);\n\t\t}\n\t\t// now add exception handlers\n\t\tfor (ExceptionRange r : exceptionList) {\n\t\t\tif (r.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgen.addExceptionHandler(jumpForward(r.getRealStart(), forDeletion), jumpForward(r.getRealEnd(), forDeletion),\n\t\t\t\t\tjumpForward(r.getHandler(), forDeletion),\n\t\t\t\t\t(r.getCatchType() == null) ? null : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));\n\t\t}\n\n\t\tfor (InstructionHandle handle : forDeletion) {\n\t\t\ttry {\n\t\t\t\ttheBody.delete(handle);\n\t\t\t} catch (TargetLostException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tgen.setInstructionList(theBody);\n\t\tif (originalMethodHasLocalVariableTable || getWorld().generateNewLvts) {\n\t\t\tif (localVariables.size() == 0) {\n\t\t\t\t// Might be a case of 173978 where around advice on an execution join point\n\t\t\t\t// has caused everything to be extracted from the method and thus we\n\t\t\t\t// are left with no local variables, not even the ones for 'this' and\n\t\t\t\t// parameters passed to the method\n\t\t\t\tcreateNewLocalVariables(gen);\n\t\t\t} else {\n\t\t\t\taddLocalVariables(gen, localVariables);\n\t\t\t}\n\t\t}\n\t\t// JAVAC adds line number tables (with just one entry) to generated\n\t\t// accessor methods - this\n\t\t// keeps some tools that rely on finding at least some form of\n\t\t// linenumbertable happy.\n\t\t// Let's check if we have one - if we don't then let's add one.\n\t\t// TODO Could be made conditional on whether line debug info is being\n\t\t// produced\n\t\tif (gen.getLineNumbers().length == 0) {\n\t\t\tgen.addLineNumber(gen.getInstructionList().getStart(), 1);\n\t\t}\n\t\twasPackedOptimally = true;\n\t}\n\n\tprivate void addLocalVariables(MethodGen gen, Map<LocalVariableTag, LVPosition> localVariables) {\n\t\t// now add local variables\n\t\tgen.removeLocalVariables();\n\n\t\t// this next iteration _might_ be overkill, but we had problems with\n\t\t// bcel before with duplicate local variables. Now that we're patching\n\t\t// bcel we should be able to do without it if we're paranoid enough\n\t\t// through the rest of the compiler.\n\t\tInstructionHandle methodStart = gen.getInstructionList().getStart();\n\t\tInstructionHandle methodEnd = gen.getInstructionList().getEnd();\n\n\t\t// Determine how many 'slots' are used by parameters to the method.\n\t\t// Then below we can determine if a local variable is a parameter variable, if it is\n\t\t// we force its range to from the method start (as it may have been shuffled down\n\t\t// due to insertion of advice like cflow entry)\n\t\tint paramSlots = gen.isStatic() ? 0 : 1;\n\t\tType[] argTypes = gen.getArgumentTypes();\n\t\tif (argTypes != null) {\n\t\t\tfor (Type argType : argTypes) {\n\t\t\t\tif (argType.getSize() == 2) {\n\t\t\t\t\tparamSlots += 2;\n\t\t\t\t} else {\n\t\t\t\t\tparamSlots += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!this.enclosingClass.getWorld().generateNewLvts) {\n\t\t\t// Here the generateNewLvts option is used to control \"Do not damage unusually positioned local\n\t\t\t// variables that represent method parameters\". Strictly speaking local variables that represent\n\t\t\t// method parameters effectively have a bytecode range from 0..end_of_method - however some\n\t\t\t// tools generate bytecode that specifies a compressed range. The code below would normally\n\t\t\t// extend the parameter local variables to cover the full method but by setting paramSlots to -1\n\t\t\t// here we cause the code below to avoid modifying any local vars that represent method\n\t\t\t// parameters.\n\t\t\tparamSlots = -1;\n\t\t}\n\n\t\tMap<InstructionHandle, Set<Integer>> duplicatedLocalMap = new HashMap<>();\n\t\tfor (LocalVariableTag tag : localVariables.keySet()) {\n\t\t\t// have we already added one with the same slot number and start\n\t\t\t// location?\n\t\t\t// if so, just continue.\n\t\t\tLVPosition lvpos = localVariables.get(tag);\n\t\t\tInstructionHandle start = (tag.getSlot() < paramSlots ? methodStart : lvpos.start);\n\t\t\tInstructionHandle end = (tag.getSlot() < paramSlots ? methodEnd : lvpos.end);\n\t\t\tSet<Integer> slots = duplicatedLocalMap.get(start);\n\t\t\tif (slots == null) {\n\t\t\t\tslots = new HashSet<>();\n\t\t\t\tduplicatedLocalMap.put(start, slots);\n\t\t\t} else if (slots.contains(tag.getSlot())) {\n\t\t\t\t// we already have a var starting at this tag with this slot\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tslots.add(tag.getSlot());\n\t\t\tType t = tag.getRealType();\n\t\t\tif (t == null) {\n\t\t\t\tt = BcelWorld.makeBcelType(UnresolvedType.forSignature(tag.getType()));\n\t\t\t}\n\t\t\tgen.addLocalVariable(tag.getName(), t, tag.getSlot(), start, end);\n\t\t}\n\t}\n\n\tprivate void addExceptionHandlers(MethodGen gen, Map<InstructionHandle, InstructionHandle> map,\n\t\t\tIterable<ExceptionRange> exnList) {\n\t\t// now add exception handlers\n\t\tfor (ExceptionRange r : exnList) {\n\t\t\tif (r.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tInstructionHandle rMappedStart = remap(r.getRealStart(), map);\n\t\t\tInstructionHandle rMappedEnd = remap(r.getRealEnd(), map);\n\t\t\tInstructionHandle rMappedHandler = remap(r.getHandler(), map);\n\t\t\tgen.addExceptionHandler(rMappedStart, rMappedEnd, rMappedHandler, (r.getCatchType() == null) ? null\n\t\t\t\t\t: (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));\n\t\t}\n\t}\n\n\tprivate void handleBranchInstruction(Map<InstructionHandle, InstructionHandle> map, Instruction oldInstruction,\n\t\t\tInstruction newInstruction) {\n\t\tInstructionBranch oldBranchInstruction = (InstructionBranch) oldInstruction;\n\t\tInstructionBranch newBranchInstruction = (InstructionBranch) newInstruction;\n\t\tInstructionHandle oldTarget = oldBranchInstruction.getTarget(); // old\n\t\t// target\n\n\t\t// New target is in hash map\n\t\tnewBranchInstruction.setTarget(remap(oldTarget, map));\n\n\t\tif (oldBranchInstruction instanceof InstructionSelect) {\n\t\t\t// Either LOOKUPSWITCH or TABLESWITCH\n\t\t\tInstructionHandle[] oldTargets = ((InstructionSelect) oldBranchInstruction).getTargets();\n\t\t\tInstructionHandle[] newTargets = ((InstructionSelect) newBranchInstruction).getTargets();\n\n\t\t\tfor (int k = oldTargets.length - 1; k >= 0; k--) {\n\t\t\t\t// Update all targets\n\t\t\t\tnewTargets[k] = remap(oldTargets[k], map);\n\t\t\t\tnewTargets[k].addTargeter(newBranchInstruction);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate InstructionHandle jumpForward(InstructionHandle t, Set<InstructionHandle> handlesForDeletion) {\n\t\tInstructionHandle target = t;\n\t\tif (handlesForDeletion.contains(target)) {\n\t\t\tdo {\n\t\t\t\ttarget = target.getNext();\n\t\t\t} while (handlesForDeletion.contains(target));\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Process a branch instruction with respect to instructions that are about to be deleted. If the target for the branch is a\n\t * candidate for deletion, move it to the next valid instruction after the deleted target.\n\t */\n\tprivate void handleBranchInstruction(BranchHandle branchHandle, Set<InstructionHandle> handlesForDeletion) {\n\t\tInstructionBranch branchInstruction = (InstructionBranch) branchHandle.getInstruction();\n\t\tInstructionHandle target = branchInstruction.getTarget(); // old target\n\n\t\tif (handlesForDeletion.contains(target)) {\n\t\t\tdo {\n\t\t\t\ttarget = target.getNext();\n\t\t\t} while (handlesForDeletion.contains(target));\n\t\t\tbranchInstruction.setTarget(target);\n\t\t}\n\n\t\tif (branchInstruction instanceof InstructionSelect) {\n\t\t\t// Either LOOKUPSWITCH or TABLESWITCH\n\t\t\tInstructionSelect iSelect = (InstructionSelect) branchInstruction;\n\t\t\tInstructionHandle[] targets = iSelect.getTargets();\n\t\t\tfor (int k = targets.length - 1; k >= 0; k--) {\n\t\t\t\tInstructionHandle oneTarget = targets[k];\n\t\t\t\tif (handlesForDeletion.contains(oneTarget)) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\toneTarget = oneTarget.getNext();\n\t\t\t\t\t} while (handlesForDeletion.contains(oneTarget));\n\t\t\t\t\tiSelect.setTarget(k, oneTarget);\n\t\t\t\t\toneTarget.addTargeter(branchInstruction);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void handleRangeInstruction(InstructionHandle ih, LinkedList<ExceptionRange> exnList) {\n\t\t// we're a range instruction\n\t\tRange r = Range.getRange(ih);\n\t\tif (r instanceof ExceptionRange) {\n\t\t\tExceptionRange er = (ExceptionRange) r;\n\t\t\tif (er.getStart() == ih) {\n\t\t\t\t// System.err.println(\"er \" + er);\n\t\t\t\tif (!er.isEmpty()) {\n\t\t\t\t\t// order is important, insert handlers in order of start\n\t\t\t\t\tinsertHandler(er, exnList);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// we must be a shadow range or something equally useless,\n\t\t\t// so forget about doing anything\n\t\t}\n\t}\n\n\t/*\n\t * Make copies of all instructions, append them to the new list and associate old instruction references with the new ones,\n\t * i.e., a 1:1 mapping.\n\t */\n\tprivate Map<InstructionHandle, InstructionHandle> copyAllInstructionsExceptRangeInstructionsInto(InstructionList intoList) {\n\t\tMap<InstructionHandle, InstructionHandle> map = new HashMap<>();\n\t\tfor (InstructionHandle ih = getBody().getStart(); ih != null; ih = ih.getNext()) {\n\t\t\tif (Range.isRangeHandle(ih)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tInstruction inst = ih.getInstruction();\n\t\t\tInstruction copy = Utility.copyInstruction(inst);\n\n\t\t\tif (copy instanceof InstructionBranch) {\n\t\t\t\tmap.put(ih, intoList.append((InstructionBranch) copy));\n\t\t\t} else {\n\t\t\t\tmap.put(ih, intoList.append(copy));\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\t/**\n\t * This procedure should not currently be used.\n\t */\n\t// public void killNops() {\n\t// InstructionHandle curr = body.getStart();\n\t// while (true) {\n\t// if (curr == null) break;\n\t// InstructionHandle next = curr.getNext();\n\t// if (curr.getInstruction() instanceof NOP) {\n\t// InstructionTargeter[] targeters = curr.getTargeters();\n\t// if (targeters != null) {\n\t// for (int i = 0, len = targeters.length; i < len; i++) {\n\t// InstructionTargeter targeter = targeters[i];\n\t// targeter.updateTarget(curr, next);\n\t// }\n\t// }\n\t// try {\n\t// body.delete(curr);\n\t// } catch (TargetLostException e) {\n\t// }\n\t// }\n\t// curr = next;\n\t// }\n\t// }\n\t// private static InstructionHandle fNext(InstructionHandle ih) {\n\t// while (true) {\n\t// if (ih.getInstruction()==Range.RANGEINSTRUCTION) ih = ih.getNext();\n\t// else return ih;\n\t// }\n\t// }\n\tprivate static InstructionHandle remap(InstructionHandle handle, Map<InstructionHandle, InstructionHandle> map) {\n\t\twhile (true) {\n\t\t\tInstructionHandle ret = map.get(handle);\n\t\t\tif (ret == null) {\n\t\t\t\thandle = handle.getNext();\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update to all these comments, ASC 11-01-2005\n\t// The right thing to do may be to do more with priorities as\n\t// we create new exception handlers, but that is a relatively\n\t// complex task. In the meantime, just taking account of the\n\t// priority here enables a couple of bugs to be fixed to do\n\t// with using return or break in code that contains a finally\n\t// block (pr78021,pr79554).\n\n\t// exception ordering.\n\t// What we should be doing is dealing with priority inversions way earlier\n\t// than we are\n\t// and counting on the tree structure. In which case, the below code is in\n\t// fact right.\n\n\t// XXX THIS COMMENT BELOW IS CURRENTLY WRONG.\n\t// An exception A preceeds an exception B in the exception table iff:\n\n\t// * A and B were in the original method, and A preceeded B in the original\n\t// exception table\n\t// * If A has a higher priority than B, than it preceeds B.\n\t// * If A and B have the same priority, then the one whose START happens\n\t// EARLIEST has LEAST priority.\n\t// in short, the outermost exception has least priority.\n\t// we implement this with a LinkedList. We could possibly implement this\n\t// with a java.util.SortedSet,\n\t// but I don't trust the only implementation, TreeSet, to do the right\n\t// thing.\n\n\t/* private */static void insertHandler(ExceptionRange fresh, List<ExceptionRange> l) {\n\t\t// Old implementation, simply: l.add(0,fresh);\n\t\tfor (ListIterator<ExceptionRange> iter = l.listIterator(); iter.hasNext();) {\n\t\t\tExceptionRange r = iter.next();\n\t\t\t// int freal = fresh.getRealStart().getPosition();\n\t\t\t// int rreal = r.getRealStart().getPosition();\n\t\t\tif (fresh.getPriority() >= r.getPriority()) {\n\t\t\t\titer.previous();\n\t\t\t\titer.add(fresh);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// we have reached the end\n\t\tl.add(fresh);\n\t}\n\n\tpublic boolean isPrivate() {\n\t\treturn Modifier.isPrivate(getAccessFlags());\n\t}\n\n\tpublic boolean isProtected() {\n\t\treturn Modifier.isProtected(getAccessFlags());\n\t}\n\n\tpublic boolean isDefault() {\n\t\treturn !(isProtected() || isPrivate() || isPublic());\n\t}\n\n\tpublic boolean isPublic() {\n\t\treturn Modifier.isPublic(getAccessFlags());\n\t}\n\n\t// ----\n\n\t/**\n\t * A good body is a body with the following properties:\n\t *\n\t * <ul>\n\t * <li>For each branch instruction S in body, target T of S is in body.\n\t * <li>For each branch instruction S in body, target T of S has S as a targeter.\n\t * <li>For each instruction T in body, for each branch instruction S that is a targeter of T, S is in body.\n\t * <li>For each non-range-handle instruction T in body, for each instruction S that is a targeter of T, S is either a branch\n\t * instruction, an exception range or a tag\n\t * <li>For each range-handle instruction T in body, there is exactly one targeter S that is a range.\n\t * <li>For each range-handle instruction T in body, the range R targeting T is in body.\n\t * <li>For each instruction T in body, for each exception range R targeting T, R is in body.\n\t * <li>For each exception range R in body, let T := R.handler. T is in body, and R is one of T's targeters\n\t * <li>All ranges are properly nested: For all ranges Q and R, if Q.start preceeds R.start, then R.end preceeds Q.end.\n\t * </ul>\n\t *\n\t * Where the shorthand \"R is in body\" means \"R.start is in body, R.end is in body, and any InstructionHandle stored in a field\n\t * of R (such as an exception handle) is in body\".\n\t */\n\n\tpublic void assertGoodBody() {\n\t\tif (true) {\n\t\t\treturn; // only enable for debugging\n\t\t}\n\t\tassertGoodBody(getBody(), toString());\n\t}\n\n\tpublic static void assertGoodBody(InstructionList il, String from) {\n\t\tif (true) {\n\t\t\treturn; // only to be enabled for debugging\n\t\t}\n//\t\tif (il == null) {\n//\t\t\treturn;\n//\t\t}\n//\t\tSet body = new HashSet();\n//\t\tStack<Range> ranges = new Stack<Range>();\n//\t\tfor (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {\n//\t\t\tbody.add(ih);\n//\t\t\tif (ih.getInstruction() instanceof InstructionBranch) {\n//\t\t\t\tbody.add(ih.getInstruction());\n//\t\t\t}\n//\t\t}\n//\n//\t\tfor (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {\n//\t\t\tassertGoodHandle(ih, body, ranges, from);\n//\t\t\tIterator<InstructionTargeter> tIter = ih.getTargeters().iterator();\n//\t\t\twhile (tIter.hasNext()) {\n//\t\t\t\tassertGoodTargeter(tIter.next(), ih, body, from);\n//\t\t\t}\n//\t\t}\n\t}\n\n//\tprivate static void assertGoodHandle(InstructionHandle ih, Set body, Stack<Range> ranges, String from) {\n//\t\tInstruction inst = ih.getInstruction();\n//\t\tif ((inst instanceof InstructionBranch) ^ (ih instanceof BranchHandle)) {\n//\t\t\tthrow new BCException(\"bad instruction/handle pair in \" + from);\n//\t\t}\n//\t\tif (Range.isRangeHandle(ih)) {\n//\t\t\tassertGoodRangeHandle(ih, body, ranges, from);\n//\t\t} else if (inst instanceof InstructionBranch) {\n//\t\t\tassertGoodBranchInstruction((BranchHandle) ih, (InstructionBranch) inst, body, ranges, from);\n//\t\t}\n//\t}\n\n//\tprivate static void assertGoodBranchInstruction(BranchHandle ih, InstructionBranch inst, Set body, Stack<Range> ranges,\n//\t\t\tString from) {\n//\t\tif (ih.getTarget() != inst.getTarget()) {\n//\t\t\tthrow new BCException(\"bad branch instruction/handle pair in \" + from);\n//\t\t}\n//\t\tInstructionHandle target = ih.getTarget();\n//\t\tassertInBody(target, body, from);\n//\t\tassertTargetedBy(target, inst, from);\n//\t\tif (inst instanceof InstructionSelect) {\n//\t\t\tInstructionSelect sel = (InstructionSelect) inst;\n//\t\t\tInstructionHandle[] itargets = sel.getTargets();\n//\t\t\tfor (int k = itargets.length - 1; k >= 0; k--) {\n//\t\t\t\tassertInBody(itargets[k], body, from);\n//\t\t\t\tassertTargetedBy(itargets[k], inst, from);\n//\t\t\t}\n//\t\t}\n//\t}\n\n\t/** ih is an InstructionHandle or a BranchInstruction */\n//\tprivate static void assertInBody(Object ih, Set body, String from) {\n//\t\tif (!body.contains(ih)) {\n//\t\t\tthrow new BCException(\"thing not in body in \" + from);\n//\t\t}\n//\t}\n\n//\tprivate static void assertGoodRangeHandle(InstructionHandle ih, Set body, Stack ranges, String from) {\n//\t\tRange r = getRangeAndAssertExactlyOne(ih, from);\n//\t\tassertGoodRange(r, body, from);\n//\t\tif (r.getStart() == ih) {\n//\t\t\tranges.push(r);\n//\t\t} else if (r.getEnd() == ih) {\n//\t\t\tif (ranges.peek() != r) {\n//\t\t\t\tthrow new BCException(\"bad range inclusion in \" + from);\n//\t\t\t}\n//\t\t\tranges.pop();\n//\t\t}\n//\t}\n\n//\tprivate static void assertGoodRange(Range r, Set body, String from) {\n//\t\tassertInBody(r.getStart(), body, from);\n//\t\tassertRangeHandle(r.getStart(), from);\n//\t\tassertTargetedBy(r.getStart(), r, from);\n//\n//\t\tassertInBody(r.getEnd(), body, from);\n//\t\tassertRangeHandle(r.getEnd(), from);\n//\t\tassertTargetedBy(r.getEnd(), r, from);\n//\n//\t\tif (r instanceof ExceptionRange) {\n//\t\t\tExceptionRange er = (ExceptionRange) r;\n//\t\t\tassertInBody(er.getHandler(), body, from);\n//\t\t\tassertTargetedBy(er.getHandler(), r, from);\n//\t\t}\n//\t}\n\n//\tprivate static void assertRangeHandle(InstructionHandle ih, String from) {\n//\t\tif (!Range.isRangeHandle(ih)) {\n//\t\t\tthrow new BCException(\"bad range handle \" + ih + \" in \" + from);\n//\t\t}\n//\t}\n\n\tprivate static void assertTargetedBy(InstructionHandle target, InstructionTargeter targeter, String from) {\n\t\tfor (InstructionTargeter instructionTargeter : target.getTargeters()) {\n\t\t\tif (instructionTargeter == targeter) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new RuntimeException(\"bad targeting relationship in \" + from);\n\t}\n\n\tprivate static void assertTargets(InstructionTargeter targeter, InstructionHandle target, String from) {\n\t\tif (targeter instanceof Range) {\n\t\t\tRange r = (Range) targeter;\n\t\t\tif (r.getStart() == target || r.getEnd() == target) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (r instanceof ExceptionRange) {\n\t\t\t\tif (((ExceptionRange) r).getHandler() == target) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (targeter instanceof InstructionBranch) {\n\t\t\tInstructionBranch bi = (InstructionBranch) targeter;\n\t\t\tif (bi.getTarget() == target) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (targeter instanceof InstructionSelect) {\n\t\t\t\tInstructionSelect sel = (InstructionSelect) targeter;\n\t\t\t\tInstructionHandle[] itargets = sel.getTargets();\n\t\t\t\tfor (int k = itargets.length - 1; k >= 0; k--) {\n\t\t\t\t\tif (itargets[k] == target) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (targeter instanceof Tag) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new BCException(targeter + \" doesn't target \" + target + \" in \" + from);\n\t}\n\n\tprivate static Range getRangeAndAssertExactlyOne(InstructionHandle ih, String from) {\n\t\tRange ret = null;\n\t\tIterator<InstructionTargeter> tIter = ih.getTargeters().iterator();\n\t\tif (!tIter.hasNext()) {\n\t\t\tthrow new BCException(\"range handle with no range in \" + from);\n\t\t}\n\t\twhile (tIter.hasNext()) {\n\t\t\tInstructionTargeter ts = tIter.next();\n\t\t\tif (ts instanceof Range) {\n\t\t\t\tif (ret != null) {\n\t\t\t\t\tthrow new BCException(\"range handle with multiple ranges in \" + from);\n\t\t\t\t}\n\t\t\t\tret = (Range) ts;\n\t\t\t}\n\t\t}\n\t\tif (ret == null) {\n\t\t\tthrow new BCException(\"range handle with no range in \" + from);\n\t\t}\n\t\treturn ret;\n\t}\n\n//\tprivate static void assertGoodTargeter(InstructionTargeter t, InstructionHandle ih, Set body, String from) {\n//\t\tassertTargets(t, ih, from);\n//\t\tif (t instanceof Range) {\n//\t\t\tassertGoodRange((Range) t, body, from);\n//\t\t} else if (t instanceof InstructionBranch) {\n//\t\t\tassertInBody(t, body, from);\n//\t\t}\n//\t}\n\n\t// ----\n\n\tboolean isAdviceMethod() {\n\t\tif (memberView == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn memberView.getAssociatedShadowMunger() != null;\n\t}\n\n\tboolean isAjSynthetic() {\n\t\tif (memberView == null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn memberView.isAjSynthetic();\n\t}\n\n\tboolean isSynthetic() {\n\t\tif (memberView == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn memberView.isSynthetic();\n\t}\n\n\tpublic ISourceLocation getSourceLocation() {\n\t\tif (memberView != null) {\n\t\t\treturn memberView.getSourceLocation();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic AjAttribute.EffectiveSignatureAttribute getEffectiveSignature() {\n\t\t// if (memberView == null) return null;\n\t\tif (effectiveSignature != null) {\n\t\t\treturn effectiveSignature;\n\t\t}\n\t\treturn memberView.getEffectiveSignature();\n\t}\n\n\tpublic void setEffectiveSignature(ResolvedMember member, Shadow.Kind kind, boolean shouldWeave) {\n\t\tthis.effectiveSignature = new AjAttribute.EffectiveSignatureAttribute(member, kind, shouldWeave);\n\t}\n\n\tpublic String getSignature() {\n\t\tif (memberView != null) {\n\t\t\treturn memberView.getSignature();\n\t\t}\n\t\treturn MemberImpl.typesToSignature(BcelWorld.fromBcel(getReturnType()), BcelWorld.fromBcel(getArgumentTypes()), false);\n\t}\n\n\tpublic String getParameterSignature() {\n\t\tif (memberView != null) {\n\t\t\treturn memberView.getParameterSignature();\n\t\t}\n\t\treturn MemberImpl.typesToSignature(BcelWorld.fromBcel(getArgumentTypes()));\n\t}\n\n\tpublic BcelMethod getMemberView() {\n\t\treturn memberView;\n\t}\n\n\tpublic void forcePublic() {\n\t\tmarkAsChanged();\n\t\tmodifiers = Utility.makePublic(modifiers);\n\t}\n\n\tpublic boolean getCanInline() {\n\t\treturn canInline;\n\t}\n\n\tpublic void setCanInline(boolean canInline) {\n\t\tthis.canInline = canInline;\n\t}\n\n\tpublic void addAttribute(Attribute attribute) {\n\t\tattributes.add(attribute);\n\t}\n\n\tpublic String toTraceString() {\n\t\treturn toShortString();\n\t}\n\n\tpublic ConstantPool getConstantPool() {\n\t\treturn enclosingClass.getConstantPool();\n\t}\n\n\tpublic static boolean isConstructor(LazyMethodGen aMethod) {\n\t\treturn aMethod.getName().equals(\"<init>\");\n\t}\n\n}\n",
    "size": 62075
  },
  {
    "file_id": "F37",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/Range.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.InstructionTargeter;\nimport org.aspectj.weaver.BCException;\n\nabstract class Range implements InstructionTargeter {\n\n\tprotected InstructionList body;\n\tprotected InstructionHandle start;\n\tprotected InstructionHandle end;\n\n\t// ---- initialization\n\n\tprotected Range(InstructionList il) {\n\t\tthis.body = il;\n\t}\n\n\t// ----\n\n\tfinal InstructionList getBody() {\n\t\treturn body;\n\t}\n\n\tfinal InstructionHandle getStart() {\n\t\treturn start;\n\t}\n\n\tfinal InstructionHandle getEnd() {\n\t\treturn end;\n\t}\n\n\t// ----\n\n\tboolean isEmpty() {\n\t\tInstructionHandle ih = start;\n\t\t// System.err.println(\"  looking for \" + end);\n\t\twhile (ih != end) {\n\t\t\t// System.err.println(\"    ih \" + ih);\n\t\t\tif (!Range.isRangeHandle(ih)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tih = ih.getNext();\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic InstructionHandle getRealStart(InstructionHandle ih) {\n\t\twhile (Range.isRangeHandle(ih)) {\n\t\t\tih = ih.getNext();\n\t\t}\n\t\treturn ih;\n\t}\n\n\tInstructionHandle getRealStart() {\n\t\treturn getRealStart(start);\n\t}\n\n\tstatic InstructionHandle getRealEnd(InstructionHandle ih) {\n\t\twhile (Range.isRangeHandle(ih)) {\n\t\t\tih = ih.getPrev();\n\t\t}\n\t\treturn ih;\n\t}\n\n\tInstructionHandle getRealEnd() {\n\t\treturn getRealEnd(end);\n\t}\n\n\tInstructionHandle getRealNext() {\n\t\treturn getRealStart(end);\n\t}\n\n\t// ----\n\n\tInstructionHandle insert(Instruction i, Where where) {\n\t\tInstructionList il = new InstructionList();\n\t\tInstructionHandle ret = il.insert(i);\n\t\tinsert(il, where);\n\t\treturn ret;\n\t}\n\n\tvoid insert(InstructionList freshIl, Where where) {\n\t\tInstructionHandle h;\n\t\tif (where == InsideBefore || where == OutsideBefore) {\n\t\t\th = getStart();\n\t\t} else {\n\t\t\th = getEnd();\n\t\t}\n\t\tif (where == InsideBefore || where == OutsideAfter) {\n\t\t\tbody.append(h, freshIl);\n\t\t} else {\n\t\t\tInstructionHandle newStart = body.insert(h, freshIl);\n\t\t\tif (where == OutsideBefore) {\n\t\t\t\t// XXX this is slow. There's a better design than this. We should\n\t\t\t\t// never have to retarget branches apart from the creation of ranges.\n\t\t\t\t// basically, we should never weave OutsideBefore.\n\t\t\t\tBcelShadow.retargetAllBranches(h, newStart);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tInstructionHandle append(Instruction i) {\n\t\treturn insert(i, InsideAfter);\n\t}\n\n\tvoid append(InstructionList i) {\n\t\tinsert(i, InsideAfter);\n\t}\n\n\tprivate static void setLineNumberFromNext(InstructionHandle ih) {\n\t\tint lineNumber = Utility.getSourceLine(ih.getNext());\n\t\tif (lineNumber != -1) {\n\t\t\tUtility.setSourceLine(ih, lineNumber);\n\t\t}\n\t}\n\n\tstatic InstructionHandle genStart(InstructionList body) {\n\t\tInstructionHandle ih = body.insert(Range.RANGEINSTRUCTION);\n\t\tsetLineNumberFromNext(ih);\n\t\treturn ih;\n\t}\n\n\tstatic InstructionHandle genEnd(InstructionList body) {\n\t\treturn body.append(Range.RANGEINSTRUCTION);\n\t}\n\n\tstatic InstructionHandle genStart(InstructionList body, InstructionHandle ih) {\n\t\tif (ih == null) {\n\t\t\treturn genStart(body);\n\t\t}\n\t\tInstructionHandle freshIh = body.insert(ih, Range.RANGEINSTRUCTION);\n\t\tsetLineNumberFromNext(freshIh);\n\t\treturn freshIh;\n\t}\n\n\tstatic InstructionHandle genEnd(InstructionList body, InstructionHandle ih) {\n\t\tif (ih == null) {\n\t\t\treturn genEnd(body);\n\t\t}\n\t\treturn body.append(ih, Range.RANGEINSTRUCTION);\n\t}\n\n\t// -----\n\n\tpublic boolean containsTarget(InstructionHandle ih) {\n\t\treturn false;\n\t}\n\n\tpublic final void updateTarget(InstructionHandle old_ih, InstructionHandle new_ih) {\n\t\tthrow new RuntimeException(\"Ranges must be updated with an enclosing instructionList\");\n\t}\n\n\tprotected void updateTarget(InstructionHandle old_ih, InstructionHandle new_ih, InstructionList new_il) {\n\t\told_ih.removeTargeter(this);\n\t\tif (new_ih != null) {\n\t\t\tnew_ih.addTargeter(this);\n\t\t}\n\t\tbody = new_il;\n\n\t\tif (old_ih == start) {\n\t\t\tstart = new_ih;\n\t\t}\n\t\tif (old_ih == end) {\n\t\t\tend = new_ih;\n\t\t}\n\t}\n\n\tpublic static final boolean isRangeHandle(InstructionHandle ih) {\n\t\tif (ih == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn ih.getInstruction() == Range.RANGEINSTRUCTION;\n\t}\n\n\tprotected static final Range getRange(InstructionHandle ih) {\n\t\t// assert isRangeHandle(ih)\n\t\tRange ret = null;\n\t\tfor (InstructionTargeter targeter : ih.getTargeters()) {\n\t\t\tif (targeter instanceof Range) {\n\t\t\t\tRange r = (Range) targeter;\n\t\t\t\tif (r.getStart() != ih && r.getEnd() != ih) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ret != null) {\n\t\t\t\t\tthrow new BCException(\"multiple ranges on same range handle: \" + ret + \",  \" + targeter);\n\t\t\t\t}\n\t\t\t\tret = r;\n\t\t\t}\n\t\t}\n\t\tif (ret == null) {\n\t\t\tthrow new BCException(\"shouldn't happen\");\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// ----\n\n\tstatic final Where InsideBefore = new Where(\"insideBefore\");\n\tstatic final Where InsideAfter = new Where(\"insideAfter\");\n\tstatic final Where OutsideBefore = new Where(\"outsideBefore\");\n\tstatic final Where OutsideAfter = new Where(\"outsideAfter\");\n\n\t// ---- constants\n\n\t// note that this is STUPIDLY copied by Instruction.copy(), so don't do that.\n\n\tpublic static final Instruction RANGEINSTRUCTION = InstructionConstants.IMPDEP1;\n\n\t// ----\n\n\tstatic class Where {\n\t\tprivate String name;\n\n\t\tpublic Where(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n",
    "size": 5856
  },
  {
    "file_id": "F38",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/ShadowRange.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionBranch;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionLV;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.InstructionSelect;\nimport org.aspectj.apache.bcel.generic.InstructionTargeter;\nimport org.aspectj.apache.bcel.generic.LocalVariableTag;\nimport org.aspectj.apache.bcel.generic.RET;\nimport org.aspectj.apache.bcel.generic.TargetLostException;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.IntMap;\nimport org.aspectj.weaver.Shadow;\n\nfinal class ShadowRange extends Range {\n\n\tprivate BcelShadow shadow;\n\n\t// ---- initialization\n\n\t/**\n\t * After this constructor is called, this range is not well situated unless both {@link #associateWithTargets} and\n\t * {@link #associateWithShadow} are called.\n\t */\n\tpublic ShadowRange(InstructionList body) {\n\t\tsuper(body);\n\t}\n\n\tprotected void associateWithTargets(InstructionHandle start, InstructionHandle end) {\n\t\t// assert body.contains(start) && body.contains(end);\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tstart.addTargeter(this);\n\t\tend.addTargeter(this);\n\t}\n\n\tpublic void associateWithShadow(BcelShadow shadow) {\n\t\tthis.shadow = shadow;\n\t\tshadow.setRange(this);\n\t}\n\n\t// ----\n\n\tpublic Shadow.Kind getKind() {\n\t\treturn shadow.getKind();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn shadow.toString();\n\t}\n\n\tvoid extractInstructionsInto(LazyMethodGen freshMethod, IntMap remap, boolean addReturn) {\n\t\tLazyMethodGen.assertGoodBody(getBody(), toString());\n\t\tfreshMethod.assertGoodBody();\n\t\tInstructionList freshBody = freshMethod.getBody();\n\n\t\tfor (InstructionHandle oldIh = start.getNext(); oldIh != end; oldIh = oldIh.getNext()) {\n\t\t\t// first we copy the instruction itself.\n\t\t\tInstruction oldI = oldIh.getInstruction();\n\t\t\tInstruction freshI = (oldI == RANGEINSTRUCTION) ? oldI : Utility.copyInstruction(oldI);\n\n\t\t\t// Now we add it to the new instruction list.\n\t\t\tInstructionHandle freshIh;\n\t\t\tif (freshI instanceof InstructionBranch) {\n\t\t\t\t// If it's a targeting instruction,\n\t\t\t\t// update the target(s) to point to the new copy instead of the old copy.\n\t\t\t\tInstructionBranch oldBranch = (InstructionBranch) oldI;\n\t\t\t\tInstructionBranch freshBranch = (InstructionBranch) freshI;\n\t\t\t\tInstructionHandle oldTarget = oldBranch.getTarget();\n\t\t\t\toldTarget.removeTargeter(oldBranch);\n\t\t\t\toldTarget.addTargeter(freshBranch);\n\t\t\t\tif (freshBranch instanceof InstructionSelect) {\n\t\t\t\t\tInstructionSelect oldSelect = (InstructionSelect) oldI;\n\t\t\t\t\tInstructionSelect freshSelect = (InstructionSelect) freshI;\n\t\t\t\t\tInstructionHandle[] oldTargets = freshSelect.getTargets();\n\t\t\t\t\tfor (int k = oldTargets.length - 1; k >= 0; k--) {\n\t\t\t\t\t\toldTargets[k].removeTargeter(oldSelect);\n\t\t\t\t\t\toldTargets[k].addTargeter(freshSelect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfreshIh = freshBody.append(freshBranch);\n\t\t\t} else {\n\t\t\t\tfreshIh = freshBody.append(freshI);\n\t\t\t}\n\n\t\t\t// if source comes before target:\n\t\t\t// source <--> target\n\t\t\t// --> [process: target.removeTargeter(source); target.addTargeter(sourcecopy)]\n\t\t\t// source ---------\\\n\t\t\t// v\n\t\t\t// sourcecopy <--> target\n\t\t\t// --> [ process: sourcecopy.updateTarget(target, targetcopy) ]\n\t\t\t// source ----> target\n\t\t\t// sourcecopy <--> targetcopy\n\n\t\t\t// if target comes before source\n\n\t\t\t// target <--> source\n\t\t\t// --> [process: source.updateTarget(target, targetcopy) ]\n\t\t\t// target\n\t\t\t// targetcopy <--> source\n\t\t\t// --> [process: targetcopy.removeTargeter(source); targetcopy.addTargeter(sourcecopy)]\n\t\t\t// target source\n\t\t\t// v\n\t\t\t// targetcopy <--> sourcecopy\n\n\t\t\t// now deal with the old instruction's targeters. Update them all to point to us\n\t\t\t// instead of the old instruction. We use updateTarget to do this. One goal is\n\t\t\t// to make sure we remove all targeters from the old guy, so we can successfully\n\t\t\t// delete it.\n\t\t\tfor (InstructionTargeter source : oldIh.getTargetersCopy()) {\n\t\t\t\tif (source instanceof LocalVariableTag) {\n\t\t\t\t\tShadow.Kind kind = getKind();\n\t\t\t\t\tif (kind == Shadow.AdviceExecution || kind == Shadow.ConstructorExecution || kind == Shadow.MethodExecution\n\t\t\t\t\t\t\t|| kind == Shadow.PreInitialization || kind == Shadow.Initialization\n\t\t\t\t\t\t\t|| kind == Shadow.StaticInitialization) {\n\t\t\t\t\t\tLocalVariableTag sourceLocalVariableTag = (LocalVariableTag) source;\n\t\t\t\t\t\tif (sourceLocalVariableTag.getSlot() == 0) {\n\t\t\t\t\t\t\t// might be 'this' so should be renamed if being dumped in a static method 277616\n\t\t\t\t\t\t\tif (sourceLocalVariableTag.getName().equals(\"this\")) {\n\t\t\t\t\t\t\t\tsourceLocalVariableTag.setName(\"ajc$this\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if we're extracting a whole block we can do this...\n\t\t\t\t\t\tsource.updateTarget(oldIh, freshIh);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// XXX destroying local variable info\n\t\t\t\t\t\t// but only for a call or get join point, so no big deal\n\t\t\t\t\t\tsource.updateTarget(oldIh, null);\n\t\t\t\t\t}\n\t\t\t\t} else if (source instanceof Range) {\n\t\t\t\t\t// exceptions and shadows are just moved\n\t\t\t\t\t((Range) source).updateTarget(oldIh, freshIh, freshBody);\n\t\t\t\t} else {\n\t\t\t\t\t// line numbers can be shared,\n\t\t\t\t\t// branches will be copied along with us.\n\t\t\t\t\tsource.updateTarget(oldIh, freshIh);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// we're now done with the old instruction entirely, and will ignore them through\n\t\t\t// the rest of this loop. The only time we'll see them again is a second pass to\n\t\t\t// delete them.\n\n\t\t\t// now deal with local variable instructions. If this points to a remapped\n\t\t\t// frame location, update the instruction's index. If this doesn't,\n\t\t\t// do compaction/expansion: allocate a new local variable, and modify the remap\n\t\t\t// to handle it. XXX We're doing the safe thing and allocating ALL these local variables\n\t\t\t// as double-wides, in case the location is found to hold a double-wide later.\n\t\t\tif (freshI.isLocalVariableInstruction() || freshI instanceof RET) {\n\t\t\t\t// IndexedInstruction indexedI = (IndexedInstruction) freshI;\n\t\t\t\tint oldIndex = freshI.getIndex();\n\t\t\t\tint freshIndex;\n\t\t\t\tif (!remap.hasKey(oldIndex)) {\n\t\t\t\t\tfreshIndex = freshMethod.allocateLocal(2);\n\t\t\t\t\tremap.put(oldIndex, freshIndex);\n\t\t\t\t} else {\n\t\t\t\t\tfreshIndex = remap.get(oldIndex);\n\t\t\t\t}\n\t\t\t\tif (freshI instanceof RET) {\n\t\t\t\t\tfreshI.setIndex(freshIndex);\n\t\t\t\t} else {\n\t\t\t\t\tfreshI = ((InstructionLV) freshI).setIndexAndCopyIfNecessary(freshIndex);\n\t\t\t\t\tfreshIh.setInstruction(freshI);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// System.err.println(\"JUST COPIED: \" +\n\t\t\t// oldIh.getInstruction().toString(freshMethod.getEnclosingClass().getConstantPoolGen().getConstantPool())\n\t\t\t// + \" INTO \" +\n\t\t\t// freshIh.getInstruction().toString(freshMethod.getEnclosingClass().getConstantPoolGen().getConstantPool()));\n\t\t}\n\n\t\t// now go through again and update variable slots that have been altered as a result\n\t\t// of remapping...\n\t\tfor (InstructionHandle newIh = freshBody.getStart(); newIh != freshBody.getEnd(); newIh = newIh.getNext()) {\n\t\t\tfor (InstructionTargeter source : newIh.getTargeters()) {\n\t\t\t\tif (source instanceof LocalVariableTag) {\n\t\t\t\t\tLocalVariableTag lvt = (LocalVariableTag) source;\n\t\t\t\t\tif (!lvt.isRemapped() && remap.hasKey(lvt.getSlot())) {\n\t\t\t\t\t\tlvt.updateSlot(remap.get(lvt.getSlot()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we've now copied out all the instructions.\n\t\t// now delete the instructions... we've already taken care of the damn\n\t\t// targets, but since TargetLostException is checked, we have to do this stuff.\n\t\ttry {\n\t\t\tfor (InstructionHandle oldIh = start.getNext(); oldIh != end;) {\n\t\t\t\tInstructionHandle next = oldIh.getNext();\n\t\t\t\tbody.delete(oldIh);\n\t\t\t\toldIh = next;\n\t\t\t}\n\t\t} catch (TargetLostException e) {\n\t\t\tthrow new BCException(\"shouldn't have gotten a target lost\");\n\t\t}\n\n\t\t// now add the return, if one is warranted.\n\t\tInstructionHandle ret = null;\n\t\tif (addReturn) {\n\t\t\t// we really should pull this out somewhere...\n\t\t\tret = freshBody.append(InstructionFactory.createReturn(freshMethod.getReturnType()));\n\t\t}\n\t\t// and remap all the old targeters of the end handle of the range to the return.\n\t\tfor (InstructionTargeter t : end.getTargetersCopy()) {\n\t\t\tif (t == this) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!addReturn) {\n\t\t\t\tthrow new BCException(\"range has target, but we aren't adding a return\");\n\t\t\t} else {\n\t\t\t\tt.updateTarget(end, ret);\n\t\t\t}\n\t\t}\n\n\t\tLazyMethodGen.assertGoodBody(getBody(), toString());\n\t\tfreshMethod.assertGoodBody();\n\t}\n\n\tpublic BcelShadow getShadow() {\n\t\treturn shadow;\n\t}\n\n}\n",
    "size": 9028
  },
  {
    "file_id": "F39",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/TypeAnnotationAccessVar.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 IBM\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Andy Clement   initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\n\n/**\n * Used for @this() @target() @args() - represents accessing an annotated 'thing'. Main use is to create the instructions that\n * retrieve the annotation from the 'thing' - see createLoadInstructions()\n */\npublic class TypeAnnotationAccessVar extends BcelVar {\n\n\tprivate BcelVar target;\n\n\tpublic TypeAnnotationAccessVar(ResolvedType type, BcelVar theAnnotatedTargetIsStoredHere) {\n\t\tsuper(type, 0);\n\t\ttarget = theAnnotatedTargetIsStoredHere;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"TypeAnnotationAccessVar(\" + getType() + \")\";\n\t}\n\n\tpublic Instruction createLoad(InstructionFactory fact) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic Instruction createStore(InstructionFactory fact) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\n\t\til.append(createLoadInstructions(getType(), fact));\n\t}\n\n\tpublic InstructionList createLoadInstructions(ResolvedType toType, InstructionFactory fact) {\n\t\tInstructionList il = new InstructionList();\n\t\tType jlClass = BcelWorld.makeBcelType(UnresolvedType.JL_CLASS);\n\t\tType jlaAnnotation = BcelWorld.makeBcelType(UnresolvedType.ANNOTATION);\n\t\til.append(target.createLoad(fact));\n\t\til.append(fact.createInvoke(\"java/lang/Object\", \"getClass\", jlClass, Type.NO_ARGS, Constants.INVOKEVIRTUAL));\n\t\til.append(fact.createConstant(new ObjectType(toType.getName())));\n\t\til.append(fact.createInvoke(\"java/lang/Class\", \"getAnnotation\", jlaAnnotation, new Type[] { jlClass },\n\t\t\t\tConstants.INVOKEVIRTUAL));\n\t\til.append(Utility.createConversion(fact, jlaAnnotation, BcelWorld.makeBcelType(toType)));\n\t\treturn il;\n\n\t}\n\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\n\t\til.append(createLoadInstructions(toType, fact));\n\n\t}\n\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\n\t\til.insert(createLoadInstructions(getType(), fact));\n\t}\n\n}\n",
    "size": 2970
  },
  {
    "file_id": "F40",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/TypeDelegateResolver.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2010 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Andy Clement, SpringSource\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ReferenceTypeDelegate;\n\n/**\n * A type delegate resolver is able to create type delegates for a named reference type.  A type delegate will implement\n * ReferenceTypeDelegate.  There are three kind of delegate already in existence: those created for eclipse structures, those\n * created for bytecode structures, and those created based on reflection.\n *\n * @author Andy Clement\n */\npublic interface TypeDelegateResolver {\n\n\tReferenceTypeDelegate getDelegate(ReferenceType referenceType);\n\n}\n",
    "size": 1085
  },
  {
    "file_id": "F41",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/UnwovenClassFile.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.weaver.IUnwovenClassFile;\n\npublic class UnwovenClassFile implements IUnwovenClassFile {\n\tprotected String filename;\n\tprotected char[] charfilename;\n\tprotected byte[] bytes;\n\t// protected JavaClass javaClass = null;\n\t// protected byte[] writtenBytes = null;\n\tprotected List<ChildClass> writtenChildClasses = Collections.emptyList();\n\tprotected String className = null;\n\tprotected boolean isModule = false;\n\n\tpublic UnwovenClassFile(String filename, byte[] bytes) {\n\t\tthis.filename = filename;\n\t\tthis.isModule = filename.toLowerCase().endsWith(\"module-info.java\");\n\t\tthis.bytes = bytes;\n\t}\n\n\t/** Use if the classname is known, saves a bytecode parse */\n\tpublic UnwovenClassFile(String filename, String classname, byte[] bytes) {\n\t\tthis.filename = filename;\n\t\tthis.isModule = filename.toLowerCase().endsWith(\"module-info.class\");\n\t\tthis.className = classname;\n\t\tthis.bytes = bytes;\n\t}\n\n\tpublic boolean shouldBeWoven() {\n\t\t// Skip module-info files for now, they aren't really types\n\t\treturn !isModule;\n\t}\n\n\tpublic String getFilename() {\n\t\treturn filename;\n\t}\n\n\tpublic String makeInnerFileName(String innerName) {\n\t\tString prefix = filename.substring(0, filename.length() - 6); // strip the .class\n\t\treturn prefix + \"$\" + innerName + \".class\";\n\t}\n\n\tpublic byte[] getBytes() {\n\t\t// if (bytes == null) bytes = javaClass.getBytes();\n\t\treturn bytes;\n\t}\n\n\tpublic JavaClass getJavaClass() {\n\t\t// XXX need to know when to make a new class and when not to\n\t\t// XXX this is an important optimization\n\t\tif (getBytes() == null) {\n\t\t\tSystem.out.println(\"no bytes for: \" + getFilename());\n\t\t\t// Thread.currentThread().dumpStack();\n\t\t\tThread.dumpStack();\n\t\t}\n\t\treturn Utility.makeJavaClass(filename, getBytes());\n\t\t// if (javaClass == null) javaClass = Utility.makeJavaClass(filename, getBytes());\n\t\t// return javaClass;\n\t}\n\n\tpublic void writeUnchangedBytes() throws IOException {\n\t\twriteWovenBytes(getBytes(), Collections.<ChildClass>emptyList());\n\t}\n\n\tpublic void writeWovenBytes(byte[] bytes, List<ChildClass> childClasses) throws IOException {\n\t\twriteChildClasses(childClasses);\n\n\t\t// System.err.println(\"should write: \" + getClassName());\n\n\t\t// System.err.println(\"about to write: \" + this + \", \" + writtenBytes + \", \");\n\t\t// + writtenBytes != null + \" && \" + unchanged(bytes, writtenBytes) );\n\n\t\t// if (writtenBytes != null && unchanged(bytes, writtenBytes)) return;\n\n\t\t// System.err.println(\"    actually wrote it\");\n\n\t\tBufferedOutputStream os = FileUtil.makeOutputStream(new File(filename));\n\t\tos.write(bytes);\n\t\tos.close();\n\n\t\t// writtenBytes = bytes;\n\t}\n\n\tprivate void writeChildClasses(List<ChildClass> childClasses) throws IOException {\n\t\t// ??? we only really need to delete writtenChildClasses whose\n\t\t// ??? names aren't in childClasses; however, it's unclear\n\t\t// ??? how much that will affect performance\n\t\tdeleteAllChildClasses();\n\n\t\tchildClasses.removeAll(writtenChildClasses); // XXX is this right\n\n\t\tfor (ChildClass childClass : childClasses) {\n\t\t\twriteChildClassFile(childClass.name, childClass.bytes);\n\t\t}\n\n\t\twrittenChildClasses = childClasses;\n\n\t}\n\n\tprivate void writeChildClassFile(String innerName, byte[] bytes) throws IOException {\n\t\tBufferedOutputStream os = FileUtil.makeOutputStream(new File(makeInnerFileName(innerName)));\n\t\tos.write(bytes);\n\t\tos.close();\n\t}\n\n\tprotected void deleteAllChildClasses() {\n\t\tfor (ChildClass childClass : writtenChildClasses) {\n\t\t\tdeleteChildClassFile(childClass.name);\n\t\t}\n\t}\n\n\tprotected void deleteChildClassFile(String innerName) {\n\t\tFile childClassFile = new File(makeInnerFileName(innerName));\n\t\tchildClassFile.delete();\n\t}\n\n\t/* private */static boolean unchanged(byte[] b1, byte[] b2) {\n\t\tint len = b1.length;\n\t\tif (b2.length != len)\n\t\t\treturn false;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (b1[i] != b2[i])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic char[] getClassNameAsChars() {\n\t\tif (charfilename == null) {\n\t\t\tcharfilename = getClassName().replace('.', '/').toCharArray();\n\t\t}\n\t\treturn charfilename;\n\t}\n\n\tpublic String getClassName() {\n\t\tif (className == null)\n\t\t\tclassName = getJavaClass().getClassName(); // OPTIMIZE quicker way to determine name??? surely?\n\t\treturn className;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"UnwovenClassFile(\" + filename + \", \" + getClassName() + \")\";\n\t}\n\n\t// record\n\t// OPTIMIZE why is the 'short name' used here (the bit after the dollar) - seems we mess about a lot trimming it off only to put\n\t// it back on!\n\tpublic static class ChildClass {\n\t\tpublic final String name;\n\t\tpublic final byte[] bytes;\n\n\t\tChildClass(String name, byte[] bytes) {\n\t\t\tthis.name = name;\n\t\t\tthis.bytes = bytes;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (!(other instanceof ChildClass))\n\t\t\t\treturn false;\n\t\t\tChildClass o = (ChildClass) other;\n\t\t\treturn o.name.equals(name) && unchanged(o.bytes, bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn name.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(ChildClass \" + name + \")\";\n\t\t}\n\t}\n\n\tpublic void setClassNameAsChars(char[] classNameAsChars) {\n\t\tthis.charfilename = classNameAsChars;\n\t}\n}\n",
    "size": 5888
  },
  {
    "file_id": "F42",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/UnwovenClassFileWithThirdPartyManagedBytecode.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2004 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.aspectj.weaver.bcel;\n\n/**\n * @author colyer This subclass of UnwovenClassFile allows a third-party to manage the actual bytes that comprise the class. This\n *         means the third party can return a reference to an existing array, or create the bytes on demand, or apply any other\n *         strategy that makes sense. By refering to bytes held elsewhere, the goal is to reduce the overall memory consumption by\n *         not holding a copy.\n */\npublic class UnwovenClassFileWithThirdPartyManagedBytecode extends UnwovenClassFile {\n\n\tIByteCodeProvider provider;\n\n\tpublic interface IByteCodeProvider {\n\t\tbyte[] getBytes();\n\t}\n\n\t// OPTIMIZE make classname an input char[]\n\tpublic UnwovenClassFileWithThirdPartyManagedBytecode(String filename, String classname, IByteCodeProvider provider) {\n\t\tsuper(filename, classname, null);\n\t\tthis.provider = provider;\n\t}\n\n\tpublic byte[] getBytes() {\n\t\treturn provider.getBytes();\n\t}\n}\n",
    "size": 1488
  },
  {
    "file_id": "F43",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/Utility.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Hashtable;\nimport java.util.List;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.classfile.Attribute;\nimport org.aspectj.apache.bcel.classfile.ClassParser;\nimport org.aspectj.apache.bcel.classfile.ConstantPool;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.apache.bcel.classfile.Unknown;\nimport org.aspectj.apache.bcel.classfile.annotation.ArrayElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.ElementValue;\nimport org.aspectj.apache.bcel.classfile.annotation.NameValuePair;\nimport org.aspectj.apache.bcel.classfile.annotation.SimpleElementValue;\nimport org.aspectj.apache.bcel.generic.ArrayType;\nimport org.aspectj.apache.bcel.generic.BasicType;\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.generic.InstructionByte;\nimport org.aspectj.apache.bcel.generic.InstructionCP;\nimport org.aspectj.apache.bcel.generic.InstructionConstants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.InstructionSelect;\nimport org.aspectj.apache.bcel.generic.InstructionShort;\nimport org.aspectj.apache.bcel.generic.InstructionTargeter;\nimport org.aspectj.apache.bcel.generic.LineNumberTag;\nimport org.aspectj.apache.bcel.generic.ObjectType;\nimport org.aspectj.apache.bcel.generic.ReferenceType;\nimport org.aspectj.apache.bcel.generic.SwitchBuilder;\nimport org.aspectj.apache.bcel.generic.TargetLostException;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.weaver.AjAttribute;\nimport org.aspectj.weaver.AjAttribute.WeaverVersionInfo;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.BCException;\nimport org.aspectj.weaver.ConstantPoolReader;\nimport org.aspectj.weaver.ISourceContext;\nimport org.aspectj.weaver.Lint;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.Utils;\nimport org.aspectj.weaver.World;\n\npublic class Utility {\n\n  private final static char PACKAGE_INITIAL_CHAR = AjAttribute.AttributePrefix.charAt(0);\n\n\tpublic static List<AjAttribute> readAjAttributes(String classname, Attribute[] as, ISourceContext context, World w,\n\t\t\tAjAttribute.WeaverVersionInfo version, ConstantPoolReader dataDecompressor) {\n\t\tList<AjAttribute> attributes = new ArrayList<>();\n\n\t\t// first pass, look for version\n\t\tList<Unknown> forSecondPass = new ArrayList<>();\n\t\tfor (int i = as.length - 1; i >= 0; i--) {\n\t\t\tAttribute a = as[i];\n\t\t\tif (a instanceof Unknown) {\n\t\t\t\tUnknown u = (Unknown) a;\n\t\t\t\tString name = u.getName();\n\t\t\t\tif (name.charAt(0) == PACKAGE_INITIAL_CHAR) { // 'o'rg.aspectj\n\t\t\t\t\tif (name.startsWith(AjAttribute.AttributePrefix)) {\n\t\t\t\t\t\tif (name.endsWith(WeaverVersionInfo.AttributeName)) {\n\t\t\t\t\t\t\tversion = (AjAttribute.WeaverVersionInfo) AjAttribute.read(version, name, u.getBytes(), context, w,\n\t\t\t\t\t\t\t\t\tdataDecompressor);\n\t\t\t\t\t\t\tif (version.getMajorVersion() > WeaverVersionInfo.getCurrentWeaverMajorVersion()) {\n\t\t\t\t\t\t\t\tthrow new BCException(\n\t\t\t\t\t\t\t\t\t\t\"Unable to continue, this version of AspectJ supports classes built with weaver version \"\n\t\t\t\t\t\t\t\t\t\t\t\t+ WeaverVersionInfo.toCurrentVersionString() + \" but the class \" + classname\n\t\t\t\t\t\t\t\t\t\t\t\t+ \" is version \" + version.toString() + \".  Please update your AspectJ.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforSecondPass.add(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// FIXASC why going backwards? is it important\n\t\tfor (int i = forSecondPass.size() - 1; i >= 0; i--) {\n\t\t\tUnknown a = forSecondPass.get(i);\n\t\t\tString name = a.getName();\n\t\t\tAjAttribute attr = AjAttribute.read(version, name, a.getBytes(), context, w, dataDecompressor);\n\t\t\tif (attr != null) {\n\t\t\t\tattributes.add(attr);\n\t\t\t}\n\t\t}\n\t\treturn attributes;\n\t}\n\n\t/*\n\t * Ensure we report a nice source location - particular in the case where the source info is missing (binary weave).\n\t */\n\tpublic static String beautifyLocation(ISourceLocation isl) {\n\t\tStringBuilder nice = new StringBuilder();\n\t\tif (isl == null || isl.getSourceFile() == null || isl.getSourceFile().getName().contains(\"no debug info available\")) {\n\t\t\tnice.append(\"no debug info available\");\n\t\t} else {\n\t\t\t// can't use File.getName() as this fails when a Linux box\n\t\t\t// encounters a path created on Windows and vice-versa\n\t\t\tint takeFrom = isl.getSourceFile().getPath().lastIndexOf('/');\n\t\t\tif (takeFrom == -1) {\n\t\t\t\ttakeFrom = isl.getSourceFile().getPath().lastIndexOf('\\\\');\n\t\t\t}\n\t\t\tnice.append(isl.getSourceFile().getPath().substring(takeFrom + 1));\n\t\t\tif (isl.getLine() != 0) {\n\t\t\t\tnice.append(\":\").append(isl.getLine());\n\t\t\t}\n\t\t}\n\t\treturn nice.toString();\n\t}\n\n\tpublic static Instruction createSuperInvoke(InstructionFactory fact, BcelWorld world, Member signature) {\n\t\tshort kind;\n\t\tif (Modifier.isInterface(signature.getModifiers())) {\n\t\t\tthrow new RuntimeException(\"bad\");\n\t\t} else if (Modifier.isPrivate(signature.getModifiers()) || signature.getName().equals(\"<init>\")) {\n\t\t\tthrow new RuntimeException(\"unimplemented, possibly bad\");\n\t\t} else if (Modifier.isStatic(signature.getModifiers())) {\n\t\t\tthrow new RuntimeException(\"bad\");\n\t\t} else {\n\t\t\tkind = Constants.INVOKESPECIAL;\n\t\t}\n\n\t\treturn fact.createInvoke(signature.getDeclaringType().getName(), signature.getName(),\n\t\t\t\tBcelWorld.makeBcelType(signature.getReturnType()), BcelWorld.makeBcelTypes(signature.getParameterTypes()), kind);\n\t}\n\n\tpublic static Instruction createInvoke(InstructionFactory fact, BcelWorld world, Member signature) {\n\t\tshort kind;\n\t\tint signatureModifiers = signature.getModifiers();\n\t\tif (Modifier.isInterface(signatureModifiers)) {\n\t\t\tkind = Constants.INVOKEINTERFACE;\n\t\t} else if (Modifier.isStatic(signatureModifiers)) {\n\t\t\tkind = Constants.INVOKESTATIC;\n\t\t} else if (Modifier.isPrivate(signatureModifiers) || signature.getName().equals(\"<init>\")) {\n\t\t\tkind = Constants.INVOKESPECIAL;\n\t\t} else {\n\t\t\tkind = Constants.INVOKEVIRTUAL;\n\t\t}\n\n\t\tUnresolvedType targetType = signature.getDeclaringType();\n\t\tif (targetType.isParameterizedType()) {\n\t\t\ttargetType = targetType.resolve(world).getGenericType();\n\t\t}\n\t\treturn fact.createInvoke(targetType.getName(), signature.getName(), BcelWorld.makeBcelType(signature.getReturnType()),\n\t\t\t\tBcelWorld.makeBcelTypes(signature.getParameterTypes()), kind);\n\t}\n\n\tpublic static Instruction createGet(InstructionFactory fact, Member signature) {\n\t\tshort kind;\n\t\tif (Modifier.isStatic(signature.getModifiers())) {\n\t\t\tkind = Constants.GETSTATIC;\n\t\t} else {\n\t\t\tkind = Constants.GETFIELD;\n\t\t}\n\n\t\treturn fact.createFieldAccess(signature.getDeclaringType().getName(), signature.getName(),\n\t\t\t\tBcelWorld.makeBcelType(signature.getReturnType()), kind);\n\t}\n\n\tpublic static Instruction createSet(InstructionFactory fact, Member signature) {\n\t\tshort kind;\n\t\tif (Modifier.isStatic(signature.getModifiers())) {\n\t\t\tkind = Constants.PUTSTATIC;\n\t\t} else {\n\t\t\tkind = Constants.PUTFIELD;\n\t\t}\n\n\t\treturn fact.createFieldAccess(signature.getDeclaringType().getName(), signature.getName(),\n\t\t\t\tBcelWorld.makeBcelType(signature.getReturnType()), kind);\n\t}\n\n\tpublic static Instruction createInstanceof(InstructionFactory fact, ReferenceType t) {\n\t\tint cpoolEntry = (t instanceof ArrayType) ? fact.getConstantPool().addArrayClass((ArrayType) t) : fact.getConstantPool()\n\t\t\t\t.addClass((ObjectType) t);\n\t\treturn new InstructionCP(Constants.INSTANCEOF, cpoolEntry);\n\t}\n\n\tpublic static Instruction createInvoke(InstructionFactory fact, LazyMethodGen m) {\n\t\tshort kind;\n\t\tif (m.getEnclosingClass().isInterface()) {\n\t\t\tif (m.isStatic()) {\n\t\t\t\t// For static methods on interfaces\n\t\t\t\tkind = Constants.INVOKESTATIC;\n\t\t\t} else {\n\t\t\t\tkind = Constants.INVOKEINTERFACE;\n\t\t\t}\n\t\t} else if (m.isStatic()) {\n\t\t\tkind = Constants.INVOKESTATIC;\n\t\t} else if (m.isPrivate() || m.getName().equals(\"<init>\")) {\n\t\t\tkind = Constants.INVOKESPECIAL;\n\t\t} else {\n\t\t\tkind = Constants.INVOKEVIRTUAL;\n\t\t}\n\n\t\treturn fact.createInvoke(m.getClassName(), m.getName(), m.getReturnType(), m.getArgumentTypes(), kind, m.getEnclosingClass().isInterface());\n\t}\n\n\t/**\n\t * Create an invoke instruction\n\t *\n\t * @param fact\n\t * @param kind INVOKEINTERFACE, INVOKEVIRTUAL..\n\t * @param member\n\t * @return\n\t */\n\tpublic static Instruction createInvoke(InstructionFactory fact, short kind, Member member) {\n\t\treturn fact.createInvoke(member.getDeclaringType().getName(), member.getName(),\n\t\t\t\tBcelWorld.makeBcelType(member.getReturnType()), BcelWorld.makeBcelTypes(member.getParameterTypes()), kind);\n\t}\n\n\tprivate static String[] argNames = new String[] { \"arg0\", \"arg1\", \"arg2\", \"arg3\", \"arg4\" };\n\n\t// ??? these should perhaps be cached. Remember to profile this to see if\n\t// it's a problem.\n\tpublic static String[] makeArgNames(int n) {\n\t\tString[] ret = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < 5) {\n\t\t\t\tret[i] = argNames[i];\n\t\t\t} else {\n\t\t\t\tret[i] = \"arg\" + i;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// Lookup table, for converting between pairs of types, it gives\n\t// us the method name in the Conversions class\n\tprivate static Hashtable<String, String> validBoxing = new Hashtable<>();\n\n\tstatic {\n\t\tvalidBoxing.put(\"Ljava/lang/Byte;B\", \"byteObject\");\n\t\tvalidBoxing.put(\"Ljava/lang/Character;C\", \"charObject\");\n\t\tvalidBoxing.put(\"Ljava/lang/Double;D\", \"doubleObject\");\n\t\tvalidBoxing.put(\"Ljava/lang/Float;F\", \"floatObject\");\n\t\tvalidBoxing.put(\"Ljava/lang/Integer;I\", \"intObject\");\n\t\tvalidBoxing.put(\"Ljava/lang/Long;J\", \"longObject\");\n\t\tvalidBoxing.put(\"Ljava/lang/Short;S\", \"shortObject\");\n\t\tvalidBoxing.put(\"Ljava/lang/Boolean;Z\", \"booleanObject\");\n\t\tvalidBoxing.put(\"BLjava/lang/Byte;\", \"byteValue\");\n\t\tvalidBoxing.put(\"CLjava/lang/Character;\", \"charValue\");\n\t\tvalidBoxing.put(\"DLjava/lang/Double;\", \"doubleValue\");\n\t\tvalidBoxing.put(\"FLjava/lang/Float;\", \"floatValue\");\n\t\tvalidBoxing.put(\"ILjava/lang/Integer;\", \"intValue\");\n\t\tvalidBoxing.put(\"JLjava/lang/Long;\", \"longValue\");\n\t\tvalidBoxing.put(\"SLjava/lang/Short;\", \"shortValue\");\n\t\tvalidBoxing.put(\"ZLjava/lang/Boolean;\", \"booleanValue\");\n\t}\n\n\tpublic static void appendConversion(InstructionList il, InstructionFactory fact, ResolvedType fromType, ResolvedType toType) {\n\t\tif (!toType.isConvertableFrom(fromType) && !fromType.isConvertableFrom(toType)) {\n\t\t\tthrow new BCException(\"can't convert from \" + fromType + \" to \" + toType);\n\t\t}\n\t\t// XXX I'm sure this test can be simpler but my brain hurts and this works\n\t\tWorld w = toType.getWorld();\n\t\tif (w == null) { // dbg349636\n\t\t\tthrow new IllegalStateException(\"Debug349636: Unexpectedly found world null for type \" + toType.getName());\n\t\t}\n\n\t\tif (!w.isInJava5Mode()) {\n\t\t\tif (toType.needsNoConversionFrom(fromType)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (toType.needsNoConversionFrom(fromType) && !(toType.isPrimitiveType() ^ fromType.isPrimitiveType())) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (toType.equals(UnresolvedType.VOID)) {\n\t\t\t// assert fromType.equals(UnresolvedType.OBJECT)\n\t\t\til.append(InstructionFactory.createPop(fromType.getSize()));\n\t\t} else if (fromType.equals(UnresolvedType.VOID)) {\n\t\t\t// assert toType.equals(UnresolvedType.OBJECT)\n\t\t\til.append(InstructionFactory.createNull(Type.OBJECT));\n\t\t\treturn;\n\t\t} else if (fromType.equals(UnresolvedType.OBJECT)) {\n\t\t\tType to = BcelWorld.makeBcelType(toType);\n\t\t\tif (toType.isPrimitiveType()) {\n\t\t\t\tString name = toType.toString() + \"Value\";\n\t\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.internal.Conversions\", name, to, new Type[] { Type.OBJECT },\n\t\t\t\t\t\tConstants.INVOKESTATIC));\n\t\t\t} else {\n\t\t\t\til.append(fact.createCheckCast((ReferenceType) to));\n\t\t\t}\n\t\t} else if (toType.equals(UnresolvedType.OBJECT)) {\n\t\t\t// assert fromType.isPrimitive()\n\t\t\tType from = BcelWorld.makeBcelType(fromType);\n\t\t\tString name = fromType.toString() + \"Object\";\n\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.internal.Conversions\", name, Type.OBJECT, new Type[] { from },\n\t\t\t\t\tConstants.INVOKESTATIC));\n\t\t} else if (toType.getWorld().isInJava5Mode() && validBoxing.get(toType.getSignature() + fromType.getSignature()) != null) {\n\t\t\t// XXX could optimize by using any java boxing code that may be just\n\t\t\t// before the call...\n\t\t\tType from = BcelWorld.makeBcelType(fromType);\n\t\t\tType to = BcelWorld.makeBcelType(toType);\n\t\t\tString name = validBoxing.get(toType.getSignature() + fromType.getSignature());\n\t\t\tif (toType.isPrimitiveType()) {\n\t\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.internal.Conversions\", name, to, new Type[] { Type.OBJECT },\n\t\t\t\t\t\tConstants.INVOKESTATIC));\n\t\t\t} else {\n\t\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.internal.Conversions\", name, Type.OBJECT, new Type[] { from },\n\t\t\t\t\t\tConstants.INVOKESTATIC));\n\t\t\t\til.append(fact.createCheckCast((ReferenceType) to));\n\t\t\t}\n\t\t} else if (fromType.isPrimitiveType()) {\n\t\t\t// assert toType.isPrimitive()\n\t\t\tType from = BcelWorld.makeBcelType(fromType);\n\t\t\tType to = BcelWorld.makeBcelType(toType);\n\t\t\ttry {\n\t\t\t\tInstruction i = fact.createCast(from, to);\n\t\t\t\tif (i != null) {\n\t\t\t\t\til.append(i);\n\t\t\t\t} else {\n\t\t\t\t\til.append(fact.createCast(from, Type.INT));\n\t\t\t\t\til.append(fact.createCast(Type.INT, to));\n\t\t\t\t}\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\til.append(fact.createCast(from, Type.INT));\n\t\t\t\til.append(fact.createCast(Type.INT, to));\n\t\t\t}\n\t\t} else {\n\t\t\tType to = BcelWorld.makeBcelType(toType);\n\t\t\t// assert ! fromType.isPrimitive() && ! toType.isPrimitive()\n\t\t\til.append(fact.createCheckCast((ReferenceType) to));\n\t\t}\n\t}\n\n\tpublic static InstructionList createConversion(InstructionFactory factory, Type fromType, Type toType) {\n\t\treturn createConversion(factory, fromType, toType, false);\n\t}\n\n\tpublic static InstructionList createConversion(InstructionFactory fact, Type fromType, Type toType, boolean allowAutoboxing) {\n\t\t// System.out.println(\"cast to: \" + toType);\n\n\t\tInstructionList il = new InstructionList();\n\n\t\t// PR71273\n\t\tif ((fromType.equals(Type.BYTE) || fromType.equals(Type.CHAR) || fromType.equals(Type.SHORT)) && (toType.equals(Type.INT))) {\n\t\t\treturn il;\n\t\t}\n\n\t\tif (fromType.equals(toType)) {\n\t\t\treturn il;\n\t\t}\n\t\tif (toType.equals(Type.VOID)) {\n\t\t\til.append(InstructionFactory.createPop(fromType.getSize()));\n\t\t\treturn il;\n\t\t}\n\n\t\tif (fromType.equals(Type.VOID)) {\n\t\t\tif (toType instanceof BasicType) {\n\t\t\t\tthrow new BCException(\"attempting to cast from void to basic type\");\n\t\t\t}\n\t\t\til.append(InstructionFactory.createNull(Type.OBJECT));\n\t\t\treturn il;\n\t\t}\n\n\t\tif (fromType.equals(Type.OBJECT)) {\n\t\t\tif (toType instanceof BasicType) {\n\t\t\t\tString name = toType.toString() + \"Value\";\n\t\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.internal.Conversions\", name, toType, new Type[] { Type.OBJECT },\n\t\t\t\t\t\tConstants.INVOKESTATIC));\n\t\t\t\treturn il;\n\t\t\t}\n\t\t}\n\n\t\tif (toType.equals(Type.OBJECT)) {\n\t\t\tif (fromType instanceof BasicType) {\n\t\t\t\tString name = fromType.toString() + \"Object\";\n\t\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.internal.Conversions\", name, Type.OBJECT, new Type[] { fromType },\n\t\t\t\t\t\tConstants.INVOKESTATIC));\n\t\t\t\treturn il;\n\t\t\t} else if (fromType instanceof ReferenceType) {\n\t\t\t\treturn il;\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\n\t\tif (fromType instanceof ReferenceType && ((ReferenceType) fromType).isAssignmentCompatibleWith(toType)) {\n\t\t\treturn il;\n\t\t}\n\n\t\tif (allowAutoboxing) {\n\t\t\tif (toType instanceof BasicType && fromType instanceof ReferenceType) {\n\t\t\t\t// unboxing\n\t\t\t\tString name = toType.toString() + \"Value\";\n\t\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.internal.Conversions\", name, toType, new Type[] { Type.OBJECT },\n\t\t\t\t\t\tConstants.INVOKESTATIC));\n\t\t\t\treturn il;\n\t\t\t}\n\n\t\t\tif (fromType instanceof BasicType && toType instanceof ReferenceType) {\n\t\t\t\t// boxing\n\t\t\t\tString name = fromType.toString() + \"Object\";\n\t\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.internal.Conversions\", name, Type.OBJECT, new Type[] { fromType },\n\t\t\t\t\t\tConstants.INVOKESTATIC));\n\t\t\t\til.append(fact.createCast(Type.OBJECT, toType));\n\t\t\t\treturn il;\n\t\t\t}\n\t\t}\n\n\t\til.append(fact.createCast(fromType, toType));\n\t\treturn il;\n\t}\n\n\tpublic static Instruction createConstant(InstructionFactory fact, int value) {\n\t\tInstruction inst;\n\t\tswitch (value) {\n\t\tcase -1:\n\t\t\tinst = InstructionConstants.ICONST_M1;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tinst = InstructionConstants.ICONST_0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tinst = InstructionConstants.ICONST_1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tinst = InstructionConstants.ICONST_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tinst = InstructionConstants.ICONST_3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tinst = InstructionConstants.ICONST_4;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tinst = InstructionConstants.ICONST_5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (value <= Byte.MAX_VALUE && value >= Byte.MIN_VALUE) {\n\t\t\t\tinst = new InstructionByte(Constants.BIPUSH, (byte) value);\n\t\t\t} else if (value <= Short.MAX_VALUE && value >= Short.MIN_VALUE) {\n\t\t\t\tinst = new InstructionShort(Constants.SIPUSH, (short) value);\n\t\t\t} else {\n\t\t\t\tint ii = fact.getClassGen().getConstantPool().addInteger(value);\n\t\t\t\tinst = new InstructionCP(value <= Constants.MAX_BYTE ? Constants.LDC : Constants.LDC_W, ii);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn inst;\n\t}\n\n\t/** For testing purposes: bit clunky but does work */\n\tpublic static int testingParseCounter = 0;\n\n\tpublic static JavaClass makeJavaClass(String filename, byte[] bytes) {\n\t\ttry {\n\t\t\ttestingParseCounter++;\n\t\t\tClassParser parser = new ClassParser(new ByteArrayInputStream(bytes), filename);\n\t\t\treturn parser.parse();\n\t\t} catch (IOException e) {\n\t\t\tthrow new BCException(\"malformed class file\");\n\t\t}\n\t}\n\n\t/**\n\t * replace an instruction handle with another instruction, in this case, a branch instruction.\n\t *\n\t * @param ih the instruction handle to replace.\n\t * @param replacementInstructions the branch instruction to replace ih with\n\t * @param enclosingMethod where to find ih's instruction list.\n\t */\n\tpublic static void replaceInstruction(InstructionHandle ih, InstructionList replacementInstructions,\n\t\t\tLazyMethodGen enclosingMethod) {\n\t\tInstructionList il = enclosingMethod.getBody();\n\t\tInstructionHandle fresh = il.append(ih, replacementInstructions);\n\t\tdeleteInstruction(ih, fresh, enclosingMethod);\n\t}\n\n\t/**\n\t * delete an instruction handle and retarget all targeters of the deleted instruction to the next instruction. Obviously, this\n\t * should not be used to delete a control transfer instruction unless you know what you're doing.\n\t *\n\t * @param ih the instruction handle to delete.\n\t * @param enclosingMethod where to find ih's instruction list.\n\t */\n\tpublic static void deleteInstruction(InstructionHandle ih, LazyMethodGen enclosingMethod) {\n\t\tdeleteInstruction(ih, ih.getNext(), enclosingMethod);\n\t}\n\n\t/**\n\t * delete an instruction handle and retarget all targeters of the deleted instruction to the provided target.\n\t *\n\t * @param ih the instruction handle to delete\n\t * @param retargetTo the instruction handle to retarget targeters of ih to.\n\t * @param enclosingMethod where to find ih's instruction list.\n\t */\n\tpublic static void deleteInstruction(InstructionHandle ih, InstructionHandle retargetTo, LazyMethodGen enclosingMethod) {\n\t\tInstructionList il = enclosingMethod.getBody();\n\t\tfor (InstructionTargeter targeter : ih.getTargetersCopy()) {\n\t\t\ttargeter.updateTarget(ih, retargetTo);\n\t\t}\n\t\tih.removeAllTargeters();\n\t\ttry {\n\t\t\til.delete(ih);\n\t\t} catch (TargetLostException e) {\n\t\t\tthrow new BCException(\"this really can't happen\");\n\t\t}\n\t}\n\n\t/**\n\t * Fix for Bugzilla #39479, #40109 patch contributed by Andy Clement\n\t *\n\t * Need to manually copy Select instructions - if we rely on the the 'fresh' object created by copy(), the InstructionHandle\n\t * array 'targets' inside the Select object will not have been deep copied, so modifying targets in fresh will modify the\n\t * original Select - not what we want ! (It is a bug in BCEL to do with cloning Select objects).\n\t *\n\t * <pre>\n\t * declare error:\n\t *     call(* Instruction.copy()) &amp;&amp; within(org.aspectj.weaver)\n\t *       &amp;&amp; !withincode(* Utility.copyInstruction(Instruction)):\n\t *     &quot;use Utility.copyInstruction to work-around bug in Select.copy()&quot;;\n\t * </pre>\n\t */\n\tpublic static Instruction copyInstruction(Instruction i) {\n\t\tif (i instanceof InstructionSelect) {\n\t\t\tInstructionSelect freshSelect = (InstructionSelect) i;\n\n\t\t\t// Create a new targets array that looks just like the existing one\n\t\t\tInstructionHandle[] targets = new InstructionHandle[freshSelect.getTargets().length];\n\t\t\tfor (int ii = 0; ii < targets.length; ii++) {\n\t\t\t\ttargets[ii] = freshSelect.getTargets()[ii];\n\t\t\t}\n\n\t\t\t// Create a new select statement with the new targets array\n\n\t\t\treturn new SwitchBuilder(freshSelect.getMatchs(), targets, freshSelect.getTarget()).getInstruction();\n\t\t} else {\n\t\t\treturn i.copy(); // Use clone for shallow copy...\n\t\t}\n\t}\n\n\t/** returns -1 if no source line attribute */\n\t// this naive version overruns the JVM stack size, if only Java understood\n\t// tail recursion...\n\t// public static int getSourceLine(InstructionHandle ih) {\n\t// if (ih == null) return -1;\n\t//\n\t// InstructionTargeter[] ts = ih.getTargeters();\n\t// if (ts != null) {\n\t// for (int j = ts.length - 1; j >= 0; j--) {\n\t// InstructionTargeter t = ts[j];\n\t// if (t instanceof LineNumberTag) {\n\t// return ((LineNumberTag)t).getLineNumber();\n\t// }\n\t// }\n\t// }\n\t// return getSourceLine(ih.getNext());\n\t// }\n\tpublic static int getSourceLine(InstructionHandle ih) {// ,boolean\n\t\t// goforwards) {\n\t\tint lookahead = 0;\n\t\t// arbitrary rule that we will never lookahead more than 100\n\t\t// instructions for a line #\n\t\twhile (lookahead++ < 100) {\n\t\t\tif (ih == null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (InstructionTargeter t : ih.getTargeters()) {\n\t\t\t\tif (t instanceof LineNumberTag) {\n\t\t\t\t\treturn ((LineNumberTag) t).getLineNumber();\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if (goforwards) ih=ih.getNext(); else\n\t\t\tih = ih.getPrev();\n\t\t}\n\t\t// System.err.println(\"no line information available for: \" + ih);\n\t\treturn -1;\n\t}\n\n\t// public static int getSourceLine(InstructionHandle ih) {\n\t// return getSourceLine(ih,false);\n\t// }\n\n\t// assumes that there is no already extant source line tag. Otherwise we'll\n\t// have to be better.\n\tpublic static void setSourceLine(InstructionHandle ih, int lineNumber) {\n\t\t// OPTIMIZE LineNumberTag instances for the same line could be shared\n\t\t// throughout a method...\n\t\tih.addTargeter(new LineNumberTag(lineNumber));\n\t}\n\n\tpublic static int makePublic(int i) {\n\t\treturn i & ~(Modifier.PROTECTED | Modifier.PRIVATE) | Modifier.PUBLIC;\n\t}\n\n\tpublic static BcelVar[] pushAndReturnArrayOfVars(ResolvedType[] proceedParamTypes, InstructionList il, InstructionFactory fact,\n\t\t\tLazyMethodGen enclosingMethod) {\n\t\tint len = proceedParamTypes.length;\n\t\tBcelVar[] ret = new BcelVar[len];\n\n\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\tResolvedType typeX = proceedParamTypes[i];\n\t\t\tType type = BcelWorld.makeBcelType(typeX);\n\t\t\tint local = enclosingMethod.allocateLocal(type);\n\n\t\t\til.append(InstructionFactory.createStore(type, local));\n\t\t\tret[i] = new BcelVar(typeX, local);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static boolean isConstantPushInstruction(Instruction i) {\n\t\tlong ii = Constants.instFlags[i.opcode];\n\t\treturn ((ii & Constants.PUSH_INST) != 0 && (ii & Constants.CONSTANT_INST) != 0);\n\t}\n\n\t/**\n\t * Checks for suppression specified on the member or on the declaring type of that member\n\t */\n\tpublic static boolean isSuppressing(Member member, String lintkey) {\n\t\tboolean isSuppressing = Utils.isSuppressing(member.getAnnotations(), lintkey);\n\t\tif (isSuppressing) {\n\t\t\treturn true;\n\t\t}\n\t\tUnresolvedType type = member.getDeclaringType();\n\t\tif (type instanceof ResolvedType) {\n\t\t\treturn Utils.isSuppressing(((ResolvedType) type).getAnnotations(), lintkey);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static List<Lint.Kind> getSuppressedWarnings(AnnotationAJ[] anns, Lint lint) {\n\t\tif (anns == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\t// Go through the annotation types\n\t\tList<Lint.Kind> suppressedWarnings = new ArrayList<>();\n\t\tboolean found = false;\n\t\tfor (int i = 0; !found && i < anns.length; i++) {\n\t\t\t// Check for the SuppressAjWarnings annotation\n\t\t\tif (UnresolvedType.SUPPRESS_AJ_WARNINGS.getSignature().equals(\n\t\t\t\t\t((BcelAnnotation) anns[i]).getBcelAnnotation().getTypeSignature())) {\n\t\t\t\tfound = true;\n\t\t\t\t// Two possibilities:\n\t\t\t\t// 1. there are no values specified (i.e. @SuppressAjWarnings)\n\t\t\t\t// 2. there are values specified (i.e. @SuppressAjWarnings(\"A\")\n\t\t\t\t// or @SuppressAjWarnings({\"A\",\"B\"})\n\t\t\t\tList<NameValuePair> vals = ((BcelAnnotation) anns[i]).getBcelAnnotation().getValues();\n\t\t\t\tif (vals == null || vals.isEmpty()) { // (1)\n\t\t\t\t\tsuppressedWarnings.addAll(lint.allKinds());\n\t\t\t\t} else { // (2)\n\t\t\t\t\t// We know the value is an array value\n\t\t\t\t\tArrayElementValue array = (ArrayElementValue) (vals.get(0)).getValue();\n\t\t\t\t\tElementValue[] values = array.getElementValuesArray();\n\t\t\t\t\tfor (ElementValue elementValue : values) {\n\t\t\t\t\t\t// We know values in the array are strings\n\t\t\t\t\t\tSimpleElementValue value = (SimpleElementValue) elementValue;\n\t\t\t\t\t\tLint.Kind lintKind = lint.getLintKind(value.getValueString());\n\t\t\t\t\t\tif (lintKind != null) {\n\t\t\t\t\t\t\tsuppressedWarnings.add(lintKind);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn suppressedWarnings;\n\t}\n\n\t// not yet used...\n\t// public static boolean isSimple(Method method) {\n\t// if (method.getCode()==null) return true;\n\t// if (method.getCode().getCode().length>10) return false;\n\t// InstructionList instrucs = new\n\t// InstructionList(method.getCode().getCode()); // expensive!\n\t// InstructionHandle InstrHandle = instrucs.getStart();\n\t// while (InstrHandle != null) {\n\t// Instruction Instr = InstrHandle.getInstruction();\n\t// int opCode = Instr.opcode;\n\t// // if current instruction is a branch instruction, see if it's a backward\n\t// branch.\n\t// // if it is return immediately (can't be trivial)\n\t// if (Instr instanceof InstructionBranch) {\n\t// // InstructionBranch BI = (InstructionBranch) Instr;\n\t// if (Instr.getIndex() < 0) return false;\n\t// } else if (Instr instanceof InvokeInstruction) {\n\t// // if current instruction is an invocation, indicate that it can't be\n\t// trivial\n\t// return false;\n\t// }\n\t// InstrHandle = InstrHandle.getNext();\n\t// }\n\t// return true;\n\t// }\n\n\tpublic static Attribute bcelAttribute(AjAttribute a, ConstantPool pool) {\n\t\tint nameIndex = pool.addUtf8(a.getNameString());\n\t\tbyte[] bytes = a.getBytes(new BcelConstantPoolWriter(pool));\n\t\tint length = bytes.length;\n\n\t\treturn new Unknown(nameIndex, length, bytes, pool);\n\t}\n}\n",
    "size": 27007
  },
  {
    "file_id": "F44",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/asm/AsmDetector.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *\t Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.bcel.asm;\n\n/**\n * Determines if a version of asm is around that will enable us to add stack map attributes to classes that we produce.\n *\n * @author Andy Clement\n */\npublic class AsmDetector {\n\tpublic static final String CLASS_READER = \"org.objectweb.asm.ClassReader\";\n\tpublic static final String CLASS_VISITOR = \"org.objectweb.asm.ClassVisitor\";\n\tpublic static boolean isAsmAround;\n\tpublic static Throwable rootCause;\n\n\tstatic {\n\t\ttry {\n\t\t\tClass<?> reader = Class.forName(CLASS_READER);\n\t\t\tClass<?> visitor = Class.forName(CLASS_VISITOR);\n\t\t\treader.getMethod(\"accept\", visitor, Integer.TYPE);\n\t\t\tisAsmAround = true;\n\t\t} catch (Exception e) {\n\t\t\tisAsmAround = false;\n\t\t\trootCause = e;\n\t\t}\n\t\t//System.out.println(isAsmAround ? \"ASM detected\" : \"No ASM found\");\n\t}\n}\n",
    "size": 1271
  },
  {
    "file_id": "F45",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/bcel/asm/StackMapAdder.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008, 2018 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *\t Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.bcel.asm;\n\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\n\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\n\n/**\n * Uses asm to add the stack map attribute to methods in a class. The class is passed in as pure byte data and then a reader/writer\n * process it. The writer is wired into the world so that types can be resolved and getCommonSuperClass() can be implemented without\n * class loading using the context class loader.\n *\n * It is important that the constant pool is preserved here and asm does not try to remove unused entries.  That is because some\n * entries are refered to from classfile attributes.  Asm cannot see into these attributes so does not realise the constant pool\n * entries are in use.  In order to ensure the copying of cp occurs, we use the variant super constructor call in AspectJConnectClassWriter\n * that passes in the classreader.  However, ordinarily that change causes a further optimization: that if a classreader sees\n * a methodvisitor that has been created by a ClassWriter then it just copies the data across without changing it (and so it\n * fails to attach the stackmapattribute).  In order to avoid this further optimization we use our own minimal MethodVisitor.\n *\n * @author Andy Clement\n */\npublic class StackMapAdder {\n\n\tpublic static byte[] addStackMaps(World world, String classname, byte[] data) {\n\t\ttry {\n\t\t\tClassReader cr = new ClassReader(data);\n\t\t\tClassWriter cw = new AspectJConnectClassWriter(cr, world);\n\t\t\tClassVisitor cv = new AspectJClassVisitor(cw);\n\t\t\tcr.accept(cv, 0);\n\t\t\treturn cw.toByteArray();\n\t\t} catch (Throwable t) {\n\t\t\t// If in here fixing an error about version, change the ASMX in class above!\n\t\t\tSystem.err.println(\"AspectJ Internal Error: unable to add stackmap attributes to class '\"+classname+\"'. \" + t.getMessage());\n\t\t\tt.printStackTrace();\n\t\t\tAsmDetector.isAsmAround = false;\n\t\t\tAsmDetector.rootCause = t;\n\t\t\treturn data;\n\t\t}\n\t}\n\n\tprivate static class AspectJClassVisitor extends ClassVisitor {\n\n\t\tpublic AspectJClassVisitor(ClassVisitor classwriter) {\n\t\t\tsuper(Opcodes.ASM9, classwriter);\n\t\t}\n\n\t\t@Override\n\t\tpublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n\t\t\tMethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n\t\t\treturn new AJMethodVisitor(mv);\n\t\t}\n\n\t\t// Minimal pass through MethodVisitor just so that the ClassReader doesn't see one that has been directly\n\t\t// created by a ClassWriter (see top level class comment)\n\t\tstatic class AJMethodVisitor extends MethodVisitor {\n\t\t\tpublic AJMethodVisitor(MethodVisitor mv) {\n\t\t\t\tsuper(Opcodes.ASM9,mv);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate static class AspectJConnectClassWriter extends ClassWriter {\n\t\tprivate final World world;\n\n\t\tpublic AspectJConnectClassWriter(ClassReader cr, World w) {\n\t\t\tsuper(cr, ClassWriter.COMPUTE_FRAMES); // passing in cr is necessary so cpool isnt modified (see 2.2.4 of asm doc)\n\t\t\tthis.world = w;\n\t\t}\n\n\n\t\t// Implementation of getCommonSuperClass() that avoids Class.forName()\n\t\t@Override\n\t\tprotected String getCommonSuperClass(final String type1, final String type2) {\n\n\t\t\tResolvedType resolvedType1 = world.resolve(UnresolvedType.forName(type1.replace('/', '.')));\n\t\t\tResolvedType resolvedType2 = world.resolve(UnresolvedType.forName(type2.replace('/', '.')));\n\n\t\t\tif (resolvedType1.isAssignableFrom(resolvedType2)) {\n\t\t\t\treturn type1;\n\t\t\t}\n\n\t\t\tif (resolvedType2.isAssignableFrom(resolvedType1)) {\n\t\t\t\treturn type2;\n\t\t\t}\n\n\t\t\tif (resolvedType1.isInterface() || resolvedType2.isInterface()) {\n\t\t\t\treturn \"java/lang/Object\";\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tresolvedType1 = resolvedType1.getSuperclass();\n\t\t\t\t\tif (resolvedType1 == null) {\n\t\t\t\t\t\t// This happens if some types are missing, the getSuperclass() call on\n\t\t\t\t\t\t// MissingResolvedTypeWithKnownSignature will return the Missing type which\n\t\t\t\t\t\t// in turn returns a superclass of null. By returning Object here it\n\t\t\t\t\t\t// should surface the cantFindType message raised in the first problematic\n\t\t\t\t\t\t// getSuperclass call\n\t\t\t\t\t\treturn \"java/lang/Object\";\n\t\t\t\t\t}\n\t\t\t\t\tif (resolvedType1.isParameterizedOrGenericType()) {\n\t\t\t\t\t\tresolvedType1 = resolvedType1.getRawType();\n\t\t\t\t\t}\n\t\t\t\t} while (!resolvedType1.isAssignableFrom(resolvedType2));\n\t\t\t\treturn resolvedType1.getRawName().replace('.', '/');\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "size": 5015
  },
  {
    "file_id": "F46",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/loadtime/IWeavingContext.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   David Knibb         initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver.loadtime;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.List;\n\nimport org.aspectj.weaver.loadtime.definition.Definition;\nimport org.aspectj.weaver.tools.WeavingAdaptor;\n\n/**\n * This class adds support to AspectJ for an OSGi environment\n *\n * @author David Knibb\n */\npublic interface IWeavingContext {\n\n\t/**\n\t * Allows the standard ClassLoader.getResources() mechanisms to be\n\t * replaced with a different implementation.\n\t * In an OSGi environment, this will allow for filtering to take\n\t * place on the results of ClassLoader.getResources(). In a non-OSGi\n\t * environment, ClassLoader.getResources should be returned.\n\t * @param name the name of the resource to search for\n\t * @return an enumeration containing all of the matching resources found\n\t * @throws IOException\n\t */\n\tEnumeration<URL> getResources(String name) throws IOException;\n\n\t/**\n\t * In an OSGi environment, determine which bundle a URL originated from.\n\t * In a non-OSGi environment, implementors should return <code>null</code>.\n\t * @param url\n\t * @return\n\t * @deprecated use getFile() or getClassLoaderName()\n\t */\n\tString getBundleIdFromURL(URL url);\n\n\t/**\n\t * In an environment with multiple class loaders allows each to be\n\t * identified using something safer and possibly shorter than toString\n\t * @return name of the associated class loader\n\t */\n\tString getClassLoaderName();\n\n    ClassLoader getClassLoader();\n\n\t/**\n\t * Format a URL\n\t * @return filename\n\t */\n\tString getFile(URL url);\n\n\t/**\n\t * In an environment with multiple class loaders allows messages\n\t * to identified according to the weaving context\n\t * @return short name\n\t */\n\tString getId();\n\n\t/**\n\t * Return true if the classloader associated with this weaving context\n\t * is the one that will define the class with the specified name.\n\t * In a delegating classloader hierarchy this might check the parent won't\n\t * define it and the child will - in OSGi it will do something else.\n\t * @param classname name of the class, eg. \"java.lang.String\"\n\t * @return true if the associated classloader will define the class\n\t */\n\tboolean isLocallyDefined(String classname);\n\n\t/**\n\t * Allow custom parsing of aop.xml or alternative mechanism for providing\n\t * Definitions\n\t *\n\t * @param loader\n\t * @param adaptor\n\t * @return List containing 0 or more Definition instances\n\t */\n\tList<Definition> getDefinitions(final ClassLoader loader, WeavingAdaptor adaptor);\n\n}\n",
    "size": 3000
  },
  {
    "file_id": "F47",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/loadtime/definition/Definition.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Alexandre Vasseur         initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver.loadtime.definition;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * A POJO that contains raw strings from the XML (sort of XMLBean for our simple LTW DTD)\n *\n * @author Alexandre Vasseur (alex AT gnilux DOT com)\n */\npublic class Definition {\n\n\tprivate final StringBuffer weaverOptions;\n\tprivate final List<String> dumpPatterns;\n\tprivate boolean dumpBefore;\n\tprivate boolean perClassloaderDumpDir;\n\tprivate final List<String> includePatterns;\n\tprivate final List<String> excludePatterns;\n\tprivate final List<String> aspectClassNames;\n\tprivate final List<String> aspectExcludePatterns;\n\tprivate final List<String> aspectIncludePatterns;\n\tprivate final List<Definition.ConcreteAspect> concreteAspects;\n\n\t/**\n\t * When aspects are defined, they can specify a scope type pattern and then will only apply to types matching that pattern.\n\t */\n\tprivate final Map<String, String> scopedAspects;\n\n\t/**\n\t * Some aspects (from aspect libraries) will describe a type that must be around for them to function properly\n\t */\n\tprivate final Map<String, String> requiredTypesForAspects;\n\n\tpublic Definition() {\n\t\tweaverOptions = new StringBuffer();\n\t\tdumpBefore = false;\n\t\tperClassloaderDumpDir = false;\n\t\tdumpPatterns = new ArrayList<>();\n\t\tincludePatterns = new ArrayList<>();\n\t\texcludePatterns = new ArrayList<>();\n\t\taspectClassNames = new ArrayList<>();\n\t\taspectExcludePatterns = new ArrayList<>();\n\t\taspectIncludePatterns = new ArrayList<>();\n\t\tconcreteAspects = new ArrayList<>();\n\t\tscopedAspects = new HashMap<>();\n\t\trequiredTypesForAspects = new HashMap<>();\n\t}\n\n\tpublic String getWeaverOptions() {\n\t\treturn weaverOptions.toString();\n\t}\n\n\tpublic List<String> getDumpPatterns() {\n\t\treturn dumpPatterns;\n\t}\n\n\tpublic void setDumpBefore(boolean b) {\n\t\tdumpBefore = b;\n\t}\n\n\tpublic boolean shouldDumpBefore() {\n\t\treturn dumpBefore;\n\t}\n\n\tpublic void setCreateDumpDirPerClassloader(boolean b) {\n\t\tperClassloaderDumpDir = b;\n\t}\n\n\tpublic boolean createDumpDirPerClassloader() {\n\t\treturn perClassloaderDumpDir;\n\t}\n\n\tpublic List<String> getIncludePatterns() {\n\t\treturn includePatterns;\n\t}\n\n\tpublic List<String> getExcludePatterns() {\n\t\treturn excludePatterns;\n\t}\n\n\tpublic List<String> getAspectClassNames() {\n\t\treturn aspectClassNames;\n\t}\n\n\tpublic List<String> getAspectExcludePatterns() {\n\t\treturn aspectExcludePatterns;\n\t}\n\n\tpublic List<String> getAspectIncludePatterns() {\n\t\treturn aspectIncludePatterns;\n\t}\n\n\tpublic List<Definition.ConcreteAspect> getConcreteAspects() {\n\t\treturn concreteAspects;\n\t}\n\n\tpublic static class ConcreteAspect {\n\t\tpublic final String name;\n\t\tpublic final String extend;\n\t\tpublic final String precedence;\n\t\tpublic final List<Definition.Pointcut> pointcuts;\n\t\tpublic final List<Definition.DeclareAnnotation> declareAnnotations;\n\t\tpublic final List<Definition.PointcutAndAdvice> pointcutsAndAdvice;\n\t\tpublic final String perclause;\n\t\tpublic List<Definition.DeclareErrorOrWarning> deows;\n\n\t\tpublic ConcreteAspect(String name, String extend) {\n\t\t\tthis(name, extend, null, null);\n\t\t}\n\n\t\tpublic ConcreteAspect(String name, String extend, String precedence, String perclause) {\n\t\t\tthis.name = name;\n\t\t\t// make sure extend set to null if \"\"\n\t\t\tif (extend == null || extend.length() == 0) {\n\t\t\t\tthis.extend = null;\n\t\t\t\tif (precedence == null || precedence.length() == 0) {\n\t\t\t\t\t// if (pointcutsAndAdvice.size() == 0) {\n\t\t\t\t\t// throw new RuntimeException(\"Not allowed\");\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.extend = extend;\n\t\t\t}\n\t\t\tthis.precedence = precedence;\n\t\t\tthis.pointcuts = new ArrayList<>();\n\t\t\tthis.declareAnnotations = new ArrayList<>();\n\t\t\tthis.pointcutsAndAdvice = new ArrayList<>();\n\t\t\tthis.deows = new ArrayList<>();\n\t\t\tthis.perclause = perclause;\n\t\t}\n\t}\n\n\tpublic static class Pointcut {\n\t\tpublic final String name;\n\t\tpublic final String expression;\n\n\t\tpublic Pointcut(String name, String expression) {\n\t\t\tthis.name = name;\n\t\t\tthis.expression = expression;\n\t\t}\n\t}\n\n\tpublic enum AdviceKind {\n\t\tBefore, After, AfterReturning, AfterThrowing, Around;\n\t}\n\n\tpublic enum DeclareAnnotationKind {\n\t\tMethod, Field, Type;\n\t}\n\n\tpublic static class DeclareAnnotation {\n\t\tpublic final DeclareAnnotationKind declareAnnotationKind;\n\t\tpublic final String pattern;\n\t\tpublic final String annotation;\n\n\t\tpublic DeclareAnnotation(DeclareAnnotationKind kind, String pattern, String annotation) {\n\t\t\tthis.declareAnnotationKind = kind;\n\t\t\tthis.pattern = pattern;\n\t\t\tthis.annotation = annotation;\n\t\t}\n\t}\n\n\tpublic static class PointcutAndAdvice {\n\t\tpublic final AdviceKind adviceKind;\n\t\tpublic final String pointcut;\n\t\tpublic final String adviceClass; // com.foo.Bar\n\t\tpublic final String adviceMethod; // foo(java.lang.String,org.aspectj.lang.JoinPoint)\n\n\t\tpublic PointcutAndAdvice(AdviceKind adviceKind, String pointcut, String adviceClass, String adviceMethod) {\n\t\t\tthis.adviceKind = adviceKind;\n\t\t\tthis.pointcut = pointcut;\n\t\t\tthis.adviceClass = adviceClass;\n\t\t\tthis.adviceMethod = adviceMethod;\n\t\t}\n\t}\n\n\tpublic static class DeclareErrorOrWarning {\n\t\tpublic final boolean isError;\n\t\tpublic final String pointcut;\n\t\tpublic final String message;\n\n\t\tpublic DeclareErrorOrWarning(boolean isError, String pointcut, String message) {\n\t\t\tthis.isError = isError;\n\t\t\tthis.pointcut = pointcut;\n\t\t\tthis.message = message;\n\t\t}\n\t}\n\n\tpublic void appendWeaverOptions(String option) {\n\t\tweaverOptions.append(option.trim()).append(' ');\n\t}\n\n\tpublic void addScopedAspect(String name, String scopePattern) {\n\t\tscopedAspects.put(name, scopePattern);\n\t}\n\n\tpublic String getScopeForAspect(String name) {\n\t\treturn scopedAspects.get(name);\n\t}\n\n\tpublic void setAspectRequires(String name, String requiredType) {\n\t\trequiredTypesForAspects.put(name, requiredType);\n\t}\n\n\tpublic String getAspectRequires(String name) {\n\t\treturn requiredTypesForAspects.get(name);\n\t}\n\n}\n",
    "size": 6357
  },
  {
    "file_id": "F48",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/loadtime/definition/DocumentParser.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Alexandre Vasseur         initial implementation\n *   Abraham Nevado - Lucierna simple caching strategy\n *******************************************************************************/\npackage org.aspectj.weaver.loadtime.definition;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Hashtable;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.loadtime.definition.Definition.AdviceKind;\nimport org.aspectj.weaver.loadtime.definition.Definition.DeclareAnnotationKind;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n *\n * @author Alexandre Vasseur\n * @author A. Nevado\n * @author Andy Clement\n */\npublic class DocumentParser extends DefaultHandler {\n\t/**\n\t * The current DTD public id. The matching dtd will be searched as a resource.\n\t */\n\tprivate final static String DTD_PUBLIC_ID = \"-//AspectJ//DTD 1.5.0//EN\";\n\n\t/**\n\t * The DTD alias, for better user experience.\n\t */\n\tprivate final static String DTD_PUBLIC_ID_ALIAS = \"-//AspectJ//DTD//EN\";\n\n\tprivate final static String ASPECTJ_ELEMENT = \"aspectj\";\n\tprivate final static String WEAVER_ELEMENT = \"weaver\";\n\tprivate final static String DUMP_ELEMENT = \"dump\";\n\tprivate final static String DUMP_BEFOREANDAFTER_ATTRIBUTE = \"beforeandafter\";\n\tprivate final static String DUMP_PERCLASSLOADERDIR_ATTRIBUTE = \"perclassloaderdumpdir\";\n\tprivate final static String INCLUDE_ELEMENT = \"include\";\n\tprivate final static String EXCLUDE_ELEMENT = \"exclude\";\n\tprivate final static String OPTIONS_ATTRIBUTE = \"options\";\n\tprivate final static String ASPECTS_ELEMENT = \"aspects\";\n\tprivate final static String ASPECT_ELEMENT = \"aspect\";\n\tprivate final static String CONCRETE_ASPECT_ELEMENT = \"concrete-aspect\";\n\tprivate final static String NAME_ATTRIBUTE = \"name\";\n\tprivate final static String SCOPE_ATTRIBUTE = \"scope\";\n\tprivate final static String REQUIRES_ATTRIBUTE = \"requires\";\n\tprivate final static String EXTEND_ATTRIBUTE = \"extends\";\n\tprivate final static String PRECEDENCE_ATTRIBUTE = \"precedence\";\n\tprivate final static String PERCLAUSE_ATTRIBUTE = \"perclause\";\n\tprivate final static String POINTCUT_ELEMENT = \"pointcut\";\n\tprivate final static String BEFORE_ELEMENT = \"before\";\n\tprivate final static String AFTER_ELEMENT = \"after\";\n\tprivate final static String AFTER_RETURNING_ELEMENT = \"after-returning\";\n\tprivate final static String AFTER_THROWING_ELEMENT = \"after-throwing\";\n\tprivate final static String AROUND_ELEMENT = \"around\";\n\tprivate final static String WITHIN_ATTRIBUTE = \"within\";\n\tprivate final static String EXPRESSION_ATTRIBUTE = \"expression\";\n\tprivate final static String DECLARE_ANNOTATION_ELEMENT = \"declare-annotation\";\n\n\tprivate final Definition definition;\n\n\tprivate boolean inAspectJ;\n\tprivate boolean inWeaver;\n\tprivate boolean inAspects;\n\n\tprivate Definition.ConcreteAspect activeConcreteAspectDefinition;\n\n\tprivate static Hashtable<String, Definition> parsedFiles = new Hashtable<>();\n\tprivate static boolean CACHE;\n\tprivate static final boolean LIGHTPARSER;\n\n\tstatic {\n\t\tboolean value = false;\n\t\ttry {\n\t\t\tvalue = System.getProperty(\"org.aspectj.weaver.loadtime.configuration.cache\", \"true\").equalsIgnoreCase(\"true\");\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t\tCACHE = value;\n\n\t\tvalue = false;\n\t\ttry {\n\t\t\tvalue = System.getProperty(\"org.aspectj.weaver.loadtime.configuration.lightxmlparser\", \"false\")\n\t\t\t\t\t.equalsIgnoreCase(\"true\");\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t\tLIGHTPARSER = value;\n\t}\n\n\tprivate DocumentParser() {\n\t\tdefinition = new Definition();\n\t}\n\n\tpublic static Definition parse(final URL url) throws Exception {\n\t\tif (CACHE && parsedFiles.containsKey(url.toString())) {\n\t\t\treturn parsedFiles.get(url.toString());\n\t\t}\n\t\tDefinition def = null;\n\n\t\tif (LIGHTPARSER) {\n\t\t\tdef = SimpleAOPParser.parse(url);\n\t\t} else {\n\t\t\tdef = saxParsing(url);\n\t\t}\n\n\t\tif (CACHE && def.getAspectClassNames().size() > 0) {\n\t\t\tparsedFiles.put(url.toString(), def);\n\t\t}\n\n\t\treturn def;\n\t}\n\n\tprivate static Definition saxParsing(URL url) throws SAXException, ParserConfigurationException, IOException {\n\t\tDocumentParser parser = new DocumentParser();\n\n\t\tXMLReader xmlReader = getXMLReader();\n\t\txmlReader.setContentHandler(parser);\n\t\txmlReader.setErrorHandler(parser);\n\n\t\ttry {\n\t\t\txmlReader.setFeature(\"https://xml.org/sax/features/validation\", false);\n\t\t} catch (SAXException e) {\n\t\t\t// fine, the parser don't do validation\n\t\t}\n\t\ttry {\n\t\t\txmlReader.setFeature(\"https://xml.org/sax/features/external-general-entities\", false);\n\t\t} catch (SAXException e) {\n\t\t\t// fine, the parser don't do validation\n\t\t}\n\t\ttry {\n\t\t\txmlReader.setFeature(\"https://xml.org/sax/features/external-parameter-entities\", false);\n\t\t} catch (SAXException e) {\n\t\t\t// fine, the parser don't do validation\n\t\t}\n\n\t\txmlReader.setEntityResolver(parser);\n\t\tInputStream in = url.openStream();\n\t\txmlReader.parse(new InputSource(in));\n\t\treturn parser.definition;\n\t}\n\n\tprivate static XMLReader getXMLReader() throws SAXException, ParserConfigurationException {\n\t\tXMLReader xmlReader = null;\n\t\t/* Try this first for Java 5 */\n\t\ttry {\n\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n\t\t}\n\n\t\t/* .. and ignore \"System property ... not set\" and then try this instead */\n\t\tcatch (SAXException ex) {\n\t\t\txmlReader = SAXParserFactory.newInstance().newSAXParser().getXMLReader();\n\t\t}\n\t\treturn xmlReader;\n\t}\n\n\tpublic InputSource resolveEntity(String publicId, String systemId) throws SAXException {\n\t\tif (publicId.equals(DTD_PUBLIC_ID) || publicId.equals(DTD_PUBLIC_ID_ALIAS)) {\n\t\t\tInputStream in = DocumentParser.class.getResourceAsStream(\"/aspectj_1_5_0.dtd\");\n\t\t\tif (in == null) {\n\t\t\t\tSystem.err.println(\"AspectJ - WARN - could not read DTD \" + publicId);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn new InputSource(in);\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.err.println(\"AspectJ - WARN - unknown DTD \" + publicId + \" - consider using \" + DTD_PUBLIC_ID);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n\t\tif (ASPECT_ELEMENT.equals(qName)) {\n\t\t\tString name = attributes.getValue(NAME_ATTRIBUTE);\n\t\t\tString scopePattern = replaceXmlAnd(attributes.getValue(SCOPE_ATTRIBUTE));\n\t\t\tString requiredType = attributes.getValue(REQUIRES_ATTRIBUTE);\n\t\t\tif (!isNull(name)) {\n\t\t\t\tdefinition.getAspectClassNames().add(name);\n\t\t\t\tif (scopePattern != null) {\n\t\t\t\t\tdefinition.addScopedAspect(name, scopePattern);\n\t\t\t\t}\n\t\t\t\tif (requiredType != null) {\n\t\t\t\t\tdefinition.setAspectRequires(name, requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (WEAVER_ELEMENT.equals(qName)) {\n\t\t\tString options = attributes.getValue(OPTIONS_ATTRIBUTE);\n\t\t\tif (!isNull(options)) {\n\t\t\t\tdefinition.appendWeaverOptions(options);\n\t\t\t}\n\t\t\tinWeaver = true;\n\t\t} else if (CONCRETE_ASPECT_ELEMENT.equals(qName)) {\n\t\t\tString name = attributes.getValue(NAME_ATTRIBUTE);\n\t\t\tString extend = attributes.getValue(EXTEND_ATTRIBUTE);\n\t\t\tString precedence = attributes.getValue(PRECEDENCE_ATTRIBUTE);\n\t\t\tString perclause = attributes.getValue(PERCLAUSE_ATTRIBUTE);\n\t\t\tif (!isNull(name)) {\n\t\t\t\tactiveConcreteAspectDefinition = new Definition.ConcreteAspect(name, extend, precedence, perclause);\n\t\t\t\t// if (isNull(precedence) && !isNull(extend)) {// if no precedence, then extends must be there\n\t\t\t\t// m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend);\n\t\t\t\t// } else if (!isNull(precedence)) {\n\t\t\t\t// // wether a pure precedence def, or an extendsANDprecedence def.\n\t\t\t\t// m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend, precedence, perclause);\n\t\t\t\t// }\n\t\t\t\tdefinition.getConcreteAspects().add(activeConcreteAspectDefinition);\n\t\t\t}\n\t\t} else if (POINTCUT_ELEMENT.equals(qName) && activeConcreteAspectDefinition != null) {\n\t\t\tString name = attributes.getValue(NAME_ATTRIBUTE);\n\t\t\tString expression = attributes.getValue(EXPRESSION_ATTRIBUTE);\n\t\t\tif (!isNull(name) && !isNull(expression)) {\n\t\t\t\tactiveConcreteAspectDefinition.pointcuts.add(new Definition.Pointcut(name, replaceXmlAnd(expression)));\n\t\t\t}\n\t\t} else if (DECLARE_ANNOTATION_ELEMENT.equals(qName) && activeConcreteAspectDefinition!=null) {\n\t\t\tString methodSig = attributes.getValue(\"method\");\n\t\t\tString fieldSig = attributes.getValue(\"field\");\n\t\t\tString typePat = attributes.getValue(\"type\");\n\t\t\tString anno = attributes.getValue(\"annotation\");\n\t\t\tif (isNull(anno)) {\n\t\t\t\tthrow new SAXException(\"Badly formed <declare-annotation> element, 'annotation' value is missing\");\n\t\t\t}\n\t\t\tif (isNull(methodSig) && isNull(fieldSig) && isNull(typePat)) {\n\t\t\t\tthrow new SAXException(\"Badly formed <declare-annotation> element, need one of 'method'/'field'/'type' specified\");\n\t\t\t}\n\t\t\tif (!isNull(methodSig)) {\n\t\t\t\t// declare @method\n\t\t\t\tactiveConcreteAspectDefinition.declareAnnotations.add(new Definition.DeclareAnnotation(DeclareAnnotationKind.Method,\n\t\t\t\t\t\tmethodSig, anno));\n\t\t\t} else if (!isNull(fieldSig)) {\n\t\t\t\t// declare @field\n\t\t\t\tactiveConcreteAspectDefinition.declareAnnotations.add(new Definition.DeclareAnnotation(DeclareAnnotationKind.Field,\n\t\t\t\t\t\tfieldSig, anno));\n\t\t\t} else if (!isNull(typePat)) {\n\t\t\t\t// declare @type\n\t\t\t\tactiveConcreteAspectDefinition.declareAnnotations.add(new Definition.DeclareAnnotation(DeclareAnnotationKind.Type,\n\t\t\t\t\t\ttypePat, anno));\n\t\t\t}\n\t\t} else if (BEFORE_ELEMENT.equals(qName) && activeConcreteAspectDefinition != null) {\n\t\t\tString pointcut = attributes.getValue(POINTCUT_ELEMENT);\n\t\t\tString adviceClass = attributes.getValue(\"invokeClass\");\n\t\t\tString adviceMethod = attributes.getValue(\"invokeMethod\");\n\t\t\tif (!isNull(pointcut) && !isNull(adviceClass) && !isNull(adviceMethod)) {\n\t\t\t\tactiveConcreteAspectDefinition.pointcutsAndAdvice.add(new Definition.PointcutAndAdvice(AdviceKind.Before,\n\t\t\t\t\t\treplaceXmlAnd(pointcut), adviceClass, adviceMethod));\n\t\t\t} else {\n\t\t\t\tthrow new SAXException(\"Badly formed <before> element\");\n\t\t\t}\n\t\t} else if (AFTER_ELEMENT.equals(qName) && activeConcreteAspectDefinition != null) {\n\t\t\tString pointcut = attributes.getValue(POINTCUT_ELEMENT);\n\t\t\tString adviceClass = attributes.getValue(\"invokeClass\");\n\t\t\tString adviceMethod = attributes.getValue(\"invokeMethod\");\n\t\t\tif (!isNull(pointcut) && !isNull(adviceClass) && !isNull(adviceMethod)) {\n\t\t\t\tactiveConcreteAspectDefinition.pointcutsAndAdvice.add(new Definition.PointcutAndAdvice(AdviceKind.After,\n\t\t\t\t\t\treplaceXmlAnd(pointcut), adviceClass, adviceMethod));\n\t\t\t} else {\n\t\t\t\tthrow new SAXException(\"Badly formed <after> element\");\n\t\t\t}\n\t\t} else if (AROUND_ELEMENT.equals(qName) && activeConcreteAspectDefinition != null) {\n\t\t\tString pointcut = attributes.getValue(POINTCUT_ELEMENT);\n\t\t\tString adviceClass = attributes.getValue(\"invokeClass\");\n\t\t\tString adviceMethod = attributes.getValue(\"invokeMethod\");\n\t\t\tif (!isNull(pointcut) && !isNull(adviceClass) && !isNull(adviceMethod)) {\n\t\t\t\tactiveConcreteAspectDefinition.pointcutsAndAdvice.add(new Definition.PointcutAndAdvice(AdviceKind.Around,\n\t\t\t\t\t\treplaceXmlAnd(pointcut), adviceClass, adviceMethod));\n\t\t\t} else {\n\t\t\t\tthrow new SAXException(\"Badly formed <before> element\");\n\t\t\t}\n\t\t} else if (ASPECTJ_ELEMENT.equals(qName)) {\n\t\t\tif (inAspectJ) {\n\t\t\t\tthrow new SAXException(\"Found nested <aspectj> element\");\n\t\t\t}\n\t\t\tinAspectJ = true;\n\t\t} else if (ASPECTS_ELEMENT.equals(qName)) {\n\t\t\tinAspects = true;\n\t\t} else if (INCLUDE_ELEMENT.equals(qName) && inWeaver) {\n\t\t\tString typePattern = getWithinAttribute(attributes);\n\t\t\tif (!isNull(typePattern)) {\n\t\t\t\tdefinition.getIncludePatterns().add(typePattern);\n\t\t\t}\n\t\t} else if (EXCLUDE_ELEMENT.equals(qName) && inWeaver) {\n\t\t\tString typePattern = getWithinAttribute(attributes);\n\t\t\tif (!isNull(typePattern)) {\n\t\t\t\tdefinition.getExcludePatterns().add(typePattern);\n\t\t\t}\n\t\t} else if (DUMP_ELEMENT.equals(qName) && inWeaver) {\n\t\t\tString typePattern = getWithinAttribute(attributes);\n\t\t\tif (!isNull(typePattern)) {\n\t\t\t\tdefinition.getDumpPatterns().add(typePattern);\n\t\t\t}\n\t\t\tString beforeAndAfter = attributes.getValue(DUMP_BEFOREANDAFTER_ATTRIBUTE);\n\t\t\tif (isTrue(beforeAndAfter)) {\n\t\t\t\tdefinition.setDumpBefore(true);\n\t\t\t}\n\t\t\tString perWeaverDumpDir = attributes.getValue(DUMP_PERCLASSLOADERDIR_ATTRIBUTE);\n\t\t\tif (isTrue(perWeaverDumpDir)) {\n\t\t\t\tdefinition.setCreateDumpDirPerClassloader(true);\n\t\t\t}\n\t\t} else if (EXCLUDE_ELEMENT.equals(qName) && inAspects) {\n\t\t\tString typePattern = getWithinAttribute(attributes);\n\t\t\tif (!isNull(typePattern)) {\n\t\t\t\tdefinition.getAspectExcludePatterns().add(typePattern);\n\t\t\t}\n\t\t} else if (INCLUDE_ELEMENT.equals(qName) && inAspects) {\n\t\t\tString typePattern = getWithinAttribute(attributes);\n\t\t\tif (!isNull(typePattern)) {\n\t\t\t\tdefinition.getAspectIncludePatterns().add(typePattern);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new SAXException(\"Unknown element while parsing <aspectj> element: \" + qName);\n\t\t}\n\t\tsuper.startElement(uri, localName, qName, attributes);\n\t}\n\n\tprivate String getWithinAttribute(Attributes attributes) {\n\t\treturn replaceXmlAnd(attributes.getValue(WITHIN_ATTRIBUTE));\n\t}\n\n\tpublic void endElement(String uri, String localName, String qName) throws SAXException {\n\t\tif (CONCRETE_ASPECT_ELEMENT.equals(qName)) {\n\t\t\tactiveConcreteAspectDefinition = null;\n\t\t} else if (ASPECTJ_ELEMENT.equals(qName)) {\n\t\t\tinAspectJ = false;\n\t\t} else if (WEAVER_ELEMENT.equals(qName)) {\n\t\t\tinWeaver = false;\n\t\t} else if (ASPECTS_ELEMENT.equals(qName)) {\n\t\t\tinAspects = false;\n\t\t}\n\t\tsuper.endElement(uri, localName, qName);\n\t}\n\n\t// TODO AV - define what we want for XML parser error - for now stderr\n\tpublic void warning(SAXParseException e) throws SAXException {\n\t\tsuper.warning(e);\n\t}\n\n\tpublic void error(SAXParseException e) throws SAXException {\n\t\tsuper.error(e);\n\t}\n\n\tpublic void fatalError(SAXParseException e) throws SAXException {\n\t\tsuper.fatalError(e);\n\t}\n\n\tprivate static String replaceXmlAnd(String expression) {\n\t\t// TODO AV do we need to handle \"..)AND\" or \"AND(..\" ?\n\t\treturn LangUtil.replace(expression, \" AND \", \" && \");\n\t}\n\n\tprivate boolean isNull(String s) {\n\t\treturn (s == null || s.length() <= 0);\n\t}\n\n\tprivate boolean isTrue(String s) {\n\t\treturn (s != null && s.equals(\"true\"));\n\t}\n\n\t/**\n\t * Turn off caching\n\t */\n\tpublic static void deactivateCaching() {\n\t\tCACHE = false;\n\t}\n\n}\n",
    "size": 14732
  },
  {
    "file_id": "F49",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/loadtime/definition/LightXMLParser.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2011 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Abraham Nevado - Lucierna\tinitial implementation\n *******************************************************************************/\npackage org.aspectj.weaver.loadtime.definition;\n\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LightXMLParser {\n\n\tprivate final static char NULL_CHAR = '\\0';\n\tprivate Map<String, Object> attributes;\n\tprivate ArrayList<LightXMLParser> children;\n\tprivate String name;\n\tprivate char pushedBackChar;\n\tprivate Reader reader;\n\n\tprivate static Map<String, char[]> entities = new HashMap<>();\n\n\tstatic {\n\t\tentities.put(\"amp\", new char[] { '&' });\n\t\tentities.put(\"quot\", new char[] { '\"' });\n\t\tentities.put(\"apos\", new char[] { '\\'' });\n\t\tentities.put(\"lt\", new char[] { '<' });\n\t\tentities.put(\"gt\", new char[] { '>' });\n\t}\n\n\tpublic LightXMLParser() {\n\t\tthis.name = null;\n\t\tthis.attributes = new HashMap<>();\n\t\tthis.children = new ArrayList<>();\n\t}\n\n\tpublic ArrayList getChildrens() {\n\t\treturn this.children;\n\t}\n\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\tpublic void parseFromReader(Reader reader) throws Exception {\n\t\tthis.pushedBackChar = NULL_CHAR;\n\t\tthis.attributes = new HashMap<>();\n\t\tthis.name = null;\n\t\tthis.children = new ArrayList<>();\n\t\tthis.reader = reader;\n\n\t\twhile (true) {\n\t\t\t// Skips whiteSpaces, blanks, \\r\\n..\n\t\t\tchar c = this.skipBlanks();\n\n\t\t\t// All xml should start by <xml, a <!-- or <nodeName, if not throw\n\t\t\t// exception\n\t\t\tif (c != '<') {\n\t\t\t\tthrow new Exception(\"LightParser Exception: Expected < but got: \" + c);\n\t\t\t}\n\n\t\t\t// read next character\n\t\t\tc = this.getNextChar();\n\n\t\t\t// if starts with ! or ? it is <?xml or a comment: skip\n\t\t\tif ((c == '!') || (c == '?')) {\n\t\t\t\tthis.skipCommentOrXmlTag(0);\n\t\t\t} else {\n\t\t\t\t// it is a node, pusch character back\n\t\t\t\tthis.pushBackChar(c);\n\t\t\t\t// parse node\n\t\t\t\tthis.parseNode(this);\n\t\t\t\t// Only one root node, so finsh.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate char skipBlanks() throws Exception {\n\t\twhile (true) {\n\t\t\tchar c = this.getNextChar();\n\t\t\tswitch (c) {\n\t\t\tcase '\\n':\n\t\t\tcase '\\r':\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate char getWhitespaces(StringBuffer result) throws Exception {\n\t\twhile (true) {\n\t\t\tchar c = this.getNextChar();\n\t\t\tswitch (c) {\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase '\\n':\n\t\t\t\tresult.append(c);\n\t\t\tcase '\\r':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void getNodeName(StringBuffer result) throws Exception {\n\t\tchar c;\n\t\twhile (true) {\n\t\t\t// Iterate while next character is not [a-z] [A-Z] [0-9] [ .:_-] not\n\t\t\t// null\n\t\t\tc = this.getNextChar();\n\t\t\tif (((c < 'a') || (c > 'z')) && ((c > 'Z') || (c < 'A')) && ((c > '9') || (c < '0')) && (c != '_') && (c != '-')\n\t\t\t\t\t&& (c != '.') && (c != ':')) {\n\t\t\t\tthis.pushBackChar(c);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult.append(c);\n\t\t}\n\t}\n\n\tprivate void getString(StringBuffer string) throws Exception {\n\t\tchar delimiter = this.getNextChar();\n\t\tif ((delimiter != '\\'') && (delimiter != '\"')) {\n\t\t\tthrow new Exception(\"Parsing error. Expected ' or \\\"  but got: \" + delimiter);\n\n\t\t}\n\n\t\twhile (true) {\n\t\t\tchar c = this.getNextChar();\n\t\t\tif (c == delimiter) {\n\t\t\t\treturn;\n\t\t\t} else if (c == '&') {\n\t\t\t\tthis.mapEntity(string);\n\t\t\t} else {\n\t\t\t\tstring.append(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void getPCData(StringBuffer data) throws Exception {\n\t\twhile (true) {\n\t\t\tchar c = this.getNextChar();\n\t\t\tif (c == '<') {\n\t\t\t\tc = this.getNextChar();\n\t\t\t\tif (c == '!') {\n\t\t\t\t\tthis.checkCDATA(data);\n\t\t\t\t} else {\n\t\t\t\t\tthis.pushBackChar(c);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata.append(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean checkCDATA(StringBuffer buf) throws Exception {\n\t\tchar c = this.getNextChar();\n\t\tif (c != '[') {\n\t\t\tthis.pushBackChar(c);\n\t\t\tthis.skipCommentOrXmlTag(0);\n\t\t\treturn false;\n\t\t} else if (!this.checkLiteral(\"CDATA[\")) {\n\t\t\tthis.skipCommentOrXmlTag(1); // one [ has already been read\n\t\t\treturn false;\n\t\t} else {\n\t\t\tint delimiterCharsSkipped = 0;\n\t\t\twhile (delimiterCharsSkipped < 3) {\n\t\t\t\tc = this.getNextChar();\n\t\t\t\tswitch (c) {\n\t\t\t\tcase ']':\n\t\t\t\t\tif (delimiterCharsSkipped < 2) {\n\t\t\t\t\t\tdelimiterCharsSkipped++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf.append(']');\n\t\t\t\t\t\tbuf.append(']');\n\t\t\t\t\t\tdelimiterCharsSkipped = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tif (delimiterCharsSkipped < 2) {\n\t\t\t\t\t\tfor (int i = 0; i < delimiterCharsSkipped; i++) {\n\t\t\t\t\t\t\tbuf.append(']');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelimiterCharsSkipped = 0;\n\t\t\t\t\t\tbuf.append('>');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelimiterCharsSkipped = 3;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfor (int i = 0; i < delimiterCharsSkipped; i++) {\n\t\t\t\t\t\tbuf.append(']');\n\t\t\t\t\t}\n\t\t\t\t\tbuf.append(c);\n\t\t\t\t\tdelimiterCharsSkipped = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate void skipCommentOrXmlTag(int bracketLevel) throws Exception {\n\t\tchar delim = NULL_CHAR;\n\t\tint level = 1;\n\t\tchar c;\n\t\tif (bracketLevel == 0) {\n\t\t\tc = this.getNextChar();\n\t\t\tif (c == '-') {\n\t\t\t\tc = this.getNextChar();\n\t\t\t\tif (c == ']') {\n\t\t\t\t\tbracketLevel--;\n\t\t\t\t} else if (c == '[') {\n\t\t\t\t\tbracketLevel++;\n\t\t\t\t} else if (c == '-') {\n\t\t\t\t\tthis.skipComment();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (c == '[') {\n\t\t\t\tbracketLevel++;\n\t\t\t}\n\t\t}\n\t\twhile (level > 0) {\n\t\t\tc = this.getNextChar();\n\t\t\tif (delim == NULL_CHAR) {\n\t\t\t\tif ((c == '\"') || (c == '\\'')) {\n\t\t\t\t\tdelim = c;\n\t\t\t\t} else if (bracketLevel <= 0) {\n\t\t\t\t\tif (c == '<') {\n\t\t\t\t\t\tlevel++;\n\t\t\t\t\t} else if (c == '>') {\n\t\t\t\t\t\tlevel--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (c == '[') {\n\t\t\t\t\tbracketLevel++;\n\t\t\t\t} else if (c == ']') {\n\t\t\t\t\tbracketLevel--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (c == delim) {\n\t\t\t\t\tdelim = NULL_CHAR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void parseNode(LightXMLParser elt) throws Exception {\n\t\t// Now we are in a new node element. Get its name\n\t\tStringBuffer buf = new StringBuffer();\n\t\tthis.getNodeName(buf);\n\t\tString name = buf.toString();\n\t\telt.setName(name);\n\n\t\tchar c = this.skipBlanks();\n\t\twhile ((c != '>') && (c != '/')) {\n\t\t\t// Get attributes\n\t\t\temptyBuf(buf);\n\t\t\tthis.pushBackChar(c);\n\t\t\tthis.getNodeName(buf);\n\t\t\tString key = buf.toString();\n\t\t\tc = this.skipBlanks();\n\t\t\tif (c != '=') {\n\t\t\t\tthrow new Exception(\"Parsing error. Expected = but got: \" + c);\n\t\t\t}\n\t\t\t// Go up to \" character and push it back\n\t\t\tthis.pushBackChar(this.skipBlanks());\n\n\t\t\temptyBuf(buf);\n\t\t\tthis.getString(buf);\n\n\t\t\telt.setAttribute(key, buf);\n\n\t\t\t// Skip blanks\n\t\t\tc = this.skipBlanks();\n\t\t}\n\t\tif (c == '/') {\n\t\t\tc = this.getNextChar();\n\t\t\tif (c != '>') {\n\t\t\t\tthrow new Exception(\"Parsing error. Expected > but got: \" + c);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Now see if we got content, or CDATA, if content get it: it is free...\n\t\temptyBuf(buf);\n\t\tc = this.getWhitespaces(buf);\n\t\tif (c != '<') {\n\t\t\t// It is PCDATA\n\t\t\tthis.pushBackChar(c);\n\t\t\tthis.getPCData(buf);\n\t\t} else {\n\t\t\t// It is content: get it, or CDATA.\n\t\t\twhile (true) {\n\t\t\t\tc = this.getNextChar();\n\t\t\t\tif (c == '!') {\n\t\t\t\t\tif (this.checkCDATA(buf)) {\n\t\t\t\t\t\tthis.getPCData(buf);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = this.getWhitespaces(buf);\n\t\t\t\t\t\tif (c != '<') {\n\t\t\t\t\t\t\tthis.pushBackChar(c);\n\t\t\t\t\t\t\tthis.getPCData(buf);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (c != '/') {\n\t\t\t\t\t\temptyBuf(buf);\n\t\t\t\t\t}\n\t\t\t\t\tif (c == '/') {\n\t\t\t\t\t\tthis.pushBackChar(c);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (buf.length() == 0) {\n\t\t\t// It is a comment\n\t\t\twhile (c != '/') {\n\t\t\t\tif (c == '!') {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tc = this.getNextChar();\n\t\t\t\t\t\tif (c != '-') {\n\t\t\t\t\t\t\tthrow new Exception(\"Parsing error. Expected element or comment\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.skipComment();\n\t\t\t\t} else {\n\t\t\t\t\t// it is a new node\n\t\t\t\t\tthis.pushBackChar(c);\n\t\t\t\t\tLightXMLParser child = this.createAnotherElement();\n\t\t\t\t\tthis.parseNode(child);\n\t\t\t\t\telt.addChild(child);\n\t\t\t\t}\n\t\t\t\tc = this.skipBlanks();\n\t\t\t\tif (c != '<') {\n\t\t\t\t\tthrow new Exception(\"Parsing error. Expected <, but got: \" + c);\n\t\t\t\t}\n\t\t\t\tc = this.getNextChar();\n\t\t\t}\n\t\t\tthis.pushBackChar(c);\n\t\t} // Here content could be grabbed\n\n\t\tc = this.getNextChar();\n\t\tif (c != '/') {\n\t\t\tthrow new Exception(\"Parsing error. Expected /, but got: \" + c);\n\t\t}\n\t\tthis.pushBackChar(this.skipBlanks());\n\t\tif (!this.checkLiteral(name)) {\n\t\t\tthrow new Exception(\"Parsing error. Expected \" + name);\n\t\t}\n\t\tif (this.skipBlanks() != '>') {\n\t\t\tthrow new Exception(\"Parsing error. Expected >, but got: \" + c);\n\t\t}\n\t}\n\n\tprivate void skipComment() throws Exception {\n\t\tint dashes = 2;\n\t\twhile (dashes > 0) {\n\t\t\tchar ch = this.getNextChar();\n\t\t\tif (ch == '-') {\n\t\t\t\tdashes -= 1;\n\t\t\t} else {\n\t\t\t\tdashes = 2;\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar = this.getNextChar();\n\t\tif (nextChar != '>') {\n\t\t\tthrow new Exception(\"Parsing error. Expected > but got: \" + nextChar);\n\t\t}\n\t}\n\n\tprivate boolean checkLiteral(String literal) throws Exception {\n\t\tint length = literal.length();\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tif (this.getNextChar() != literal.charAt(i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate char getNextChar() throws Exception {\n\t\tif (this.pushedBackChar != NULL_CHAR) {\n\t\t\tchar c = this.pushedBackChar;\n\t\t\tthis.pushedBackChar = NULL_CHAR;\n\t\t\treturn c;\n\t\t} else {\n\t\t\tint i = this.reader.read();\n\t\t\tif (i < 0) {\n\t\t\t\tthrow new Exception(\"Parsing error. Unexpected end of data\");\n\t\t\t} else {\n\t\t\t\treturn (char) i;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void mapEntity(StringBuffer buf) throws Exception {\n\t\tchar c = this.NULL_CHAR;\n\t\tStringBuilder keyBuf = new StringBuilder();\n\t\twhile (true) {\n\t\t\tc = this.getNextChar();\n\t\t\tif (c == ';') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkeyBuf.append(c);\n\t\t}\n\t\tString key = keyBuf.toString();\n\t\tif (key.charAt(0) == '#') {\n\t\t\ttry {\n\t\t\t\tif (key.charAt(1) == 'x') {\n\t\t\t\t\tc = (char) Integer.parseInt(key.substring(2), 16);\n\t\t\t\t} else {\n\t\t\t\t\tc = (char) Integer.parseInt(key.substring(1), 10);\n\t\t\t\t}\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new Exception(\"Unknown entity: \" + key);\n\t\t\t}\n\t\t\tbuf.append(c);\n\t\t} else {\n\t\t\tchar[] value = entities.get(key);\n\t\t\tif (value == null) {\n\t\t\t\tthrow new Exception(\"Unknown entity: \" + key);\n\t\t\t}\n\t\t\tbuf.append(value);\n\t\t}\n\t}\n\n\tprivate void pushBackChar(char c) {\n\t\tthis.pushedBackChar = c;\n\t}\n\n\tprivate void addChild(LightXMLParser child) {\n\t\tthis.children.add(child);\n\t}\n\n\tprivate void setAttribute(String name, Object value) {\n\t\tthis.attributes.put(name, value.toString());\n\t}\n\n\tpublic Map<String, Object> getAttributes() {\n\t\treturn this.attributes;\n\t}\n\n\tprivate LightXMLParser createAnotherElement() {\n\t\treturn new LightXMLParser();\n\t}\n\n\tprivate void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tprivate void emptyBuf(StringBuffer buf) {\n\t\tbuf.setLength(0);\n\t}\n\n}\n",
    "size": 10782
  },
  {
    "file_id": "F50",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/loadtime/definition/SimpleAOPParser.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2011 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Abraham Nevado - Lucierna\tinitial implementation\n *   \tJust a slight variation of current DocumentParser.java from Alexandre Vasseur.\n *******************************************************************************/\npackage org.aspectj.weaver.loadtime.definition;\n\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Map;\n\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.loadtime.definition.Definition.AdviceKind;\nimport org.aspectj.weaver.loadtime.definition.Definition.DeclareAnnotationKind;\nimport org.xml.sax.SAXException;\n\n/**\n * This class has been created to avoid deadlocks when instrumenting SAXParser.\n * So it is used as a wrapper for the ligthweigh XML parser LightXMLParser.\n *\n * @author A. Nevado\n */\npublic class SimpleAOPParser {\n\n\tprivate final static String ASPECTJ_ELEMENT = \"aspectj\";\n\tprivate final static String WEAVER_ELEMENT = \"weaver\";\n\tprivate final static String DUMP_ELEMENT = \"dump\";\n\tprivate final static String DUMP_BEFOREANDAFTER_ATTRIBUTE = \"beforeandafter\";\n\tprivate final static String DUMP_PERCLASSLOADERDIR_ATTRIBUTE = \"perclassloaderdumpdir\";\n\tprivate final static String INCLUDE_ELEMENT = \"include\";\n\tprivate final static String EXCLUDE_ELEMENT = \"exclude\";\n\tprivate final static String OPTIONS_ATTRIBUTE = \"options\";\n\tprivate final static String ASPECTS_ELEMENT = \"aspects\";\n\tprivate final static String ASPECT_ELEMENT = \"aspect\";\n\tprivate final static String CONCRETE_ASPECT_ELEMENT = \"concrete-aspect\";\n\tprivate final static String NAME_ATTRIBUTE = \"name\";\n\tprivate final static String SCOPE_ATTRIBUTE = \"scope\";\n\tprivate final static String REQUIRES_ATTRIBUTE = \"requires\";\n\tprivate final static String EXTEND_ATTRIBUTE = \"extends\";\n\tprivate final static String PRECEDENCE_ATTRIBUTE = \"precedence\";\n\tprivate final static String PERCLAUSE_ATTRIBUTE = \"perclause\";\n\tprivate final static String POINTCUT_ELEMENT = \"pointcut\";\n\tprivate final static String WITHIN_ATTRIBUTE = \"within\";\n\tprivate final static String EXPRESSION_ATTRIBUTE = \"expression\";\n\tprivate static final String DECLARE_ANNOTATION = \"declare-annotation\";\n\tprivate static final String ANNONATION_TAG = \"annotation\";\n\tprivate static final String ANNO_KIND_TYPE = \"type\";\n\tprivate static final String ANNO_KIND_METHOD = \"method\";\n\tprivate static final String ANNO_KIND_FIELD = \"field\";\n\tprivate final static String BEFORE_ELEMENT = \"before\";\n\tprivate final static String AFTER_ELEMENT = \"after\";\n\tprivate final static String AROUND_ELEMENT = \"around\";\n\tprivate final Definition m_definition;\n\tprivate boolean m_inAspectJ;\n\tprivate boolean m_inWeaver;\n\tprivate boolean m_inAspects;\n\n\tprivate Definition.ConcreteAspect m_lastConcreteAspect;\n\n\tprivate SimpleAOPParser() {\n\t\tm_definition = new Definition();\n\t}\n\n\tpublic static Definition parse(final URL url) throws Exception {\n\t\t// FileReader freader = new FileReader(\"/tmp/aop.xml\");\n\t\tInputStream in = url.openStream();\n\t\tLightXMLParser xml = new LightXMLParser();\n\t\txml.parseFromReader(new InputStreamReader(in));\n\t\tSimpleAOPParser sap = new SimpleAOPParser();\n\t\ttraverse(sap, xml);\n\t\treturn sap.m_definition;\n\t}\n\n\tprivate void startElement(String qName, Map<String, Object> attrMap) throws Exception {\n\t\tif (ASPECT_ELEMENT.equals(qName)) {\n\t\t\tString name = (String) attrMap.get(NAME_ATTRIBUTE);\n\t\t\tString scopePattern = replaceXmlAnd((String) attrMap\n\t\t\t\t\t.get(SCOPE_ATTRIBUTE));\n\t\t\tString requiredType = (String) attrMap.get(REQUIRES_ATTRIBUTE);\n\t\t\tif (!isNull(name)) {\n\t\t\t\tm_definition.getAspectClassNames().add(name);\n\t\t\t\tif (scopePattern != null) {\n\t\t\t\t\tm_definition.addScopedAspect(name, scopePattern);\n\t\t\t\t}\n\t\t\t\tif (requiredType != null) {\n\t\t\t\t\tm_definition.setAspectRequires(name, requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (WEAVER_ELEMENT.equals(qName)) {\n\t\t\tString options = (String) attrMap.get(OPTIONS_ATTRIBUTE);\n\t\t\tif (!isNull(options)) {\n\t\t\t\tm_definition.appendWeaverOptions(options);\n\t\t\t}\n\t\t\tm_inWeaver = true;\n\t\t} else if (CONCRETE_ASPECT_ELEMENT.equals(qName)) {\n\t\t\tString name = (String) attrMap.get(NAME_ATTRIBUTE);\n\t\t\tString extend = (String) attrMap.get(EXTEND_ATTRIBUTE);\n\t\t\tString precedence = (String) attrMap.get(PRECEDENCE_ATTRIBUTE);\n\t\t\tString perclause = (String) attrMap.get(PERCLAUSE_ATTRIBUTE);\n\t\t\tif (!isNull(name)) {\n\t\t\t\tm_lastConcreteAspect = new Definition.ConcreteAspect(name,\n\t\t\t\t\t\textend, precedence, perclause);\n\t\t\t\tm_definition.getConcreteAspects().add(m_lastConcreteAspect);\n\t\t\t}\n\t\t} else if (POINTCUT_ELEMENT.equals(qName)\n\t\t\t\t&& m_lastConcreteAspect != null) {\n\t\t\tString name = (String) attrMap.get(NAME_ATTRIBUTE);\n\t\t\tString expression = (String) attrMap.get(EXPRESSION_ATTRIBUTE);\n\t\t\tif (!isNull(name) && !isNull(expression)) {\n\t\t\t\tm_lastConcreteAspect.pointcuts.add(new Definition.Pointcut(\n\t\t\t\t\t\tname, replaceXmlAnd(expression)));\n\t\t\t}\n\t\t} else if (ASPECTJ_ELEMENT.equals(qName)) {\n\t\t\tif (m_inAspectJ) {\n\t\t\t\tthrow new Exception(\"Found nested <aspectj> element\");\n\t\t\t}\n\t\t\tm_inAspectJ = true;\n\t\t} else if (ASPECTS_ELEMENT.equals(qName)) {\n\t\t\tm_inAspects = true;\n\t\t} else if (INCLUDE_ELEMENT.equals(qName) && m_inWeaver) {\n\t\t\tString typePattern = getWithinAttribute(attrMap);\n\t\t\tif (!isNull(typePattern)) {\n\t\t\t\tm_definition.getIncludePatterns().add(typePattern);\n\t\t\t}\n\t\t} else if (EXCLUDE_ELEMENT.equals(qName) && m_inWeaver) {\n\t\t\tString typePattern = getWithinAttribute(attrMap);\n\t\t\tif (!isNull(typePattern)) {\n\t\t\t\tm_definition.getExcludePatterns().add(typePattern);\n\t\t\t}\n\t\t} else if (DUMP_ELEMENT.equals(qName) && m_inWeaver) {\n\t\t\tString typePattern = getWithinAttribute(attrMap);\n\t\t\tif (!isNull(typePattern)) {\n\t\t\t\tm_definition.getDumpPatterns().add(typePattern);\n\t\t\t}\n\t\t\tString beforeAndAfter = (String) attrMap\n\t\t\t\t\t.get(DUMP_BEFOREANDAFTER_ATTRIBUTE);\n\t\t\tif (isTrue(beforeAndAfter)) {\n\t\t\t\tm_definition.setDumpBefore(true);\n\t\t\t}\n\t\t\tString perWeaverDumpDir = (String) attrMap\n\t\t\t\t\t.get(DUMP_PERCLASSLOADERDIR_ATTRIBUTE);\n\t\t\tif (isTrue(perWeaverDumpDir)) {\n\t\t\t\tm_definition.setCreateDumpDirPerClassloader(true);\n\t\t\t}\n\t\t} else if (EXCLUDE_ELEMENT.equals(qName) && m_inAspects) {\n\t\t\tString typePattern = getWithinAttribute(attrMap);\n\t\t\tif (!isNull(typePattern)) {\n\t\t\t\tm_definition.getAspectExcludePatterns().add(typePattern);\n\t\t\t}\n\t\t} else if (INCLUDE_ELEMENT.equals(qName) && m_inAspects) {\n\t\t\tString typePattern = getWithinAttribute(attrMap);\n\t\t\tif (!isNull(typePattern)) {\n\t\t\t\tm_definition.getAspectIncludePatterns().add(typePattern);\n\t\t\t}\n\t\t}else if (DECLARE_ANNOTATION.equals(qName) && m_inAspects) {\n\t\t\tString anno = (String) attrMap.get(ANNONATION_TAG);\n\t\t\tif (!isNull(anno)){\n\t\t\t\tString pattern = (String) attrMap.get(ANNO_KIND_FIELD);\n\t\t\t\tif (pattern != null){\n\t\t\t\t\tm_lastConcreteAspect.declareAnnotations.add(new Definition.DeclareAnnotation(\n\t\t\t\t\t\t\tDeclareAnnotationKind.Field, pattern, anno));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpattern = (String) attrMap.get(ANNO_KIND_METHOD);\n\t\t\t\t\tif (pattern != null){\n\t\t\t\t\t\tm_lastConcreteAspect.declareAnnotations.add(new Definition.DeclareAnnotation(\n\t\t\t\t\t\t\t\tDeclareAnnotationKind.Method, pattern, anno));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpattern = (String) attrMap.get(ANNO_KIND_TYPE);\n\t\t\t\t\t\tif (pattern != null){\n\t\t\t\t\t\t\tm_lastConcreteAspect.declareAnnotations.add(new Definition.DeclareAnnotation(\n\t\t\t\t\t\t\t\t\tDeclareAnnotationKind.Type, pattern, anno));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\telse if (BEFORE_ELEMENT.equals(qName) && m_inAspects ) {\n\t\t\tString pointcut = (String) attrMap.get(POINTCUT_ELEMENT);\n\t\t\tString adviceClass = (String) attrMap.get(\"invokeClass\");\n\t\t\tString adviceMethod = (String) attrMap.get(\"invokeMethod\");\n\t\t\tif (!isNull(pointcut) && !isNull(adviceClass) && !isNull(adviceMethod)) {\n\t\t\t\tm_lastConcreteAspect.pointcutsAndAdvice.add(new Definition.PointcutAndAdvice(AdviceKind.Before,\n\t\t\t\t\t\treplaceXmlAnd(pointcut), adviceClass, adviceMethod));\n\t\t\t} else {\n\t\t\t\tthrow new SAXException(\"Badly formed <before> element\");\n\t\t\t}\n\t\t} else if (AFTER_ELEMENT.equals(qName) && m_inAspects) {\n\t\t\tString pointcut = (String) attrMap.get(POINTCUT_ELEMENT);\n\t\t\tString adviceClass = (String) attrMap.get(\"invokeClass\");\n\t\t\tString adviceMethod = (String) attrMap.get(\"invokeMethod\");\n\t\t\tif (!isNull(pointcut) && !isNull(adviceClass) && !isNull(adviceMethod)) {\n\t\t\t\tm_lastConcreteAspect.pointcutsAndAdvice.add(new Definition.PointcutAndAdvice(AdviceKind.After,\n\t\t\t\t\t\treplaceXmlAnd(pointcut), adviceClass, adviceMethod));\n\t\t\t} else {\n\t\t\t\tthrow new SAXException(\"Badly formed <after> element\");\n\t\t\t}\n\t\t} else if (AROUND_ELEMENT.equals(qName) && m_inAspects) {\n\t\t\tString pointcut = (String) attrMap.get(POINTCUT_ELEMENT);\n\t\t\tString adviceClass = (String) attrMap.get(\"invokeClass\");\n\t\t\tString adviceMethod = (String) attrMap.get(\"invokeMethod\");\n\t\t\tif (!isNull(pointcut) && !isNull(adviceClass) && !isNull(adviceMethod)) {\n\t\t\t\tm_lastConcreteAspect.pointcutsAndAdvice.add(new Definition.PointcutAndAdvice(AdviceKind.Around,\n\t\t\t\t\t\treplaceXmlAnd(pointcut), adviceClass, adviceMethod));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new Exception(\n\t\t\t\t\t\"Unknown element while parsing <aspectj> element: \" + qName);\n\t\t}\n\t}\n\n\tprivate void endElement(String qName) throws Exception {\n\t\tif (CONCRETE_ASPECT_ELEMENT.equals(qName)) {\n\t\t\tm_lastConcreteAspect = null;\n\t\t} else if (ASPECTJ_ELEMENT.equals(qName)) {\n\t\t\tm_inAspectJ = false;\n\t\t} else if (WEAVER_ELEMENT.equals(qName)) {\n\t\t\tm_inWeaver = false;\n\t\t} else if (ASPECTS_ELEMENT.equals(qName)) {\n\t\t\tm_inAspects = false;\n\t\t}\n\t}\n\n\tprivate String getWithinAttribute(Map<String, Object> attributes) {\n\t\treturn replaceXmlAnd((String) attributes.get(WITHIN_ATTRIBUTE));\n\t}\n\n\tprivate static String replaceXmlAnd(String expression) {\n\t\t// TODO AV do we need to handle \"..)AND\" or \"AND(..\" ?\n\t\treturn LangUtil.replace(expression, \" AND \", \" && \");\n\t}\n\n\tprivate boolean isNull(String s) {\n\t\treturn (s == null || s.length() <= 0);\n\t}\n\n\tprivate boolean isTrue(String s) {\n\t\treturn (s != null && s.equals(\"true\"));\n\t}\n\n\tprivate static void traverse(SimpleAOPParser sap, LightXMLParser xml)\n\t\t\tthrows Exception {\n\t\tsap.startElement(xml.getName(), xml.getAttributes());\n\t\tIterable<LightXMLParser> childrens = xml.getChildrens();\n\t\tfor (LightXMLParser child : childrens) {\n\t\t\ttraverse(sap, child);\n\t\t}\n\t\tsap.endElement(xml.getName());\n\n\t}\n}\n",
    "size": 10569
  },
  {
    "file_id": "F51",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/ltw/LTWWorld.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Ron Bodkin\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.ltw;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.weaver.Dump.IVisitor;\nimport org.aspectj.weaver.ICrossReferenceHandler;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ReferenceTypeDelegate;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.bcel.BcelWorld;\nimport org.aspectj.weaver.loadtime.IWeavingContext;\nimport org.aspectj.weaver.reflect.AnnotationFinder;\nimport org.aspectj.weaver.reflect.IReflectionWorld;\nimport org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory;\nimport org.aspectj.weaver.reflect.ReflectionWorld;\n\n/**\n * @author adrian\n * @author Ron Bodkin\n *\n *         For use in LT weaving\n *\n *         Backed by both a BcelWorld and a ReflectionWorld\n *\n *         Needs a callback when a woven class is defined This is the trigger for us to ditch the class from Bcel and cache it in\n *         the reflective world instead.\n *\n *         Create by passing in a classloader, message handler\n */\npublic class LTWWorld extends BcelWorld implements IReflectionWorld {\n\n\tprivate AnnotationFinder annotationFinder;\n\tprivate IWeavingContext weavingContext;\n\tprivate String classLoaderString;\n\n\tprivate String classLoaderParentString;\n\n\tprotected final static Class concurrentMapClass;\n\n\tprivate static final boolean ShareBootstrapTypes = false;\n\tprotected static Map/* <String, WeakReference<ReflectionBasedReferenceTypeDelegate>> */bootstrapTypes;\n\n\tstatic {\n\t\tif (ShareBootstrapTypes) {\n\t\t\tconcurrentMapClass = makeConcurrentMapClass();\n\t\t\tbootstrapTypes = makeConcurrentMap();\n\t\t} else {\n\t\t\tconcurrentMapClass = null;\n\t\t}\n\t}\n\n\t/**\n\t * Build a World from a ClassLoader, for LTW support\n\t */\n\tpublic LTWWorld(ClassLoader loader, IWeavingContext weavingContext, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {\n\t\tsuper(loader, handler, xrefHandler);\n\t\tthis.weavingContext = weavingContext;\n\t\ttry {\n\t\t\tclassLoaderString = loader.toString();\n\t\t} catch (Throwable t) {\n\t\t\t// Possibly some state in the loader isn't initialized but is used in the toString()\n\t\t\tclassLoaderString = loader.getClass().getName()+\":\"+Integer.toString(System.identityHashCode(loader));\n\t\t}\n\t\tclassLoaderParentString = (loader.getParent() == null ? \"<NullParent>\" : loader.getParent().toString());\n\t\tsetBehaveInJava5Way(true);\n\t\tannotationFinder = ReflectionWorld.makeAnnotationFinderIfAny(loader, this);\n\t}\n\n\tpublic ClassLoader getClassLoader() {\n\t\treturn weavingContext.getClassLoader();\n\t}\n\n\t// TEST\n\t// this is probably easier: just mark anything loaded while loading aspects as not\n\t// expendible... it also fixes a possible bug whereby non-rewoven aspects are deemed expendible\n\t// <exclude within=\"org.foo.aspects..*\"/>\n\t// protected boolean isExpendable(ResolvedType type) {\n\t// return ((type != null) && !loadingAspects && !type.isAspect() && (!type\n\t// .isPrimitiveType()));\n\t// }\n\n\t/**\n\t * Override\n\t */\n\t@Override\n\tprotected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {\n\n\t\t// use reflection delegates for all bootstrap types\n\t\tReferenceTypeDelegate bootstrapLoaderDelegate = resolveIfBootstrapDelegate(ty);\n\t\tif (bootstrapLoaderDelegate != null) {\n\t\t\treturn bootstrapLoaderDelegate;\n\t\t}\n\n\t\treturn super.resolveDelegate(ty);\n\t}\n\n\tprotected ReferenceTypeDelegate resolveIfBootstrapDelegate(ReferenceType ty) {\n\t\t// first check for anything available in the bootstrap loader: these types are just defined from that without allowing\n\t\t// nondelegation\n\t\t// if (!ShareBootstrapTypes) return null;\n\t\t// String name = ty.getName();\n\t\t// Reference bootRef = (Reference) bootstrapTypes.get(name);\n\t\t// if (bootRef != null) {\n\t\t// ReferenceTypeDelegate rtd = (ReferenceTypeDelegate) bootRef.get();\n\t\t// if (rtd != null) {\n\t\t// return rtd;\n\t\t// }\n\t\t// }\n\t\t//\n\t\t// char fc = name.charAt(0);\n\t\t// if (fc == 'j' || fc == 'c' || fc == 'o' || fc == 's') { // cheaper than imminent string startsWith tests\n\t\t// if (name.startsWith(\"java\") || name.startsWith(\"com.sun.\") || name.startsWith(\"org.w3c\") ||\n\t\t// name.startsWith(\"sun.\") || name.startsWith(\"org.omg\")) {\n\t\t// ReferenceTypeDelegate bootstrapLoaderDelegate = resolveReflectionTypeDelegate(ty, null);\n\t\t// if (bootstrapLoaderDelegate != null) {\n\t\t// // it's always fine to load these bytes: there's no weaving into them\n\t\t// // and since the class isn't initialized, all we are doing at this point is loading the bytes\n\t\t// // processedRefTypes.put(ty, this); // has no effect - and probably too aggressive if we did store\n\t\t// // these in the type map\n\t\t//\n\t\t// // should we share these, like we do the BCEL delegates?\n\t\t// bootstrapTypes.put(ty.getName(), new WeakReference(bootstrapLoaderDelegate));\n\t\t// }\n\t\t// return bootstrapLoaderDelegate;\n\t\t// }\n\t\t// }\n\t\treturn null;\n\t}\n\n\t/**\n\t * Helper method to resolve the delegate from the reflection delegate factory.\n\t */\n\tprivate ReferenceTypeDelegate resolveReflectionTypeDelegate(ReferenceType ty, ClassLoader resolutionLoader) {\n\t\tReferenceTypeDelegate res = ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ty, this, resolutionLoader);\n\t\treturn res;\n\t}\n\n\t/**\n\t * Remove this class from the typeMap. Call back to be made from a publishing class loader The class loader should, ideally,\n\t * make this call on each not yet working\n\t *\n\t * @param clazz\n\t */\n\tpublic void loadedClass(Class clazz) {\n\t}\n\n\tprivate static final long serialVersionUID = 1;\n\n\tpublic AnnotationFinder getAnnotationFinder() {\n\t\treturn this.annotationFinder;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see org.aspectj.weaver.reflect.IReflectionWorld#resolve(java.lang.Class)\n\t */\n\tpublic ResolvedType resolve(Class aClass) {\n\t\treturn ReflectionWorld.resolve(this, aClass);\n\t}\n\n\tprivate static Map<?, ?> makeConcurrentMap() {\n\t\tif (concurrentMapClass != null) {\n\t\t\ttry {\n\t\t\t\treturn (Map) concurrentMapClass.getDeclaredConstructor().newInstance();\n\t\t\t} catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ignored) {}\n\t\t\t// fall through if exceptions\n\t\t}\n\t\treturn Collections.synchronizedMap(new HashMap<>());\n\t}\n\n\tprivate static Class<?> makeConcurrentMapClass() {\n\t\tString betterChoices[] = { \"java.util.concurrent.ConcurrentHashMap\",\n\t\t\t\t\"edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap\",\n\t\t\t\t\"EDU.oswego.cs.dl.util.concurrent.ConcurrentHashMap\" };\n\t\tfor (String betterChoice : betterChoices) {\n\t\t\ttry {\n\t\t\t\treturn Class.forName(betterChoice);\n\t\t\t} catch (ClassNotFoundException cnfe) {\n\t\t\t\t// try the next one\n\t\t\t} catch (SecurityException se) {\n\t\t\t\t// you get one of these if you dare to try to load an undefined class in a\n\t\t\t\t// package starting with java like java.util.concurrent\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isRunMinimalMemory() {\n\t\tif (isRunMinimalMemorySet()) {\n\t\t\treturn super.isRunMinimalMemory();\n\t\t}\n\t\treturn false;\n\t}\n\n\t// One type is completed at a time, if multiple need doing then they\n\t// are queued up\n\tprivate boolean typeCompletionInProgress = false;\n\tprivate List<ResolvedType> typesForCompletion = new ArrayList<>();\n\n\t@Override\n\tprotected void completeBinaryType(ResolvedType ret) {\n\t\tif (isLocallyDefined(ret.getName())) {\n\t\t\tif (typeCompletionInProgress) {\n\t\t\t\ttypesForCompletion.add(ret);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\ttypeCompletionInProgress = true;\n\t\t\t\t\tcompleteHierarchyForType(ret);\n\t\t\t\t} finally {\n\t\t\t\t\ttypeCompletionInProgress = false;\n\t\t\t\t}\n\t\t\t\twhile (typesForCompletion.size() != 0) {\n\t\t\t\t\tResolvedType rt = typesForCompletion.get(0);\n\t\t\t\t\tcompleteHierarchyForType(rt);\n\t\t\t\t\ttypesForCompletion.remove(0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ret.needsModifiableDelegate()) {\n\t\t\t\tret = completeNonLocalType(ret);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void completeHierarchyForType(ResolvedType ret) {\n\t\tgetLint().typeNotExposedToWeaver.setSuppressed(true);\n\t\tweaveInterTypeDeclarations(ret);\n\t\tgetLint().typeNotExposedToWeaver.setSuppressed(false);\n\t}\n\n\tprotected boolean needsCompletion() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isLocallyDefined(String classname) {\n\t\treturn weavingContext.isLocallyDefined(classname);\n\t}\n\n\tprotected ResolvedType completeNonLocalType(ResolvedType ret) {\n\t\tif (ret.isMissing()) {\n\t\t\treturn ret; // who knows ?!?\n\t\t}\n\t\tResolvedType toResolve = ret;\n\t\tif (ret.isParameterizedType() || ret.isGenericType()) {\n\t\t\ttoResolve = toResolve.getGenericType();\n\t\t}\n\t\tReferenceTypeDelegate rtd = resolveReflectionTypeDelegate((ReferenceType) toResolve, getClassLoader());\n\t\t((ReferenceType) ret).setDelegate(rtd);\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void storeClass(JavaClass clazz) {\n\t\tensureRepositorySetup();\n\t\tdelegate.storeClass(clazz);\n\t}\n\n\t@Override\n\tpublic void accept(IVisitor visitor) {\n\t\tvisitor.visitObject(\"Class loader:\");\n\t\tvisitor.visitObject(classLoaderString);\n\t\tvisitor.visitObject(\"Class loader parent:\");\n\t\tvisitor.visitObject(classLoaderParentString);\n\t\tsuper.accept(visitor);\n\t}\n\n\tpublic boolean isLoadtimeWeaving() {\n\t\treturn true;\n\t}\n\n}\n",
    "size": 9626
  },
  {
    "file_id": "F52",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/model/AsmRelationshipProvider.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.model;\n\nimport java.io.File;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.aspectj.asm.AsmManager;\nimport org.aspectj.asm.IHierarchy;\nimport org.aspectj.asm.IProgramElement;\nimport org.aspectj.asm.IRelationship;\nimport org.aspectj.asm.IRelationshipMap;\nimport org.aspectj.asm.internal.HandleProviderDelimiter;\nimport org.aspectj.asm.internal.ProgramElement;\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.bridge.SourceLocation;\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.Checker;\nimport org.aspectj.weaver.Lint;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.NewParentTypeMunger;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedPointcutDefinition;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ResolvedTypeMunger;\nimport org.aspectj.weaver.ResolvedTypeMunger.Kind;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelShadow;\nimport org.aspectj.weaver.bcel.BcelTypeMunger;\nimport org.aspectj.weaver.patterns.DeclareErrorOrWarning;\nimport org.aspectj.weaver.patterns.DeclareParents;\nimport org.aspectj.weaver.patterns.Pointcut;\nimport org.aspectj.weaver.patterns.TypePatternList;\n\npublic class AsmRelationshipProvider {\n\n\tpublic static final String ADVISES = \"advises\";\n\tpublic static final String ADVISED_BY = \"advised by\";\n\tpublic static final String DECLARES_ON = \"declares on\";\n\tpublic static final String DECLAREDY_BY = \"declared by\";\n\tpublic static final String SOFTENS = \"softens\";\n\tpublic static final String SOFTENED_BY = \"softened by\";\n\tpublic static final String MATCHED_BY = \"matched by\";\n\tpublic static final String MATCHES_DECLARE = \"matches declare\";\n\tpublic static final String INTER_TYPE_DECLARES = \"declared on\";\n\tpublic static final String INTER_TYPE_DECLARED_BY = \"aspect declarations\";\n\n\tpublic static final String ANNOTATES = \"annotates\";\n\tpublic static final String ANNOTATED_BY = \"annotated by\";\n\n\t// public static final String REMOVES_ANNOTATION = \"removes annotation\";\n\t// public static final String ANNOTATION_REMOVED_BY = \"annotated removed by\";\n\n\t/**\n\t * Add a relationship for a declare error or declare warning\n\t */\n\tpublic static void addDeclareErrorOrWarningRelationship(AsmManager model, Shadow affectedShadow, Checker deow) {\n\t\tif (model == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (affectedShadow.getSourceLocation() == null || deow.getSourceLocation() == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (World.createInjarHierarchy) {\n\t\t\tcreateHierarchyForBinaryAspect(model, deow);\n\t\t}\n\n\t\tIProgramElement targetNode = getNode(model, affectedShadow);\n\t\tif (targetNode == null) {\n\t\t\treturn;\n\t\t}\n\t\tString targetHandle = targetNode.getHandleIdentifier();\n\t\tif (targetHandle == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIProgramElement sourceNode = model.getHierarchy().findElementForSourceLine(deow.getSourceLocation());\n\t\tString sourceHandle = sourceNode.getHandleIdentifier();\n\t\tif (sourceHandle == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIRelationshipMap relmap = model.getRelationshipMap();\n\t\tIRelationship foreward = relmap.get(sourceHandle, IRelationship.Kind.DECLARE, MATCHED_BY, false, true);\n\t\tforeward.addTarget(targetHandle);\n\n\t\tIRelationship back = relmap.get(targetHandle, IRelationship.Kind.DECLARE, MATCHES_DECLARE, false, true);\n\t\tif (back != null && back.getTargets() != null) {\n\t\t\tback.addTarget(sourceHandle);\n\t\t}\n\t\tif (sourceNode.getSourceLocation() != null) {\n\t\t\tmodel.addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());\n\t\t}\n\t}\n\n\tprivate static boolean isMixinRelated(ResolvedTypeMunger typeTransformer) {\n\t\tKind kind = typeTransformer.getKind();\n\t\treturn kind == ResolvedTypeMunger.MethodDelegate2 || kind == ResolvedTypeMunger.FieldHost\n\t\t\t\t|| (kind == ResolvedTypeMunger.Parent && ((NewParentTypeMunger) typeTransformer).isMixin());\n\t}\n\n\t/**\n\t * Add a relationship for a type transformation (declare parents, intertype method declaration, declare annotation on type).\n\t */\n\tpublic static void addRelationship(AsmManager model, ResolvedType onType, ResolvedTypeMunger typeTransformer,\n\t\t\tResolvedType originatingAspect) {\n\t\tif (model == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (World.createInjarHierarchy && isBinaryAspect(originatingAspect)) {\n\t\t\tcreateHierarchy(model, typeTransformer, originatingAspect);\n\t\t}\n\n\t\tif (originatingAspect.getSourceLocation() != null) {\n\t\t\tString sourceHandle = \"\";\n\t\t\tIProgramElement sourceNode = null;\n\t\t\tif (typeTransformer.getSourceLocation() != null && typeTransformer.getSourceLocation().getOffset() != -1\n\t\t\t\t\t&& !isMixinRelated(typeTransformer)) {\n\t\t\t\tsourceNode = model.getHierarchy().findElementForType(originatingAspect.getPackageName(),\n\t\t\t\t\t\toriginatingAspect.getClassName());\n\t\t\t\tIProgramElement closer = model.getHierarchy().findCloserMatchForLineNumber(sourceNode,\n\t\t\t\t\t\ttypeTransformer.getSourceLocation().getLine());\n\t\t\t\tif (closer != null) {\n\t\t\t\t\tsourceNode = closer;\n\t\t\t\t}\n\t\t\t\tif (sourceNode == null) {\n\t\t\t\t\t// This can be caused by the aspect defining the type munger actually being on the classpath and not the\n\t\t\t\t\t// inpath or aspectpath. Rather than NPE at the next line, let's have another go at faulting it in.\n\t\t\t\t\t// This inner loop is a small duplicate of the outer loop that attempts to find something closer than\n\t\t\t\t\t// the type declaration\n\t\t\t\t\tif (World.createInjarHierarchy) {\n\t\t\t\t\t\tcreateHierarchy(model, typeTransformer, originatingAspect);\n\t\t\t\t\t\tif (typeTransformer.getSourceLocation() != null && typeTransformer.getSourceLocation().getOffset() != -1\n\t\t\t\t\t\t\t\t&& !isMixinRelated(typeTransformer)) {\n\t\t\t\t\t\t\tsourceNode = model.getHierarchy().findElementForType(originatingAspect.getPackageName(),\n\t\t\t\t\t\t\t\t\toriginatingAspect.getClassName());\n\t\t\t\t\t\t\tIProgramElement closer2 = model.getHierarchy().findCloserMatchForLineNumber(sourceNode,\n\t\t\t\t\t\t\t\t\ttypeTransformer.getSourceLocation().getLine());\n\t\t\t\t\t\t\tif (closer2 != null) {\n\t\t\t\t\t\t\t\tsourceNode = closer2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsourceNode = model.getHierarchy().findElementForType(originatingAspect.getPackageName(),\n\t\t\t\t\t\t\t\t\toriginatingAspect.getClassName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsourceHandle = sourceNode.getHandleIdentifier();\n\t\t\t} else {\n\t\t\t\tsourceNode = model.getHierarchy().findElementForType(originatingAspect.getPackageName(),\n\t\t\t\t\t\toriginatingAspect.getClassName());\n\t\t\t\t// sourceNode =\n\t\t\t\t// asm.getHierarchy().findElementForSourceLine(originatingAspect\n\t\t\t\t// .getSourceLocation());\n\t\t\t\tsourceHandle = sourceNode.getHandleIdentifier();\n\t\t\t}\n\t\t\t// sourceNode =\n\t\t\t// asm.getHierarchy().findElementForType(originatingAspect\n\t\t\t// .getPackageName(),\n\t\t\t// originatingAspect.getClassName());\n\t\t\t// // sourceNode =\n\t\t\t// asm.getHierarchy().findElementForSourceLine(munger\n\t\t\t// .getSourceLocation());\n\t\t\t// sourceHandle =\n\t\t\t// asm.getHandleProvider().createHandleIdentifier(sourceNode);\n\t\t\tif (sourceHandle == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tString targetHandle = findOrFakeUpNode(model, onType);\n\t\t\tif (targetHandle == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tIRelationshipMap mapper = model.getRelationshipMap();\n\t\t\tIRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARES, false,\n\t\t\t\t\ttrue);\n\t\t\tforeward.addTarget(targetHandle);\n\n\t\t\tIRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARED_BY, false,\n\t\t\t\t\ttrue);\n\t\t\tback.addTarget(sourceHandle);\n\t\t\tif (sourceNode != null && sourceNode.getSourceLocation() != null) {\n\t\t\t\t// May have been a bug in the compiled aspect - so it didn't get put in the model\n\t\t\t\tmodel.addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String findOrFakeUpNode(AsmManager model, ResolvedType onType) {\n\t\tIHierarchy hierarchy = model.getHierarchy();\n\t\tISourceLocation sourceLocation = onType.getSourceLocation();\n\t\tString canonicalFilePath = model.getCanonicalFilePath(sourceLocation.getSourceFile());\n\t\tint lineNumber = sourceLocation.getLine();\n\t\t// Find the relevant source file node first\n\t\tIProgramElement node = hierarchy.findNodeForSourceFile(hierarchy.getRoot(), canonicalFilePath);\n\t\tif (node == null) {\n\t\t\t// Does not exist in the model - probably an inpath\n\t\t\tString bpath = onType.getBinaryPath();\n\t\t\tif (bpath == null) {\n\t\t\t\treturn model.getHandleProvider().createHandleIdentifier(createFileStructureNode(model, canonicalFilePath));\n\t\t\t} else {\n\t\t\t\tIProgramElement programElement = model.getHierarchy().getRoot();\n\t\t\t\t// =Foo/,<g(G.class[G\n\t\t\t\tStringBuilder phantomHandle = new StringBuilder();\n\n\t\t\t\t// =Foo\n\t\t\t\tphantomHandle.append(programElement.getHandleIdentifier());\n\n\t\t\t\t// /, - the comma is a 'well defined char' that means inpath\n\t\t\t\tphantomHandle.append(HandleProviderDelimiter.PACKAGEFRAGMENTROOT.getDelimiter()).append(\n\t\t\t\t\t\tHandleProviderDelimiter.PHANTOM.getDelimiter());\n\n\t\t\t\tint pos = bpath.indexOf('!');\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\t// jar or dir\n\t\t\t\t\tString jarPath = bpath.substring(0, pos);\n\t\t\t\t\tString element = model.getHandleElementForInpath(jarPath);\n\t\t\t\t\tif (element != null) {\n\t\t\t\t\t\tphantomHandle.append(element);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// <g\n\t\t\t\tString packageName = onType.getPackageName();\n\t\t\t\tphantomHandle.append(HandleProviderDelimiter.PACKAGEFRAGMENT.getDelimiter()).append(packageName);\n\n\t\t\t\t// (G.class\n\t\t\t\t// could fix the binary path to only be blah.class bit\n\t\t\t\tint dotClassPosition = bpath.lastIndexOf(\".class\");// what to do if -1\n\t\t\t\tif (dotClassPosition == -1) {\n\t\t\t\t\tphantomHandle.append(HandleProviderDelimiter.CLASSFILE.getDelimiter()).append(\"UNKNOWN.class\");\n\t\t\t\t} else {\n\t\t\t\t\tint startPosition = dotClassPosition;\n\t\t\t\t\tchar ch;\n\t\t\t\t\twhile (startPosition > 0 && ((ch = bpath.charAt(startPosition)) != '/' && ch != '\\\\' && ch != '!')) {\n\t\t\t\t\t\tstartPosition--;\n\t\t\t\t\t}\n\t\t\t\t\tString classFile = bpath.substring(startPosition + 1, dotClassPosition + 6);\n\t\t\t\t\tphantomHandle.append(HandleProviderDelimiter.CLASSFILE.getDelimiter()).append(classFile);\n\t\t\t\t}\n\n\t\t\t\t// [G\n\t\t\t\tphantomHandle.append(HandleProviderDelimiter.TYPE.getDelimiter()).append(onType.getClassName());\n\n\t\t\t\treturn phantomHandle.toString();\n\t\t\t}\n\t\t} else {\n\t\t\t// Check if there is a more accurate child node of that source file node:\n\t\t\tIProgramElement closernode = hierarchy.findCloserMatchForLineNumber(node, lineNumber);\n\t\t\tif (closernode == null) {\n\t\t\t\treturn node.getHandleIdentifier();\n\t\t\t} else {\n\t\t\t\treturn closernode.getHandleIdentifier();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static IProgramElement createFileStructureNode(AsmManager asm, String sourceFilePath) {\n\t\t// SourceFilePath might have originated on windows on linux...\n\t\tint lastSlash = sourceFilePath.lastIndexOf('\\\\');\n\t\tif (lastSlash == -1) {\n\t\t\tlastSlash = sourceFilePath.lastIndexOf('/');\n\t\t}\n\t\t// '!' is used like in URLs \"c:/blahblah/X.jar!a/b.class\"\n\t\tint i = sourceFilePath.lastIndexOf('!');\n\t\tint j = sourceFilePath.indexOf(\".class\");\n\t\tif (i > lastSlash && i != -1 && j != -1) {\n\t\t\t// we are a binary aspect in the default package\n\t\t\tlastSlash = i;\n\t\t}\n\t\tString fileName = sourceFilePath.substring(lastSlash + 1);\n\t\tIProgramElement fileNode = new ProgramElement(asm, fileName, IProgramElement.Kind.FILE_JAVA, new SourceLocation(new File(\n\t\t\t\tsourceFilePath), 1, 1), 0, null, null);\n\t\t// fileNode.setSourceLocation();\n\t\tfileNode.addChild(IHierarchy.NO_STRUCTURE);\n\t\treturn fileNode;\n\t}\n\n\tprivate static boolean isBinaryAspect(ResolvedType aspect) {\n\t\treturn aspect.getBinaryPath() != null;\n\t}\n\n\t/**\n\t * Returns the binarySourceLocation for the given sourcelocation. This isn't cached because it's used when faulting in the\n\t * binary nodes and is called with ISourceLocations for all advice, pointcuts and deows contained within the\n\t * resolvedDeclaringAspect.\n\t */\n\tprivate static ISourceLocation getBinarySourceLocation(ResolvedType aspect, ISourceLocation sl) {\n\t\tif (sl == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString sourceFileName = null;\n\t\tif (aspect instanceof ReferenceType) {\n\t\t\tString s = ((ReferenceType) aspect).getDelegate().getSourcefilename();\n\t\t\tint i = s.lastIndexOf('/');\n\t\t\tif (i != -1) {\n\t\t\t\tsourceFileName = s.substring(i + 1);\n\t\t\t} else {\n\t\t\t\tsourceFileName = s;\n\t\t\t}\n\t\t}\n\t\tISourceLocation sLoc = new SourceLocation(getBinaryFile(aspect), sl.getLine(), sl.getEndLine(),\n\t\t\t\t((sl.getColumn() == 0) ? ISourceLocation.NO_COLUMN : sl.getColumn()), sl.getContext(), sourceFileName);\n\t\treturn sLoc;\n\t}\n\n\tprivate static ISourceLocation createSourceLocation(String sourcefilename, ResolvedType aspect, ISourceLocation sl) {\n\t\tISourceLocation sLoc = new SourceLocation(getBinaryFile(aspect), sl.getLine(), sl.getEndLine(),\n\t\t\t\t((sl.getColumn() == 0) ? ISourceLocation.NO_COLUMN : sl.getColumn()), sl.getContext(), sourcefilename);\n\t\treturn sLoc;\n\t}\n\n\tprivate static String getSourceFileName(ResolvedType aspect) {\n\t\tString sourceFileName = null;\n\t\tif (aspect instanceof ReferenceType) {\n\t\t\tString s = ((ReferenceType) aspect).getDelegate().getSourcefilename();\n\t\t\tint i = s.lastIndexOf('/');\n\t\t\tif (i != -1) {\n\t\t\t\tsourceFileName = s.substring(i + 1);\n\t\t\t} else {\n\t\t\t\tsourceFileName = s;\n\t\t\t}\n\t\t}\n\t\treturn sourceFileName;\n\t}\n\n\t/**\n\t * Returns the File with pathname to the class file, for example either C:\\temp\n\t * \\ajcSandbox\\workspace\\ajcTest16957.tmp\\simple.jar!pkg\\BinaryAspect.class if the class file is in a jar file, or\n\t * C:\\temp\\ajcSandbox\\workspace\\ajcTest16957.tmp!pkg\\BinaryAspect.class if the class file is in a directory\n\t */\n\tprivate static File getBinaryFile(ResolvedType aspect) {\n\t\tString s = aspect.getBinaryPath();\n\t\tFile f = aspect.getSourceLocation().getSourceFile();\n\t\t// Replace the source file suffix with .class\n\t\tint i = f.getPath().lastIndexOf('.');\n\t\tString path = null;\n\t\tif (i != -1) {\n\t\t\tpath = f.getPath().substring(0, i) + \".class\";\n\t\t} else {\n\t\t\tpath = f.getPath() + \".class\";\n\t\t}\n\t\treturn new File(s + \"!\" + path);\n\t}\n\n\t/**\n\t * Create a basic hierarchy to represent an aspect only available in binary (from the aspectpath).\n\t */\n\tprivate static void createHierarchy(AsmManager model, ResolvedTypeMunger typeTransformer, ResolvedType aspect) {\n\t\t// assert aspect != null;\n\n\t\t// Check if already defined in the model\n\t\t// IProgramElement filenode =\n\t\t// model.getHierarchy().findElementForType(aspect.getPackageName(),\n\t\t// aspect.getClassName());\n\t\t// SourceLine(typeTransformer.getSourceLocation());\n\t\tIProgramElement filenode = model.getHierarchy().findElementForSourceLine(typeTransformer.getSourceLocation());\n\t\tif (filenode == null) {\n\t\t\tif (typeTransformer.getKind() == ResolvedTypeMunger.MethodDelegate2\n\t\t\t\t\t|| typeTransformer.getKind() == ResolvedTypeMunger.FieldHost) {\n\t\t\t\t// not yet faulting these in\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// the call to findElementForSourceLine(ISourceLocation) returns a file\n\t\t// node\n\t\t// if it can't find a node in the hierarchy for the given\n\t\t// sourcelocation.\n\t\t// Therefore, if this is returned, we know we can't find one and have to\n\t\t// // continue to fault in the model.\n\t\t// if (filenode != null) { //\n\t\tif (!filenode.getKind().equals(IProgramElement.Kind.FILE_JAVA)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// create the class file node\n\t\tISourceLocation binLocation = getBinarySourceLocation(aspect, aspect.getSourceLocation());\n\t\tString f = getBinaryFile(aspect).getName();\n\t\tIProgramElement classFileNode = new ProgramElement(model, f, IProgramElement.Kind.FILE, binLocation, 0, null, null);\n\n\t\t// create package ipe if one exists....\n\t\tIProgramElement root = model.getHierarchy().getRoot();\n\t\tIProgramElement binaries = model.getHierarchy().findElementForLabel(root, IProgramElement.Kind.SOURCE_FOLDER, \"binaries\");\n\t\tif (binaries == null) {\n\t\t\tbinaries = new ProgramElement(model, \"binaries\", IProgramElement.Kind.SOURCE_FOLDER, new ArrayList<>());\n\t\t\troot.addChild(binaries);\n\t\t}\n\t\t// if (aspect.getPackageName() != null) {\n\t\tString packagename = aspect.getPackageName() == null ? \"\" : aspect.getPackageName();\n\t\t// check that there doesn't already exist a node with this name\n\t\tIProgramElement pkgNode = model.getHierarchy().findElementForLabel(binaries, IProgramElement.Kind.PACKAGE, packagename);\n\t\t// note packages themselves have no source location\n\t\tif (pkgNode == null) {\n\t\t\tpkgNode = new ProgramElement(model, packagename, IProgramElement.Kind.PACKAGE, new ArrayList<>());\n\t\t\tbinaries.addChild(pkgNode);\n\t\t\tpkgNode.addChild(classFileNode);\n\t\t} else {\n\t\t\t// need to add it first otherwise the handle for classFileNode\n\t\t\t// may not be generated correctly if it uses information from\n\t\t\t// it's parent node\n\t\t\tpkgNode.addChild(classFileNode);\n\t\t\tfor (IProgramElement element: pkgNode.getChildren()) {\n\t\t\t\tif (!element.equals(classFileNode) && element.getHandleIdentifier().equals(classFileNode.getHandleIdentifier())) {\n\t\t\t\t\t// already added the classfile so have already\n\t\t\t\t\t// added the structure for this aspect\n\t\t\t\t\tpkgNode.removeChild(classFileNode);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// } else {\n\t\t// // need to add it first otherwise the handle for classFileNode\n\t\t// // may not be generated correctly if it uses information from\n\t\t// // it's parent node\n\t\t// root.addChild(classFileNode);\n\t\t// for (Iterator iter = root.getChildren().iterator(); iter.hasNext();)\n\t\t// {\n\t\t// IProgramElement element = (IProgramElement) iter.next();\n\t\t// if (!element.equals(classFileNode) &&\n\t\t// element.getHandleIdentifier().equals\n\t\t// (classFileNode.getHandleIdentifier())) {\n\t\t// // already added the sourcefile so have already\n\t\t// // added the structure for this aspect\n\t\t// root.removeChild(classFileNode);\n\t\t// return;\n\t\t// }\n\t\t// }\n\t\t// }\n\n\t\t// add and create empty import declaration ipe\n\t\t// no import container for binary type - 265693\n\t\t// classFileNode.addChild(new ProgramElement(model, \"import declarations\", IProgramElement.Kind.IMPORT_REFERENCE, null, 0,\n\t\t// null, null));\n\n\t\t// add and create aspect ipe\n\t\tIProgramElement aspectNode = new ProgramElement(model, aspect.getSimpleName(), IProgramElement.Kind.ASPECT,\n\t\t\t\tgetBinarySourceLocation(aspect, aspect.getSourceLocation()), aspect.getModifiers(), null, null);\n\t\tclassFileNode.addChild(aspectNode);\n\n\t\taddChildNodes(model, aspect, aspectNode, aspect.getDeclaredPointcuts());\n\n\t\taddChildNodes(model, aspect, aspectNode, aspect.getDeclaredAdvice());\n\t\taddChildNodes(model, aspect, aspectNode, aspect.getDeclares());\n\t\taddChildNodes(model, aspect, aspectNode, aspect.getTypeMungers());\n\t}\n\n\t/**\n\t * Adds a declare annotation relationship, sometimes entities don't have source locs (methods/fields) so use other variants of\n\t * this method if that is the case as they will look the entities up in the structure model.\n\t */\n\tpublic static void addDeclareAnnotationRelationship(AsmManager model, ISourceLocation declareAnnotationLocation,\n\t\t\tISourceLocation annotatedLocation, boolean isRemove) {\n\t\tif (model == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIProgramElement sourceNode = model.getHierarchy().findElementForSourceLine(declareAnnotationLocation);\n\t\tString sourceHandle = sourceNode.getHandleIdentifier();\n\t\tif (sourceHandle == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIProgramElement targetNode = model.getHierarchy().findElementForSourceLine(annotatedLocation);\n\t\tString targetHandle = targetNode.getHandleIdentifier();\n\t\tif (targetHandle == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIRelationshipMap mapper = model.getRelationshipMap();\n\t\t// if (isRemove) {\n\t\t// IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, REMOVES_ANNOTATION, false,\n\t\t// true);\n\t\t// foreward.addTarget(targetHandle);\n\t\t//\n\t\t// IRelationship back = mapper\n\t\t// .get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATION_REMOVED_BY, false, true);\n\t\t// back.addTarget(sourceHandle);\n\t\t// if (sourceNode.getSourceLocation() != null) {\n\t\t// model.addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());\n\t\t// }\n\t\t// } else {\n\t\tIRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES, false, true);\n\t\tforeward.addTarget(targetHandle);\n\n\t\tIRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY, false, true);\n\t\tback.addTarget(sourceHandle);\n\t\tif (sourceNode.getSourceLocation() != null) {\n\t\t\tmodel.addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());\n\t\t}\n\t\t// }\n\t}\n\n\t/**\n\t * Creates the hierarchy for binary aspects\n\t */\n\tpublic static void createHierarchyForBinaryAspect(AsmManager asm, ShadowMunger munger) {\n\t\tif (!munger.isBinary()) {\n\t\t\treturn;\n\t\t}\n\n\t\tIProgramElement sourceFileNode = asm.getHierarchy().findElementForSourceLine(munger.getSourceLocation());\n\t\t// the call to findElementForSourceLine(ISourceLocation) returns a file\n\t\t// node if it can't find a node in the hierarchy for the given sourcelocation.\n\t\t// Therefore, if this is returned, we know we can't find one and have to\n\t\t// continue to fault in the model.\n\t\tif (!sourceFileNode.getKind().equals(IProgramElement.Kind.FILE_JAVA)) {\n\t\t\treturn;\n\t\t}\n\n\t\tResolvedType aspect = munger.getDeclaringType();\n\n\t\t// create the class file node\n\t\tIProgramElement classFileNode = new ProgramElement(asm, sourceFileNode.getName(), IProgramElement.Kind.FILE,\n\t\t\t\tmunger.getBinarySourceLocation(aspect.getSourceLocation()), 0, null, null);\n\n\t\t// create package ipe if one exists....\n\t\tIProgramElement root = asm.getHierarchy().getRoot();\n\t\tIProgramElement binaries = asm.getHierarchy().findElementForLabel(root, IProgramElement.Kind.SOURCE_FOLDER, \"binaries\");\n\t\tif (binaries == null) {\n\t\t\tbinaries = new ProgramElement(asm, \"binaries\", IProgramElement.Kind.SOURCE_FOLDER, new ArrayList<>());\n\t\t\troot.addChild(binaries);\n\t\t}\n\t\t// if (aspect.getPackageName() != null) {\n\t\tString packagename = aspect.getPackageName() == null ? \"\" : aspect.getPackageName();\n\t\t// check that there doesn't already exist a node with this name\n\t\tIProgramElement pkgNode = asm.getHierarchy().findElementForLabel(binaries, IProgramElement.Kind.PACKAGE, packagename);\n\t\t// note packages themselves have no source location\n\t\tif (pkgNode == null) {\n\t\t\tpkgNode = new ProgramElement(asm, packagename, IProgramElement.Kind.PACKAGE, new ArrayList<>());\n\t\t\tbinaries.addChild(pkgNode);\n\t\t\tpkgNode.addChild(classFileNode);\n\t\t} else {\n\t\t\t// need to add it first otherwise the handle for classFileNode\n\t\t\t// may not be generated correctly if it uses information from\n\t\t\t// it's parent node\n\t\t\tpkgNode.addChild(classFileNode);\n\t\t\tfor (IProgramElement element: pkgNode.getChildren()) {\n\t\t\t\tif (!element.equals(classFileNode) && element.getHandleIdentifier().equals(classFileNode.getHandleIdentifier())) {\n\t\t\t\t\t// already added the classfile so have already\n\t\t\t\t\t// added the structure for this aspect\n\t\t\t\t\tpkgNode.removeChild(classFileNode);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// } else {\n\t\t// // need to add it first otherwise the handle for classFileNode\n\t\t// // may not be generated correctly if it uses information from\n\t\t// // it's parent node\n\t\t// root.addChild(classFileNode);\n\t\t// for (Iterator iter = root.getChildren().iterator(); iter.hasNext();)\n\t\t// {\n\t\t// IProgramElement element = (IProgramElement) iter.next();\n\t\t// if (!element.equals(classFileNode) &&\n\t\t// element.getHandleIdentifier().equals\n\t\t// (classFileNode.getHandleIdentifier())) {\n\t\t// // already added the sourcefile so have already\n\t\t// // added the structure for this aspect\n\t\t// root.removeChild(classFileNode);\n\t\t// return;\n\t\t// }\n\t\t// }\n\t\t// }\n\n\t\t// add and create empty import declaration ipe\n\t\t// classFileNode.addChild(new ProgramElement(asm, \"import declarations\", IProgramElement.Kind.IMPORT_REFERENCE, null, 0,\n\t\t// null,\n\t\t// null));\n\n\t\t// add and create aspect ipe\n\t\tIProgramElement aspectNode = new ProgramElement(asm, aspect.getSimpleName(), IProgramElement.Kind.ASPECT,\n\t\t\t\tmunger.getBinarySourceLocation(aspect.getSourceLocation()), aspect.getModifiers(), null, null);\n\t\tclassFileNode.addChild(aspectNode);\n\n\t\tString sourcefilename = getSourceFileName(aspect);\n\t\taddPointcuts(asm, sourcefilename, aspect, aspectNode, aspect.getDeclaredPointcuts());\n\t\taddChildNodes(asm, aspect, aspectNode, aspect.getDeclaredAdvice());\n\t\taddChildNodes(asm, aspect, aspectNode, aspect.getDeclares());\n\t\taddChildNodes(asm, aspect, aspectNode, aspect.getTypeMungers());\n\n\t}\n\n\tprivate static void addPointcuts(AsmManager model, String sourcefilename, ResolvedType aspect,\n\t\t\tIProgramElement containingAspect, ResolvedMember[] pointcuts) {\n\t\tfor (ResolvedMember pointcut : pointcuts) {\n\t\t\tif (pointcut instanceof ResolvedPointcutDefinition) {\n\t\t\t\tResolvedPointcutDefinition rpcd = (ResolvedPointcutDefinition) pointcut;\n\t\t\t\tPointcut p = rpcd.getPointcut();\n\t\t\t\tISourceLocation sLoc = (p == null ? null : p.getSourceLocation());\n\t\t\t\tif (sLoc == null) {\n\t\t\t\t\tsLoc = rpcd.getSourceLocation();\n\t\t\t\t}\n\t\t\t\tISourceLocation pointcutLocation = (sLoc == null ? null : createSourceLocation(sourcefilename, aspect, sLoc));\n\t\t\t\tProgramElement pointcutElement = new ProgramElement(model, pointcut.getName(), IProgramElement.Kind.POINTCUT,\n\t\t\t\t\t\tpointcutLocation, pointcut.getModifiers(), NO_COMMENT, Collections.<IProgramElement>emptyList());\n\t\t\t\tcontainingAspect.addChild(pointcutElement);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static final String NO_COMMENT = null;\n\n\tprivate static void addChildNodes(AsmManager asm, ResolvedType aspect, IProgramElement parent, ResolvedMember[] children) {\n\t\tfor (ResolvedMember pcd : children) {\n\t\t\tif (pcd instanceof ResolvedPointcutDefinition) {\n\t\t\t\tResolvedPointcutDefinition rpcd = (ResolvedPointcutDefinition) pcd;\n\t\t\t\tPointcut p = rpcd.getPointcut();\n\t\t\t\tISourceLocation sLoc = (p == null ? null : p.getSourceLocation());\n\t\t\t\tif (sLoc == null) {\n\t\t\t\t\tsLoc = rpcd.getSourceLocation();\n\t\t\t\t}\n\t\t\t\tparent.addChild(new ProgramElement(asm, pcd.getName(), IProgramElement.Kind.POINTCUT, getBinarySourceLocation(\n\t\t\t\t\t\taspect, sLoc), pcd.getModifiers(), null, Collections.<IProgramElement>emptyList()));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void addChildNodes(AsmManager asm, ResolvedType aspect, IProgramElement parent, Collection<?> children) {\n\t\tint deCtr = 1;\n\t\tint dwCtr = 1;\n\t\tfor (Object element: children) {\n\t\t\tif (element instanceof DeclareErrorOrWarning) {\n\t\t\t\tDeclareErrorOrWarning decl = (DeclareErrorOrWarning) element;\n\t\t\t\tint counter = 0;\n\t\t\t\tif (decl.isError()) {\n\t\t\t\t\tcounter = deCtr++;\n\t\t\t\t} else {\n\t\t\t\t\tcounter = dwCtr++;\n\t\t\t\t}\n\t\t\t\tparent.addChild(createDeclareErrorOrWarningChild(asm, aspect, decl, counter));\n\t\t\t} else if (element instanceof Advice) {\n\t\t\t\tAdvice advice = (Advice) element;\n\t\t\t\tparent.addChild(createAdviceChild(asm, advice));\n\t\t\t} else if (element instanceof DeclareParents) {\n\t\t\t\tparent.addChild(createDeclareParentsChild(asm, (DeclareParents) element));\n\t\t\t} else if (element instanceof BcelTypeMunger) {\n\t\t\t\tIProgramElement newChild = createIntertypeDeclaredChild(asm, aspect, (BcelTypeMunger) element);\n\t\t\t\t// newChild==null means it is something that could not be handled by createIntertypeDeclaredChild()\n\t\t\t\tif (newChild != null) {\n\t\t\t\t\tparent.addChild(newChild);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// private static IProgramElement\n\t// createDeclareErrorOrWarningChild(AsmManager asm, ShadowMunger munger,\n\t// DeclareErrorOrWarning decl, int count) {\n\t// IProgramElement deowNode = new ProgramElement(asm, decl.getName(),\n\t// decl.isError() ? IProgramElement.Kind.DECLARE_ERROR\n\t// : IProgramElement.Kind.DECLARE_WARNING,\n\t// munger.getBinarySourceLocation(decl.getSourceLocation()), decl\n\t// .getDeclaringType().getModifiers(), null, null);\n\t// deowNode.setDetails(\"\\\"\" +\n\t// AsmRelationshipUtils.genDeclareMessage(decl.getMessage()) + \"\\\"\");\n\t// if (count != -1) {\n\t// deowNode.setBytecodeName(decl.getName() + \"_\" + count);\n\t// }\n\t// return deowNode;\n\t// }\n\n\tprivate static IProgramElement createDeclareErrorOrWarningChild(AsmManager model, ResolvedType aspect,\n\t\t\tDeclareErrorOrWarning decl, int count) {\n\t\tIProgramElement deowNode = new ProgramElement(model, decl.getName(), decl.isError() ? IProgramElement.Kind.DECLARE_ERROR\n\t\t\t\t: IProgramElement.Kind.DECLARE_WARNING, getBinarySourceLocation(aspect, decl.getSourceLocation()), decl\n\t\t\t\t.getDeclaringType().getModifiers(), null, null);\n\t\tdeowNode.setDetails(\"\\\"\" + AsmRelationshipUtils.genDeclareMessage(decl.getMessage()) + \"\\\"\");\n\t\tif (count != -1) {\n\t\t\tdeowNode.setBytecodeName(decl.getName() + \"_\" + count);\n\t\t}\n\t\treturn deowNode;\n\t}\n\n\tprivate static IProgramElement createAdviceChild(AsmManager model, Advice advice) {\n\t\tIProgramElement adviceNode = new ProgramElement(model, advice.getKind().getName(), IProgramElement.Kind.ADVICE,\n\t\t\t\tadvice.getBinarySourceLocation(advice.getSourceLocation()), advice.getSignature().getModifiers(), null,\n\t\t\t\tCollections.<IProgramElement>emptyList());\n\t\tadviceNode.setDetails(AsmRelationshipUtils.genPointcutDetails(advice.getPointcut()));\n\t\tadviceNode.setBytecodeName(advice.getSignature().getName());\n\t\treturn adviceNode;\n\t}\n\n\t/**\n\t * Half baked implementation - will need completing if we go down this route rather than replacing it all for binary aspects.\n\t * Doesn't attempt to get parameter names correct - they may have been lost during (de)serialization of the munger, but the\n\t * member could still be located so they might be retrievable.\n\t */\n\tprivate static IProgramElement createIntertypeDeclaredChild(AsmManager model, ResolvedType aspect, BcelTypeMunger itd) {\n\t\tResolvedTypeMunger rtMunger = itd.getMunger();\n\n\t\tResolvedMember sig = rtMunger.getSignature();\n\t\tKind kind = rtMunger.getKind();\n\t\tif (kind == ResolvedTypeMunger.Field) { // ITD FIELD\n\t\t\t// String name = rtMunger.getSignature().toString();\n\t\t\tString name = sig.getDeclaringType().getClassName() + \".\" + sig.getName();\n\t\t\tif (name.contains(\"$\")) {\n\t\t\t\tname = name.substring(name.indexOf(\"$\") + 1);\n\t\t\t}\n\t\t\tIProgramElement pe = new ProgramElement(model, name, IProgramElement.Kind.INTER_TYPE_FIELD, getBinarySourceLocation(\n\t\t\t\t\taspect, itd.getSourceLocation()), rtMunger.getSignature().getModifiers(), null, Collections.<IProgramElement>emptyList());\n\t\t\tpe.setCorrespondingType(sig.getReturnType().getName());\n\t\t\treturn pe;\n\t\t} else if (kind == ResolvedTypeMunger.Method) { // ITD\n\t\t\t// METHOD\n\t\t\tString name = sig.getDeclaringType().getClassName() + \".\" + sig.getName();\n\t\t\tif (name.contains(\"$\")) {\n\t\t\t\tname = name.substring(name.indexOf(\"$\") + 1);\n\t\t\t}\n\t\t\tIProgramElement pe = new ProgramElement(model, name, IProgramElement.Kind.INTER_TYPE_METHOD, getBinarySourceLocation(\n\t\t\t\t\taspect, itd.getSourceLocation()), rtMunger.getSignature().getModifiers(), null, Collections.<IProgramElement>emptyList());\n\t\t\tsetParams(pe, sig);\n\t\t\treturn pe;\n\t\t} else if (kind == ResolvedTypeMunger.Constructor) {\n\t\t\tString name = sig.getDeclaringType().getClassName() + \".\" + sig.getDeclaringType().getClassName();\n\t\t\tif (name.contains(\"$\")) {\n\t\t\t\tname = name.substring(name.indexOf(\"$\") + 1);\n\t\t\t}\n\t\t\tIProgramElement pe = new ProgramElement(model, name, IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,\n\t\t\t\t\tgetBinarySourceLocation(aspect, itd.getSourceLocation()), rtMunger.getSignature().getModifiers(), null,\n\t\t\t\t\tCollections.<IProgramElement>emptyList());\n\t\t\tsetParams(pe, sig);\n\t\t\treturn pe;\n\t\t\t// } else if (kind == ResolvedTypeMunger.MethodDelegate2) {\n\t\t\t// String name = sig.getDeclaringType().getClassName() + \".\" + sig.getName();\n\t\t\t// if (name.indexOf(\"$\") != -1) {\n\t\t\t// name = name.substring(name.indexOf(\"$\") + 1);\n\t\t\t// }\n\t\t\t// IProgramElement pe = new ProgramElement(model, name, IProgramElement.Kind.INTER_TYPE_METHOD, getBinarySourceLocation(\n\t\t\t// aspect, itd.getSourceLocation()), rtMunger.getSignature().getModifiers(), null, Collections.EMPTY_LIST);\n\t\t\t// setParams(pe, sig);\n\t\t\t// return pe;\n\t\t}\n\t\t// other cases ignored for now\n\t\treturn null;\n\t}\n\n\tprivate static void setParams(IProgramElement pe, ResolvedMember sig) {\n\t\t// do it for itds too\n\t\tUnresolvedType[] ts = sig.getParameterTypes();\n\t\tpe.setParameterNames(Collections.<String>emptyList());\n\t\t// TODO should be doing param names?\n\t\tif (ts == null) {\n\t\t\tpe.setParameterSignatures(Collections.<char[]>emptyList(), Collections.<String>emptyList());\n\t\t} else {\n\t\t\tList<char[]> paramSigs = new ArrayList<>();\n\t\t\tfor (UnresolvedType t : ts) {\n\t\t\t\tparamSigs.add(t.getSignature().toCharArray());\n\t\t\t}\n\t\t\tpe.setParameterSignatures(paramSigs, Collections.<String>emptyList());\n\t\t}\n\t\tpe.setCorrespondingType(sig.getReturnType().getName());\n\t}\n\n\tprivate static IProgramElement createDeclareParentsChild(AsmManager model, DeclareParents decp) {\n\t\tIProgramElement decpElement = new ProgramElement(model, \"declare parents\", IProgramElement.Kind.DECLARE_PARENTS,\n\t\t\t\tgetBinarySourceLocation(decp.getDeclaringType(), decp.getSourceLocation()), Modifier.PUBLIC, null,\n\t\t\t\tCollections.<IProgramElement>emptyList());\n\t\tsetParentTypesOnDeclareParentsNode(decp, decpElement);\n\t\treturn decpElement;\n\t}\n\n\tprivate static void setParentTypesOnDeclareParentsNode(DeclareParents decp, IProgramElement decpElement) {\n\t\tTypePatternList tpl = decp.getParents();\n\t\tList<String> parents = new ArrayList<>();\n\t\tfor (int i = 0; i < tpl.size(); i++) {\n\t\t\tparents.add(tpl.get(i).getExactType().getName().replaceAll(\"\\\\$\", \".\"));\n\t\t}\n\t\tdecpElement.setParentTypes(parents);\n\t}\n\n\tpublic static String getHandle(AsmManager asm, Advice advice) {\n\t\tif (null == advice.handle) {\n\t\t\tISourceLocation sl = advice.getSourceLocation();\n\t\t\tif (sl != null) {\n\t\t\t\tIProgramElement ipe = asm.getHierarchy().findElementForSourceLine(sl);\n\t\t\t\tadvice.handle = ipe.getHandleIdentifier();\n\t\t\t}\n\t\t}\n\t\treturn advice.handle;\n\t}\n\n\tpublic static void addAdvisedRelationship(AsmManager model, Shadow matchedShadow, ShadowMunger munger) {\n\t\tif (model == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (munger instanceof Advice) {\n\t\t\tAdvice advice = (Advice) munger;\n\n\t\t\tif (advice.getKind().isPerEntry() || advice.getKind().isCflow()) {\n\t\t\t\t// TODO: might want to show these in the future\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (World.createInjarHierarchy) {\n\t\t\t\tcreateHierarchyForBinaryAspect(model, advice);\n\t\t\t}\n\n\t\t\tIRelationshipMap mapper = model.getRelationshipMap();\n\t\t\tIProgramElement targetNode = getNode(model, matchedShadow);\n\t\t\tif (targetNode == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tboolean runtimeTest = advice.hasDynamicTests();\n\n\t\t\tIProgramElement.ExtraInformation extra = new IProgramElement.ExtraInformation();\n\n\t\t\tString adviceHandle = getHandle(model, advice);\n\t\t\tif (adviceHandle == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\textra.setExtraAdviceInformation(advice.getKind().getName());\n\t\t\tIProgramElement adviceElement = model.getHierarchy().findElementForHandle(adviceHandle);\n\t\t\tif (adviceElement != null) {\n\t\t\t\tadviceElement.setExtraInfo(extra);\n\t\t\t}\n\t\t\tString targetHandle = targetNode.getHandleIdentifier();\n\t\t\tif (advice.getKind().equals(AdviceKind.Softener)) {\n\t\t\t\tIRelationship foreward = mapper.get(adviceHandle, IRelationship.Kind.DECLARE_SOFT, SOFTENS, runtimeTest, true);\n\t\t\t\tif (foreward != null) {\n\t\t\t\t\tforeward.addTarget(targetHandle);\n\t\t\t\t}\n\n\t\t\t\tIRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE, SOFTENED_BY, runtimeTest, true);\n\t\t\t\tif (back != null) {\n\t\t\t\t\tback.addTarget(adviceHandle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tIRelationship foreward = mapper.get(adviceHandle, IRelationship.Kind.ADVICE, ADVISES, runtimeTest, true);\n\t\t\t\tif (foreward != null) {\n\t\t\t\t\tforeward.addTarget(targetHandle);\n\t\t\t\t}\n\n\t\t\t\tIRelationship back = mapper.get(targetHandle, IRelationship.Kind.ADVICE, ADVISED_BY, runtimeTest, true);\n\t\t\t\tif (back != null) {\n\t\t\t\t\tback.addTarget(adviceHandle);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (adviceElement.getSourceLocation() != null) {\n\t\t\t\tmodel.addAspectInEffectThisBuild(adviceElement.getSourceLocation().getSourceFile());\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected static IProgramElement getNode(AsmManager model, Shadow shadow) {\n\t\tMember enclosingMember = shadow.getEnclosingCodeSignature();\n\t\t// This variant will not be tricked by ITDs that would report they are\n\t\t// in the target type already.\n\t\t// This enables us to discover the ITD declaration (in the aspect) and\n\t\t// advise it appropriately.\n\n\t\t// Have to be smart here, for a code node within an ITD we want to\n\t\t// lookup the declaration of the\n\t\t// ITD in the aspect in order to add the code node at the right place -\n\t\t// and not lookup the\n\t\t// ITD as it applies in some target type. Due to the use of\n\t\t// effectiveSignature we will find\n\t\t// that shadow.getEnclosingCodeSignature() will return a member\n\t\t// representing the ITD as it will\n\t\t// appear in the target type. So here, we do an extra bit of analysis to\n\t\t// make sure we\n\t\t// do the right thing in the ITD case.\n\t\tIProgramElement enclosingNode = null;\n\t\tif (shadow instanceof BcelShadow) {\n\t\t\tMember actualEnclosingMember = ((BcelShadow) shadow).getRealEnclosingCodeSignature();\n\n\t\t\tif (actualEnclosingMember == null) {\n\t\t\t\tenclosingNode = lookupMember(model.getHierarchy(), shadow.getEnclosingType(), enclosingMember);\n\t\t\t} else {\n\t\t\t\tUnresolvedType type = enclosingMember.getDeclaringType();\n\t\t\t\tUnresolvedType actualType = actualEnclosingMember.getDeclaringType();\n\n\t\t\t\t// if these are not the same, it is an ITD and we need to use\n\t\t\t\t// the latter to lookup\n\t\t\t\tif (type.equals(actualType)) {\n\t\t\t\t\tenclosingNode = lookupMember(model.getHierarchy(), shadow.getEnclosingType(), enclosingMember);\n\t\t\t\t} else {\n\t\t\t\t\tenclosingNode = lookupMember(model.getHierarchy(), shadow.getEnclosingType(), actualEnclosingMember);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tenclosingNode = lookupMember(model.getHierarchy(), shadow.getEnclosingType(), enclosingMember);\n\t\t}\n\n\t\tif (enclosingNode == null) {\n\t\t\tLint.Kind err = shadow.getIWorld().getLint().shadowNotInStructure;\n\t\t\tif (err.isEnabled()) {\n\t\t\t\terr.signal(shadow.toString(), shadow.getSourceLocation());\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tMember shadowSig = shadow.getSignature();\n\t\t// pr235204\n\t\tif (shadow.getKind() == Shadow.MethodCall || shadow.getKind() == Shadow.ConstructorCall\n\t\t\t\t|| !shadowSig.equals(enclosingMember)) {\n\t\t\tIProgramElement bodyNode = findOrCreateCodeNode(model, enclosingNode, shadowSig, shadow);\n\t\t\treturn bodyNode;\n\t\t} else {\n\t\t\treturn enclosingNode;\n\t\t}\n\t}\n\n\tprivate static boolean sourceLinesMatch(ISourceLocation location1, ISourceLocation location2) {\n\t\treturn (location1.getLine() == location2.getLine());\n\t}\n\n\t/**\n\t * Finds or creates a code IProgramElement for the given shadow.\n\t *\n\t * The byteCodeName of the created node is set to 'shadowSig.getName() + \"!\" + counter', eg \"println!3\". The counter is the\n\t * occurence count of children within the enclosingNode which have the same name. So, for example, if a method contains two\n\t * System.out.println statements, the first one will have byteCodeName 'println!1' and the second will have byteCodeName\n\t * 'println!2'. This is to ensure the two nodes have unique handles when the handles do not depend on sourcelocations.\n\t *\n\t * Currently the shadows are examined in the sequence they appear in the source file. This means that the counters are\n\t * consistent over incremental builds. All aspects are compiled up front and any new aspect created will force a full build.\n\t * Moreover, if the body of the enclosingShadow is changed, then the model for this is rebuilt from scratch.\n\t */\n\tprivate static IProgramElement findOrCreateCodeNode(AsmManager asm, IProgramElement enclosingNode, Member shadowSig,\n\t\t\tShadow shadow) {\n\t\tfor (IProgramElement node : enclosingNode.getChildren()) {\n\t\t\tint excl = node.getBytecodeName().lastIndexOf('!');\n\t\t\tif (((excl != -1 && shadowSig.getName().equals(node.getBytecodeName().substring(0, excl))) || shadowSig.getName()\n\t\t\t\t\t.equals(node.getBytecodeName()))\n\t\t\t\t\t&& shadowSig.getSignature().equals(node.getBytecodeSignature())\n\t\t\t\t\t&& sourceLinesMatch(node.getSourceLocation(), shadow.getSourceLocation())) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\n\t\tISourceLocation sl = shadow.getSourceLocation();\n\n\t\t// XXX why not use shadow file? new SourceLocation(sl.getSourceFile(),\n\t\t// sl.getLine()),\n\t\tSourceLocation peLoc = new SourceLocation(enclosingNode.getSourceLocation().getSourceFile(), sl.getLine());\n\t\tpeLoc.setOffset(sl.getOffset());\n\t\tIProgramElement peNode = new ProgramElement(asm, shadow.toString(), IProgramElement.Kind.CODE, peLoc, 0, null, null);\n\n\t\t// check to see if the enclosing shadow already has children with the\n\t\t// same name. If so we want to add a counter to the byteCodeName\n\t\t// otherwise\n\t\t// we wont get unique handles\n\t\tint numberOfChildrenWithThisName = 0;\n\t\tfor (IProgramElement child: enclosingNode.getChildren()) {\n\t\t\tif (child.getName().equals(shadow.toString())) {\n\t\t\t\tnumberOfChildrenWithThisName++;\n\t\t\t}\n\t\t}\n\t\tpeNode.setBytecodeName(shadowSig.getName() + \"!\" + String.valueOf(numberOfChildrenWithThisName + 1));\n\t\tpeNode.setBytecodeSignature(shadowSig.getSignature());\n\t\tenclosingNode.addChild(peNode);\n\t\treturn peNode;\n\t}\n\n\tprivate static IProgramElement lookupMember(IHierarchy model, UnresolvedType declaringType, Member member) {\n\t\tIProgramElement typeElement = model.findElementForType(declaringType.getPackageName(), declaringType.getClassName());\n\t\tif (typeElement == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (IProgramElement element : typeElement.getChildren()) {\n\t\t\tif (member.getName().equals(element.getBytecodeName()) && member.getSignature().equals(element.getBytecodeSignature())) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t}\n\t\t// if we can't find the member, we'll just put it in the class\n\t\treturn typeElement;\n\t}\n\n\t/**\n\t * Add a relationship for a matching declare annotation method or declare annotation constructor. Locating the method is a messy\n\t * (for messy read 'fragile') bit of code that could break at any moment but it's working for my simple testcase.\n\t */\n\tpublic static void addDeclareAnnotationMethodRelationship(ISourceLocation sourceLocation, String affectedTypeName,\n\t\t\tResolvedMember affectedMethod, AsmManager model) {\n\t\tif (model == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString pkg = null;\n\t\tString type = affectedTypeName;\n\t\tint packageSeparator = affectedTypeName.lastIndexOf(\".\");\n\t\tif (packageSeparator != -1) {\n\t\t\tpkg = affectedTypeName.substring(0, packageSeparator);\n\t\t\ttype = affectedTypeName.substring(packageSeparator + 1);\n\t\t}\n\n\t\tIHierarchy hierarchy = model.getHierarchy();\n\n\t\tIProgramElement typeElem = hierarchy.findElementForType(pkg, type);\n\t\tif (typeElem == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!typeElem.getKind().isType()) {\n\t\t\tthrow new IllegalStateException(\"Did not find a type element, found a \"+typeElem.getKind()+\" element\");\n\t\t}\n\n\t\tStringBuilder parmString = new StringBuilder(\"(\");\n\t\tUnresolvedType[] args = affectedMethod.getParameterTypes();\n\t\tfor (int i = 0; i < args.length; i++) {\n\t\t\tparmString.append(args[i].getName());\n\t\t\tif ((i + 1) < args.length) {\n\t\t\t\tparmString.append(\",\");\n\t\t\t}\n\t\t}\n\t\tparmString.append(\")\");\n\t\tIProgramElement methodElem = null;\n\n\t\tif (affectedMethod.getName().startsWith(\"<init>\")) {\n\t\t\t// its a ctor\n\t\t\tmethodElem = hierarchy.findElementForSignature(typeElem, IProgramElement.Kind.CONSTRUCTOR, type + parmString);\n\t\t\tif (methodElem == null && args.length == 0) {\n\t\t\t\tmethodElem = typeElem; // assume default ctor\n\t\t\t}\n\t\t} else {\n\t\t\t// its a method\n\t\t\tmethodElem = hierarchy.findElementForSignature(typeElem, IProgramElement.Kind.METHOD, affectedMethod.getName()\n\t\t\t\t\t+ parmString);\n\t\t}\n\n\t\tif (methodElem == null) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tString targetHandle = methodElem.getHandleIdentifier();\n\t\t\tif (targetHandle == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tIProgramElement sourceNode = hierarchy.findElementForSourceLine(sourceLocation);\n\t\t\tString sourceHandle = sourceNode.getHandleIdentifier();\n\t\t\tif (sourceHandle == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tIRelationshipMap mapper = model.getRelationshipMap();\n\t\t\tIRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES, false, true);\n\t\t\tforeward.addTarget(targetHandle);\n\n\t\t\tIRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY, false, true);\n\t\t\tback.addTarget(sourceHandle);\n\t\t} catch (Throwable t) { // I'm worried about that code above, this will\n\t\t\t// make sure we don't explode if it plays up\n\t\t\tt.printStackTrace(); // I know I know .. but I don't want to lose\n\t\t\t// it!\n\t\t}\n\t}\n\n\t/**\n\t * Add a relationship for a matching declare ATfield. Locating the field is trickier than it might seem since we have no line\n\t * number info for it, we have to dig through the structure model under the fields' type in order to locate it.\n\t */\n\tpublic static void addDeclareAnnotationFieldRelationship(AsmManager model, ISourceLocation declareLocation,\n\t\t\tString affectedTypeName, ResolvedMember affectedFieldName, boolean isRemove) {\n\t\tif (model == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString pkg = null;\n\t\tString type = affectedTypeName;\n\t\tint packageSeparator = affectedTypeName.lastIndexOf(\".\");\n\t\tif (packageSeparator != -1) {\n\t\t\tpkg = affectedTypeName.substring(0, packageSeparator);\n\t\t\ttype = affectedTypeName.substring(packageSeparator + 1);\n\t\t}\n\t\tIHierarchy hierarchy = model.getHierarchy();\n\t\tIProgramElement typeElem = hierarchy.findElementForType(pkg, type);\n\t\tif (typeElem == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIProgramElement fieldElem = hierarchy.findElementForSignature(typeElem, IProgramElement.Kind.FIELD,\n\t\t\t\taffectedFieldName.getName());\n\t\tif (fieldElem == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString targetHandle = fieldElem.getHandleIdentifier();\n\t\tif (targetHandle == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIProgramElement sourceNode = hierarchy.findElementForSourceLine(declareLocation);\n\t\tString sourceHandle = sourceNode.getHandleIdentifier();\n\t\tif (sourceHandle == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tIRelationshipMap relmap = model.getRelationshipMap();\n\t\t// if (isRemove) {\n\t\t// IRelationship foreward = relmap.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, REMOVES_ANNOTATION, false,\n\t\t// true);\n\t\t// foreward.addTarget(targetHandle);\n\t\t// IRelationship back = relmap\n\t\t// .get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATION_REMOVED_BY, false, true);\n\t\t// back.addTarget(sourceHandle);\n\t\t// } else {\n\t\tIRelationship foreward = relmap.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES, false, true);\n\t\tforeward.addTarget(targetHandle);\n\t\tIRelationship back = relmap.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY, false, true);\n\t\tback.addTarget(sourceHandle);\n\t\t// }\n\t}\n\n}\n",
    "size": 46559
  },
  {
    "file_id": "F53",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/model/AsmRelationshipUtils.java",
    "text": "/********************************************************************\n * Copyright (c) 2006 Contributors. All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors: IBM Corporation - initial API and implementation\n * \t\t\t\t Helen Hawkins   - initial version\n *******************************************************************/\npackage org.aspectj.weaver.model;\n\nimport org.aspectj.weaver.patterns.AndPointcut;\nimport org.aspectj.weaver.patterns.OrPointcut;\nimport org.aspectj.weaver.patterns.Pointcut;\nimport org.aspectj.weaver.patterns.ReferencePointcut;\n\n/**\n * Provides utility methods for generating details for IProgramElements used when creating the model both from source (via\n * AsmElementFormatter.visit(..)) and when filling in the model for binary aspects (via AsmRelationshipProvider bug 145963)\n */\npublic class AsmRelationshipUtils {\n\n\t// public static final String UNDEFINED=\"<undefined>\";\n\tpublic static final String DECLARE_PRECEDENCE = \"precedence\";\n\tpublic static final String DECLARE_SOFT = \"soft\";\n\tpublic static final String DECLARE_PARENTS = \"parents\";\n\tpublic static final String DECLARE_WARNING = \"warning\";\n\tpublic static final String DECLARE_ERROR = \"error\";\n\tpublic static final String DECLARE_UNKNONWN = \"<unknown declare>\";\n\tpublic static final String POINTCUT_ABSTRACT = \"<abstract pointcut>\";\n\tpublic static final String POINTCUT_ANONYMOUS = \"<anonymous pointcut>\";\n\tpublic static final String DOUBLE_DOTS = \"..\";\n\tpublic static final int MAX_MESSAGE_LENGTH = 18;\n\tpublic static final String DEC_LABEL = \"declare\";\n\n\t/**\n\t * Generates the declare message used in the details, for example if the declare warning statement has message\n\t * \"There should be no printlns\" will return 'declare warning: \"There should be n..\"'\n\t */\n\tpublic static String genDeclareMessage(String message) {\n\t\tint length = message.length();\n\t\tif (length < MAX_MESSAGE_LENGTH) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn message.substring(0, MAX_MESSAGE_LENGTH - 1) + DOUBLE_DOTS;\n\t\t}\n\t}\n\n\t/**\n\t * Generates the pointcut details for the given pointcut, for example an anonymous pointcut will return '&lt;anonymous pointcut&gt;'\n\t * and a named pointcut called p() will return 'p()..'\n\t */\n\tpublic static String genPointcutDetails(Pointcut pcd) {\n\t\tStringBuilder details = new StringBuilder();\n\t\tif (pcd instanceof ReferencePointcut) {\n\t\t\tReferencePointcut rp = (ReferencePointcut) pcd;\n\t\t\tdetails.append(rp.name).append(DOUBLE_DOTS);\n\t\t} else if (pcd instanceof AndPointcut) {\n\t\t\tAndPointcut ap = (AndPointcut) pcd;\n\t\t\tif (ap.getLeft() instanceof ReferencePointcut) {\n\t\t\t\tdetails.append(ap.getLeft().toString()).append(DOUBLE_DOTS);\n\t\t\t} else {\n\t\t\t\tdetails.append(POINTCUT_ANONYMOUS).append(DOUBLE_DOTS);\n\t\t\t}\n\t\t} else if (pcd instanceof OrPointcut) {\n\t\t\tOrPointcut op = (OrPointcut) pcd;\n\t\t\tif (op.getLeft() instanceof ReferencePointcut) {\n\t\t\t\tdetails.append(op.getLeft().toString()).append(DOUBLE_DOTS);\n\t\t\t} else {\n\t\t\t\tdetails.append(POINTCUT_ANONYMOUS).append(DOUBLE_DOTS);\n\t\t\t}\n\t\t} else {\n\t\t\tdetails.append(POINTCUT_ANONYMOUS);\n\t\t}\n\t\treturn details.toString();\n\t}\n\n}\n",
    "size": 3298
  },
  {
    "file_id": "F54",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/reflect/ArgNameFinder.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005-2017 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n * ******************************************************************/\npackage org.aspectj.weaver.reflect;\n\nimport java.lang.reflect.Member;\n\n/**\n * @author Adrian Colyer\n * @author Andy Clement\n */\npublic interface ArgNameFinder {\n\n\t/**\n\t * Attempt to discover the parameter names for a reflectively obtained member.\n\t * @param forMember the member for which parameter names are being looked up\n\t * @return parameter names or null if names can't be determined\n\t */\n\tString[] getParameterNames(Member forMember);\n\n}\n",
    "size": 893
  },
  {
    "file_id": "F55",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/reflect/DeferredResolvedPointcutDefinition.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2006 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer          Initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.reflect;\n\nimport org.aspectj.weaver.ResolvedPointcutDefinition;\nimport org.aspectj.weaver.UnresolvedType;\n\n/**\n * When a Java15ReflectionBasedDelegate gets the pointcuts for a given class it tries to resolve them before returning. This can\n * cause problems if the resolution of one pointcut in the type depends on another pointcut in the same type. Therefore the\n * algorithm proceeds in two phases, first we create and store instances of this class in the pointcuts array, and once that is\n * done, we come back round and resolve the actual pointcut expression. This means that if we recurse doing resolution, we will find\n * the named pointcut we are looking for!\n *\n * @author adrian colyer\n *\n */\npublic class DeferredResolvedPointcutDefinition extends ResolvedPointcutDefinition {\n\n\tpublic DeferredResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name,\n\t\t\tUnresolvedType[] parameterTypes) {\n\t\tsuper(declaringType, modifiers, name, parameterTypes, UnresolvedType.VOID, null);\n\t}\n\n}\n",
    "size": 1559
  },
  {
    "file_id": "F56",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/reflect/InternalUseOnlyPointcutParser.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2006 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer          Initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.reflect;\n\nimport org.aspectj.weaver.patterns.Pointcut;\nimport org.aspectj.weaver.tools.PointcutParameter;\nimport org.aspectj.weaver.tools.PointcutParser;\n\npublic class InternalUseOnlyPointcutParser extends PointcutParser {\n\n\tpublic InternalUseOnlyPointcutParser(ClassLoader classLoader, ReflectionWorld world) {\n\t\tsuper();\n\t\tsetClassLoader(classLoader);\n\t\tsetWorld(world);\n\t}\n\n\tpublic InternalUseOnlyPointcutParser(ClassLoader classLoader) {\n\t\tsuper();\n\t\tsetClassLoader(classLoader);\n\t}\n\n\tpublic Pointcut resolvePointcutExpression(\n\t    \t\tString expression,\n\t    \t\tClass inScope,\n\t    \t\tPointcutParameter[] formalParameters) {\n\t\treturn super.resolvePointcutExpression(expression, inScope, formalParameters);\n\t}\n\n\tpublic Pointcut concretizePointcutExpression(Pointcut pc, Class inScope, PointcutParameter[] formalParameters) {\n\t\treturn super.concretizePointcutExpression(pc, inScope, formalParameters);\n\t}\n\n}\n",
    "size": 1450
  },
  {
    "file_id": "F57",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/reflect/Java15AnnotationFinder.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005, 2017 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n * ******************************************************************/\npackage org.aspectj.weaver.reflect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\n\nimport org.aspectj.apache.bcel.classfile.AnnotationDefault;\nimport org.aspectj.apache.bcel.classfile.Attribute;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.apache.bcel.classfile.LocalVariable;\nimport org.aspectj.apache.bcel.classfile.LocalVariableTable;\nimport org.aspectj.apache.bcel.classfile.annotation.AnnotationGen;\nimport org.aspectj.apache.bcel.util.ClassLoaderRepository;\nimport org.aspectj.apache.bcel.util.NonCachingClassLoaderRepository;\nimport org.aspectj.apache.bcel.util.Repository;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelAnnotation;\nimport org.aspectj.weaver.bcel.BcelWeakClassLoaderReference;\n\n/**\n *\n * @author Adrian Colyer\n * @author Andy Clement\n */\npublic class Java15AnnotationFinder implements AnnotationFinder, ArgNameFinder {\n\n\tpublic static final ResolvedType[][] NO_PARAMETER_ANNOTATIONS = new ResolvedType[][] {};\n\n\tprivate Repository bcelRepository;\n\tprivate BcelWeakClassLoaderReference classLoaderRef;\n\n\tprivate static Repository staticBcelRepository;\n\tprivate static BcelWeakClassLoaderReference staticClassLoaderRef;\n\n\tprivate World world;\n\tprivate static boolean useCachingClassLoaderRepository;\n\n\t// Use single instance of Repository and ClassLoader\n\tpublic static boolean useSingleInstances =\n\t\tSystem.getProperty(\"org.aspectj.apache.bcel.useSingleRepositoryInstance\", \"false\").equalsIgnoreCase(\"true\");\n\n\tstatic {\n\t\ttry {\n\t\t\tuseCachingClassLoaderRepository = System.getProperty(\"Xset:bcelRepositoryCaching\",\"true\").equalsIgnoreCase(\"true\");\n\t\t} catch (Throwable t) {\n\t\t\tuseCachingClassLoaderRepository = false;\n\t\t}\n\t}\n\n\t// must have no-arg constructor for reflective construction\n\tpublic Java15AnnotationFinder() {\n\t}\n\n\tpublic void setClassLoader(ClassLoader aLoader) {\n\t\t// Set class loader ref\n\t\tif (useSingleInstances && staticClassLoaderRef == null) {\n\t\t\tstaticClassLoaderRef = new BcelWeakClassLoaderReference(aLoader);\n\t\t} else {\n\t\t\tthis.classLoaderRef = new BcelWeakClassLoaderReference(aLoader);\n\t\t}\n\n\t\t// Set repository\n\t\tif (useCachingClassLoaderRepository) {\n\t\t\tif (useSingleInstances && staticBcelRepository == null) {\n\t\t\t\tstaticBcelRepository = new ClassLoaderRepository(getClassLoader());\n\t\t\t} else {\n\t\t\t\tthis.bcelRepository = new ClassLoaderRepository(classLoaderRef);\n\t\t\t}\n\t\t} else {\n\t\t\tif (useSingleInstances && staticBcelRepository == null) {\n\t\t\t\tstaticBcelRepository = new NonCachingClassLoaderRepository(getClassLoader());\n\t\t\t} else {\n\t\t\t\tthis.bcelRepository = new NonCachingClassLoaderRepository(classLoaderRef);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Repository getBcelRepository() {\n\t\treturn useSingleInstances ? staticBcelRepository : bcelRepository;\n\t}\n\n\tpublic void setWorld(World aWorld) {\n\t\tthis.world = aWorld;\n\t}\n\n\tpublic Object getAnnotation(ResolvedType annotationType, Object onObject) {\n\t\ttry {\n\t\t\tClass<? extends Annotation> annotationClass = (Class<? extends Annotation>) Class.forName(annotationType.getName(),\n\t\t\t\t\tfalse, getClassLoader());\n\t\t\tif (onObject.getClass().isAnnotationPresent(annotationClass)) {\n\t\t\t\treturn onObject.getClass().getAnnotation(annotationClass);\n\t\t\t}\n\t\t} catch (ClassNotFoundException ex) {\n\t\t\t// just return null\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic Object getAnnotationFromClass(ResolvedType annotationType, Class aClass) {\n\t\ttry {\n\t\t\tClass<? extends Annotation> annotationClass = (Class<? extends Annotation>) Class.forName(annotationType.getName(),\n\t\t\t\t\tfalse, getClassLoader());\n\t\t\tif (aClass.isAnnotationPresent(annotationClass)) {\n\t\t\t\treturn aClass.getAnnotation(annotationClass);\n\t\t\t}\n\t\t} catch (ClassNotFoundException ex) {\n\t\t\t// just return null\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic Object getAnnotationFromMember(ResolvedType annotationType, Member aMember) {\n\t\tif (!(aMember instanceof AccessibleObject))\n\t\t\treturn null;\n\t\tAccessibleObject ao = (AccessibleObject) aMember;\n\t\ttry {\n\t\t\tClass annotationClass = Class.forName(annotationType.getName(), false, getClassLoader());\n\t\t\tif (ao.isAnnotationPresent(annotationClass)) {\n\t\t\t\treturn ao.getAnnotation(annotationClass);\n\t\t\t}\n\t\t} catch (ClassNotFoundException ex) {\n\t\t\t// just return null\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate ClassLoader getClassLoader() {\n\t\treturn useSingleInstances ? staticClassLoaderRef.getClassLoader() : classLoaderRef.getClassLoader();\n\t}\n\n\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType, Member onMember) {\n\t\tif (!(onMember instanceof AccessibleObject))\n\t\t\treturn null;\n\t\t// here we really want both the runtime visible AND the class visible\n\t\t// annotations\n\t\t// so we bail out to Bcel and then chuck away the JavaClass so that we\n\t\t// don't hog\n\t\t// memory.\n\t\ttry {\n\t\t\tJavaClass jc = bcelRepository.loadClass(onMember.getDeclaringClass());\n\t\t\torg.aspectj.apache.bcel.classfile.annotation.AnnotationGen[] anns = AnnotationGen.NO_ANNOTATIONS;\n\t\t\tif (onMember instanceof Method) {\n\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelMethod = jc.getMethod((Method) onMember);\n\t\t\t\tif (bcelMethod == null) {\n\t\t\t\t\t// pr220430\n\t\t\t\t\t// System.err.println(\n\t\t\t\t\t// \"Unexpected problem in Java15AnnotationFinder: cannot retrieve annotations on method '\"\n\t\t\t\t\t// +\n\t\t\t\t\t// onMember.getName()+\"' in class '\"+jc.getClassName()+\"'\");\n\t\t\t\t} else {\n\t\t\t\t\tanns = bcelMethod.getAnnotations();\n\t\t\t\t}\n\t\t\t} else if (onMember instanceof Constructor) {\n\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelCons = jc.getMethod((Constructor<?>) onMember);\n\t\t\t\tanns = bcelCons.getAnnotations();\n\t\t\t} else if (onMember instanceof Field) {\n\t\t\t\torg.aspectj.apache.bcel.classfile.Field bcelField = jc.getField((Field) onMember);\n\t\t\t\tanns = bcelField.getAnnotations();\n\t\t\t}\n\t\t\t// the answer is cached and we don't want to hold on to memory\n\t\t\tgetBcelRepository().clear();\n\t\t\t// OPTIMIZE make constant 0 size array for sharing\n\t\t\tif (anns == null)\n\t\t\t\tanns = AnnotationGen.NO_ANNOTATIONS;\n\t\t\t// convert to our Annotation type\n\t\t\tfor (org.aspectj.apache.bcel.classfile.annotation.AnnotationGen ann : anns) {\n\t\t\t\tif (ann.getTypeSignature().equals(ofType.getSignature())) {\n\t\t\t\t\treturn new BcelAnnotation(ann, world);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t} catch (ClassNotFoundException cnfEx) {\n\t\t\t// just use reflection then\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic String getAnnotationDefaultValue(Member onMember) {\n\t\ttry {\n\t\t\tJavaClass jc = getBcelRepository().loadClass(onMember.getDeclaringClass());\n\t\t\tif (onMember instanceof Method) {\n\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelMethod = jc.getMethod((Method) onMember);\n\n\t\t\t\tif (bcelMethod == null) {\n\t\t\t\t\t// pr220430\n\t\t\t\t\t// System.err.println(\n\t\t\t\t\t// \"Unexpected problem in Java15AnnotationFinder: cannot retrieve annotations on method '\"\n\t\t\t\t\t// +\n\t\t\t\t\t// onMember.getName()+\"' in class '\"+jc.getClassName()+\"'\");\n\t\t\t\t} else {\n\t\t\t\t\tAttribute[] attrs = bcelMethod.getAttributes();\n\t\t\t\t\tfor (Attribute attribute : attrs) {\n\t\t\t\t\t\tif (attribute.getName().equals(\"AnnotationDefault\")) {\n\t\t\t\t\t\t\tAnnotationDefault def = (AnnotationDefault) attribute;\n\t\t\t\t\t\t\treturn def.getElementValue().stringifyValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException cnfEx) {\n\t\t\t// just use reflection then\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic ResolvedType[] getAnnotations(Member onMember, boolean areRuntimeAnnotationsSufficient) {\n\t\tif (!(onMember instanceof AccessibleObject)) {\n\t\t\treturn ResolvedType.NONE;\n\t\t}\n\t\t// If annotations with class level retention are required then we need to open\n\t\t// open the class file. If only runtime retention annotations are required\n\t\t// we can just use reflection.\n\t\tif (!areRuntimeAnnotationsSufficient) {\n\t\t\ttry {\n\t\t\t\tJavaClass jc = getBcelRepository().loadClass(onMember.getDeclaringClass());\n\t\t\t\torg.aspectj.apache.bcel.classfile.annotation.AnnotationGen[] anns = null;\n\t\t\t\tif (onMember instanceof Method) {\n\t\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelMethod = jc.getMethod((Method) onMember);\n\t\t\t\t\tif (bcelMethod != null) {\n\t\t\t\t\t\tanns = bcelMethod.getAnnotations();\n\t\t\t\t\t}\n\t\t\t\t} else if (onMember instanceof Constructor) {\n\t\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelCons = jc.getMethod((Constructor<?>) onMember);\n\t\t\t\t\tanns = bcelCons.getAnnotations();\n\t\t\t\t} else if (onMember instanceof Field) {\n\t\t\t\t\torg.aspectj.apache.bcel.classfile.Field bcelField = jc.getField((Field) onMember);\n\t\t\t\t\tanns = bcelField.getAnnotations();\n\t\t\t\t}\n\t\t\t\t// the answer is cached and we don't want to hold on to memory\n\t\t\t\tgetBcelRepository().clear();\n\t\t\t\tif (anns == null || anns.length == 0) {\n\t\t\t\t\treturn ResolvedType.NONE;\n\t\t\t\t}\n\t\t\t\tResolvedType[] annotationTypes = new ResolvedType[anns.length];\n\t\t\t\tfor (int i = 0; i < anns.length; i++) {\n\t\t\t\t\tannotationTypes[i] = world.resolve(UnresolvedType.forSignature(anns[i].getTypeSignature()));\n\t\t\t\t}\n\t\t\t\treturn annotationTypes;\n\t\t\t} catch (ClassNotFoundException cnfEx) {\n\t\t\t\t// just use reflection then\n\t\t\t}\n\t\t}\n\n\t\tAccessibleObject ao = (AccessibleObject) onMember;\n\t\tAnnotation[] anns = ao.getDeclaredAnnotations();\n\t\tif (anns.length == 0) {\n\t\t\treturn ResolvedType.NONE;\n\t\t}\n\t\tResolvedType[] annotationTypes = new ResolvedType[anns.length];\n\t\tfor (int i = 0; i < anns.length; i++) {\n\t\t\tannotationTypes[i] = UnresolvedType.forName(anns[i].annotationType().getName()).resolve(world);\n\t\t}\n\t\treturn annotationTypes;\n\t}\n\n\tpublic ResolvedType[] getAnnotations(Class forClass, World inWorld) {\n\t\t// here we really want both the runtime visible AND the class visible\n\t\t// annotations so we bail out to Bcel and then chuck away the JavaClass so that we\n\t\t// don't hog memory.\n\t\ttry {\n\t\t\tJavaClass jc = getBcelRepository().loadClass(forClass);\n\t\t\torg.aspectj.apache.bcel.classfile.annotation.AnnotationGen[] anns = jc.getAnnotations();\n\t\t\tgetBcelRepository().clear();\n\t\t\tif (anns == null) {\n\t\t\t\treturn ResolvedType.NONE;\n\t\t\t} else {\n\t\t\t\tResolvedType[] ret = new ResolvedType[anns.length];\n\t\t\t\tfor (int i = 0; i < ret.length; i++) {\n\t\t\t\t\tret[i] = inWorld.resolve(UnresolvedType.forSignature(anns[i].getTypeSignature()));\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (ClassNotFoundException cnfEx) {\n\t\t\t// just use reflection then\n\t\t}\n\n\t\tAnnotation[] classAnnotations = forClass.getAnnotations();\n\t\tResolvedType[] ret = new ResolvedType[classAnnotations.length];\n\t\tfor (int i = 0; i < classAnnotations.length; i++) {\n\t\t\tret[i] = inWorld.resolve(classAnnotations[i].annotationType().getName());\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic String[] getParameterNames(Member forMember) {\n\t\tif (!(forMember instanceof AccessibleObject))\n\t\t\treturn null;\n\n\t\ttry {\n\t\t\tJavaClass jc = getBcelRepository().loadClass(forMember.getDeclaringClass());\n\t\t\tLocalVariableTable lvt = null;\n\t\t\tint numVars = 0;\n\t\t\tif (forMember instanceof Method) {\n\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelMethod = jc.getMethod((Method) forMember);\n\t\t\t\tlvt = bcelMethod.getLocalVariableTable();\n\t\t\t\tnumVars = bcelMethod.getArgumentTypes().length;\n\t\t\t} else if (forMember instanceof Constructor) {\n\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelCons = jc.getMethod((Constructor<?>) forMember);\n\t\t\t\tlvt = bcelCons.getLocalVariableTable();\n\t\t\t\tnumVars = bcelCons.getArgumentTypes().length;\n\t\t\t}\n\t\t\treturn getParameterNamesFromLVT(lvt, numVars);\n\t\t} catch (ClassNotFoundException cnfEx) {\n\t\t\t; // no luck\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate String[] getParameterNamesFromLVT(LocalVariableTable lvt, int numVars) {\n\t\tif (lvt == null)\n\t\t\treturn null;// pr222987 - prevent NPE\n\t\tLocalVariable[] vars = lvt.getLocalVariableTable();\n\t\tif (vars.length < numVars) {\n\t\t\t// basic error, we can't get the names...\n\t\t\treturn null;\n\t\t}\n\t\tString[] ret = new String[numVars];\n\t\tfor (int i = 0; i < numVars; i++) {\n\t\t\tret[i] = vars[i + 1].getName();\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic ResolvedType[][] getParameterAnnotationTypes(Member onMember) {\n\t\tif (!(onMember instanceof AccessibleObject))\n\t\t\treturn NO_PARAMETER_ANNOTATIONS;\n\t\t// here we really want both the runtime visible AND the class visible\n\t\t// annotations\n\t\t// so we bail out to Bcel and then chuck away the JavaClass so that we\n\t\t// don't hog\n\t\t// memory.\n\t\ttry {\n\t\t\tJavaClass jc = getBcelRepository().loadClass(onMember.getDeclaringClass());\n\t\t\torg.aspectj.apache.bcel.classfile.annotation.AnnotationGen[][] anns = null;\n\t\t\tif (onMember instanceof Method) {\n\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelMethod = jc.getMethod((Method) onMember);\n\t\t\t\tif (bcelMethod == null) {\n\t\t\t\t\t// pr220430\n\t\t\t\t\t// System.err.println(\n\t\t\t\t\t// \"Unexpected problem in Java15AnnotationFinder: cannot retrieve annotations on method '\"\n\t\t\t\t\t// +\n\t\t\t\t\t// onMember.getName()+\"' in class '\"+jc.getClassName()+\"'\");\n\t\t\t\t} else {\n\t\t\t\t\tanns = bcelMethod.getParameterAnnotations();\n\t\t\t\t}\n\t\t\t} else if (onMember instanceof Constructor) {\n\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelCons = jc.getMethod((Constructor<?>) onMember);\n\t\t\t\tanns = bcelCons.getParameterAnnotations();\n\t\t\t} else if (onMember instanceof Field) {\n\t\t\t\t// anns = null;\n\t\t\t}\n\t\t\t// the answer is cached and we don't want to hold on to memory\n\t\t\tgetBcelRepository().clear();\n\t\t\tif (anns == null)\n\t\t\t\treturn NO_PARAMETER_ANNOTATIONS;\n\t\t\tResolvedType[][] result = new ResolvedType[anns.length][];\n\t\t\t// CACHING??\n\t\t\tfor (int i = 0; i < anns.length; i++) {\n\t\t\t\tif (anns[i] != null) {\n\t\t\t\t\tresult[i] = new ResolvedType[anns[i].length];\n\t\t\t\t\tfor (int j = 0; j < anns[i].length; j++) {\n\t\t\t\t\t\tresult[i][j] = world.resolve(UnresolvedType.forSignature(anns[i][j].getTypeSignature()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (ClassNotFoundException cnfEx) {\n\t\t\t// just use reflection then\n\t\t}\n\n\t\t// reflection...\n\t\tAccessibleObject ao = (AccessibleObject) onMember;\n\t\tAnnotation[][] anns = null;\n\t\tif (onMember instanceof Method) {\n\t\t\tanns = ((Method) ao).getParameterAnnotations();\n\t\t} else if (onMember instanceof Constructor) {\n\t\t\tanns = ((Constructor<?>) ao).getParameterAnnotations();\n\t\t} else if (onMember instanceof Field) {\n\t\t\t// anns = null;\n\t\t}\n\t\tif (anns == null)\n\t\t\treturn NO_PARAMETER_ANNOTATIONS;\n\t\tResolvedType[][] result = new ResolvedType[anns.length][];\n\t\t// CACHING??\n\t\tfor (int i = 0; i < anns.length; i++) {\n\t\t\tif (anns[i] != null) {\n\t\t\t\tresult[i] = new ResolvedType[anns[i].length];\n\t\t\t\tfor (int j = 0; j < anns[i].length; j++) {\n\t\t\t\t\tresult[i][j] = UnresolvedType.forName(anns[i][j].annotationType().getName()).resolve(world);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}\n",
    "size": 14969
  },
  {
    "file_id": "F58",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/reflect/Java15GenericSignatureInformationProvider.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.reflect;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\n\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\n\n/**\n * Uses Java 1.5 reflection APIs to determine generic signatures\n */\npublic class Java15GenericSignatureInformationProvider implements\n\t\tGenericSignatureInformationProvider {\n\n\tprivate final World world;\n\n\tpublic Java15GenericSignatureInformationProvider(World forWorld) {\n\t\tthis.world = forWorld;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#getGenericParameterTypes(org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl)\n\t */\n\tpublic UnresolvedType[] getGenericParameterTypes(\n\t\t\tReflectionBasedResolvedMemberImpl resolvedMember) {\n\t\tJavaLangTypeToResolvedTypeConverter typeConverter = new JavaLangTypeToResolvedTypeConverter(world);\n\t\tType[] pTypes = new Type[0];\n\t\tMember member = resolvedMember.getMember();\n\t\tif (member instanceof Method) {\n\t\t\tpTypes = ((Method)member).getGenericParameterTypes();\n\t\t} else if (member instanceof Constructor) {\n\t\t\tpTypes = ((Constructor<?>)member).getGenericParameterTypes();\n\t\t}\n\t\treturn typeConverter.fromTypes(pTypes);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#getGenericReturnType(org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl)\n\t */\n\tpublic UnresolvedType getGenericReturnType(\n\t\t\tReflectionBasedResolvedMemberImpl resolvedMember) {\n\t\tJavaLangTypeToResolvedTypeConverter typeConverter = new JavaLangTypeToResolvedTypeConverter(world);\n\t\tMember member = resolvedMember.getMember();\n\t\tif (member instanceof Field) {\n\t\t\treturn typeConverter.fromType(((Field)member).getGenericType());\n\t\t} else if (member instanceof Method) {\n\t\t\treturn typeConverter.fromType(((Method)member).getGenericReturnType());\n\t\t} else if (member instanceof Constructor) {\n\t\t\treturn typeConverter.fromType(((Constructor<?>)member).getDeclaringClass());\n\t\t} else {\n\t\t\tthrow new IllegalStateException(\"unexpected member type: \" + member);\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#isBridge()\n\t */\n\tpublic boolean isBridge(ReflectionBasedResolvedMemberImpl resolvedMember) {\n\t\tMember member =  resolvedMember.getMember();\n\t\tif (member instanceof Method) {\n\t\t\treturn ((Method)member).isBridge();\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#isVarArgs()\n\t */\n\tpublic boolean isVarArgs(ReflectionBasedResolvedMemberImpl resolvedMember) {\n\t\tMember member =  resolvedMember.getMember();\n\t\tif (member instanceof Method) {\n\t\t\treturn ((Method)member).isVarArgs();\n\t\t} else if (member instanceof Constructor) {\n\t\t\treturn ((Constructor<?>)member).isVarArgs();\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#isSynthetic()\n\t */\n\tpublic boolean isSynthetic(ReflectionBasedResolvedMemberImpl resolvedMember) {\n\t\tMember member =  resolvedMember.getMember();\n\t\treturn member.isSynthetic();\n\t}\n\n}\n",
    "size": 3722
  },
  {
    "file_id": "F59",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.reflect;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Set;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.reflect.AjType;\nimport org.aspectj.lang.reflect.AjTypeSystem;\nimport org.aspectj.lang.reflect.Pointcut;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedPointcutDefinition;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.TypeVariable;\nimport org.aspectj.weaver.TypeVariableReferenceType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.tools.PointcutDesignatorHandler;\nimport org.aspectj.weaver.tools.PointcutParameter;\n\n/**\n * Provides Java 5 behaviour in reflection based delegates (overriding 1.4 behaviour from superclass where\n * appropriate)\n *\n * @author Adrian Colyer\n * @author Andy Clement\n */\npublic class Java15ReflectionBasedReferenceTypeDelegate extends ReflectionBasedReferenceTypeDelegate {\n\n\tprivate AjType<?> myType;\n\tprivate ResolvedType[] annotations;\n\tprivate ResolvedMember[] pointcuts;\n\tprivate ResolvedMember[] methods;\n\tprivate ResolvedMember[] fields;\n\tprivate TypeVariable[] typeVariables;\n\tprivate ResolvedType superclass;\n\tprivate ResolvedType[] superInterfaces;\n\tprivate String genericSignature = null;\n\tprivate JavaLangTypeToResolvedTypeConverter typeConverter;\n\tprivate Java15AnnotationFinder annotationFinder = null;\n\tprivate ArgNameFinder argNameFinder = null;\n\n\tpublic Java15ReflectionBasedReferenceTypeDelegate() {\n\t}\n\n\t@Override\n\tpublic void initialize(ReferenceType aType, Class aClass, ClassLoader classLoader, World aWorld) {\n\t\tsuper.initialize(aType, aClass, classLoader, aWorld);\n\t\tmyType = AjTypeSystem.getAjType(aClass);\n\t\tannotationFinder = new Java15AnnotationFinder();\n\t\targNameFinder = annotationFinder;\n\t\tannotationFinder.setClassLoader(this.classLoaderReference.getClassLoader());\n\t\tannotationFinder.setWorld(aWorld);\n\t\tthis.typeConverter = new JavaLangTypeToResolvedTypeConverter(aWorld);\n\t}\n\n\t@Override\n\tpublic ReferenceType buildGenericType() {\n\t\treturn (ReferenceType) UnresolvedType.forGenericTypeVariables(getResolvedTypeX().getSignature(), getTypeVariables())\n\t\t\t\t.resolve(getWorld());\n\t}\n\n\t@Override\n\tpublic AnnotationAJ[] getAnnotations() {\n\t\t// AMC - we seem not to need to implement this method...\n\t\t// throw new UnsupportedOperationException(\n\t\t// \"getAnnotations on Java15ReflectionBasedReferenceTypeDelegate is not implemented yet\"\n\t\t// );\n\t\t// FIXME is this the right implementation in the reflective case?\n\t\treturn super.getAnnotations();\n\t}\n\n\t@Override\n\tpublic ResolvedType[] getAnnotationTypes() {\n\t\tif (annotations == null) {\n\t\t\tannotations = annotationFinder.getAnnotations(getBaseClass(), getWorld());\n\t\t}\n\t\treturn annotations;\n\t}\n\n\t@Override\n\tpublic boolean hasAnnotations() {\n\t\tif (annotations == null) {\n\t\t\tannotations = annotationFinder.getAnnotations(getBaseClass(), getWorld());\n\t\t}\n\t\treturn annotations.length != 0;\n\t}\n\n\t@Override\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\n\t\tResolvedType[] myAnns = getAnnotationTypes();\n\t\tResolvedType toLookFor = ofType.resolve(getWorld());\n\t\tfor (ResolvedType myAnn : myAnns) {\n\t\t\tif (myAnn == toLookFor) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// use the MAP to ensure that any aj-synthetic fields are filtered out\n\t@Override\n\tpublic ResolvedMember[] getDeclaredFields() {\n\t\tif (fields == null) {\n\t\t\tField[] reflectFields = this.myType.getDeclaredFields();\n\t\t\tResolvedMember[] rFields = new ResolvedMember[reflectFields.length];\n\t\t\tfor (int i = 0; i < reflectFields.length; i++) {\n\t\t\t\trFields[i] = createGenericFieldMember(reflectFields[i]);\n\t\t\t}\n\t\t\tthis.fields = rFields;\n\t\t}\n\t\treturn fields;\n\t}\n\n\t@Override\n\tpublic String getDeclaredGenericSignature() {\n\t\tif (this.genericSignature == null && isGeneric()) {\n\t\t\t// BUG? what the hell is this doing - see testcode in MemberTestCase15.testMemberSignatureCreation() and run it\n\t\t\t// off a Reflection World\n\t\t}\n\t\treturn genericSignature;\n\t}\n\n\t@Override\n\tpublic ResolvedType[] getDeclaredInterfaces() {\n\t\tif (superInterfaces == null) {\n\t\t\tType[] genericInterfaces = getBaseClass().getGenericInterfaces();\n\t\t\tthis.superInterfaces = typeConverter.fromTypes(genericInterfaces);\n\t\t}\n\t\treturn superInterfaces;\n\t}\n\n\t@Override\n\tpublic ResolvedType getSuperclass() {\n\t\t// Superclass of object is null\n\t\tif (superclass == null && getBaseClass() != Object.class) {\n\t\t\tType t = this.getBaseClass().getGenericSuperclass();\n\t\t\tif (t != null) {\n\t\t\t\tsuperclass = typeConverter.fromType(t);\n\t\t\t}\n\t\t\tif (t == null) {\n\t\t\t\t// If the superclass is null, return Object - same as bcel does\n\t\t\t\tsuperclass = getWorld().resolve(UnresolvedType.OBJECT);\n\t\t\t}\n\t\t}\n\t\treturn superclass;\n\t}\n\n\t@Override\n\tpublic TypeVariable[] getTypeVariables() {\n\t\tTypeVariable[] workInProgressSetOfVariables = getResolvedTypeX().getWorld().getTypeVariablesCurrentlyBeingProcessed(\n\t\t\t\tgetBaseClass());\n\t\tif (workInProgressSetOfVariables != null) {\n\t\t\treturn workInProgressSetOfVariables;\n\t\t}\n\t\tif (this.typeVariables == null) {\n\t\t\tjava.lang.reflect.TypeVariable[] tVars = this.getBaseClass().getTypeParameters();\n\t\t\tTypeVariable[] rTypeVariables = new TypeVariable[tVars.length];\n\t\t\t// basic initialization\n\t\t\tfor (int i = 0; i < tVars.length; i++) {\n\t\t\t\trTypeVariables[i] = new TypeVariable(tVars[i].getName());\n\t\t\t}\n\t\t\t// stash it\n\t\t\tthis.getResolvedTypeX().getWorld().recordTypeVariablesCurrentlyBeingProcessed(getBaseClass(), rTypeVariables);\n\t\t\t// now fill in the details...\n\t\t\tfor (int i = 0; i < tVars.length; i++) {\n\t\t\t\tTypeVariableReferenceType tvrt = ((TypeVariableReferenceType) typeConverter.fromType(tVars[i]));\n\t\t\t\tTypeVariable tv = tvrt.getTypeVariable();\n\t\t\t\trTypeVariables[i].setSuperclass(tv.getSuperclass());\n\t\t\t\trTypeVariables[i].setAdditionalInterfaceBounds(tv.getSuperInterfaces());\n\t\t\t\trTypeVariables[i].setDeclaringElement(tv.getDeclaringElement());\n\t\t\t\trTypeVariables[i].setDeclaringElementKind(tv.getDeclaringElementKind());\n\t\t\t\trTypeVariables[i].setRank(tv.getRank());\n\t\t\t}\n\t\t\tthis.typeVariables = rTypeVariables;\n\t\t\tthis.getResolvedTypeX().getWorld().forgetTypeVariablesCurrentlyBeingProcessed(getBaseClass());\n\t\t}\n\t\treturn this.typeVariables;\n\t}\n\n\t// overrides super method since by using the MAP we can filter out advice\n\t// methods that really shouldn't be seen in this list\n\t@Override\n\tpublic ResolvedMember[] getDeclaredMethods() {\n\t\tif (methods == null) {\n\t\t\tMethod[] reflectMethods = this.myType.getDeclaredMethods();\n\t\t\tConstructor[] reflectCons = this.myType.getDeclaredConstructors();\n\t\t\tResolvedMember[] rMethods = new ResolvedMember[reflectMethods.length + reflectCons.length];\n\t\t\tfor (int i = 0; i < reflectMethods.length; i++) {\n\t\t\t\trMethods[i] = createGenericMethodMember(reflectMethods[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < reflectCons.length; i++) {\n\t\t\t\trMethods[i + reflectMethods.length] = createGenericConstructorMember(reflectCons[i]);\n\t\t\t}\n\t\t\tthis.methods = rMethods;\n\t\t}\n\t\treturn methods;\n\t}\n\n\t/**\n\t * Returns the generic type, regardless of the resolvedType we 'know about'\n\t */\n\tpublic ResolvedType getGenericResolvedType() {\n\t\tResolvedType rt = getResolvedTypeX();\n\t\tif (rt.isParameterizedType() || rt.isRawType()) {\n\t\t\treturn rt.getGenericType();\n\t\t}\n\t\treturn rt;\n\t}\n\n\tprivate ResolvedMember createGenericMethodMember(Method forMethod) {\n\t\tReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,\n\t\t\t\tgetGenericResolvedType(), forMethod.getModifiers(), typeConverter.fromType(forMethod.getReturnType()),\n\t\t\t\tforMethod.getName(), typeConverter.fromTypes(forMethod.getParameterTypes()), typeConverter.fromTypes(forMethod\n\t\t\t\t\t\t.getExceptionTypes()), forMethod);\n\t\tret.setAnnotationFinder(this.annotationFinder);\n\t\tret.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(this.getWorld()));\n\t\treturn ret;\n\t}\n\n\tprivate ResolvedMember createGenericConstructorMember(Constructor<?> forConstructor) {\n\t\tReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,\n\t\t\t\tgetGenericResolvedType(), forConstructor.getModifiers(),\n\t\t\t\t// to return what BCEL returns the return type is void\n\t\t\t\tUnresolvedType.VOID,// getGenericResolvedType(),\n\t\t\t\t\"<init>\", typeConverter.fromTypes(forConstructor.getParameterTypes()), typeConverter.fromTypes(forConstructor\n\t\t\t\t\t\t.getExceptionTypes()), forConstructor);\n\t\tret.setAnnotationFinder(this.annotationFinder);\n\t\tret.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(this.getWorld()));\n\t\treturn ret;\n\t}\n\n\tprivate ResolvedMember createGenericFieldMember(Field forField) {\n\t\tReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.FIELD,\n\t\t\t\tgetGenericResolvedType(), forField.getModifiers(), typeConverter.fromType(forField.getType()), forField.getName(),\n\t\t\t\tUnresolvedType.NONE, forField);\n\t\tret.setAnnotationFinder(this.annotationFinder);\n\t\tret.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(this.getWorld()));\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic ResolvedMember[] getDeclaredPointcuts() {\n\t\tif (pointcuts == null) {\n\t\t\tPointcut[] pcs = this.myType.getDeclaredPointcuts();\n\t\t\tpointcuts = new ResolvedMember[pcs.length];\n\t\t\tInternalUseOnlyPointcutParser parser = null;\n\t\t\tWorld world = getWorld();\n\t\t\tif (world instanceof ReflectionWorld) {\n\t\t\t\tparser = new InternalUseOnlyPointcutParser(classLoaderReference.getClassLoader(), (ReflectionWorld) getWorld());\n\t\t\t} else {\n\t\t\t\tparser = new InternalUseOnlyPointcutParser(classLoaderReference.getClassLoader());\n\t\t\t}\n\t\t\tSet<PointcutDesignatorHandler> additionalPointcutHandlers = world.getRegisteredPointcutHandlers();\n\t\t\tfor (PointcutDesignatorHandler handler : additionalPointcutHandlers) {\n\t\t\t\tparser.registerPointcutDesignatorHandler(handler);\n\t\t\t}\n\n\t\t\t// phase 1, create legitimate entries in pointcuts[] before we\n\t\t\t// attempt to resolve *any* of the pointcuts\n\t\t\t// resolution can sometimes cause us to recurse, and this two stage\n\t\t\t// process allows us to cope with that\n\t\t\tfor (int i = 0; i < pcs.length; i++) {\n\t\t\t\tAjType<?>[] ptypes = pcs[i].getParameterTypes();\n\t\t\t\tUnresolvedType[] weaverPTypes = new UnresolvedType[ptypes.length];\n\t\t\t\tfor (int j = 0; j < weaverPTypes.length; j++) {\n\t\t\t\t\tweaverPTypes[j] = this.typeConverter.fromType(ptypes[j].getJavaClass());\n\t\t\t\t}\n\t\t\t\tpointcuts[i] = new DeferredResolvedPointcutDefinition(getResolvedTypeX(), pcs[i].getModifiers(), pcs[i].getName(),\n\t\t\t\t\t\tweaverPTypes);\n\t\t\t}\n\t\t\t// phase 2, now go back round and resolve in-place all of the\n\t\t\t// pointcuts\n\t\t\tPointcutParameter[][] parameters = new PointcutParameter[pcs.length][];\n\t\t\tfor (int i = 0; i < pcs.length; i++) {\n\t\t\t\tAjType<?>[] ptypes = pcs[i].getParameterTypes();\n\t\t\t\tString[] pnames = pcs[i].getParameterNames();\n\t\t\t\tif (pnames.length != ptypes.length) {\n\t\t\t\t\tpnames = tryToDiscoverParameterNames(pcs[i]);\n\t\t\t\t\tif (pnames == null || (pnames.length != ptypes.length)) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"Required parameter names not available when parsing pointcut \"\n\t\t\t\t\t\t\t\t+ pcs[i].getName() + \" in type \" + getResolvedTypeX().getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparameters[i] = new PointcutParameter[ptypes.length];\n\t\t\t\tfor (int j = 0; j < parameters[i].length; j++) {\n\t\t\t\t\tparameters[i][j] = parser.createPointcutParameter(pnames[j], ptypes[j].getJavaClass());\n\t\t\t\t}\n\t\t\t\tString pcExpr = pcs[i].getPointcutExpression().toString();\n\t\t\t\torg.aspectj.weaver.patterns.Pointcut pc = parser.resolvePointcutExpression(pcExpr, getBaseClass(), parameters[i]);\n\t\t\t\t((ResolvedPointcutDefinition) pointcuts[i]).setParameterNames(pnames);\n\t\t\t\t((ResolvedPointcutDefinition) pointcuts[i]).setPointcut(pc);\n\t\t\t}\n\t\t\t// phase 3, now concretize them all\n\t\t\tfor (int i = 0; i < pointcuts.length; i++) {\n\t\t\t\tResolvedPointcutDefinition rpd = (ResolvedPointcutDefinition) pointcuts[i];\n\t\t\t\trpd.setPointcut(parser.concretizePointcutExpression(rpd.getPointcut(), getBaseClass(), parameters[i]));\n\t\t\t}\n\t\t}\n\t\treturn pointcuts;\n\t}\n\n\t// for @AspectJ pointcuts compiled by javac only...\n\tprivate String[] tryToDiscoverParameterNames(Pointcut pcut) {\n\t\tMethod[] ms = pcut.getDeclaringType().getJavaClass().getDeclaredMethods();\n\t\tfor (Method m : ms) {\n\t\t\tif (m.getName().equals(pcut.getName())) {\n\t\t\t\treturn argNameFinder.getParameterNames(m);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isAnnotation() {\n\t\treturn getBaseClass().isAnnotation();\n\t}\n\n\t@Override\n\tpublic boolean isAnnotationStyleAspect() {\n\t\treturn getBaseClass().isAnnotationPresent(Aspect.class);\n\t}\n\n\t@Override\n\tpublic boolean isAnnotationWithRuntimeRetention() {\n\t\tif (!isAnnotation()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getBaseClass().isAnnotationPresent(Retention.class)) {\n\t\t\tRetention retention = (Retention) getBaseClass().getAnnotation(Retention.class);\n\t\t\tRetentionPolicy policy = retention.value();\n\t\t\treturn policy == RetentionPolicy.RUNTIME;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isAspect() {\n\t\treturn this.myType.isAspect();\n\t}\n\n\t@Override\n\tpublic boolean isEnum() {\n\t\treturn getBaseClass().isEnum();\n\t}\n\n\t@Override\n\tpublic boolean isGeneric() {\n\t\t// return false; // for now\n\t\treturn getBaseClass().getTypeParameters().length > 0;\n\t}\n\n\t@Override\n\tpublic boolean isAnonymous() {\n\t\treturn this.myClass.isAnonymousClass();\n\t}\n\n\t@Override\n\tpublic boolean isNested() {\n\t\treturn this.myClass.isMemberClass();\n\t}\n\n\t@Override\n\tpublic ResolvedType getOuterClass() {\n\t\t return ReflectionBasedReferenceTypeDelegateFactory.resolveTypeInWorld(\n\t\t\t\t \tmyClass.getEnclosingClass(),world);\n\t}\n\n}\n",
    "size": 14326
  },
  {
    "file_id": "F60",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/reflect/JavaLangTypeToResolvedTypeConverter.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n * ******************************************************************/\npackage org.aspectj.weaver.reflect;\n\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.WildcardType;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.aspectj.weaver.BoundedReferenceType;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.TypeFactory;\nimport org.aspectj.weaver.TypeVariable;\nimport org.aspectj.weaver.TypeVariableReferenceType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\n\n/**\n * Handles the translation of java.lang.reflect.Type objects into AspectJ UnresolvedTypes.\n *\n * @author Adrian Colyer\n */\npublic class JavaLangTypeToResolvedTypeConverter {\n\n\t// Used to prevent recursion - we record what we are working on and return it if asked again *whilst* working on it\n\tprivate Map<Type, TypeVariableReferenceType> typeVariablesInProgress = new HashMap<>();\n\tprivate final World world;\n\n\tpublic JavaLangTypeToResolvedTypeConverter(World aWorld) {\n\t\tthis.world = aWorld;\n\t}\n\n\tprivate World getWorld() {\n\t\treturn this.world;\n\t}\n\n\tpublic ResolvedType fromType(Type type) {\n\t\tif (type instanceof Class) {\n\t\t\tClass<?> clazz = (Class<?>) type;\n\t\t\tString name = clazz.getName();\n\t\t\t/**\n\t\t\t * getName() can return:\n\t\t\t *\n\t\t\t * 1. If this class object represents a reference type that is not an\n\t\t\t * array type then the binary name of the class is returned\n\t\t\t * 2. If this class object represents a primitive type or void, then\n\t\t\t * the name returned is a String equal to the Java language keyword\n\t\t\t * corresponding to the primitive type or void.\n\t\t\t * 3. If this class object represents a class of arrays, then the internal\n\t\t\t * form of the name consists of the name of the element type preceded by\n\t\t\t * one or more '[' characters representing the depth of the array nesting.\n\t\t\t */\n\t\t\tif (clazz.isArray()) {\n\t\t\t\tUnresolvedType ut = UnresolvedType.forSignature(name.replace('.', '/'));\n\t\t\t\treturn getWorld().resolve(ut);\n\t\t\t} else {\n\t\t\t\treturn getWorld().resolve(name);\n\t\t\t}\n\t\t} else if (type instanceof ParameterizedType) {\n\t\t\t// https://bugs.eclipse.org/bugs/show_bug.cgi?id=509327\n\t\t\t// TODO should deal with the ownerType if it set, indicating this is possibly an inner type of a parameterized type\n\t\t\tType ownerType = ((ParameterizedType) type).getOwnerType();\n\t\t\tParameterizedType parameterizedType = (ParameterizedType) type;\n\t\t\tResolvedType baseType = fromType(parameterizedType.getRawType());\n\t\t\tType[] typeArguments = parameterizedType.getActualTypeArguments();\n\t\t\tif (baseType.isSimpleType() && typeArguments.length == 0 && ownerType != null) {\n\t\t\t\t// 'type' is an inner type of some outer parameterized type\n\t\t\t\t// For now just return the base type - in future create the parameterized form of the outer\n\t\t\t\t// and use it with the inner. We return the base type to be compatible with what the\n\t\t\t\t// code does that accesses the info from the bytecode (unlike this code which accesses it\n\t\t\t\t// reflectively).\n\t\t\t\treturn baseType;\n\t\t\t}\n\t\t\tResolvedType[] resolvedTypeArguments = fromTypes(typeArguments);\n\t\t\treturn TypeFactory.createParameterizedType(baseType, resolvedTypeArguments, getWorld());\n\t\t} else if (type instanceof java.lang.reflect.TypeVariable) {\n\t\t\tTypeVariableReferenceType inprogressVar = typeVariablesInProgress.get(type);\n\t\t\tif (inprogressVar != null) {\n\t\t\t\treturn inprogressVar;\n\t\t\t}\n\t\t\tjava.lang.reflect.TypeVariable<?> tv = (java.lang.reflect.TypeVariable<?>) type;\n\t\t\tTypeVariable rt_tv = new TypeVariable(tv.getName());\n\t\t\tTypeVariableReferenceType tvrt = new TypeVariableReferenceType(rt_tv, getWorld());\n\t\t\ttypeVariablesInProgress.put(type, tvrt); // record what we are working on, for recursion case\n\t\t\tType[] bounds = tv.getBounds();\n\t\t\tResolvedType[] resBounds = fromTypes(bounds);\n\t\t\tResolvedType upperBound = resBounds[0];\n\t\t\tResolvedType[] additionalBounds = ResolvedType.EMPTY_RESOLVED_TYPE_ARRAY;\n\t\t\tif (resBounds.length > 1) {\n\t\t\t\tadditionalBounds = new ResolvedType[resBounds.length - 1];\n\t\t\t\tSystem.arraycopy(resBounds, 1, additionalBounds, 0, additionalBounds.length);\n\t\t\t}\n\t\t\trt_tv.setUpperBound(upperBound);\n\t\t\trt_tv.setAdditionalInterfaceBounds(additionalBounds);\n\t\t\ttypeVariablesInProgress.remove(type); // we have finished working on it\n\t\t\treturn tvrt;\n\t\t} else if (type instanceof WildcardType) {\n\t\t\tWildcardType wildType = (WildcardType) type;\n\t\t\tType[] lowerBounds = wildType.getLowerBounds();\n\t\t\tType[] upperBounds = wildType.getUpperBounds();\n\t\t\tResolvedType bound = null;\n\t\t\tboolean isExtends = lowerBounds.length == 0;\n\t\t\tif (isExtends) {\n\t\t\t\tbound = fromType(upperBounds[0]);\n\t\t\t} else {\n\t\t\t\tbound = fromType(lowerBounds[0]);\n\t\t\t}\n\t\t\treturn new BoundedReferenceType((ReferenceType) bound, isExtends, getWorld());\n\t\t} else if (type instanceof GenericArrayType) {\n\t\t\tGenericArrayType genericArrayType = (GenericArrayType) type;\n\t\t\tType componentType = genericArrayType.getGenericComponentType();\n\t\t\treturn UnresolvedType.makeArray(fromType(componentType), 1).resolve(getWorld());\n\t\t}\n\t\treturn ResolvedType.MISSING;\n\t}\n\n\tpublic ResolvedType[] fromTypes(Type[] types) {\n\t\tResolvedType[] ret = new ResolvedType[types.length];\n\t\tfor (int i = 0; i < ret.length; i++) {\n\t\t\tret[i] = fromType(types[i]);\n\t\t}\n\t\treturn ret;\n\t}\n\n}\n",
    "size": 5727
  },
  {
    "file_id": "F61",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/Jdk14Trace.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2006 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster - initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver.tools;\n\nimport java.util.logging.Handler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n// OPTIMIZE move out for now? check what doc says about using these variants on trace (commons/14)\npublic class Jdk14Trace extends AbstractTrace {\n\n\tprivate Logger logger;\n\tprivate String name;\n\n\tpublic Jdk14Trace (Class clazz) {\n\t\tsuper(clazz);\n\t\tthis.name = clazz.getName();\n\t\tthis.logger = Logger.getLogger(name);\n\t}\n\n\tpublic void enter(String methodName, Object thiz, Object[] args) {\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tlogger.entering(name,methodName,formatObj(thiz));\n\t\t\tif (args != null && logger.isLoggable(Level.FINER)) {\n\t\t\t\tlogger.entering(name,methodName,formatObjects(args));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void enter(String methodName, Object thiz) {\n\t\tenter(methodName,thiz,null);\n\t}\n\n\tpublic void exit(String methodName, Object ret) {\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tlogger.exiting(name,methodName,formatObj(ret));\n\t\t}\n\t}\n\n\tpublic void exit(String methodName, Throwable th) {\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tlogger.exiting(name,methodName,th);\n\t\t}\n\t}\n\n\tpublic void exit(String methodName) {\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tlogger.exiting(name,methodName);\n\t\t}\n\t}\n\n\tpublic void event(String methodName, Object thiz, Object[] args) {\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tlogger.logp(Level.FINER,name,methodName,\"EVENT\",formatObj(thiz));\n\t\t\tif (args != null && logger.isLoggable(Level.FINER)) {\n\t\t\t\tlogger.logp(Level.FINER,name,methodName,\"EVENT\",formatObjects(args));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void event(String methodName) {\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tlogger.logp(Level.FINER,name,methodName,\"EVENT\");\n\t\t}\n\t}\n\n\tpublic boolean isTraceEnabled() {\n\t\treturn logger.isLoggable(Level.FINER);\n\t}\n\n\tpublic void setTraceEnabled (boolean b) {\n\t\tif (b) {\n\t\t\tlogger.setLevel(Level.FINER);\n\t\t\tHandler[] handlers = logger.getHandlers();\n\t\t\tif (handlers.length == 0) {\n\t\t\t\tLogger parent = logger.getParent();\n\t\t\t\tif (parent != null) handlers = parent.getHandlers();\n\t\t\t}\n\t\t\tfor (Handler handler : handlers) {\n\t\t\t\thandler.setLevel(Level.FINER);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlogger.setLevel(Level.INFO);\n\t\t}\n\t}\n\n\tpublic void debug (String message) {\n\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\tlogger.fine(message);\n\t\t}\n\t}\n\n\tpublic void info(String message) {\n\t\tif (logger.isLoggable(Level.INFO)) {\n\t\t\tlogger.info(message);\n\t\t}\n\t}\n\n\tpublic void warn (String message, Throwable th) {\n\t\tif (logger.isLoggable(Level.WARNING)) {\n\t\t\tlogger.log(Level.WARNING,message,th);\n\t\t}\n\t}\n\n\tpublic void error (String message, Throwable th) {\n\t\tif (logger.isLoggable(Level.SEVERE)) {\n\t\t\tlogger.log(Level.SEVERE,message,th);\n\t\t}\n\t}\n\n\tpublic void fatal (String message, Throwable th) {\n\t\tif (logger.isLoggable(Level.SEVERE)) {\n\t\t\tlogger.log(Level.SEVERE,message,th);\n\t\t}\n\t}\n\n}\n",
    "size": 3367
  },
  {
    "file_id": "F62",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/Jdk14TraceFactory.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2006 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster - initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver.tools;\n\npublic class Jdk14TraceFactory extends TraceFactory {\n\n\t@Override\n\tpublic Trace getTrace(Class clazz) {\n\t\treturn new Jdk14Trace(clazz);\n\t}\n\n}\n",
    "size": 721
  },
  {
    "file_id": "F63",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/WeavingAdaptor.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2004 IBM Corporation\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster, Adrian Colyer, John Kew + Lyor Goldstein (caching)\n *     Martin Lippert     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.tools;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.security.ProtectionDomain;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.aspectj.bridge.AbortException;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.IMessage.Kind;\nimport org.aspectj.bridge.IMessageContext;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.bridge.IMessageHolder;\nimport org.aspectj.bridge.Message;\nimport org.aspectj.bridge.MessageHandler;\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.bridge.MessageWriter;\nimport org.aspectj.bridge.Version;\nimport org.aspectj.bridge.WeaveMessage;\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.IClassFileProvider;\nimport org.aspectj.weaver.IUnwovenClassFile;\nimport org.aspectj.weaver.IWeaveRequestor;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelObjectType;\nimport org.aspectj.weaver.bcel.BcelWeaver;\nimport org.aspectj.weaver.bcel.BcelWorld;\nimport org.aspectj.weaver.bcel.UnwovenClassFile;\nimport org.aspectj.weaver.tools.cache.CachedClassEntry;\nimport org.aspectj.weaver.tools.cache.CachedClassReference;\nimport org.aspectj.weaver.tools.cache.SimpleCache;\nimport org.aspectj.weaver.tools.cache.SimpleCacheFactory;\nimport org.aspectj.weaver.tools.cache.WeavedClassCache;\n\n// OPTIMIZE add guards for all the debug/info/etc\n/**\n * This adaptor allows the AspectJ compiler to be embedded in an existing system to facilitate load-time weaving. It provides an\n * interface for a weaving class loader to provide a classpath to be woven by a set of aspects. A callback is supplied to allow a\n * class loader to define classes generated by the compiler during the weaving process.\n * <p>\n * A weaving class loader should create a <code>WeavingAdaptor</code> before any classes are defined, typically during construction.\n * The set of aspects passed to the adaptor is fixed for the lifetime of the adaptor although the classpath can be augmented. A\n * system property can be set to allow verbose weaving messages to be written to the console.\n *\n */\npublic class WeavingAdaptor implements IMessageContext {\n\n\t/**\n\t * System property used to turn on verbose weaving messages\n\t */\n\tpublic static final String WEAVING_ADAPTOR_VERBOSE = \"aj.weaving.verbose\";\n\tpublic static final String SHOW_WEAVE_INFO_PROPERTY = \"org.aspectj.weaver.showWeaveInfo\";\n\tpublic static final String TRACE_MESSAGES_PROPERTY = \"org.aspectj.tracing.messages\";\n\n  private final static String ASPECTJ_BASE_PACKAGE = \"org.aspectj.\";\n  private final static String PACKAGE_INITIAL_CHARS = ASPECTJ_BASE_PACKAGE.charAt(0) + \"sj\";\n\n\tprivate boolean enabled = false;\n\tprotected boolean verbose = getVerbose();\n\tprotected BcelWorld bcelWorld;\n\tprotected BcelWeaver weaver;\n\tprivate IMessageHandler messageHandler;\n\tprivate WeavingAdaptorMessageHolder messageHolder;\n\tprivate boolean abortOnError = false;\n\tprotected GeneratedClassHandler generatedClassHandler;\n\tprotected Map<String, IUnwovenClassFile> generatedClasses = new HashMap<>();\n\tpublic BcelObjectType delegateForCurrentClass; // lazily initialized, should be used to prevent parsing bytecode multiple\n\t// times\n\tprotected ProtectionDomain activeProtectionDomain;\n\n\tprivate boolean haveWarnedOnJavax = false;\n    protected WeavedClassCache cache;\n\n\tprivate int weavingSpecialTypes = 0;\n\tprivate static final int INITIALIZED = 0x1;\n\tprivate static final int WEAVE_JAVA_PACKAGE = 0x2;\n\tprivate static final int WEAVE_JAVAX_PACKAGE = 0x4;\n\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(WeavingAdaptor.class);\n\n\tprotected WeavingAdaptor() {\n\t}\n\n\t/**\n\t * Construct a WeavingAdaptor with a reference to a weaving class loader. The adaptor will automatically search the class loader\n\t * hierarchy to resolve classes. The adaptor will also search the hierarchy for WeavingClassLoader instances to determine the\n\t * set of aspects to be used for weaving.\n\t *\n\t * @param loader instance of <code>ClassLoader</code>\n\t */\n\tpublic WeavingAdaptor(WeavingClassLoader loader) {\n\t\t// System.err.println(\"? WeavingAdaptor.<init>(\" + loader +\",\" + aspectURLs.length + \")\");\n\t\tgeneratedClassHandler = loader;\n\t\tinit((ClassLoader)loader, getFullClassPath((ClassLoader) loader), getFullAspectPath((ClassLoader) loader/* ,aspectURLs */));\n\t}\n\n\t/**\n\t * Construct a WeavingAdaptor with a reference to a <code>GeneratedClassHandler</code>, a full search path for resolving classes\n\t * and a complete set of aspects. The search path must include classes loaded by the class loader constructing the\n\t * WeavingAdaptor and all its parents in the hierarchy.\n\t *\n\t * @param handler <code>GeneratedClassHandler</code>\n\t * @param classURLs the URLs from which to resolve classes\n\t * @param aspectURLs the aspects used to weave classes defined by this class loader\n\t */\n\tpublic WeavingAdaptor(GeneratedClassHandler handler, URL[] classURLs, URL[] aspectURLs) {\n\t\t// System.err.println(\"? WeavingAdaptor.<init>()\");\n\t\tgeneratedClassHandler = handler;\n\t\tinit(null, FileUtil.makeClasspath(classURLs), FileUtil.makeClasspath(aspectURLs));\n\t}\n\n\tprotected List<String> getFullClassPath(ClassLoader loader) {\n\t\tList<String> list = new LinkedList<>();\n\t\tfor (; loader != null; loader = loader.getParent()) {\n\t\t\tif (loader instanceof URLClassLoader) {\n\t\t\t\tURL[] urls = ((URLClassLoader) loader).getURLs();\n\t\t\t\tlist.addAll(0, FileUtil.makeClasspath(urls));\n\t\t\t} else {\n\t\t\t\twarn(\"cannot determine classpath\");\n\t\t\t}\n\t\t}\n\t\t// On Java9 it is possible to fail to find a URLClassLoader from which to derive a suitable classpath\n\t\t// For now we can determine it from the java.class.path:\n        if (LangUtil.isVMGreaterOrEqual(9)) {\n\t    \t\tlist.add(0, LangUtil.getJrtFsFilePath());\n\t\t\tList<String> javaClassPathEntries = makeClasspath(System.getProperty(\"java.class.path\"));\n\t\t\tfor (int i=javaClassPathEntries.size()-1;i>=0;i--) {\n\t\t\t\tString javaClassPathEntry = javaClassPathEntries.get(i);\n\t\t\t\tif (!list.contains(javaClassPathEntry)) {\n\t\t\t\t\tlist.add(0,javaClassPathEntry);\n\t\t\t\t}\n\t\t\t}\n        }\n\t\t// On Java9 the sun.boot.class.path won't be set. System classes accessible through JRT filesystem\n\t\tlist.addAll(0, makeClasspath(System.getProperty(\"sun.boot.class.path\")));\n\t\treturn list;\n\t}\n\n\tprivate List<String> getFullAspectPath(ClassLoader loader) {\n\t\tList<String> list = new LinkedList<>();\n\t\tfor (; loader != null; loader = loader.getParent()) {\n\t\t\tif (loader instanceof WeavingClassLoader) {\n\t\t\t\tURL[] urls = ((WeavingClassLoader) loader).getAspectURLs();\n\t\t\t\tlist.addAll(0, FileUtil.makeClasspath(urls));\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate static boolean getVerbose() {\n\t\ttry {\n\t\t\treturn Boolean.getBoolean(WEAVING_ADAPTOR_VERBOSE);\n\t\t} catch (Throwable t) {\n\t\t\t// security exception\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the WeavingAdapter\n\t * @param loader ClassLoader used by this adapter; which can be null\n\t * @param classPath classpath of this adapter\n\t * @param aspectPath list of aspect paths\n\t */\n\tprivate void init(ClassLoader loader, List<String> classPath, List<String> aspectPath) {\n\t\tabortOnError = true;\n\t\tcreateMessageHandler();\n\n\t\tinfo(\"using classpath: \" + classPath);\n\t\tinfo(\"using aspectpath: \" + aspectPath);\n\n\t\tbcelWorld = new BcelWorld(classPath, messageHandler, null);\n\t\tbcelWorld.setXnoInline(false);\n\t\tbcelWorld.getLint().loadDefaultProperties();\n\t\tbcelWorld.setBehaveInJava5Way(true);\n\n\t\tweaver = new BcelWeaver(bcelWorld);\n\t\tregisterAspectLibraries(aspectPath);\n\t\tinitializeCache(loader, aspectPath, null, getMessageHandler());\n\t\tenabled = true;\n\t}\n\n\t/**\n\t * If the cache is enabled, initialize it and swap out the existing classhandler\n\t * for the caching one -\n\t *\n\t * @param loader\t\t\t   classloader for this adapter, may be null\n\t * @param aspects\t\t\t  List of strings representing aspects managed by the adapter; these could be urls or classnames\n\t * @param existingClassHandler current class handler\n\t * @param myMessageHandler\t current message handler\n\t */\n\tprotected void initializeCache(ClassLoader loader, List<String> aspects, GeneratedClassHandler existingClassHandler, IMessageHandler myMessageHandler) {\n\t\tif (WeavedClassCache.isEnabled()) {\n\t\t\tcache = WeavedClassCache.createCache(loader, aspects, existingClassHandler, myMessageHandler);\n\t\t\t// Wrap the existing class handler so that any generated classes are also cached\n\t\t\tif (cache != null) {\n\t\t\t\tthis.generatedClassHandler = cache.getCachingClassHandler();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprotected void createMessageHandler() {\n\t\tmessageHolder = new WeavingAdaptorMessageHolder(new PrintWriter(System.err));\n\t\tmessageHandler = messageHolder;\n\t\tif (verbose) {\n\t\t\tmessageHandler.dontIgnore(IMessage.INFO);\n\t\t}\n\t\tif (Boolean.getBoolean(SHOW_WEAVE_INFO_PROPERTY)) {\n\t\t\tmessageHandler.dontIgnore(IMessage.WEAVEINFO);\n\t\t}\n\t\tinfo(\"AspectJ Weaver Version \" + Version.getText() + \" built on \" + Version.getTimeText()); //$NON-NLS-1$\n\t}\n\n\tprotected IMessageHandler getMessageHandler() {\n\t\treturn messageHandler;\n\t}\n\n\tpublic IMessageHolder getMessageHolder() {\n\t\treturn messageHolder;\n\t}\n\n\tprotected void setMessageHandler(IMessageHandler mh) {\n\t\tif (mh instanceof ISupportsMessageContext) {\n\t\t\tISupportsMessageContext smc = (ISupportsMessageContext) mh;\n\t\t\tsmc.setMessageContext(this);\n\t\t}\n\t\tif (mh != messageHolder) {\n\t\t\tmessageHolder.setDelegate(mh);\n\t\t}\n\t\tmessageHolder.flushMessages();\n\t}\n\n\tprotected void disable() {\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.enter(\"disable\", this);\n\t\t}\n\n\t\tenabled = false;\n\t\tmessageHolder.flushMessages();\n\n\t\tif (trace.isTraceEnabled()) {\n\t\t\ttrace.exit(\"disable\");\n\t\t}\n\t}\n\n\tprotected void enable() {\n\t\tenabled = true;\n\t\tmessageHolder.flushMessages();\n\t}\n\n\tprotected boolean isEnabled() {\n\t\treturn enabled;\n\t}\n\n\t/**\n\t * Appends URL to path used by the WeavingAdptor to resolve classes\n\t *\n\t * @param url to be appended to search path\n\t */\n\tpublic void addURL(URL url) {\n\t\tFile libFile = new File(url.getPath());\n\t\ttry {\n\t\t\tweaver.addLibraryJarFile(libFile);\n\t\t} catch (IOException ex) {\n\t\t\twarn(\"bad library: '\" + libFile + \"'\");\n\t\t}\n\t}\n\n\t/**\n\t * Weave a class using aspects previously supplied to the adaptor.\n\t *\n\t * @param name the name of the class\n\t * @param bytes the class bytes\n\t * @return the woven bytes\n\t * @exception IOException weave failed\n\t */\n\tpublic byte[] weaveClass(String name, byte[] bytes) throws IOException {\n\t\treturn weaveClass(name, bytes, false);\n\t}\n\n\t// Track if the weaver is already running on this thread - don't allow re-entrant calls\n\tprivate ThreadLocal<Boolean> weaverRunning = new ThreadLocal<Boolean>() {\n\t\t@Override\n\t\tprotected Boolean initialValue() {\n\t\t\treturn Boolean.FALSE;\n\t\t}\n\t};\n\n\t/**\n\t * Weave a class using aspects previously supplied to the adaptor.\n\t *\n\t * @param name      the name of the class in the internal form of fully qualified class and interface names as defined\n\t *                  in <i>The Java Virtual Machine Specification</i>. For example, <code>\"java/util/List\"</code>.\n\t * @param bytes     the input byte buffer in class file format - must not be modified\n\t * @param mustWeave if true then this class <i>must</i> get woven (used for concrete aspects generated from XML)\n\t *\n\t * @return a well-formed class file buffer (the weaving result), or {@code null} if no weaving was performed\n\t *\n\t * @throws IOException weave failed\n\t *\n\t * @see java.lang.instrument.ClassFileTransformer#transform(ClassLoader, String, Class, ProtectionDomain, byte[])\n\t */\n\tpublic byte[] weaveClass(String name, final byte[] bytes, boolean mustWeave) throws IOException {\n\t\tif (trace == null) {\n\t\t\t// Pr231945: we are likely to be under tomcat and ENABLE_CLEAR_REFERENCES hasn't been set\n\t\t\tSystem.err\n\t\t\t\t\t.println(\"AspectJ Weaver cannot continue to weave, static state has been cleared.  Are you under Tomcat? In order to weave '\"\n\t\t\t\t\t\t\t+ name\n\t\t\t\t\t\t\t+ \"' during shutdown, 'org.apache.catalina.loader.WebappClassLoader.ENABLE_CLEAR_REFERENCES=false' must be set (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=231945).\");\n\t\t\treturn null;\n\t\t}\n\t\tif (weaverRunning.get()) {\n\t\t\t// System.out.println(\"AJC: avoiding re-entrant call to transform \" + name);\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tbyte[] newBytes = null;\n\t\t\tweaverRunning.set(true);\n\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\ttrace.enter(\"weaveClass\", this, new Object[] { name, bytes });\n\t\t\t}\n\n\t\t\tif (!enabled) {\n\t\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\t\ttrace.exit(\"weaveClass\", false);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tboolean debugOn = !messageHandler.isIgnoring(Message.DEBUG);\n\n\t\t\tname = name.replace('/', '.');\n\t\t\tbyte[] wovenBytes = wovenWithGeneratedClass(name);\n\t\t\tif (wovenBytes != null) {\n\t\t\t\tif (debugOn) {\n\t\t\t\t\tdebug(\"returning woven bytes for '\" + name + \"' that were generated by a previous weaving process\");\n\t\t\t\t}\n\t\t\t\treturn wovenBytes;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tdelegateForCurrentClass = null;\n\t\t\t\tif (shouldWeaveName(name)) {\n\t\t\t\t\tif (accept(name, bytes)) {\n\n\t\t\t\t\t\t// Determine if we have the weaved class cached\n\t\t\t\t\t\tCachedClassReference cacheKey = null;\n\t\t\t\t\t\tif (cache != null && !mustWeave) {\n\t\t\t\t\t\t\tcacheKey = cache.createCacheKey(name, bytes);\n\t\t\t\t\t\t\tCachedClassEntry entry = cache.get(cacheKey, bytes);\n\t\t\t\t\t\t\tif (entry != null) {\n\t\t\t\t\t\t\t\t// If the entry has been explicitly ignored\n\t\t\t\t\t\t\t\t// return the original bytes\n\t\t\t\t\t\t\t\tif (entry.isIgnored()) {\n\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn entry.getBytes();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TODO @AspectJ problem\n\t\t\t\t\t\t// Annotation style aspects need to be included regardless in order to get\n\t\t\t\t\t\t// a valid aspectOf()/hasAspect() generated in them. However - if they are excluded\n\t\t\t\t\t\t// (via include/exclude in aop.xml) they really should only get aspectOf()/hasAspect()\n\t\t\t\t\t\t// and not be included in the full set of aspects being applied by 'this' weaver\n\t\t\t\t\t\tif (debugOn) {\n\t\t\t\t\t\t\tdebug(\"weaving '\" + name + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewBytes = getWovenBytes(name, bytes);\n\t\t\t\t\t\t// TODO: Is this OK performance-wise?\n\t\t\t\t\t\tif (Arrays.equals(bytes, newBytes)) {\n\t\t\t\t\t\t\t// null means unchanged in java.lang.instrument.ClassFileTransformer::transform\n\t\t\t\t\t\t\tnewBytes = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// temporarily out - searching for @Aspect annotated types is a slow thing to do - we should\n\t\t\t\t\t\t// expect the user to name them if they want them woven - just like code style\n\t\t\t\t\t\t// } else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {\n\t\t\t\t\t\t// if (mustWeave) {\n\t\t\t\t\t\t// if (bcelWorld.getLint().mustWeaveXmlDefinedAspects.isEnabled()) {\n\t\t\t\t\t\t// bcelWorld.getLint().mustWeaveXmlDefinedAspects.signal(name, null);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// // an @AspectJ aspect needs to be at least munged by the aspectOf munger\n\t\t\t\t\t\t// if (debugOn) {\n\t\t\t\t\t\t// debug(\"weaving '\" + name + \"'\");\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// bytes = getAtAspectJAspectBytes(name, bytes);\n\n\t\t\t\t\t\t// Add the weaved class to the cache only if there\n\t\t\t\t\t\t// has been an actual change\n\t\t\t\t\t\t// JVK: Is there a better way to check if the class has\n\t\t\t\t\t\t// been transformed without carrying up some value\n\t\t\t\t\t\t// from the depths?\n\t\t\t\t\t\tif (cacheKey != null) {\n\t\t\t\t\t\t\t// If no transform has been applied, mark the class\n\t\t\t\t\t\t\t// as ignored.\n\t\t\t\t\t\t\tif (newBytes == null) {\n\t\t\t\t\t\t\t\tcache.ignore(cacheKey, bytes);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcache.put(cacheKey, bytes, newBytes);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (debugOn) {\n\t\t\t\t\t\tdebug(\"not weaving '\" + name + \"'\");\n\t\t\t\t\t}\n\t\t\t\t} else if (debugOn) {\n\t\t\t\t\tdebug(\"cannot weave '\" + name + \"'\");\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tdelegateForCurrentClass = null;\n\t\t\t}\n\n\t\t\tif (trace.isTraceEnabled()) {\n\t\t\t\ttrace.exit(\"weaveClass\", newBytes);\n\t\t\t}\n\t\t\treturn newBytes;\n\t\t} finally {\n\t\t\tweaverRunning.remove();\n\t\t}\n\t}\n\n\t/**\n\t * Return the bytes from a (parallel?) weaving process that generated an inner class, e.g. to support Around closures.\n\t * This is done instead of weaving again, as weaving would generate another inner class.\n\t * @param name\n\t * @return the cached bytes of a previously woven class, or null if not found\n\t */\n\tprivate byte[] wovenWithGeneratedClass(String name) {\n\t\tIUnwovenClassFile woven = generatedClasses.get(name);\n\t\tif (woven == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn woven.getBytes();\n\t}\n\n\t// ATAJ\n\tprotected boolean accept(String name, byte[] bytes) {\n\t\treturn true;\n\t}\n\n\tprotected boolean shouldDump(String name, boolean before) {\n\t\treturn false;\n\t}\n\n\tprivate boolean shouldWeaveName(String name) {\n\t\tif (PACKAGE_INITIAL_CHARS.indexOf(name.charAt(0)) != -1) {\n\t\t\tif ((weavingSpecialTypes & INITIALIZED) == 0) {\n\t\t\t\tweavingSpecialTypes |= INITIALIZED;\n\t\t\t\t// initialize it\n\t\t\t\tProperties p = weaver.getWorld().getExtraConfiguration();\n\t\t\t\tif (p != null) {\n\t\t\t\t\tboolean b = p.getProperty(World.xsetWEAVE_JAVA_PACKAGES, \"false\").equalsIgnoreCase(\"true\");\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\tweavingSpecialTypes |= WEAVE_JAVA_PACKAGE;\n\t\t\t\t\t}\n\t\t\t\t\tb = p.getProperty(World.xsetWEAVE_JAVAX_PACKAGES, \"false\").equalsIgnoreCase(\"true\");\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\tweavingSpecialTypes |= WEAVE_JAVAX_PACKAGE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (name.startsWith(ASPECTJ_BASE_PACKAGE)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (name.startsWith(\"sun.reflect.\")) {// JDK reflect\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (name.startsWith(\"javax.\")) {\n\t\t\t\tif ((weavingSpecialTypes & WEAVE_JAVAX_PACKAGE) != 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!haveWarnedOnJavax) {\n\t\t\t\t\t\thaveWarnedOnJavax = true;\n\t\t\t\t\t\twarn(\"javax.* types are not being woven because the weaver option '-Xset:weaveJavaxPackages=true' has not been specified\");\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (name.startsWith(\"java.\")) {\n\t\t\t\tif ((weavingSpecialTypes & WEAVE_JAVA_PACKAGE) != 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// boolean should = !(name.startsWith(\"org.aspectj.\")\n\t\t// || (name.startsWith(\"java.\") && (weavingSpecialTypes & WEAVE_JAVA_PACKAGE) == 0)\n\t\t// || (name.startsWith(\"javax.\") && (weavingSpecialTypes & WEAVE_JAVAX_PACKAGE) == 0)\n\t\t// // || name.startsWith(\"$Proxy\")//JDK proxies//FIXME AV is that 1.3 proxy ? fe. ataspect.$Proxy0 is a java5 proxy...\n\t\t// || name.startsWith(\"sun.reflect.\"));\n\t\treturn true;\n\t}\n\n\t/**\n\t * We allow @AJ aspect weaving so that we can add aspectOf() as part of the weaving (and not part of the source compilation)\n\t *\n\t * @param name\n\t * @param bytes bytecode (from classloader), allow to NOT lookup stuff on disk again during resolve\n\t * @return true if @Aspect\n\t */\n\tprivate boolean shouldWeaveAnnotationStyleAspect(String name, byte[] bytes) {\n\t\tif (delegateForCurrentClass == null) {\n\t\t\t// if (weaver.getWorld().isASMAround()) return asmCheckAnnotationStyleAspect(bytes);\n\t\t\t// else\n\t\t\tensureDelegateInitialized(name, bytes);\n\t\t}\n\t\treturn (delegateForCurrentClass.isAnnotationStyleAspect());\n\t}\n\n\t// private boolean asmCheckAnnotationStyleAspect(byte[] bytes) {\n\t// IsAtAspectAnnotationVisitor detector = new IsAtAspectAnnotationVisitor();\n\t//\n\t// ClassReader cr = new ClassReader(bytes);\n\t// try {\n\t// cr.accept(detector, true);//, ClassReader.SKIP_DEBUG | ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES);\n\t// } catch (Exception spe) {\n\t// // if anything goes wrong, e.g., an NPE, then assume it's NOT an @AspectJ aspect...\n\t// System.err.println(\"Unexpected problem parsing bytes to discover @Aspect annotation\");\n\t// spe.printStackTrace();\n\t// return false;\n\t// }\n\t//\n\t// return detector.isAspect();\n\t// }\n\n\tprotected void ensureDelegateInitialized(String name, byte[] bytes) {\n\t\tif (delegateForCurrentClass == null) {\n\t\t\tBcelWorld world = (BcelWorld) weaver.getWorld();\n\t\t\tdelegateForCurrentClass = world.addSourceObjectType(name, bytes, false);\n\t\t}\n\t}\n\n\t/**\n\t * Weave a set of bytes defining a class.\n\t *\n\t * @param name the name of the class being woven\n\t * @param bytes the bytes that define the class\n\t * @return byte[] the woven bytes for the class\n\t * @throws IOException\n\t */\n\tprivate byte[] getWovenBytes(String name, byte[] bytes) throws IOException {\n\t\tWeavingClassFileProvider wcp = new WeavingClassFileProvider(name, bytes);\n\t\tweaver.weave(wcp);\n\t\treturn wcp.getBytes();\n\t}\n\n\t/**\n\t * Weave a set of bytes defining a class for only what is needed to turn @AspectJ aspect in a usefull form ie with aspectOf\n\t * method - see #113587\n\t *\n\t * @param name the name of the class being woven\n\t * @param bytes the bytes that define the class\n\t * @return byte[] the woven bytes for the class\n\t * @throws IOException\n\t */\n\tprivate byte[] getAtAspectJAspectBytes(String name, byte[] bytes) throws IOException {\n\t\tWeavingClassFileProvider wcp = new WeavingClassFileProvider(name, bytes);\n\t\twcp.setApplyAtAspectJMungersOnly();\n\t\tweaver.weave(wcp);\n\t\treturn wcp.getBytes();\n\t}\n\n\tprivate void registerAspectLibraries(List<String> aspectPath) {\n\t\t// System.err.println(\"? WeavingAdaptor.registerAspectLibraries(\" + aspectPath + \")\");\n\t\tfor (String libName : aspectPath) {\n\t\t\taddAspectLibrary(libName);\n\t\t}\n\n\t\tweaver.prepareForWeave();\n\t}\n\n\t/*\n\t * Register an aspect library with this classloader for use during weaving. This class loader will also return (unmodified) any\n\t * of the classes in the library in response to a <code>findClass()</code> request. The library is not required to be on the\n\t * weavingClasspath given when this classloader was constructed.\n\t *\n\t * @param aspectLibraryJarFile a jar file representing an aspect library\n\t *\n\t * @throws IOException\n\t */\n\tprivate void addAspectLibrary(String aspectLibraryName) {\n\t\tFile aspectLibrary = new File(aspectLibraryName);\n\t\tif (aspectLibrary.isDirectory() || (FileUtil.isZipFile(aspectLibrary))) {\n\t\t\ttry {\n\t\t\t\tinfo(\"adding aspect library: '\" + aspectLibrary + \"'\");\n\t\t\t\tweaver.addLibraryJarFile(aspectLibrary);\n\t\t\t} catch (IOException ex) {\n\t\t\t\terror(\"exception adding aspect library: '\" + ex + \"'\");\n\t\t\t}\n\t\t} else {\n\t\t\terror(\"bad aspect library: '\" + aspectLibrary + \"'\");\n\t\t}\n\t}\n\n\tprivate static List<String> makeClasspath(String cp) {\n\t\tList<String> ret = new ArrayList<>();\n\t\tif (cp != null) {\n\t\t\tStringTokenizer tok = new StringTokenizer(cp, File.pathSeparator);\n\t\t\twhile (tok.hasMoreTokens()) {\n\t\t\t\tret.add(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprotected boolean debug(String message) {\n\t\treturn MessageUtil.debug(messageHandler, message);\n\t}\n\n\tprotected boolean info(String message) {\n\t\treturn MessageUtil.info(messageHandler, message);\n\t}\n\n\tprotected boolean warn(String message) {\n\t\treturn MessageUtil.warn(messageHandler, message);\n\t}\n\n\tprotected boolean warn(String message, Throwable th) {\n\t\treturn messageHandler.handleMessage(new Message(message, IMessage.WARNING, th, null));\n\t}\n\n\tprotected boolean error(String message) {\n\t\treturn MessageUtil.error(messageHandler, message);\n\t}\n\n\tprotected boolean error(String message, Throwable th) {\n\t\treturn messageHandler.handleMessage(new Message(message, IMessage.ERROR, th, null));\n\t}\n\n\tpublic String getContextId() {\n\t\treturn \"WeavingAdaptor\";\n\t}\n\n\t/**\n\t * Dump the given bytcode in _dump/... (dev mode)\n\t *\n\t * @param name\n\t * @param b\n\t * @param before whether we are dumping before weaving\n\t */\n\tprotected void dump(String name, byte[] b, boolean before) {\n\t\tString dirName = getDumpDir();\n\n\t\tif (before) {\n\t\t\tdirName = dirName + File.separator + \"_before\";\n\t\t}\n\n\t\tString className = name.replace('.', '/');\n\t\tfinal File dir;\n\t\tif (className.indexOf('/') > 0) {\n\t\t\tdir = new File(dirName + File.separator + className.substring(0, className.lastIndexOf('/')));\n\t\t} else {\n\t\t\tdir = new File(dirName);\n\t\t}\n\t\tdir.mkdirs();\n\t\tString fileName = dirName + File.separator + className + \".class\";\n\t\ttry {\n\t\t\t// System.out.println(\"WeavingAdaptor.dump() fileName=\" + new File(fileName).getAbsolutePath());\n\t\t\tFileOutputStream os = new FileOutputStream(fileName);\n\t\t\tos.write(b);\n\t\t\tos.close();\n\t\t} catch (IOException ex) {\n\t\t\twarn(\"unable to dump class \" + name + \" in directory \" + dirName, ex);\n\t\t}\n\t}\n\n\t/**\n\t * @return the directory in which to dump - default is _ajdump but it\n\t */\n\tprotected String getDumpDir() {\n\t\treturn \"_ajdump\";\n\t}\n\n\t/**\n\t * Processes messages arising from weaver operations. Tell weaver to abort on any message more severe than warning.\n\t */\n\tprotected class WeavingAdaptorMessageHolder extends MessageHandler {\n\n\t\tprivate IMessageHandler delegate;\n\t\tprivate List<IMessage> savedMessages;\n\n\t\tprotected boolean traceMessages = Boolean.getBoolean(TRACE_MESSAGES_PROPERTY);\n\n\t\tpublic WeavingAdaptorMessageHolder(PrintWriter writer) {\n\n\t\t\tthis.delegate = new WeavingAdaptorMessageWriter(writer);\n\t\t\tsuper.dontIgnore(IMessage.WEAVEINFO);\n\t\t}\n\n\t\tprivate void traceMessage(IMessage message) {\n\t\t\tif (message instanceof WeaveMessage) {\n\t\t\t\ttrace.debug(render(message));\n\t\t\t} else if (message.isDebug()) {\n\t\t\t\ttrace.debug(render(message));\n\t\t\t} else if (message.isInfo()) {\n\t\t\t\ttrace.info(render(message));\n\t\t\t} else if (message.isWarning()) {\n\t\t\t\ttrace.warn(render(message), message.getThrown());\n\t\t\t} else if (message.isError()) {\n\t\t\t\ttrace.error(render(message), message.getThrown());\n\t\t\t} else if (message.isFailed()) {\n\t\t\t\ttrace.fatal(render(message), message.getThrown());\n\t\t\t} else if (message.isAbort()) {\n\t\t\t\ttrace.fatal(render(message), message.getThrown());\n\t\t\t} else {\n\t\t\t\ttrace.error(render(message), message.getThrown());\n\t\t\t}\n\t\t}\n\n\t\tprotected String render(IMessage message) {\n\t\t\treturn \"[\" + getContextId() + \"] \" + message.toString();\n\t\t}\n\n\t\tpublic void flushMessages() {\n\t\t\tif (savedMessages == null) {\n\t\t\t\tsavedMessages = new ArrayList<>();\n\t\t\t\tsavedMessages.addAll(super.getUnmodifiableListView());\n\t\t\t\tclearMessages();\n\t\t\t\tfor (IMessage message : savedMessages) {\n\t\t\t\t\tdelegate.handleMessage(message);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// accumulating = false;\n\t\t\t// messages.clear();\n\t\t}\n\n\t\tpublic void setDelegate(IMessageHandler messageHandler) {\n\t\t\tdelegate = messageHandler;\n\t\t}\n\n\t\t/*\n\t\t * IMessageHandler\n\t\t */\n\n\t\t@Override\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\n\t\t\tif (traceMessages) {\n\t\t\t\ttraceMessage(message);\n\t\t\t}\n\n\t\t\tsuper.handleMessage(message);\n\n\t\t\tif (abortOnError && 0 <= message.getKind().compareTo(IMessage.ERROR)) {\n\t\t\t\tthrow new AbortException(message);\n\t\t\t}\n\t\t\t// if (accumulating) {\n\t\t\t// boolean result = addMessage(message);\n\t\t\t// if (abortOnError && 0 <= message.getKind().compareTo(IMessage.ERROR)) {\n\t\t\t// throw new AbortException(message);\n\t\t\t// }\n\t\t\t// return result;\n\t\t\t// }\n\t\t\t// else return delegate.handleMessage(message);\n\n\t\t\tif (savedMessages != null) {\n\t\t\t\tdelegate.handleMessage(message);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isIgnoring(Kind kind) {\n\t\t\treturn delegate.isIgnoring(kind);\n\t\t}\n\n\t\t@Override\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\n\t\t\tif (null != kind && delegate != null) {\n\t\t\t\tdelegate.dontIgnore(kind);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void ignore(Kind kind) {\n\t\t\tif (null != kind && delegate != null) {\n\t\t\t\tdelegate.ignore(kind);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * IMessageHolder\n\t\t */\n\n\t\t@Override\n\t\tpublic List<IMessage> getUnmodifiableListView() {\n\t\t\t// System.err.println(\"? WeavingAdaptorMessageHolder.getUnmodifiableListView() savedMessages=\" + savedMessages);\n\t\t\tList<IMessage> allMessages = new ArrayList<>();\n\t\t\tallMessages.addAll(savedMessages);\n\t\t\tallMessages.addAll(super.getUnmodifiableListView());\n\t\t\treturn allMessages;\n\t\t}\n\t}\n\n\tprotected class WeavingAdaptorMessageWriter extends MessageWriter {\n\n\t\tprivate final Set<IMessage.Kind> ignoring = new HashSet<>();\n\t\tprivate final IMessage.Kind failKind;\n\n\t\tpublic WeavingAdaptorMessageWriter(PrintWriter writer) {\n\t\t\tsuper(writer, true);\n\n\t\t\tignore(IMessage.WEAVEINFO);\n\t\t\tignore(IMessage.DEBUG);\n\t\t\tignore(IMessage.INFO);\n\t\t\tthis.failKind = IMessage.ERROR;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\n\t\t\t// boolean result =\n\t\t\tsuper.handleMessage(message);\n\t\t\tif (abortOnError && 0 <= message.getKind().compareTo(failKind)) {\n\t\t\t\tthrow new AbortException(message);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isIgnoring(Kind kind) {\n\t\t\treturn ((null != kind) && (ignoring.contains(kind)));\n\t\t}\n\n\t\t/**\n\t\t * Set a message kind to be ignored from now on\n\t\t */\n\t\t@Override\n\t\tpublic void ignore(IMessage.Kind kind) {\n\t\t\tif ((null != kind) && (!ignoring.contains(kind))) {\n\t\t\t\tignoring.add(kind);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Remove a message kind from the list of those ignored from now on.\n\t\t */\n\t\t@Override\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\n\t\t\tif (null != kind) {\n\t\t\t\tignoring.remove(kind);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected String render(IMessage message) {\n\t\t\treturn \"[\" + getContextId() + \"] \" + super.render(message);\n\t\t}\n\t}\n\n\tprivate class WeavingClassFileProvider implements IClassFileProvider {\n\n\t\tprivate final UnwovenClassFile unwovenClass;\n\t\tprivate final List<UnwovenClassFile> unwovenClasses = new ArrayList<>();\n\t\tprivate IUnwovenClassFile wovenClass;\n\t\tprivate boolean isApplyAtAspectJMungersOnly = false;\n\n\t\tpublic WeavingClassFileProvider(String name, byte[] bytes) {\n\t\t\tensureDelegateInitialized(name, bytes);\n\t\t\tthis.unwovenClass = new UnwovenClassFile(name, delegateForCurrentClass.getResolvedTypeX().getName(), bytes);\n\t\t\tthis.unwovenClasses.add(unwovenClass);\n\n\t\t\tif (shouldDump(name.replace('/', '.'), true)) {\n\t\t\t\tdump(name, bytes, true);\n\t\t\t}\n\n\t\t}\n\n\t\tpublic void setApplyAtAspectJMungersOnly() {\n\t\t\tisApplyAtAspectJMungersOnly = true;\n\t\t}\n\n\t\tpublic boolean isApplyAtAspectJMungersOnly() {\n\t\t\treturn isApplyAtAspectJMungersOnly;\n\t\t}\n\n\t\tpublic byte[] getBytes() {\n\t\t\tif (wovenClass != null) {\n\t\t\t\treturn wovenClass.getBytes();\n\t\t\t} else {\n\t\t\t\treturn unwovenClass.getBytes();\n\t\t\t}\n\t\t}\n\n\t\tpublic Iterator<UnwovenClassFile> getClassFileIterator() {\n\t\t\treturn unwovenClasses.iterator();\n\t\t}\n\n\t\tpublic IWeaveRequestor getRequestor() {\n\t\t\treturn new WeaveRequestor();\n\t\t}\n\n\t\tprivate class WeaveRequestor implements IWeaveRequestor {\n\t\t\t@Override\n\t\t\tpublic void acceptResult(IUnwovenClassFile result) {\n\t\t\t\tif (wovenClass == null) {\n\t\t\t\t\twovenClass = result;\n\t\t\t\t\tString name = result.getClassName();\n\t\t\t\t\tif (shouldDump(name.replace('/', '.'), false)) {\n\t\t\t\t\t\tdump(name, result.getBytes(), false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Classes generated by weaver e.g. around closure advice\n\t\t\t\t\tString className = result.getClassName();\n\t\t\t\t\tbyte[]\tresultBytes = result.getBytes();\n\n\t\t\t\t\tif (SimpleCacheFactory.isEnabled()) {\n\t\t\t\t\t\tSimpleCache lacache=SimpleCacheFactory.createSimpleCache();\n\t\t\t\t\t\tlacache.put(result.getClassName(), wovenClass.getBytes(), result.getBytes());\n\t\t\t\t\t\tlacache.addGeneratedClassesNames(wovenClass.getClassName(), wovenClass.getBytes(), result.getClassName());\n\t\t\t\t\t}\n\n\t\t\t\t\tgeneratedClasses.put(className, result);\n\t\t\t\t\tgeneratedClasses.put(wovenClass.getClassName(), wovenClass);\n\t\t\t\t\tgeneratedClassHandler.acceptClass(className, null, resultBytes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void processingReweavableState() {}\n\n\t\t\tpublic void addingTypeMungers() {}\n\n\t\t\tpublic void weavingAspects() {}\n\n\t\t\tpublic void weavingClasses() {}\n\n\t\t\tpublic void weaveCompleted() {\n\t\t\t\t// ResolvedType.resetPrimitives();\n\t\t\t\tif (delegateForCurrentClass != null) {\n\t\t\t\t\tdelegateForCurrentClass.weavingCompleted();\n\t\t\t\t}\n\t\t\t\t// ResolvedType.resetPrimitives();\n\t\t\t\t// bcelWorld.discardType(typeBeingProcessed.getResolvedTypeX()); // work in progress\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setActiveProtectionDomain(ProtectionDomain protectionDomain) {\n\t\tactiveProtectionDomain = protectionDomain;\n\t}\n}\n",
    "size": 31969
  },
  {
    "file_id": "F64",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/AbstractCacheBacking.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         \tinitial implementation\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\npackage org.aspectj.weaver.tools.cache;\n\nimport java.util.zip.CRC32;\n\nimport org.aspectj.weaver.tools.Trace;\nimport org.aspectj.weaver.tools.TraceFactory;\n\n/**\n * Basic &quot;common&quot; {@link CacheBacking} implementation\n */\npublic abstract class AbstractCacheBacking implements CacheBacking {\n    protected final Trace  logger=TraceFactory.getTraceFactory().getTrace(getClass());\n\n\tprotected AbstractCacheBacking () {\n\t\tsuper();\n\t}\n\n    /**\n     * Calculates CRC32 on the provided bytes\n     * @param bytes The bytes array - ignored if <code>null</code>/empty\n     * @return Calculated CRC\n     * @see CRC32\n     */\n    public static final long crc (byte[] bytes) {\n        if ((bytes == null) || (bytes.length <= 0)) {\n            return 0L;\n        }\n\n        CRC32   crc32=new CRC32();\n        crc32.update(bytes);\n        return crc32.getValue();\n    }\n}\n",
    "size": 1477
  },
  {
    "file_id": "F65",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/AbstractFileCacheBacking.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         \tinitial implementation\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\n/**\n * Useful &quot;common&quot; functionality for caching to files\n */\npublic abstract class AbstractFileCacheBacking extends AbstractCacheBacking {\n\t/**\n\t * Default property used to specify a default weaving cache dir location\n\t */\n\tpublic static final String WEAVED_CLASS_CACHE_DIR = \"aj.weaving.cache.dir\";\n\tprivate final File cacheDirectory;\n\n\tprotected AbstractFileCacheBacking (File cacheDirectory) {\n        if ((this.cacheDirectory=cacheDirectory) == null) {\n            throw new IllegalStateException(\"No cache directory specified\");\n        }\n\t}\n\n    public File getCacheDirectory () {\n        return cacheDirectory;\n    }\n\n    protected void writeClassBytes (String key, byte[] bytes) throws Exception {\n        File    dir=getCacheDirectory(), file=new File(dir, key);\n        FileOutputStream    out=new FileOutputStream(file);\n        try {\n            out.write(bytes);\n        } finally {\n        \tclose(out, file);\n        }\n    }\n\n\tprotected void delete(File file) {\n\t\tif (file.exists() && (!file.delete())) {\n\t\t\tif ((logger != null) && logger.isTraceEnabled()) {\n\t\t\t\tlogger.error(\"Error deleting file \" + file.getAbsolutePath());\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void close(OutputStream out, File file) {\n\t\tif (out != null) {\n\t\t\ttry {\n\t\t\t\tout.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tif ((logger != null) && logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.error(\"Failed (\" + e.getClass().getSimpleName() + \")\"\n\t\t\t\t\t\t\t   + \" to close write file \" + file.getAbsolutePath()\n\t\t\t\t\t\t\t   + \": \" + e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void close(InputStream in, File file) {\n\t\tif (in != null) {\n\t\t\ttry {\n\t\t\t\tin.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tif ((logger != null) && logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.error(\"Failed (\" + e.getClass().getSimpleName() + \")\"\n\t\t\t\t\t\t\t   + \" to close read file \" + file.getAbsolutePath()\n\t\t\t\t\t\t\t   + \": \" + e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "size": 2693
  },
  {
    "file_id": "F66",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/AbstractIndexedFileCacheBacking.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         \tinitial implementation\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.io.StreamCorruptedException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport org.aspectj.util.LangUtil;\n\n/**\n * Uses an <code>index</code> file to keep track of the cached entries\n */\npublic abstract class AbstractIndexedFileCacheBacking extends AbstractFileCacheBacking {\n\t/**\n\t * Default name of cache index file - assumed to contain {@link IndexEntry}-s\n\t */\n\tpublic static final String INDEX_FILE = \"cache.idx\";\n\tprotected static final IndexEntry[]\tEMPTY_INDEX=new IndexEntry[0];\n\tprotected static final String[]\tEMPTY_KEYS=new String[0];\n\n\tprivate final File\tindexFile;\n\n\tprotected AbstractIndexedFileCacheBacking(File cacheDir) {\n\t\tsuper(cacheDir);\n\n        indexFile = new File(cacheDir, INDEX_FILE);\n\t}\n\n    public File getIndexFile () {\n        return indexFile;\n    }\n\n    public String[] getKeys(String regex) {\n    \tMap<String, IndexEntry>\tindex=getIndex();\n    \tif ((index == null) || index.isEmpty()) {\n    \t\treturn EMPTY_KEYS;\n    \t}\n\n        Collection<String>  matches= new LinkedList<>();\n        synchronized(index) {\n            for (String key : index.keySet()) {\n                if (key.matches(regex)) {\n                    matches.add(key);\n                }\n            }\n        }\n\n        if (matches.isEmpty()) {\n            return EMPTY_KEYS;\n        } else {\n            return matches.toArray(new String[0]);\n        }\n    }\n\n    protected Map<String, IndexEntry> readIndex () {\n    \treturn readIndex(getCacheDirectory(), getIndexFile());\n    }\n\n    protected void writeIndex () {\n    \twriteIndex(getIndexFile());\n    }\n\n    protected void writeIndex (File file) {\n    \ttry {\n    \t\twriteIndex(file, getIndex());\n    \t} catch(Exception e) {\n    \t\tif ((logger != null) && logger.isTraceEnabled()) {\n    \t\t\tlogger.warn(\"writeIndex(\" + file + \") \" + e.getClass().getSimpleName() + \": \" + e.getMessage(), e);\n    \t\t}\n    \t}\n    }\n\n    protected abstract Map<String, IndexEntry> getIndex ();\n\n    protected Map<String, IndexEntry> readIndex (File cacheDir, File cacheFile) {\n        Map<String, IndexEntry> indexMap= new TreeMap<>();\n        IndexEntry[]            idxValues=readIndex(cacheFile);\n        if (LangUtil.isEmpty(idxValues)) {\n        \tif ((logger != null) && logger.isTraceEnabled()) {\n                logger.debug(\"readIndex(\" + cacheFile + \") no index entries\");\n        \t}\n        \treturn indexMap;\n        }\n\n        for (IndexEntry ie : idxValues) {\n            IndexEntry  resEntry=resolveIndexMapEntry(cacheDir, ie);\n            if (resEntry != null) {\n                indexMap.put(resEntry.key, resEntry);\n            } else if ((logger != null) && logger.isTraceEnabled()) {\n                logger.debug(\"readIndex(\" + cacheFile + \") skip \" + ie.key);\n            }\n        }\n\n        return indexMap;\n    }\n\n    protected IndexEntry resolveIndexMapEntry (File cacheDir, IndexEntry ie) {\n    \treturn ie;\n    }\n\n\tpublic IndexEntry[] readIndex(File indexFile) {\n\t\tif (!indexFile.canRead()) {\n\t\t\treturn EMPTY_INDEX;\n\t\t}\n\n\t\tObjectInputStream ois = null;\n\t\ttry {\n\t\t\tois = new ObjectInputStream(new FileInputStream(indexFile));\n\t\t\treturn (IndexEntry[]) ois.readObject();\n\t\t} catch (Exception e) {\n\t\t\tif ((logger != null) && logger.isTraceEnabled()) {\n\t\t\t\tlogger.error(\"Failed (\" + e.getClass().getSimpleName() + \")\"\n\t\t\t\t\t\t   + \" to read index from \" + indexFile.getAbsolutePath()\n\t\t\t\t\t\t   + \" : \" + e.getMessage(), e);\n\t\t\t}\n\t\t\tdelete(indexFile);\n\t\t} finally {\n\t\t\tclose(ois, indexFile);\n\t\t}\n\n\t\treturn EMPTY_INDEX;\n\t}\n\n\tprotected void writeIndex (File indexFile, Map<String,? extends IndexEntry> index) throws IOException {\n\t\twriteIndex(indexFile, LangUtil.isEmpty(index) ? Collections.<IndexEntry>emptyList() : index.values());\n\t}\n\n    protected void writeIndex (File indexFile, IndexEntry ... entries) throws IOException {\n        writeIndex(indexFile, LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));\n    }\n\n    protected void writeIndex (File indexFile, Collection<? extends IndexEntry> entries) throws IOException {\n        File    indexDir=indexFile.getParentFile();\n        if ((!indexDir.exists()) && (!indexDir.mkdirs())) {\n            throw new IOException(\"Failed to create path to \" + indexFile.getAbsolutePath());\n        }\n\n        int             numEntries=LangUtil.isEmpty(entries) ? 0 : entries.size();\n        IndexEntry[]    entryValues=(numEntries <= 0) ? null : entries.toArray(new IndexEntry[numEntries]);\n        // if no entries, simply delete the index file\n        if (LangUtil.isEmpty(entryValues)) {\n            if (indexFile.exists() && (!indexFile.delete())) {\n                throw new StreamCorruptedException(\"Failed to clean up index file at \" + indexFile.getAbsolutePath());\n            }\n\n            return;\n        }\n\n        ObjectOutputStream oos=new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(indexFile), 4096));\n        try {\n            oos.writeObject(entryValues);\n        } finally {\n            close(oos, indexFile);\n        }\n    }\n\n    public static final IndexEntry createIndexEntry (CachedClassEntry classEntry, byte[] originalBytes) {\n        if (classEntry == null) {\n            return null;\n        }\n\n        IndexEntry  indexEntry = new IndexEntry();\n        indexEntry.key = classEntry.getKey();\n        indexEntry.generated = classEntry.isGenerated();\n        indexEntry.ignored = classEntry.isIgnored();\n    \tindexEntry.crcClass = crc(originalBytes);\n        if (!classEntry.isIgnored()) {\n            indexEntry.crcWeaved = crc(classEntry.getBytes());\n        }\n\n        return indexEntry;\n    }\n\n\t/**\n\t * The default index entry in the index file\n\t */\n\tpublic static class IndexEntry implements Serializable, Cloneable {\n\t\tprivate static final long serialVersionUID = 756391290557029363L;\n\n\t\tpublic String key;\n\t\tpublic boolean generated;\n\t\tpublic boolean ignored;\n\t\tpublic long crcClass;\n\t\tpublic long crcWeaved;\n\n\t\tpublic IndexEntry () {\n\t\t\tsuper();\n\t\t}\n\n\t\t@Override\n\t\tpublic IndexEntry clone () {\n\t\t\ttry {\n\t\t\t\treturn getClass().cast(super.clone());\n\t\t\t} catch(CloneNotSupportedException e) {\n\t\t\t\tthrow new RuntimeException(\"Failed to clone: \" + toString() + \": \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (int) (key.hashCode()\n\t\t\t\t + (generated ? 1 : 0)\n\t\t\t\t + (ignored ? 1 : 0)\n\t\t\t\t + crcClass\n\t\t\t\t + crcWeaved);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\n\t\t\tIndexEntry\tother=(IndexEntry) obj;\n\t\t\tif (this.key.equals(other.key)\n\t\t\t && (this.ignored == other.ignored)\n\t\t\t && (this.generated == other.generated)\n\t\t\t && (this.crcClass == other.crcClass)\n\t\t\t && (this.crcWeaved == other.crcWeaved)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn key\n\t\t\t\t + \"[\" + (generated ? \"generated\" : \"ignored\") + \"]\"\n\t\t\t\t + \";crcClass=0x\" + Long.toHexString(crcClass)\n\t\t\t\t + \";crcWeaved=0x\" + Long.toHexString(crcWeaved)\n\t\t\t\t ;\n\t\t}\n\t}\n\n}\n",
    "size": 8078
  },
  {
    "file_id": "F67",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/AsynchronousFileCacheBacking.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.tools.Trace;\nimport org.aspectj.weaver.tools.TraceFactory;\n\n/**\n * Uses a background thread to do the actual I/O and for caching &quot;persistence&quot;\n * so that the caching works faster on repeated activations of the application.\n * The class maintains an in-memory cache, and uses a queue of {@link AsyncCommand}s\n * to signal to a background thread various actions required to &quot;synchronize&quot;\n * the in-memory cache with the persisted copy. Whenever there is a cache miss\n * from the {@link #get(CachedClassReference, byte[])} call, the weaver issues a\n * {@link #put(CachedClassEntry, byte[])} call. This call has 2 side-effects:\n * <UL>\n * \t\t<LI>\n * \t\tThe in-memory cache is updated so that subsequent calls to {@link #get(CachedClassReference, byte[])}\n * \t\twill not return the mapped value.\n * \t\t</LI>\n *\n *  \t<LI>\n *  \tAn &quot;update index&quot; {@link AsyncCommand} is posted to the background\n *  \tthread so that the newly mapped value will be persisted (eventually)\n *  \t</LI>\n * </UL>\n * The actual persistence is implemented by the <U>concrete</U> classes\n */\npublic abstract class AsynchronousFileCacheBacking extends AbstractIndexedFileCacheBacking {\n    private static final BlockingQueue<AsyncCommand>   commandsQ= new LinkedBlockingQueue<>();\n    private static final ExecutorService    execService=Executors.newSingleThreadExecutor();\n    private static Future<?> commandsRunner;\n\n    protected final Map<String, IndexEntry> index, exposedIndex;\n    protected final Map<String, byte[]>   bytesMap, exposedBytes;\n\n    protected AsynchronousFileCacheBacking (File cacheDir) {\n    \tsuper(cacheDir);\n\n        index = readIndex(cacheDir, getIndexFile());\n        exposedIndex = Collections.unmodifiableMap(index);\n        bytesMap = readClassBytes(index, cacheDir);\n        exposedBytes = Collections.unmodifiableMap(bytesMap);\n    }\n\n    @Override\n\tprotected Map<String, IndexEntry> getIndex() {\n\t\treturn index;\n\t}\n\n\tpublic CachedClassEntry get(CachedClassReference ref, byte[] originalBytes) {\n        String              key=ref.getKey();\n        final IndexEntry    indexEntry;\n        synchronized(index) {\n            if ((indexEntry=index.get(key)) == null) {\n                return null;\n            }\n        }\n\n        if (crc(originalBytes) != indexEntry.crcClass) {\n            if ((logger != null) && logger.isTraceEnabled()) {\n                logger.debug(\"get(\" + getCacheDirectory() + \") mismatched original class bytes CRC for \" + key);\n            }\n\n            remove(key);\n            return null;\n        }\n\n        if (indexEntry.ignored) {\n            return new CachedClassEntry(ref, WeavedClassCache.ZERO_BYTES, CachedClassEntry.EntryType.IGNORED);\n        }\n\n        final byte[]    bytes;\n        synchronized(bytesMap) {\n            /*\n             * NOTE: we assume that keys represent classes so if we have their\n             * bytes they will not be re-created\n             */\n            if ((bytes=bytesMap.remove(key)) == null) {\n                return null;\n            }\n        }\n\n        if (indexEntry.generated) {\n            return new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.GENERATED);\n        } else {\n            return new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.WEAVED);\n        }\n    }\n\n    public void put(CachedClassEntry entry, byte[] originalBytes) {\n        String  key=entry.getKey();\n        byte[]  bytes=entry.isIgnored() ? null : entry.getBytes();\n        synchronized(index) {\n            IndexEntry  indexEntry=index.get(key);\n            if (indexEntry != null) {\n                return;\n            }\n\n            /*\n             * Note: we do not cache the class bytes - only send them to\n             * be saved. The assumption is that the 'put' call was invoked\n             * because 'get' failed to return any bytes. And since we assume\n             * that each class bytes are required only once, there is no\n             * need to cache them\n             */\n            indexEntry = createIndexEntry(entry, originalBytes);\n            index.put(key, indexEntry);\n        }\n\n        if (!postCacheCommand(new InsertCommand(this, key, bytes))) {\n            if ((logger != null) && logger.isTraceEnabled()) {\n                logger.error(\"put(\" + getCacheDirectory() + \") Failed to post insert command for \" + key);\n            }\n        }\n\n        if ((logger != null) && logger.isTraceEnabled()) {\n            logger.debug(\"put(\" + getCacheDirectory() + \")[\" + key + \"] inserted\");\n        }\n    }\n\n    public void remove(CachedClassReference ref) {\n    \tremove(ref.getKey());\n    }\n\n    protected IndexEntry remove (String key) {\n        IndexEntry  entry;\n        synchronized(index) {\n            entry = index.remove(key);\n        }\n\n        synchronized(bytesMap) {\n            bytesMap.remove(key);\n        }\n\n        if (!postCacheCommand(new RemoveCommand(this, key))) {\n            if ((logger != null) && logger.isTraceEnabled()) {\n                logger.error(\"remove(\" + getCacheDirectory() + \") Failed to post remove command for \" + key);\n            }\n        }\n\n        if (entry != null) {\n            if (!key.equals(entry.key)) {\n                if ((logger != null) && logger.isTraceEnabled()) {\n                    logger.error(\"remove(\" + getCacheDirectory() + \") Mismatched keys: \" + key + \" / \" + entry.key);\n                }\n            } else if ((logger != null) && logger.isTraceEnabled()) {\n                logger.debug(\"remove(\" + getCacheDirectory() + \")[\" + key + \"] removed\");\n            }\n        }\n\n        return entry;\n    }\n\n    public List<IndexEntry> getIndexEntries () {\n        synchronized(index) {\n            if (index.isEmpty()) {\n                return Collections.emptyList();\n            } else {\n                return new ArrayList<>(index.values());\n            }\n        }\n    }\n\n    public Map<String, IndexEntry> getIndexMap () {\n        return exposedIndex;\n    }\n\n    public Map<String, byte[]> getBytesMap () {\n        return exposedBytes;\n    }\n\n    public void clear() {\n        synchronized(index) {\n            index.clear();\n        }\n\n        if (!postCacheCommand(new ClearCommand(this))) {\n            if ((logger != null) && logger.isTraceEnabled()) {\n                logger.error(\"Failed to post clear command for \" + getIndexFile());\n            }\n        }\n    }\n\n    protected void executeCommand (AsyncCommand cmd) throws Exception {\n        if (cmd instanceof ClearCommand) {\n            executeClearCommand();\n        } else if (cmd instanceof UpdateIndexCommand) {\n            executeUpdateIndexCommand();\n        } else if (cmd instanceof InsertCommand) {\n            executeInsertCommand((InsertCommand) cmd);\n        } else if (cmd instanceof RemoveCommand) {\n            executeRemoveCommand((RemoveCommand) cmd);\n        } else {\n            throw new UnsupportedOperationException(\"Unknown command: \" + cmd);\n        }\n    }\n\n    protected void executeClearCommand () throws Exception {\n        FileUtil.deleteContents(getIndexFile());\n        FileUtil.deleteContents(getCacheDirectory());\n    }\n\n    protected void executeUpdateIndexCommand () throws Exception {\n        writeIndex(getIndexFile(), getIndexEntries());\n    }\n\n    protected void executeInsertCommand (InsertCommand cmd) throws Exception {\n        writeIndex(getIndexFile(), getIndexEntries());\n\n        byte[]  bytes=cmd.getClassBytes();\n        if (bytes != null) {\n            writeClassBytes(cmd.getKey(), bytes);\n        }\n    }\n\n    protected void executeRemoveCommand (RemoveCommand cmd) throws Exception {\n        Exception err=null;\n        try {\n            removeClassBytes(cmd.getKey());\n        } catch(Exception e) {\n            err = e;\n        }\n\n        writeIndex(getIndexFile(), getIndexEntries());\n\n        if (err != null) {\n            throw err;  // check if the class bytes remove had any problems\n        }\n    }\n\n    /**\n     * Helper for {@link #executeRemoveCommand(RemoveCommand)}\n     * @param key The key representing the class whose bytes are to be removed\n     * @throws Exception if failed to remove class bytes\n     */\n    protected abstract void removeClassBytes (String key) throws Exception;\n\n    protected abstract Map<String, byte[]> readClassBytes (Map<String,IndexEntry> indexMap, File cacheDir);\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"[\" + String.valueOf(getCacheDirectory()) + \"]\";\n    }\n\n    protected static final <T extends AsynchronousFileCacheBacking> T createBacking (\n                            File cacheDir, AsynchronousFileCacheBackingCreator<T> creator) {\n        final Trace trace=TraceFactory.getTraceFactory().getTrace(AsynchronousFileCacheBacking.class);\n        if (!cacheDir.exists()) {\n            if (!cacheDir.mkdirs()) {\n                if ((trace != null) && trace.isTraceEnabled()) {\n                    trace.error(\"Unable to create cache directory at \" + cacheDir.getAbsolutePath());\n                }\n                return null;\n            }\n        }\n\n        if (!cacheDir.canWrite()) {\n            if ((trace != null) && trace.isTraceEnabled()) {\n                trace.error(\"Cache directory is not writable at \" + cacheDir.getAbsolutePath());\n            }\n            return null;\n        }\n\n        // start the service (if needed) only if successfully create the backing instance\n        T    backing=creator.create(cacheDir);\n        synchronized(execService) {\n            if (commandsRunner == null) {\n                commandsRunner = execService.submit(new Runnable() {\n                    @SuppressWarnings(\"synthetic-access\")\n                    public void run() {\n                        for ( ; ; ) {\n                            try {\n                                AsyncCommand    cmd=commandsQ.take();\n                                try {\n                                    AsynchronousFileCacheBacking    cache=cmd.getCache();\n                                    cache.executeCommand(cmd);\n                                } catch(Exception e) {\n                                    if ((trace != null) && trace.isTraceEnabled()) {\n                                        trace.error(\"Failed (\" + e.getClass().getSimpleName() + \")\"\n                                                  + \" to execute \" + cmd + \": \" + e.getMessage(), e);\n                                    }\n                                }\n                            } catch(InterruptedException e) {\n                                if ((trace != null) && trace.isTraceEnabled()) {\n                                    trace.warn(\"Interrupted\");\n                                }\n                                Thread.currentThread().interrupt();\n                                break;\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        // fire-up an update-index command in case index was changed by the constructor\n        if (!postCacheCommand(new UpdateIndexCommand(backing))) {\n            if ((trace != null) && trace.isTraceEnabled()) {\n                trace.warn(\"Failed to offer update index command to \" + cacheDir.getAbsolutePath());\n            }\n        }\n\n        return backing;\n    }\n\n    public static final boolean postCacheCommand (AsyncCommand cmd) {\n        return commandsQ.offer(cmd);\n    }\n\n    public interface AsynchronousFileCacheBackingCreator<T extends AsynchronousFileCacheBacking> {\n        T create (File cacheDir);\n    }\n    /**\n     * Represents an asynchronous command that can be sent to the\n     * {@link AsynchronousFileCacheBacking} instance to be executed\n     * on it <U>asynchronously</U>\n     */\n    public interface AsyncCommand {\n        /**\n         * @return The {@link AsynchronousFileCacheBacking} on which\n         * this command is supposed to be executed\n         * @see AsynchronousFileCacheBacking#executeCommand(AsyncCommand)\n         */\n        AsynchronousFileCacheBacking getCache ();\n    }\n\n    public static abstract class AbstractCommand implements AsyncCommand {\n        private final AsynchronousFileCacheBacking  cache;\n        protected AbstractCommand (AsynchronousFileCacheBacking backing) {\n            if ((cache=backing) == null) {\n                throw new IllegalStateException(\"No backing cache specified\");\n            }\n        }\n\n        public final AsynchronousFileCacheBacking getCache () {\n            return cache;\n        }\n\n        @Override\n        public String toString() {\n            return getClass().getSimpleName() + \"[\" + getCache() + \"]\";\n        }\n    }\n\n    public static class ClearCommand extends AbstractCommand {\n        public ClearCommand (AsynchronousFileCacheBacking cache) {\n            super(cache);\n        }\n    }\n\n    public static class UpdateIndexCommand extends AbstractCommand {\n        public UpdateIndexCommand (AsynchronousFileCacheBacking cache) {\n            super(cache);\n        }\n    }\n\n    /**\n     * Base class for {@link AbstractCommand}s that refer to a cache key\n     */\n    public static abstract class KeyedCommand extends AbstractCommand {\n        private final String    key;\n        protected KeyedCommand (AsynchronousFileCacheBacking cache, String keyValue) {\n            super(cache);\n\n            if (LangUtil.isEmpty(keyValue)) {\n                throw new IllegalStateException(\"No key value\");\n            }\n\n            key = keyValue;\n        }\n\n        public final String getKey () {\n            return key;\n        }\n\n        @Override\n        public String toString() {\n            return super.toString() + \"[\" + getKey() + \"]\";\n        }\n    }\n\n    public static class RemoveCommand extends KeyedCommand {\n        public RemoveCommand (AsynchronousFileCacheBacking cache, String keyValue) {\n            super(cache, keyValue);\n        }\n    }\n\n    public static class InsertCommand extends KeyedCommand {\n        private final byte[]    bytes;\n\n        public InsertCommand (AsynchronousFileCacheBacking cache, String keyValue, byte[] classBytes) {\n            super(cache, keyValue);\n            bytes = classBytes;\n        }\n\n        public final byte[] getClassBytes () {\n            return bytes;\n        }\n    }\n}\n",
    "size": 15261
  },
  {
    "file_id": "F68",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/CacheBacking.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         \tinitial implementation\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\npackage org.aspectj.weaver.tools.cache;\n\n/**\n * Interface for the backing to the cache; usually a file,\n * but could be an in-memory backing for testing.\n * <p>\n * aspectj and jvmti provide no suitable guarantees\n * on locking for class redefinitions, so every implementation\n * must have a some locking mechanism to prevent invalid reads.\n * </p>\n */\npublic interface CacheBacking {\n\t/**\n\t * Return a list of keys which match the given\n\t * regex.\n\t *\n\t * @param regex\n\t * @return\n\t */\n\tString[] getKeys(String regex);\n\n\t/**\n\t * Remove an entry from the cache\n\t *\n\t * @param ref\n\t */\n\tvoid remove(CachedClassReference ref);\n\n\t/**\n\t * Clear the entire cache\n\t */\n\tvoid clear();\n\n\t/**\n\t * Get a cache entry\n\t *\n\t * @param ref entry to retrieve\n\t * @param originalBytes Pre-weaving class bytes - required in order to\n\t * ensure that the cached entry refers to the same original class\n\t * @return the cached bytes or null, if the entry does not exist\n\t */\n\tCachedClassEntry get(CachedClassReference ref, byte[] originalBytes);\n\n\t/**\n\t * Put an entry in the cache\n\t *\n\t * @param entry key of the entry\n\t * @param originalBytes Pre-weaving class bytes - required in order to\n\t * ensure that the cached entry refers to the same original class\n\t */\n\tvoid put(CachedClassEntry entry, byte[] originalBytes);\n}\n",
    "size": 1914
  },
  {
    "file_id": "F69",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/CacheFactory.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver.tools.cache;\n\n/**\n * Facility for overriding the default CacheKeyResolver\n * and CacheBacking; an implementing factory must be set\n * on the {@link WeavedClassCache} before the\n * {@link org.aspectj.weaver.tools.WeavingAdaptor} is\n * configured.\n */\npublic interface CacheFactory {\n\tCacheKeyResolver createResolver();\n\n\tCacheBacking createBacking(String scope);\n}\n",
    "size": 929
  },
  {
    "file_id": "F70",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/CacheKeyResolver.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         initial implementation\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.util.List;\n\n/**\n * Interface to allow alternate hashing schemes for weaved and\n * generated classes. While the DefaultCacheKeyResolver may be\n * a reasonable naive implementation, the management and invalidation\n * of the cache may be more usefully accomplished at the Application\n * or Container level.\n * <p>\n * The key is not a one-way hash; it must be convertible back to a\n * className and must match the regex for the type of key it is\n * (generated or weaved).\n * </p>\n */\npublic interface CacheKeyResolver {\n\t/**\n\t * Create a key for the given className from a class generated by\n\t * the weaver such that:\n\t * <pre>\n\t *    className == keyToClass(generatedKey(className)) holds\n\t * and\n\t *    generatedKey(className).matches(getGeneratedRegex()) == true\n\t * </pre>\n\t *\n\t * @param className class to create a key for\n\t * @return key for the class, or null if no caching should be performed\n\t */\n\tCachedClassReference generatedKey(String className);\n\n\t/**\n\t * Create a key for the given class name and byte array from the pre-weaved\n\t * class such that\n\t * <pre>\n\t *    className == keyToClass(weavedKey(className, various_bytes)) holds\n\t * and\n\t *    weavedKey(className, various_bytes).matches(getWeavedRegex()) == true\n\t * </pre>\n\t *\n\t * @param className\t  class to create a key for\n\t * @param original_bytes bytes of the pre-weaved class\n\t * @return key for the class, or null if no caching should be performed\n\t */\n\tCachedClassReference weavedKey(String className, byte[] original_bytes);\n\n\t/**\n\t * Convert a key back to a className\n\t *\n\t * @param key cache key\n\t * @return className\n\t */\n\tString keyToClass(String key);\n\n\t/**\n\t * Create a unique string for the given classpath and aspect list\n\t *\n\t * @param loader  Classloader for this adapter\n\t * @param aspects list of aspects; either urls or class names handled by this adapter\n\t * @return scope, or null, if no caching should be performed for this classloader\n\t */\n\tString createClassLoaderScope(ClassLoader loader, List<String> aspects);\n\n\t/**\n\t * Return a regex which matches all generated keys\n\t *\n\t * @return string regex\n\t */\n\tString getGeneratedRegex();\n\n\t/**\n\t * Return a regex which matches all weaved keys;\n\t *\n\t * @return string regex\n\t */\n\tString getWeavedRegex();\n}\n",
    "size": 2837
  },
  {
    "file_id": "F71",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/CacheStatistics.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         initial implementation\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\n/**\n * Maintains some basic statistics on the class cache.\n */\npublic class CacheStatistics {\n\tprivate volatile int hits;\n\tprivate volatile int misses;\n\tprivate volatile int weaved;\n\tprivate volatile int generated;\n\tprivate volatile int ignored;\n\tprivate volatile int puts;\n\tprivate volatile int puts_ignored;\n\n\tpublic void hit() {\n\t\thits++;\n\t}\n\n\tpublic void miss() {\n\t\tmisses++;\n\t}\n\n\tpublic void weaved() {\n\t\tweaved++;\n\t}\n\n\tpublic void generated() {\n\t\tgenerated++;\n\t}\n\n\tpublic void ignored() {\n\t\tignored++;\n\t}\n\n\tpublic void put() {\n\t\tputs++;\n\t}\n\n\tpublic void putIgnored() {\n\t\tputs_ignored++;\n\t}\n\n\n\tpublic int getHits() {\n\t\treturn hits;\n\t}\n\n\tpublic int getMisses() {\n\t\treturn misses;\n\t}\n\n\tpublic int getWeaved() {\n\t\treturn weaved;\n\t}\n\n\tpublic int getGenerated() {\n\t\treturn generated;\n\t}\n\n\tpublic int getIgnored() {\n\t\treturn ignored;\n\t}\n\n\tpublic int getPuts() {\n\t\treturn puts;\n\t}\n\n\tpublic int getPutsIgnored() {\n\t\treturn puts_ignored;\n\t}\n\n\n\tpublic void reset() {\n\t\thits = 0;\n\t\tmisses = 0;\n\t\tweaved = 0;\n\t\tgenerated = 0;\n\t\tignored = 0;\n\t\tputs = 0;\n\t\tputs_ignored = 0;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"CacheStatistics{\" +\n\t\t\t\t\"hits=\" + hits +\n\t\t\t\t\", misses=\" + misses +\n\t\t\t\t\", weaved=\" + weaved +\n\t\t\t\t\", generated=\" + generated +\n\t\t\t\t\", ignored=\" + ignored +\n\t\t\t\t\", puts=\" + puts +\n\t\t\t\t\", puts_ignored=\" + puts_ignored +\n\t\t\t\t'}';\n\t}\n}\n",
    "size": 1932
  },
  {
    "file_id": "F72",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/CachedClassEntry.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)          initial implementation\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\npackage org.aspectj.weaver.tools.cache;\n\n/**\n * Represents a class which has been cached\n */\npublic class CachedClassEntry {\n    enum EntryType {\n        GENERATED,\n        WEAVED,\n        IGNORED,\n    }\n\n    private final CachedClassReference ref;\n    private final byte[] weavedBytes;\n    private final EntryType type;\n\n    public CachedClassEntry(CachedClassReference ref, byte[] weavedBytes, EntryType type) {\n        this.weavedBytes = weavedBytes;\n        this.ref = ref;\n        this.type = type;\n    }\n\n    public String getClassName() {\n        return ref.getClassName();\n    }\n\n    public byte[] getBytes() {\n        return weavedBytes;\n    }\n\n    public String getKey() {\n        return ref.getKey();\n    }\n\n    public boolean isGenerated() {\n        return type == EntryType.GENERATED;\n    }\n\n    public boolean isWeaved() {\n        return type == EntryType.WEAVED;\n    }\n\n    public boolean isIgnored() {\n        return type == EntryType.IGNORED;\n    }\n\n    @Override\n    public int hashCode() {\n        return getClassName().hashCode()\n             + getKey().hashCode()\n             + type.hashCode()\n             ;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (getClass() != obj.getClass())\n            return false;\n\n        CachedClassEntry    other=(CachedClassEntry) obj;\n        if (getClassName().equals(other.getClassName())\n         && getKey().equals(other.getKey())\n         && (type == other.type)) {\n             return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getClassName() + \"[\" + type + \"]\";\n    }\n}\n",
    "size": 2359
  },
  {
    "file_id": "F73",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/CachedClassReference.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         \tinitial implementation\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\n/**\n * A typed reference to a cached class entry. The key to any\n * cache entry is a simple string, but that string may contain\n * some specialized encoding. This class handles all of that\n * encoding.\n * <p>\n * External users of the cache should not be able to create these\n * objects manually.\n * </p>\n */\npublic class CachedClassReference {\n\tenum EntryType {\n\t\tGENERATED,\n\t\tWEAVED,\n\t\tIGNORED,\n\t}\n\n\tprivate final String key;\n\tprivate final String className;\n\n\tprotected CachedClassReference(String key, CacheKeyResolver resolver) {\n\t\tthis(key, resolver.keyToClass(key));\n\t}\n\n\t/**\n\t * Protected to allow only the WeavedClassCache initialization rights\n\t *\n\t * @param key\t   encoded key of the class\n\t * @param className the classname\n\t */\n\tprotected CachedClassReference(String key, String className) {\n\t\tthis.key = key;\n\t\tthis.className = className;\n\t}\n\n\tpublic String getKey() {\n\t\treturn key;\n\t}\n\n\tpublic String getClassName() {\n\t\treturn className;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn getKey().hashCode() + getClassName().hashCode();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n        if (obj == null)\n            return false;\n        if (this == obj)\n            return true;\n        if (getClass() != obj.getClass())\n            return false;\n\n        CachedClassReference\tother=(CachedClassReference) obj;\n\t\tif (getKey().equals(other.getKey())\n\t\t && getClassName().equals(other.getClassName())) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getClassName() + \"[\" + getKey() + \"]\";\n\t}\n}\n",
    "size": 2226
  },
  {
    "file_id": "F74",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/DefaultCacheFactory.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         initial implementation\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\n/**\n * Default factory for creating the backing and resolving classes.\n */\npublic class DefaultCacheFactory implements CacheFactory {\n\tpublic CacheKeyResolver createResolver() {\n\t\treturn new DefaultCacheKeyResolver();\n\t}\n\n\tpublic CacheBacking createBacking(String scope) {\n\t\treturn DefaultFileCacheBacking.createBacking(scope);\n\t}\n}\n",
    "size": 913
  },
  {
    "file_id": "F75",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/DefaultCacheKeyResolver.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         initial implementation\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.zip.CRC32;\n\n/**\n * Naive default class and classloader hashing implementation useful\n * for some multi-classloader environments.\n * <p>\n * This implementation creates classloader scopes of the form:<br>\n * \"ExampleClassLoaderName.[crc hash]\"\n * </p>\n * <p>\n * And weaved class keys of the form:<br>\n * \"com.foo.BarClassName.[bytes len][crc].weaved\"\n * </p>\n * <p>\n * And generated class keys of the form:<br>\n * \"com.foo.BarClassName$AjClosure.generated\n * </p>\n */\npublic class DefaultCacheKeyResolver implements CacheKeyResolver {\n\tpublic static final String GENERATED_SUFFIX = \".generated\";\n\tpublic static final String WEAVED_SUFFIX = \".weaved\";\n\n\t/**\n\t * Create a scope from a set of urls and aspect urls. Creates scope\n\t * of the form \"ExampleClassLoaderName.[md5sum]\" or\n\t * \"ExampleClassLoaderName.[crc]\"\n\t *\n\t * @param cl\t  the classloader which uses the cache, can be null\n\t * @param aspects the aspects\n\t * @return a unique string for URLClassloaders, otherwise a non-unique classname\n\t */\n\tpublic String createClassLoaderScope(ClassLoader cl, List<String> aspects) {\n\t\tString name = cl != null ? cl.getClass().getSimpleName() : \"unknown\";\n\n\t\tList<String> hashableStrings = new LinkedList<>();\n\t\tStringBuilder hashable = new StringBuilder(256);\n\n\t\t// Add the list of loader urls to the hash list\n\t\tif (cl instanceof URLClassLoader) {\n\t\t\tURL[] urls = ((URLClassLoader) cl).getURLs();\n\t\t\tfor (URL url : urls) {\n\t\t\t\thashableStrings.add(url.toString());\n\t\t\t}\n\t\t}\n\n\t\thashableStrings.addAll(aspects);\n\t\tCollections.sort(hashableStrings);\n\t\tfor (String url : hashableStrings) {\n\t\t\thashable.append(url);\n\t\t}\n\t\tString hash = null;\n\t\tbyte[] bytes = hashable.toString().getBytes();\n\t\thash = crc(bytes);\n\n\t\treturn name + '.' + hash;\n\t}\n\n\tprivate String crc(byte[] input) {\n\t\tCRC32 crc32 = new CRC32();\n\t\tcrc32.update(input);\n\t\treturn String.valueOf(crc32.getValue());\n\t}\n\n\tpublic String getGeneratedRegex() {\n\t\treturn \".*\" + GENERATED_SUFFIX;\n\t}\n\n\tpublic String getWeavedRegex() {\n\t\treturn \".*\" + WEAVED_SUFFIX;\n\t}\n\n\n\t/**\n\t * Converts a cache key back to a className\n\t *\n\t * @param key to convert\n\t * @return className, e.g. \"com.foo.Bar\"\n\t */\n\tpublic String keyToClass(String key) {\n\t\tif (key.endsWith(GENERATED_SUFFIX)) {\n\t\t\treturn key.replaceAll(GENERATED_SUFFIX + \"$\", \"\");\n\t\t}\n\t\tif (key.endsWith(WEAVED_SUFFIX)) {\n\t\t\treturn key.replaceAll(\"\\\\.[^.]+\" + WEAVED_SUFFIX, \"\");\n\t\t}\n\t\treturn key;\n\t}\n\n\tpublic CachedClassReference weavedKey(String className, byte[] original_bytes) {\n\t\tString hash = crc(original_bytes);\n\t\treturn new CachedClassReference(className + \".\" + hash + WEAVED_SUFFIX, className);\n\n\t}\n\n\tpublic CachedClassReference generatedKey(String className) {\n\t\treturn new CachedClassReference(className + GENERATED_SUFFIX, className);\n\t}\n\n}\n",
    "size": 3483
  },
  {
    "file_id": "F76",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         \tinitial implementation\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.OutputStream;\nimport java.util.Map;\n\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.util.LangUtil;\n\n\n/**\n * Naive File-Backed Class Cache with no expiry or application\n * centric invalidation.\n * <p>\n * Enabled with the system property, \"aj.weaving.cache.dir\"\n * If this system property is not set, no caching will be\n * performed.\n * </p>\n * <p>\n * A CRC checksum is stored alongside the class file to verify\n * the bytes on read. If for some reason there is an error\n * reading either the class or crc file, or if the crc does not\n * match the class data the cache entry is deleted.\n * </p>\n * <p>\n * An alternate implementation of this could store the class file\n * as a jar/zip directly, which would have the required crc; as\n * a first pass however it is somewhat useful to view these files\n * in expanded form for debugging.\n * </p>\n */\npublic class DefaultFileCacheBacking extends AbstractIndexedFileCacheBacking {\n\tprivate final Map<String, IndexEntry> index;\n\n\tprivate static final Object LOCK = new Object();\n\n\tprotected DefaultFileCacheBacking(File cacheDir) {\n\t\tsuper(cacheDir);\n\t\tindex = readIndex();\n\t}\n\n\tpublic static final DefaultFileCacheBacking createBacking(File cacheDir) {\n\t\tif (!cacheDir.exists()) {\n\t\t\tif (!cacheDir.mkdirs()) {\n\t\t\t\tMessageUtil.error(\"Unable to create cache directory at \" + cacheDir.getName());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if (!cacheDir.isDirectory()) {\n\t\t\tMessageUtil.error(\"Not a cache directory at \" + cacheDir.getName());\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!cacheDir.canWrite()) {\n\t\t\tMessageUtil.error(\"Cache directory is not writable at \" + cacheDir.getName());\n\t\t\treturn null;\n\t\t}\n\t\treturn new DefaultFileCacheBacking(cacheDir);\n\t}\n\n    @Override\n\tprotected Map<String, IndexEntry> getIndex() {\n\t\treturn index;\n\t}\n\n\t@Override\n    protected IndexEntry resolveIndexMapEntry (File cacheDir, IndexEntry ie) {\n        File cacheEntry = new File(cacheDir, ie.key);\n        if (ie.ignored || cacheEntry.canRead()) {\n            return ie;\n        } else {\n            return null;\n        }\n    }\n\n\tprivate void removeIndexEntry(String key) {\n\t\tsynchronized (LOCK) {\n\t\t\tindex.remove(key);\n\t\t\twriteIndex();\n\t\t}\n\t}\n\n\tprivate void addIndexEntry(IndexEntry ie) {\n\t\tsynchronized (LOCK) {\n\t\t\tindex.put(ie.key, ie);\n\t\t\twriteIndex();\n\t\t}\n\t}\n\n    @Override\n\tprotected Map<String, IndexEntry> readIndex() {\n\t\tsynchronized (LOCK) {\n\t\t\treturn super.readIndex();\n\t\t}\n\t}\n\n\t@Override\n\tprotected void writeIndex() {\n\t\tsynchronized (LOCK) {\n\t\t\tsuper.writeIndex();\n\t\t}\n\t}\n\n\tpublic void clear() {\n\t\tFile\tcacheDir=getCacheDirectory();\n\t\tint\t\tnumDeleted=0;\n\t\tsynchronized (LOCK) {\n\t\t\tnumDeleted = FileUtil.deleteContents(cacheDir);\n\t\t}\n\n\t\tif ((numDeleted > 0) && (logger != null) && logger.isTraceEnabled()) {\n\t\t\tlogger.info(\"clear(\" + cacheDir + \") deleted\");\n\t\t}\n\t}\n\n\tpublic static CacheBacking createBacking(String scope) {\n\t\tString cache = System.getProperty(WEAVED_CLASS_CACHE_DIR);\n\t\tif (cache == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tFile cacheDir = new File(cache, scope);\n\t\treturn createBacking(cacheDir);\n\t}\n\n\t@Override\n\tpublic String[] getKeys(final String regex) {\n\t\tFile\tcacheDirectory = getCacheDirectory();\n\t\tFile[] files = cacheDirectory.listFiles(new FilenameFilter() {\n\t\t\t\tpublic boolean accept(File file, String s) {\n\t\t\t\t\tif (s.matches(regex)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\tif (LangUtil.isEmpty(files)) {\n\t\t\treturn EMPTY_KEYS;\n\t\t}\n\t\tString[] keys = new String[files.length];\n\t\tfor (int i = 0; i < files.length; i++) {\n\t\t\tkeys[i] = files[i].getName();\n\t\t}\n\t\treturn keys;\n\t}\n\n\tpublic CachedClassEntry get(CachedClassReference ref, byte[] originalBytes) {\n\t\tFile cacheDirectory = getCacheDirectory();\n\t\tString\trefKey=ref.getKey();\n\t\tFile cacheFile = new File(cacheDirectory, refKey);\n\t\tIndexEntry ie = index.get(refKey);\n\t\tif (ie == null) {\n\t\t\t// no index, delete\n\t\t\tdelete(cacheFile);\n\t\t\treturn null;\n\t\t}\n\n\t\t// check if original file changed\n\t\tif (crc(originalBytes) != ie.crcClass) {\n\t\t\tdelete(cacheFile);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (ie.ignored) {\n\t\t\treturn new CachedClassEntry(ref, WeavedClassCache.ZERO_BYTES, CachedClassEntry.EntryType.IGNORED);\n\t\t}\n\n\t\tif (cacheFile.canRead()) {\n\t\t\tbyte[] bytes = read(cacheFile, ie.crcWeaved);\n\t\t\tif (bytes != null) {\n\t\t\t\tif (!ie.generated) {\n\t\t\t\t\treturn new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.WEAVED);\n\t\t\t\t} else {\n\t\t\t\t\treturn new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.GENERATED);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic void put(CachedClassEntry entry, byte[] originalBytes) {\n\t\tFile\tcacheDirectory = getCacheDirectory();\n\t\tString\trefKey = entry.getKey();\n\t\tIndexEntry ie = index.get(refKey);\n\t\tFile \tcacheFile = new File(cacheDirectory, refKey);\n\t\tfinal boolean\twriteEntryBytes;\n\t\t// check if original bytes changed or the ignored/generated flags\n\t\tif ((ie != null)\n\t\t && ((ie.ignored != entry.isIgnored()) || (ie.generated != entry.isGenerated()) || (crc(originalBytes) != ie.crcClass))) {\n\t\t\tdelete(cacheFile);\n\t\t\twriteEntryBytes = true;\n\t\t} else {\n\t\t\twriteEntryBytes = !cacheFile.exists();\n\t\t}\n\n\t\tif (writeEntryBytes) {\n\t\t\tie = createIndexEntry(entry, originalBytes);\n\t\t\tif (!entry.isIgnored()) {\n\t\t\t\tie.crcWeaved = write(cacheFile, entry.getBytes());\n\t\t\t}\n\t\t\taddIndexEntry(ie);\n\t\t}\n\t}\n\n\tpublic void remove(CachedClassReference ref) {\n\t\tFile\tcacheDirectory = getCacheDirectory();\n\t\tString\trefKey = ref.getKey();\n\t\tFile\tcacheFile = new File(cacheDirectory, refKey);\n\t\tsynchronized (LOCK) {\n\t\t\tremoveIndexEntry(refKey);\n\t\t\tdelete(cacheFile);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void delete(File file) {\n\t\tsynchronized (LOCK) {\n\t\t\tsuper.delete(file);\n\t\t}\n\t}\n\n\tprotected byte[] read(File file, long expectedCRC) {\n\t\tbyte[]\tbytes=null;\n\t\tsynchronized (LOCK) {\n\t\t\tFileInputStream fis = null;\n\t\t\ttry {\n\t\t\t\tfis = new FileInputStream(file);\n\t\t\t\tbytes = FileUtil.readAsByteArray(fis);\n\t\t\t} catch (Exception e) {\n\t\t\t\tif ((logger != null) && logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.warn(\"read(\" + file.getAbsolutePath() + \")\"\n\t\t\t\t\t\t\t+ \" failed (\" + e.getClass().getSimpleName() + \")\"\n\t\t\t\t\t\t\t+ \" to read contents: \" + e.getMessage(), e);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tclose(fis, file);\n\t\t\t}\n\n\t\t\t// delete the file if there was an exception reading it or mismatched crc\n\t\t\tif ((bytes == null) || (crc(bytes) != expectedCRC)) {\n\t\t\t\tdelete(file);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\tprotected long write(File file, byte[] bytes) {\n\t\tsynchronized (LOCK) {\n\t\t\tif (file.exists()) {\n\t\t\t\treturn -1L;\n\t\t\t}\n\t\t\tOutputStream out = null;\n\t\t\ttry {\n\t\t\t\tout = new FileOutputStream(file);\n\t\t\t\tout.write(bytes);\n\t\t\t} catch (Exception e) {\n\t\t\t\tif ((logger != null) && logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.warn(\"write(\" + file.getAbsolutePath() + \")\"\n\t\t\t\t\t\t\t+ \" failed (\" + e.getClass().getSimpleName() + \")\"\n\t\t\t\t\t\t\t+ \" to write contents: \" + e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\t// delete the file if there was an exception writing it\n\t\t\t\tdelete(file);\n\t\t\t\treturn -1L;\n\t\t\t} finally {\n\t\t\t\tclose(out, file);\n\t\t\t}\n\n\t\t\treturn crc(bytes);\n\t\t}\n\t}\n\n}\n",
    "size": 7782
  },
  {
    "file_id": "F77",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/FlatFileCacheBacking.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2012 VMware, Inc. custard\n *\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n * Lyor Goldstein\n * ******************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.StreamCorruptedException;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.util.LangUtil;\n\n/**\n * Uses a &quot;flat&quot; files model to store the cached instrumented classes\n * and aspects - i.e., each class/aspect is stored as a <U>separate</U> (binary)\n * file. This is a good mechanism when the number of instrumented class is\n * relatively small (a few 10's). The reason for it is that scanning a folder\n * that has many files in it quickly becomes an I/O bottleneck. Also, some\n * O/S-es may impose internal limits on the maximum number of &quot;children&quot;\n * a folder node may have. On the other hand, it is much faster (again, for\n * small number of instrumented classes) than the ZIP cache since each class/aspect\n * is represented by a single file - thus adding/removing/modifying it is easier.\n *\n * @author Lyor Goldstein\n */\npublic class FlatFileCacheBacking extends AsynchronousFileCacheBacking {\n    private static final AsynchronousFileCacheBackingCreator<FlatFileCacheBacking>    defaultCreator=\n            new AsynchronousFileCacheBackingCreator<FlatFileCacheBacking>() {\n                public FlatFileCacheBacking create(File cacheDir) {\n                    return new FlatFileCacheBacking(cacheDir);\n                }\n        };\n    public FlatFileCacheBacking(File cacheDir) {\n        super(cacheDir);\n    }\n\n    public static final FlatFileCacheBacking createBacking (File cacheDir) {\n        return createBacking(cacheDir, defaultCreator);\n    }\n\n    @Override\n    protected Map<String, byte[]> readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir) {\n        return readClassBytes(indexMap, cacheDir.listFiles());\n    }\n\n    protected Map<String, byte[]> readClassBytes (Map<String,IndexEntry> indexMap, File[] files) {\n        Map<String, byte[]> result= new TreeMap<>();\n        if (LangUtil.isEmpty(files)) {\n            return result;\n        }\n\n        for (File file : files) {\n            if (!file.isFile()) {\n                continue;   // skip sub-directories - we expect flat files\n            }\n\n            String  key=file.getName();\n            if (INDEX_FILE.equalsIgnoreCase(key)) {\n                continue;   // skip the index itself if found\n            }\n\n            IndexEntry  entry=indexMap.get(key);\n            if ((entry == null) || entry.ignored) {    // if not in index or ignored then remove it\n                if ((logger != null) && logger.isTraceEnabled()) {\n                    logger.info(\"readClassBytes(\" + key + \") remove orphan/ignored: \" + file.getAbsolutePath());\n                }\n                FileUtil.deleteContents(file);\n                continue;\n            }\n\n            try {\n                byte[]  bytes=FileUtil.readAsByteArray(file);\n                long    crc=crc(bytes);\n                if (crc != entry.crcWeaved) {\n                    throw new StreamCorruptedException(\"Mismatched CRC - expected=\" + entry.crcWeaved + \"/got=\" + crc);\n                }\n\n                result.put(key, bytes);\n                if ((logger != null) && logger.isTraceEnabled()) {\n                    logger.debug(\"readClassBytes(\" + key + \") cached from \" + file.getAbsolutePath());\n                }\n            } catch(IOException  e) {\n                if ((logger != null) && logger.isTraceEnabled()) {\n                    logger.error(\"Failed (\" + e.getClass().getSimpleName() + \")\"\n                               + \" to read bytes from \" + file.getAbsolutePath()\n                               + \": \" + e.getMessage());\n                }\n                indexMap.remove(key);   // no need for the entry if no file - force a re-write of its bytes\n                FileUtil.deleteContents(file);  // assume some kind of corruption\n                continue;\n            }\n        }\n\n        return result;\n    }\n\n    @Override\n    protected IndexEntry resolveIndexMapEntry (File cacheDir, IndexEntry ie) {\n        File cacheEntry = new File(cacheDir, ie.key);\n        if (ie.ignored || cacheEntry.canRead()) {\n            return ie;\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    protected void writeClassBytes (String key, byte[] bytes) throws Exception {\n        File    dir=getCacheDirectory(), file=new File(dir, key);\n        FileOutputStream    out=new FileOutputStream(file);\n        try {\n            out.write(bytes);\n        } finally {\n            out.close();\n        }\n    }\n\n    @Override\n    protected void removeClassBytes (String key) throws Exception {\n        File        dir=getCacheDirectory(), file=new File(dir, key);\n        if (file.exists() && (!file.delete())) {\n            throw new StreamCorruptedException(\"Failed to delete \" + file.getAbsolutePath());\n        }\n    }\n\n}\n",
    "size": 5400
  },
  {
    "file_id": "F78",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/GeneratedCachedClassHandler.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         \tinitial implementation\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport org.aspectj.weaver.tools.GeneratedClassHandler;\n\n/**\n * Handler for generated classes; such as Shadowed closures, etc. This wraps the normal\n * generated class handler with caching\n */\npublic class GeneratedCachedClassHandler implements GeneratedClassHandler {\n\tprivate final WeavedClassCache cache;\n\tprivate final GeneratedClassHandler nextGeneratedClassHandler;\n\n\tpublic GeneratedCachedClassHandler(WeavedClassCache cache, GeneratedClassHandler nextHandler) {\n\t\tthis.cache = cache;\n\t\tthis.nextGeneratedClassHandler = nextHandler;\n\t}\n\n\tpublic void acceptClass (String name, byte[] originalBytes, byte[] wovenBytes) {\n\t\t// The cache expects classNames in dot form\n\t\tCachedClassReference ref = cache.createGeneratedCacheKey(name.replace('/', '.'));\n\t\tcache.put(ref, originalBytes, wovenBytes);\n\t\tif (nextGeneratedClassHandler != null) {\n\t\t\tnextGeneratedClassHandler.acceptClass(name, originalBytes, wovenBytes);\n\t\t}\n\t}\n}\n",
    "size": 1583
  },
  {
    "file_id": "F79",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/SimpleCache.java",
    "text": "package org.aspectj.weaver.tools.cache;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.security.ProtectionDomain;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.zip.CRC32;\n\nimport org.aspectj.weaver.Dump;\nimport org.aspectj.weaver.tools.Trace;\nimport org.aspectj.weaver.tools.TraceFactory;\n\n/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Abraham Nevado (lucierna) initial implementation\n ********************************************************************************/\n\npublic class SimpleCache {\n\n\tprivate static final String SAME_BYTES_STRING = \"IDEM\";\n\tstatic final byte[] SAME_BYTES = SAME_BYTES_STRING.getBytes(StandardCharsets.UTF_8);\n\n\tprivate final Map<String, byte[]> cacheMap;\n\tprivate boolean enabled = false;\n\n\t// cache for generated classes\n\tprivate Map<String, byte[]> generatedCache;\n\tprivate static final String GENERATED_CACHE_SUBFOLDER = \"panenka.cache\";\n\tprivate static final String GENERATED_CACHE_SEPARATOR = \";\";\n\n\tpublic static final String IMPL_NAME = \"shared\";\n\n\tprotected SimpleCache(String folder, boolean enabled) {\n\t\tthis.enabled = enabled;\n\n\t\tcacheMap = Collections.synchronizedMap(StoreableCachingMap.init(folder));\n\n\t\tif (enabled) {\n\t\t\tString generatedCachePath = folder + File.separator + GENERATED_CACHE_SUBFOLDER;\n\t\t\tFile f = new File(generatedCachePath);\n\t\t\tif (!f.exists()) {\n\t\t\t\tf.mkdir();\n\t\t\t}\n\t\t\tgeneratedCache = Collections.synchronizedMap(StoreableCachingMap.init(generatedCachePath, 0));\n\t\t}\n\t}\n\n\t/**\n\t * Get bytes for given class from cache. If necessary, define and initialise the class first.\n\t *\n\t * @param classname        name of class to be retrieved from the cache\n\t * @param bytes            class bytes (used to calculate cache key)\n\t * @param loader           class loader\n\t * @param protectionDomain protection domain\n\t *\n\t * @return {@code null}, if the cache is disabled or if it contains no entry for the given class. An\n\t * {@code Optional<byte[]>} value, if the cache knows about the class. The optional will be empty, if the cache entry\n\t * represents and unwoven class, i.e. its bytes are identical to the original bytes.\n\t */\n\t@SuppressWarnings(\"OptionalAssignedToNull\")\n\tpublic Optional<byte[]> getAndInitialize(\n\t\tString classname,\n\t\tbyte[] bytes,\n\t\tClassLoader loader,\n\t\tProtectionDomain protectionDomain\n\t)\n\t{\n\t\tif (!enabled) {\n\t\t\t// Cache disabled\n\t\t\treturn null;\n\t\t}\n\t\tbyte[] res = get(classname, bytes);\n\t\tif (Arrays.equals(SAME_BYTES, res)) {\n\t\t\t// Cache hit: unwoven class\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tif (res != null) {\n\t\t\t// Cache hit: woven class\n\t\t\tinitializeClass(classname, res, loader, protectionDomain);\n\t\t\treturn Optional.of(res);\n\t\t}\n\t\t// Cache miss\n\t\treturn null;\n\t}\n\n\tprivate byte[] get(String classname, byte[] bytes) {\n\t\tString key = generateKey(classname, bytes);\n\t\treturn cacheMap.get(key);\n\t}\n\n\tpublic void put(String classname, byte[] origbytes, byte[] wovenbytes) {\n\t\tif (!enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\tString key = generateKey(classname, origbytes);\n\n\t\tif (wovenbytes == null || Arrays.equals(origbytes, wovenbytes)) {\n\t\t\tcacheMap.put(key, SAME_BYTES);\n\t\t\treturn;\n\t\t}\n\t\tcacheMap.put(key, wovenbytes);\n\t}\n\n\tprivate String generateKey(String classname, byte[] bytes) {\n\t\tCRC32 checksum = new CRC32();\n\t\tchecksum.update(bytes);\n\t\tlong crc = checksum.getValue();\n\t\tclassname = classname.replace(\"/\", \".\");\n\t\treturn classname + \"-\" + crc;\n\n\t}\n\n\tprivate static class StoreableCachingMap extends HashMap {\n\n\t\t// TODO: This class extends a raw HashMap, but instances of this class are assigned to fields\n\t\t//       Map<String, byte[]> cacheMap and Map<String, byte[]> generatedCache without casts. However, we cannot\n\t\t//       simply declare 'extends HashMap<String, byte[]>', because 'put' writes String values (paths) when given\n\t\t//       byte[] ones, while 'get' geturns byte[] ones, which is inconsistent. I.e., superficially the class behaves\n\t\t//       like a Map<String, byte[]>, while not really being one. This is ugly and hard to understand.\n\n\t\tprivate final String folder;\n\t\tprivate static final String CACHENAMEIDX = \"cache.idx\";\n\n\t\tprivate long lastStored = System.currentTimeMillis();\n\t\tprivate static final int DEF_STORING_TIMER = 60000; //ms\n\t\tprivate final int storingTimer;\n\n\t\tprivate transient Trace trace;\n\n\t\tprivate void initTrace() {\n\t\t\ttrace = TraceFactory.getTraceFactory().getTrace(StoreableCachingMap.class);\n\t\t}\n\n\t\tprivate StoreableCachingMap(String folder, int storingTimer) {\n\t\t\tthis.folder = folder;\n\t\t\tinitTrace();\n\t\t\tthis.storingTimer = storingTimer;\n\t\t}\n\n\t\tpublic static StoreableCachingMap init(String folder) {\n\t\t\treturn init(folder, DEF_STORING_TIMER);\n\t\t}\n\n\t\tpublic static StoreableCachingMap init(String folder, int storingTimer) {\n\t\t\tFile file = new File(folder + File.separator + CACHENAMEIDX);\n\t\t\tif (file.exists()) {\n\t\t\t\ttry (ObjectInputStream in = new ObjectInputStream(Files.newInputStream(file.toPath()))) {\n\t\t\t\t\t// Deserialize the object\n\t\t\t\t\tStoreableCachingMap sm = (StoreableCachingMap) in.readObject();\n\t\t\t\t\tsm.initTrace();\n\t\t\t\t\treturn sm;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tTrace trace = TraceFactory.getTraceFactory().getTrace(StoreableCachingMap.class);\n\t\t\t\t\ttrace.error(\"Error reading Storable Cache\", e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new StoreableCachingMap(folder, storingTimer);\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Object get(Object obj) {\n\t\t\ttry {\n\t\t\t\tif (super.containsKey(obj)) {\n\t\t\t\t\tString path = (String) super.get(obj);\n\t\t\t\t\tif (path.equals(SAME_BYTES_STRING)) {\n\t\t\t\t\t\treturn SAME_BYTES;\n\t\t\t\t\t}\n\t\t\t\t\treturn readFromPath(path);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\ttrace.error(\"Error reading key:\" + obj.toString(), e);\n\t\t\t\tDump.dumpWithException(e);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object put(Object key, Object value) {\n\t\t\ttry {\n\t\t\t\tString path;\n\t\t\t\tbyte[] valueBytes = (byte[]) value;\n\n\t\t\t\tif (Arrays.equals(valueBytes, SAME_BYTES)) {\n\t\t\t\t\tpath = SAME_BYTES_STRING;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpath = writeToPath((String) key, valueBytes);\n\t\t\t\t}\n\t\t\t\tObject result = super.put(key, path);\n\t\t\t\tstoreMap();\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (IOException e) {\n\t\t\t\ttrace.error(\"Error inserting in cache: key:\" + key + \"; value:\" + value.toString(), e);\n\t\t\t\tDump.dumpWithException(e);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\n\t\tpublic void storeMap() {\n\t\t\tlong now = System.currentTimeMillis();\n\t\t\tif ((now - lastStored) < storingTimer) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tFile file = new File(folder + File.separator + CACHENAMEIDX);\n\t\t\ttry (ObjectOutputStream out = new ObjectOutputStream(Files.newOutputStream(file.toPath()))) {\n\t\t\t\t// Deserialize the object\n\t\t\t\tout.writeObject(this);\n\t\t\t\tlastStored = now;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\ttrace.error(\"Error storing cache; cache file:\" + file.getAbsolutePath(), e);\n\t\t\t\tDump.dumpWithException(e);\n\t\t\t}\n\t\t}\n\n\t\tprivate byte[] readFromPath(String fullPath) throws IOException {\n\t\t\ttry (\n\t\t\t\tFileInputStream is = new FileInputStream(fullPath);\n\t\t\t\tByteArrayOutputStream buffer = new ByteArrayOutputStream()\n\t\t\t) {\n\t\t\t\tint nRead;\n\t\t\t\tbyte[] data = new byte[16384];\n\t\t\t\twhile ((nRead = is.read(data, 0, data.length)) != -1) {\n\t\t\t\t\tbuffer.write(data, 0, nRead);\n\t\t\t\t}\n\t\t\t\tbuffer.flush();\n\t\t\t\treturn buffer.toByteArray();\n\t\t\t}\n\t\t\tcatch (FileNotFoundException e) {\n\t\t\t\t// May be caused by a generated class that has been stored in generated cache but not saved in cache folder\n\t\t\t\tSystem.out.println(\"FileNotFoundExceptions: The aspectj cache is corrupt. Please clean it and reboot the server. Cache path:\" + this.folder);\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tprivate String writeToPath(String key, byte[] bytes) throws IOException {\n\t\t\tString fullPath = folder + File.separator + key;\n\t\t\ttry (FileOutputStream fos = new FileOutputStream(fullPath)) {\n\t\t\t\tfos.write(bytes);\n\t\t\t\tfos.flush();\n\t\t\t}\n\t\t\treturn fullPath;\n\t\t}\n\n\t}\n\n\tprivate void initializeClass(\n\t\tString className, byte[] bytes,\n\t\tClassLoader loader, ProtectionDomain protectionDomain\n\t)\n\t{\n\t\tString[] generatedClassesNames = getGeneratedClassesNames(className, bytes);\n\t\tif (generatedClassesNames == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (String generatedClassName : generatedClassesNames) {\n\t\t\tbyte[] generatedBytes = get(generatedClassName, bytes);\n\t\t\tif (protectionDomain == null) {\n\t\t\t\tdefineClass(loader, generatedClassName, generatedBytes);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdefineClass(loader, generatedClassName, generatedBytes, protectionDomain);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String[] getGeneratedClassesNames(String className, byte[] bytes) {\n\t\tString key = generateKey(className, bytes);\n\n\t\tbyte[] readBytes = generatedCache.get(key);\n\t\tif (readBytes == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString readString = new String(readBytes);\n\t\treturn readString.split(GENERATED_CACHE_SEPARATOR);\n\t}\n\n\tpublic void addGeneratedClassesNames(String parentClassName, byte[] parentBytes, String generatedClassName) {\n\t\tif (!enabled) {\n\t\t\treturn;\n\t\t}\n\t\tString key = generateKey(parentClassName, parentBytes);\n\n\t\tbyte[] storedBytes = generatedCache.get(key);\n\t\tif (storedBytes == null) {\n\t\t\tgeneratedCache.put(key, generatedClassName.getBytes());\n\t\t}\n\t\telse {\n\t\t\tString storedClasses = new String(storedBytes);\n\t\t\tstoredClasses += GENERATED_CACHE_SEPARATOR + generatedClassName;\n\t\t\tgeneratedCache.put(key, storedClasses.getBytes());\n\t\t}\n\t}\n\n\tprivate Method defineClassMethod = null;\n\tprivate Method defineClassWithProtectionDomainMethod = null;\n\n\tprivate void defineClass(ClassLoader loader, String name, byte[] bytes) {\n\t\ttry {\n\t\t\tif (defineClassMethod == null) {\n\t\t\t\t// TODO: Replace by class definition strategy used in ClassLoaderWeavingAdaptor\n\t\t\t\tdefineClassMethod = ClassLoader.class.getDeclaredMethod(\n\t\t\t\t\t\"defineClass\",\n\t\t\t\t\tString.class, bytes.getClass(), int.class, int.class\n\t\t\t\t);\n\t\t\t\tdefineClassMethod.setAccessible(true);\n\t\t\t}\n\t\t\tdefineClassMethod.invoke(loader, name, bytes, 0, bytes.length);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\tif (e.getTargetException() instanceof LinkageError) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"define generated class failed\" + e.getTargetException());\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tDump.dumpWithException(e);\n\t\t}\n\t}\n\n\tprivate void defineClass(ClassLoader loader, String name, byte[] bytes, ProtectionDomain protectionDomain) {\n\t\ttry {\n\t\t\tif (defineClassWithProtectionDomainMethod == null) {\n\t\t\t\t// TODO: Replace by class definition strategy used in ClassLoaderWeavingAdaptor\n\t\t\t\tdefineClassWithProtectionDomainMethod = ClassLoader.class.getDeclaredMethod(\n\t\t\t\t\t\"defineClass\",\n\t\t\t\t\tString.class, bytes.getClass(), int.class, int.class, ProtectionDomain.class\n\t\t\t\t);\n\t\t\t\tdefineClassWithProtectionDomainMethod.setAccessible(true);\n\t\t\t}\n\t\t\tdefineClassWithProtectionDomainMethod.invoke(loader, name, bytes, 0, bytes.length, protectionDomain);\n\t\t}\n\t\tcatch (InvocationTargetException e) {\n\t\t\tif (e.getTargetException() instanceof LinkageError) {\n\t\t\t\te.printStackTrace();\n\t\t\t\t// is already defined (happens for X$ajcMightHaveAspect\n\t\t\t\t// interfaces since aspects are reweaved)\n\t\t\t\t// TODO maw I don't think this is OK and\n\t\t\t}\n\t\t\telse {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tcatch (NullPointerException e) {\n\t\t\tSystem.out.println(\"NullPointerException loading class:\" + name + \".  Probabily caused by a corruput cache. Please clean it and reboot the server\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tDump.dumpWithException(e);\n\t\t}\n\n\t}\n\n}\n",
    "size": 12134
  },
  {
    "file_id": "F80",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/SimpleCacheFactory.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Abraham Nevado (lucierna) initial implementation\n ********************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.File;\n\nimport org.aspectj.weaver.Dump;\n\npublic class SimpleCacheFactory {\n\n\tpublic static final String CACHE_ENABLED_PROPERTY = \"aj.weaving.cache.enabled\";\n\tpublic static final String CACHE_DIR = \"aj.weaving.cache.dir\";\n\tpublic static final String CACHE_IMPL = \"aj.weaving.cache.impl\";\n\n\tpublic static final String PATH_DEFAULT= \"/tmp/\"; // TODO windows default...?\n\tpublic static final boolean BYDEFAULT= false;\n\n\n\tpublic static String path = PATH_DEFAULT;\n\tpublic static Boolean enabled = false;\n\tprivate static boolean determinedIfEnabled = false;\n\tprivate static SimpleCache lacache=null;\n\n\tpublic static synchronized SimpleCache createSimpleCache(){\n\t\tif (lacache==null){\n\t\t \tif (!determinedIfEnabled) {\n\t\t \t\tdetermineIfEnabled();\n\t\t \t}\n\n\t\t\tif (!enabled) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tpath = System.getProperty(CACHE_DIR);\n\t\t\t\tif (path == null){\n\t\t\t\t\tpath = PATH_DEFAULT;\n\t\t\t\t}\n\n\t\t\t} catch (Throwable t) {\n\t\t\t\tpath=PATH_DEFAULT;\n\t\t\t\tt.printStackTrace();\n\t\t\t\tDump.dumpWithException(t);\n\t\t\t}\n\t\t\tFile f = new File(path);\n\t\t\tif (!f.exists()){\n\t\t\t\tf.mkdir();\n\t\t\t}\n\t\t\tlacache= new SimpleCache(path, enabled);\n\t\t}\n\t\treturn lacache;\n\n\t}\n\n\tprivate static void determineIfEnabled() {\n\t\ttry {\n\t\t\tString property = System.getProperty(CACHE_ENABLED_PROPERTY);\n\t\t\tif (property == null ){\n\t\t\t\tenabled = BYDEFAULT;\n\t\t\t}\n\t\t\telse if (property.equalsIgnoreCase(\"true\")){\n\n\t\t\t\t\tString impl = System.getProperty(CACHE_IMPL);\n\t\t\t\t\tif (SimpleCache.IMPL_NAME.equals(impl)){\n\t\t\t\t\t\tenabled = true;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tenabled = BYDEFAULT;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tenabled = BYDEFAULT;\n\t\t\t}\n\n\t\t} catch (Throwable t) {\n\t\t\tenabled=BYDEFAULT;\n\t\t\tSystem.err.println(\"Error creating cache\");\n\t\t\tt.printStackTrace();\n\t\t\tDump.dumpWithException(t);\n\t\t}\n\t\tdeterminedIfEnabled = true;\n\t}\n\n\t// Should behave ok with two threads going through here, well whoever gets there first will set determinedIfEnabled but only after\n\t// it has set 'enabled' to the right value.\n\tpublic static boolean isEnabled() {\n\t\tif (!determinedIfEnabled) {\n\t\t\tdetermineIfEnabled();\n\t\t}\n\t\treturn enabled;\n\t}\n\n\n}\n",
    "size": 2663
  },
  {
    "file_id": "F81",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/WeavedClassCache.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         \tinitial implementation\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.bridge.Message;\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.weaver.tools.GeneratedClassHandler;\n\n/**\n * Manages a cache of weaved and generated classes similar to Eclipse Equinox,\n * except designed to operate across multiple restarts of the JVM and with one\n * cache per classloader; allowing URLClassLoaders with the same set of URI\n * paths to share the same cache (with the default configuration).\n * <p>\n * To enable the default configuration two system properties must be set:\n * </p>\n * <pre>\n *    \"-Daj.weaving.cache.enabled=true\"\n *    \"-Daj.weaving.cache.dir=/some/directory\"\n * </pre>\n * <p>\n * The class cache is often something that application developers or\n * containers would like to manage, so there are a few interfaces for overriding the\n * default behavior and performing other management functions.\n * </p>\n * <p/>\n * {@link CacheBacking} <br>\n * Provides an interface for implementing a custom backing store\n * for the cache; The default implementation in {@link DefaultFileCacheBacking}\n * provides a naive file-backed cache. An alternate implementation may ignore\n * caching until signaled explicitly by the application, or only cache files\n * for a specific duration. This class delegates the locking and synchronization\n * requirements to the CacheBacking implementation.\n * </p>\n * <p>\n * {@link CacheKeyResolver} <br>\n * Provides methods for creating keys from classes to be cached and for\n * creating the \"scope\" of the cache itself for a given classloader and aspect\n * list. The default implementation is provided by {@link DefaultCacheKeyResolver}\n * but an alternate implementation may want to associate a cache with a particular\n * application running underneath a container.\n * </p>\n * <p>\n * This naive cache does not normally invalidate *any* classes; the interfaces above\n * must be used to implement more intelligent behavior. Cache invalidation\n * problems may occur in at least three scenarios:\n * </p>\n * <ol>\n *    <li>New aspects are added dynamically somewhere in the classloader hierarchy; affecting\n *       other classes elsewhere.</li>\n *    <li>Use of declare parent in aspects to change the type hierarchy; if the cache\n *       has not invalidated the right classes in the type hierarchy aspectj may not\n *       be reconstruct the class incorrectly.</li>\n *    <li>Similarly to (2), the addition of fields or methods on classes which have\n *       already been weaved and cached could have inter-type conflicts.</li>\n * </ol>\n */\npublic class WeavedClassCache {\n\tpublic static final String WEAVED_CLASS_CACHE_ENABLED = \"aj.weaving.cache.enabled\";\n\tpublic static final String CACHE_IMPL = SimpleCacheFactory.CACHE_IMPL;\n\tprivate static CacheFactory DEFAULT_FACTORY = new DefaultCacheFactory();\n\tpublic static final byte[] ZERO_BYTES = new byte[0];\n\tprivate final IMessageHandler messageHandler;\n\tprivate final GeneratedCachedClassHandler cachingClassHandler;\n\tprivate final CacheBacking backing;\n\tprivate final CacheStatistics stats;\n\tprivate final CacheKeyResolver resolver;\n\tprivate final String name;\n\n\tprivate static final List<WeavedClassCache> cacheRegistry = new LinkedList<>();\n\n\tprotected WeavedClassCache(GeneratedClassHandler existingClassHandler,\n\t\t\t\t\t\t\t   IMessageHandler messageHandler,\n\t\t\t\t\t\t\t   String name,\n\t\t\t\t\t\t\t   CacheBacking backing,\n\t\t\t\t\t\t\t   CacheKeyResolver resolver) {\n\t\tthis.resolver = resolver;\n\t\tthis.name = name;\n\t\tthis.backing = backing;\n\t\tthis.messageHandler = messageHandler;\n\t\t// wrap the existing class handler with a caching version\n\t\tcachingClassHandler = new GeneratedCachedClassHandler(this, existingClassHandler);\n\t\tthis.stats = new CacheStatistics();\n\t\tsynchronized (cacheRegistry) {\n\t\t\tcacheRegistry.add(this);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new cache using the resolver and backing returned by the DefaultCacheFactory.\n\t *\n\t * @param loader\t\t\t   classloader for this cache\n\t * @param aspects\t\t\t  list of aspects used by the WeavingAdapter\n\t * @param existingClassHandler the existing GeneratedClassHandler used by the weaver\n\t * @param messageHandler\t   the existing messageHandler used by the weaver\n\t * @return\n\t */\n\tpublic static WeavedClassCache createCache(ClassLoader loader, List<String> aspects, GeneratedClassHandler existingClassHandler, IMessageHandler messageHandler) {\n\t\tCacheKeyResolver resolver = DEFAULT_FACTORY.createResolver();\n\t\tString name = resolver.createClassLoaderScope(loader, aspects);\n\t\tif (name == null) {\n\t\t\treturn null;\n\t\t}\n\t\tCacheBacking backing = DEFAULT_FACTORY.createBacking(name);\n\t\tif (backing != null) {\n\t\t\treturn new WeavedClassCache(existingClassHandler, messageHandler, name, backing, resolver);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t/**\n\t * The Cache and be extended in two ways, through a specialized CacheKeyResolver and\n\t * a specialized CacheBacking. The default factory used to create these classes can\n\t * be set with this method. Since each weaver will create a cache, this method must be\n\t * called before the weaver is first initialized.\n\t *\n\t * @param factory\n\t */\n\tpublic static void setDefaultCacheFactory(CacheFactory factory) {\n\t\tDEFAULT_FACTORY = factory;\n\t}\n\n\t/**\n\t * Created a key for a generated class\n\t *\n\t * @param className ClassName, e.g. \"com.foo.Bar\"\n\t * @return the cache key, or null if no caching should be performed\n\t */\n\tpublic CachedClassReference createGeneratedCacheKey(String className) {\n\t\treturn resolver.generatedKey(className);\n\t}\n\n\t/**\n\t * Create a key for a normal weaved class\n\t *\n\t * @param className\t ClassName, e.g. \"com.foo.Bar\"\n\t * @param originalBytes Original byte array of the class\n\t * @return a cache key, or null if no caching should be performed\n\t */\n\tpublic CachedClassReference createCacheKey(String className, byte[] originalBytes) {\n\t\treturn resolver.weavedKey(className, originalBytes);\n\t}\n\n\t/**\n\t * Returns a generated class handler which wraps the handler this cache was initialized\n\t * with; this handler should be used to make sure that generated classes are added\n\t * to the cache\n\t */\n\tpublic GeneratedClassHandler getCachingClassHandler() {\n\t\treturn cachingClassHandler;\n\t}\n\n\t/**\n\t * Has caching been enabled through the System property,\n\t * WEAVED_CLASS_CACHE_ENABLED\n\t *\n\t * @return true if caching is enabled\n\t */\n\tpublic static boolean isEnabled() {\n\t\tString enabled = System.getProperty(WEAVED_CLASS_CACHE_ENABLED);\n\t\tString impl = System.getProperty(CACHE_IMPL);\n\t\treturn (enabled != null && (impl == null || !SimpleCache.IMPL_NAME.equalsIgnoreCase(impl) ) );\n\t}\n\n\t/**\n\t * Put a class in the cache\n\t *\n\t * @param ref\t\t reference to the entry, as created through createCacheKey\n\t * @param classBytes pre-weaving class bytes\n\t * @param weavedBytes bytes to cache\n\t */\n\tpublic void put(CachedClassReference ref, byte[] classBytes, byte[] weavedBytes) {\n\t\tCachedClassEntry.EntryType type = CachedClassEntry.EntryType.WEAVED;\n\t\tif (ref.getKey().matches(resolver.getGeneratedRegex())) {\n\t\t\ttype = CachedClassEntry.EntryType.GENERATED;\n\t\t}\n\t\tbacking.put(new CachedClassEntry(ref, weavedBytes, type), classBytes);\n\t\tstats.put();\n\t}\n\n\t/**\n\t * Get a cache value\n\t *\n\t * @param ref reference to the cache entry, created through createCacheKey\n\t * @param classBytes Pre-weaving class bytes - required to ensure that\n\t * cached aspects refer to an unchanged original class\n\t * @return the CacheEntry, or null if no entry exists in the cache\n\t */\n\tpublic CachedClassEntry get(CachedClassReference ref, byte[] classBytes) {\n\t\tCachedClassEntry entry = backing.get(ref, classBytes);\n\t\tif (entry == null) {\n\t\t\tstats.miss();\n\t\t} else {\n\t\t\tstats.hit();\n\t\t\tif (entry.isGenerated()) stats.generated();\n\t\t\tif (entry.isWeaved()) stats.weaved();\n\t\t\tif (entry.isIgnored()) stats.ignored();\n\t\t}\n\t\treturn entry;\n\t}\n\n\t/**\n\t * Put a cache entry to indicate that the class should not be\n\t * weaved; the original bytes of the class should be used.\n\t *\n\t * @param ref The cache reference\n\t * @param classBytes The un-weaved class bytes\n\t */\n\tpublic void ignore(CachedClassReference ref, byte[] classBytes) {\n\t\tstats.putIgnored();\n\t\tbacking.put(new CachedClassEntry(ref, ZERO_BYTES, CachedClassEntry.EntryType.IGNORED), classBytes);\n\t}\n\n\t/**\n\t * Invalidate a cache entry\n\t *\n\t * @param ref\n\t */\n\tpublic void remove(CachedClassReference ref) {\n\t\tbacking.remove(ref);\n\t}\n\n\t/**\n\t * Clear the entire cache\n\t */\n\tpublic void clear() {\n\t\tbacking.clear();\n\t}\n\n\t/**\n\t * Get the statistics associated with this cache, or\n\t * null if statistics have not been enabled.\n\t *\n\t * @return\n\t */\n\tpublic CacheStatistics getStats() {\n\t\treturn stats;\n\t}\n\n\t/**\n\t * Return a list of all WeavedClassCaches which have been initialized\n\t *\n\t * @return\n\t */\n\tpublic static List<WeavedClassCache> getCaches() {\n\t\tsynchronized (cacheRegistry) {\n\t\t\treturn new LinkedList<>(cacheRegistry);\n\t\t}\n\t}\n\n\tprotected void error(String message, Throwable th) {\n\t\tmessageHandler.handleMessage(new Message(message, IMessage.ERROR, th, null));\n\t}\n\n\tprotected void error(String message) {\n\t\tMessageUtil.error(messageHandler, message);\n\t}\n\n\tprotected void info(String message) {\n\t\tMessageUtil.info(message);\n\t}\n\n}\n",
    "size": 9893
  },
  {
    "file_id": "F82",
    "path": "aspectj-master/weaver/src/main/java/org/aspectj/weaver/tools/cache/ZippedFileCacheBacking.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StreamCorruptedException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.util.LangUtil;\n\n/**\n * Uses a ZIP file to store the instrumented classes/aspects - each one as a\n * <U>separate</U> {@link ZipEntry}. This mechanism is suitable for relatively\n * large numbers of instrumented classes/aspects (100's and more) since it\n * holds all of them in a single (ZIP) file. The down side is that any\n * modifications to the cache require re-writing the entire ZIP file. This\n * can cause the ZIP file to become corrupted if interrupted in mid-update,\n * thus requiring the re-population of the cache on next application activation\n * (though the overhead in this case is not prohibitvely high...)\n */\npublic class ZippedFileCacheBacking extends AsynchronousFileCacheBacking {\n    public static final String ZIP_FILE = \"cache.zip\";\n    private static final AsynchronousFileCacheBackingCreator<ZippedFileCacheBacking>    defaultCreator=\n            new AsynchronousFileCacheBackingCreator<ZippedFileCacheBacking>() {\n                public ZippedFileCacheBacking create(File cacheDir) {\n                    return new ZippedFileCacheBacking(cacheDir);\n                }\n        };\n\n    private final File  zipFile;\n    public ZippedFileCacheBacking(File cacheDir) {\n        super(cacheDir);\n        zipFile = new File(cacheDir, ZIP_FILE);\n    }\n\n    public File getZipFile () {\n        return zipFile;\n    }\n\n    public static final ZippedFileCacheBacking createBacking (File cacheDir) {\n        return createBacking(cacheDir, defaultCreator);\n    }\n\n    @Override\n    protected void writeClassBytes(String key, byte[] bytes) throws Exception {\n        File                  outFile=getZipFile();\n        Map<String,byte[]>    entriesMap;\n        try {\n            entriesMap = readZipClassBytes(outFile);\n        } catch(Exception e) {\n            if ((logger != null) && logger.isTraceEnabled()) {\n                logger.warn(\"writeClassBytes(\" + outFile + \")[\" + key + \"]\"\n                          + \" failed (\" + e.getClass().getSimpleName() + \")\"\n                          + \" to read current data: \" + e.getMessage(),\n                            e);\n            }\n\n            FileUtil.deleteContents(outFile);\n            return;\n        }\n\n        if (entriesMap.isEmpty()) {\n            entriesMap = Collections.singletonMap(key, bytes);\n        } else {\n            entriesMap.put(key, bytes);\n        }\n\n        try {\n            writeZipClassBytes(outFile, entriesMap);\n        } catch(Exception e) {\n            if ((logger != null) && logger.isTraceEnabled()) {\n                logger.warn(\"writeClassBytes(\" + outFile + \")[\" + key + \"]\"\n                          + \" failed (\" + e.getClass().getSimpleName() + \")\"\n                          + \" to write updated data: \" + e.getMessage(),\n                            e);\n            }\n\n            FileUtil.deleteContents(outFile);\n        }\n    }\n\n    @Override\n    protected void removeClassBytes(String key) throws Exception {\n        File                  outFile=getZipFile();\n        Map<String,byte[]>    entriesMap;\n        try {\n            entriesMap = readZipClassBytes(outFile);\n        } catch(Exception e) {\n            if ((logger != null) && logger.isTraceEnabled()) {\n                logger.warn(\"removeClassBytes(\" + outFile + \")[\" + key + \"]\"\n                          + \" failed (\" + e.getClass().getSimpleName() + \")\"\n                          + \" to read current data: \" + e.getMessage(),\n                            e);\n            }\n\n            FileUtil.deleteContents(outFile);\n            return;\n        }\n\n        if (!entriesMap.isEmpty()) {\n            if (entriesMap.remove(key) == null) {\n                return; // not in the data file to begin with so nothing to update\n            }\n        }\n\n        try {\n            writeZipClassBytes(outFile, entriesMap);\n        } catch(Exception e) {\n            if ((logger != null) && logger.isTraceEnabled()) {\n                logger.warn(\"removeClassBytes(\" + outFile + \")[\" + key + \"]\"\n                          + \" failed (\" + e.getClass().getSimpleName() + \")\"\n                          + \" to write updated data: \" + e.getMessage(),\n                            e);\n            }\n\n            FileUtil.deleteContents(outFile);\n        }\n    }\n\n    @Override\n    protected Map<String, byte[]> readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir) {\n        File                dataFile=new File(cacheDir, ZIP_FILE);\n        Map<String,byte[]>  entriesMap;\n        boolean             okEntries=true;\n        try {\n            entriesMap = readZipClassBytes(dataFile);\n        } catch(Exception e) {\n            if ((logger != null) && logger.isTraceEnabled()) {\n                logger.warn(\"Failed (\" + e.getClass().getSimpleName() + \")\"\n                          + \" to read zip entries from \" + dataFile\n                          + \": \" + e.getMessage(),\n                          e);\n            }\n\n            entriesMap = new TreeMap<>();\n            okEntries = false;\n        }\n\n        if (!syncClassBytesEntries(dataFile, indexMap, entriesMap)) {\n            okEntries = false;\n        }\n\n        if (!okEntries) {\n            FileUtil.deleteContents(dataFile);\n\n            if (!entriesMap.isEmpty()) {\n                entriesMap.clear();\n            }\n        }\n\n        syncIndexEntries(dataFile, indexMap, entriesMap);\n\n        return entriesMap;\n    }\n\n    // remove all non-ignored entries that have no class bytes\n    protected Collection<String> syncIndexEntries (File dataFile, Map<String, IndexEntry> indexMap, Map<String,byte[]>  entriesMap) {\n        Collection<String>  toDelete=null;\n        for (Map.Entry<String, IndexEntry> ie : indexMap.entrySet()) {\n            String      key=ie.getKey();\n            IndexEntry  indexEntry=ie.getValue();\n            if (indexEntry.ignored) {\n                continue;   // ignored entries have no class bytes\n            }\n\n            if (entriesMap.containsKey(key)) {\n                continue;\n            }\n\n            if ((logger != null) && logger.isTraceEnabled()) {\n                logger.debug(\"syncIndexEntries(\" + dataFile + \")[\" + key + \"] no class bytes\");\n            }\n\n            if (toDelete == null) {\n                toDelete = new TreeSet<>();\n            }\n            toDelete.add(key);\n        }\n\n        if (toDelete == null) {\n            return Collections.emptySet();\n        }\n\n        for (String key : toDelete) {\n            indexMap.remove(key);\n        }\n\n        return toDelete;\n    }\n\n    // check if all class bytes entries are valid\n    protected boolean syncClassBytesEntries (File dataFile, Map<String, IndexEntry> indexMap, Map<String,byte[]>  entriesMap) {\n        boolean okEntries=true;\n\n        for (Map.Entry<String,byte[]> bytesEntry : entriesMap.entrySet()) {\n            String      key=bytesEntry.getKey();\n            IndexEntry  indexEntry=indexMap.get(key);\n            // ignored entries should have no bytes\n            if ((indexEntry == null) || indexEntry.ignored) {\n                if ((logger != null) && logger.isTraceEnabled()) {\n                    logger.debug(\"syncClassBytesEntries(\" + dataFile + \")[\" + key + \"] bad index entry\");\n                }\n\n                okEntries = false;\n                continue;\n            }\n\n            long    crc=crc(bytesEntry.getValue());\n            if (crc != indexEntry.crcWeaved) {\n                if ((logger != null) && logger.isTraceEnabled()) {\n                    logger.debug(\"syncClassBytesEntries(\" + dataFile + \")[\" + key + \"]\"\n                               + \" mismatched CRC - expected=\" + indexEntry.crcWeaved + \"/got=\" + crc);\n                }\n\n                indexMap.remove(key);\n                okEntries = false;\n                continue;\n            }\n        }\n\n        return okEntries;\n    }\n\n    @Override\n    protected IndexEntry resolveIndexMapEntry(File cacheDir, IndexEntry ie) {\n        if (cacheDir.exists()) {\n            return ie;  // we will take care of non-existing index entries in the readClassBytes method\n        } else {\n            return null;\n        }\n    }\n\n    public static final Map<String,byte[]> readZipClassBytes (File file) throws IOException {\n        if (!file.canRead()) {\n            return Collections.emptyMap();\n        }\n\n        Map<String,byte[]>      result= new TreeMap<>();\n        byte[]                  copyBuf=new byte[4096];\n        ByteArrayOutputStream   out=new ByteArrayOutputStream(copyBuf.length);\n        ZipFile                 zipFile=new ZipFile(file);\n        try {\n            for (Enumeration<? extends ZipEntry> entries=zipFile.entries(); (entries != null) && entries.hasMoreElements(); ) {\n                ZipEntry    e=entries.nextElement();\n                String      name=e.getName();\n                if (LangUtil.isEmpty(name)) {\n                    continue;\n                }\n\n                out.reset();\n\n                InputStream zipStream=zipFile.getInputStream(e);\n                try {\n                    for (int    nRead=zipStream.read(copyBuf); nRead != (-1); nRead=zipStream.read(copyBuf)) {\n                        out.write(copyBuf, 0, nRead);\n                    }\n                } finally {\n                    zipStream.close();\n                }\n\n                byte[]  data=out.toByteArray(), prev=result.put(name, data);\n                if (prev != null) {\n                    throw new StreamCorruptedException(\"Multiple entries for \" + name);\n                }\n            }\n        } finally {\n            zipFile.close();\n        }\n\n        return result;\n    }\n\n    public static final void writeZipClassBytes (File file, Map<String,byte[]> entriesMap) throws IOException {\n        if (entriesMap.isEmpty()) {\n            FileUtil.deleteContents(file);\n            return;\n        }\n\n        File\tzipDir=file.getParentFile();\n        if ((!zipDir.exists()) && (!zipDir.mkdirs())) {\n            throw new IOException(\"Failed to create path to \" + zipDir.getAbsolutePath());\n        }\n\n        ZipOutputStream zipOut=new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(file), 4096));\n        try {\n            for (Map.Entry<String,byte[]> bytesEntry : entriesMap.entrySet()) {\n                String      key=bytesEntry.getKey();\n                byte[]      bytes=bytesEntry.getValue();\n                zipOut.putNextEntry(new ZipEntry(key));\n                zipOut.write(bytes);\n                zipOut.closeEntry();\n            }\n        } finally {\n            zipOut.close();\n        }\n    }\n}\n",
    "size": 11629
  },
  {
    "file_id": "F83",
    "path": "aspectj-master/weaver/src/test/java/$Proxy1.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2009 Contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement - initial API and implementation\n *******************************************************************************/\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class $Proxy1 extends Proxy implements MessageService {\n\n\tprotected $Proxy1(InvocationHandler arg0) {\n\t\tsuper(arg0);\n\t}\n\n\tpublic Object get1(Long t) {\n\t\treturn null;\n\t}\n\n\tpublic Object get2(Serializable s) {\n\t\treturn null;\n\t}\n}\n",
    "size": 874
  },
  {
    "file_id": "F84",
    "path": "aspectj-master/weaver/src/test/java/CounterAspect.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Andy Clement         initial implementation\n * ******************************************************************/\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\n\n/**\n * Created to enable PointcutDesignatorHandlerTests.testParsingBeanInReferencePointcut01 and 02 to run\n *\n * @author Andy Clement\n */\n@Aspect\npublic class CounterAspect {\n\n    int count;\n\n    @Before(\"execution(* set*(..)) && bean(testBean1)\")\n    public void increment1ForAnonymousPointcut() {\n        count++;\n    }\n\n    @Pointcut(\"execution(* toString(..)) && bean(testBean1)\")\n    public void testBean1toString() {\n    }\n\n    @Pointcut(\"execution(* setAge(..)) && bean(testBean1)\")\n    public void testBean1SetAge() {\n    }\n\n    @Pointcut(\"execution(* setAge(..)) && bean(testBean2)\")\n    public void testBean2SetAge() {\n    }\n\n    @Before(\"testBean1SetAge()\")\n    public void increment1() {\n        count++;\n    }\n\n    @Before(\"testBean2SetAge()\")\n    public void increment2() {\n        count++;\n    }\n}\n",
    "size": 1457
  },
  {
    "file_id": "F85",
    "path": "aspectj-master/weaver/src/test/java/GenericService.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2009 Contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement - initial API and implementation\n *******************************************************************************/\nimport java.io.Serializable;\n\npublic interface GenericService<T extends Serializable> {\n\tObject get1(T t);\n\n\tObject get2(Serializable s);\n}\n",
    "size": 673
  },
  {
    "file_id": "F86",
    "path": "aspectj-master/weaver/src/test/java/MA.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\n\npublic @interface MA {\n\n}\n",
    "size": 506
  },
  {
    "file_id": "F87",
    "path": "aspectj-master/weaver/src/test/java/MB.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\n\npublic @interface MB {\n\n}\n",
    "size": 506
  },
  {
    "file_id": "F88",
    "path": "aspectj-master/weaver/src/test/java/MC.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\n\npublic @interface MC {\n\n}\n",
    "size": 506
  },
  {
    "file_id": "F89",
    "path": "aspectj-master/weaver/src/test/java/MD.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\n\npublic @interface MD {\n\n}\n",
    "size": 506
  },
  {
    "file_id": "F90",
    "path": "aspectj-master/weaver/src/test/java/MessageService.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2009 Contributors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement - initial API and implementation\n *******************************************************************************/\npublic interface MessageService extends GenericService<Long> {\n\n}\n",
    "size": 599
  },
  {
    "file_id": "F91",
    "path": "aspectj-master/weaver/src/test/java/fluffy/Aspect.java",
    "text": "package fluffy;\nimport org.aspectj.runtime.internal.AroundClosure;\n\npublic class Aspect {\n\n\tpublic static void ignoreMe() {}\n\n\tpublic static void before_method_call() {\n\t\tSystem.out.println(\"before\");\n\t}\n\n\tpublic static void afterReturning_method_call() {\n\t\tSystem.out.println(\"afterReturning\");\n\t}\n\n\tpublic static void afterThrowing_method_execution(Throwable t) {\n\t\tSystem.out.println(\"afterThrowing \" + t);\n\t\tt.printStackTrace();\n\t}\n\n\tpublic static Object aroundFun(AroundClosure c) {\n\t\tSystem.out.println(\"around\");\n\t\ttry {\n\t\t\treturn c.run(new Object[0]);\n\t\t} catch (Throwable t) {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n",
    "size": 611
  },
  {
    "file_id": "F92",
    "path": "aspectj-master/weaver/src/test/java/fluffy/Base.java",
    "text": "package fluffy;\n\npublic class Base {\n\n\tpublic static void onlyBase() {}\n\tpublic static void both() {}\n\n\tpublic void onlyBaseNonStatic() {}\n\tpublic void bothNonStatic() {}\n\n\tpublic int onlyBase;\n\tpublic int both;\n\n\tpublic Base() {}\n\tpublic Base(int i) {}\n\n\tpublic void m() throws CloneNotSupportedException {}\n}\n",
    "size": 311
  },
  {
    "file_id": "F93",
    "path": "aspectj-master/weaver/src/test/java/fluffy/Derived.java",
    "text": "package fluffy;\n\nimport java.io.IOException;\n\npublic class Derived extends Base {\n\n\tpublic static void onlyDerived() throws IOException, CloneNotSupportedException {}\n\tpublic static void both() {}\n\n\tpublic void onlyDerivedNonStatic() {}\n\tpublic void bothNonStatic() {}\n\n\tpublic int onlyDerived;\n\tpublic int both;\n\n\tpublic Derived() {}\n\n\tpublic void m() {}\n\n}\n",
    "size": 359
  },
  {
    "file_id": "F94",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/matcher/tools/ReflectionWorldAdvancedPointcutExpressionTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n * Andy Clement\n * ******************************************************************/\npackage org.aspectj.matcher.tools;\n\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.reflect.ReflectionWorld;\n\n/**\n * Run all the pointcut parsing/matching tests against a ReflectionWorld.\n *\n * @author Andy Clement\n */\npublic class ReflectionWorldAdvancedPointcutExpressionTest extends CommonAdvancedPointcutExpressionTests {\n\n\tprotected World getWorld() {\n\t\tWorld w = new ReflectionWorld(false, getClass().getClassLoader());\n\t\tw.setBehaveInJava5Way(true);\n\t\treturn w;\n\t}\n\n}\n",
    "size": 964
  },
  {
    "file_id": "F95",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/AbstractTraceTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2006 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster - initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport java.util.ArrayList;\n\nimport org.aspectj.weaver.tools.AbstractTrace;\nimport org.aspectj.weaver.tools.DefaultTrace;\nimport org.aspectj.weaver.tools.Traceable;\n\nimport junit.framework.TestCase;\n\npublic abstract class AbstractTraceTest extends TestCase {\n\n\tprotected AbstractTrace trace;\n\n\tpublic void testIsTraceEnabled() {\n\t\tDefaultTrace trace = new DefaultTrace(getClass());\n\t\tassertFalse(trace.isTraceEnabled());\n\t}\n\n\tpublic void testEnterWithThisAndArgs() {\n\t\ttrace.enter(\"testEnterWithThisAndArgs\",this,new Object[] { \"arg1\", \"arg2\" });\n\t}\n\n\tpublic void testEnterWithThisAndArray() {\n\t\tObject arg1 = new String[] { \"s1\", \"s2\" };\n\t\tObject arg2 = new char[] { 'a', 'b', 'c' };\n\t\ttrace.enter(getName(),this,new Object[] { arg1, arg2 });\n\t}\n\n\tpublic void testEnterWithThisAndCollection() {\n\t\tObject arg1 = new ArrayList();\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\n\t}\n\n\tpublic void testEnterWithThisAndTraceable () {\n\t\tObject arg1 = new Traceable() {\n\n\t\t\tpublic String toTraceString() {\n\t\t\t\treturn getClass().getName() + \"[Traceable]\";\n\t\t\t}\n\n\t\t};\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\n\t}\n\n\tpublic void testEnterWithThisAndToStringException () {\n\t\tObject arg1 = new Object() {\n\n\t\t\tpublic String toString() {\n\t\t\t\tthrow new RuntimeException(\"toString() can throw an Exception\");\n\t\t\t}\n\n\t\t};\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\n\t}\n\n\tpublic void testEnterWithThisAndHashCodeException () {\n\t\tObject arg1 = new Object() {\n\n\t\t\tpublic int hashCode() {\n\t\t\t\tthrow new RuntimeException(\"hashCode can throw an Exception\");\n\t\t\t}\n\n\t\t};\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\n\t}\n\n\tpublic void testEnterWithThisAndClassLoader () {\n\t\tObject arg1 = new ClassLoader() {\n\n\t\t\tpublic String toString() {\n\t\t\t\tthrow new Error(\"Don't call ClassLoader.toString()\");\n\t\t\t}\n\n\t\t};\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\n\t}\n\n\tpublic void testEnterWithThis() {\n\t\ttrace.enter(\"testEnterWithThis\",this);\n\t}\n\n\tpublic void testEnter() {\n\t\ttrace.enter(\"testEnter\");\n\t}\n\n\tpublic void testExitWithReturn() {\n\t\ttrace.exit(\"testExitWithReturn\",\"ret\");\n\t}\n\n\tpublic void testExitWithThrowable() {\n\t\ttrace.exit(\"testExitWithThrowable\",new RuntimeException());\n\t}\n\n\tpublic void testExit() {\n\t\ttrace.exit(\"testExit\");\n\t}\n\n\tpublic void testEvent() {\n\t\ttrace.event(\"testEvent\");\n\t}\n\n\tpublic void testEventWithThisAndArgs() {\n\t\ttrace.event(\"testEventWithThisAndArgs\",this,new Object[] { \"arg1\", \"arg2\" });\n\t}\n\n\tpublic void testEventWithThisAndArg() {\n\t\ttrace.event(\"testEventWithThisAndArg\",this,\"arg1\");\n\t}\n\n\tpublic void testDebug() {\n\t\ttrace.debug(\"debug\");\n\t}\n\n\tpublic void testInfo() {\n\t\ttrace.info(\"information\");\n\t}\n\n\tpublic void testWarn() {\n\t\ttrace.warn(\"warning\");\n\t}\n\n\tpublic void testWarnWithException() {\n\t\ttrace.warn(\"warning\",new RuntimeException(\"warning\"));\n\t}\n\n\tpublic void testError() {\n\t\ttrace.error(\"error\");\n\t}\n\n\tpublic void testErrorWithException() {\n\t\ttrace.error(\"error\",new RuntimeException(\"error\"));\n\t}\n\n\tpublic void testFatal() {\n\t\ttrace.fatal(\"fatal\");\n\t}\n\n\tpublic void testFatalWithException() {\n\t\ttrace.fatal(\"fatal\",new RuntimeException(\"fatal\"));\n\t}\n\n}\n",
    "size": 3685
  },
  {
    "file_id": "F96",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/BoundedReferenceTypeTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\npublic class BoundedReferenceTypeTestCase extends TestCase {\n\n\tReferenceType javaLangClass;\n\tReferenceType javaLangObject;\n\tBoundedReferenceType extendsClass;\n\tBoundedReferenceType superClass;\n\tBoundedReferenceType extendsWithExtras;\n\n\tpublic void testSignature() {\n\t\tString extendsSig = extendsClass.getSignature();\n\t\tassertEquals(\"+Ljava/lang/Class;\", extendsSig);\n\t\tassertEquals(\"-Ljava/lang/Class;\", superClass.getSignature());\n\t}\n\n\tpublic void testExtendsBounds() {\n\t\tassertFalse(\"has no lower bound\", extendsClass.hasLowerBound());\n\t\tassertNull(\"no lower bound\", extendsClass.getLowerBound());\n\t\tassertEquals(javaLangClass, extendsClass.getUpperBound());\n\t\tassertEquals(\"no interface bounds\", 0, extendsClass.getAdditionalBounds().length);\n\t}\n\n\tpublic void testSuperBounds() {\n\t\tassertTrue(\"has lower bound\", superClass.hasLowerBound());\n\t\tassertEquals(javaLangClass, superClass.getLowerBound());\n\t\tassertEquals(\"Ljava/lang/Object;\", superClass.getUpperBound().getSignature());\n\t\tassertEquals(\"no interface bounds\", 0, superClass.getAdditionalBounds().length);\n\t}\n\n\tpublic void testIsExtends() {\n\t\tassertTrue(extendsClass.kind == BoundedReferenceType.EXTENDS);\n\t\tassertFalse(superClass.kind == BoundedReferenceType.EXTENDS);\n\t}\n\n\tpublic void testIsSuper() {\n\t\tassertTrue(superClass.kind == BoundedReferenceType.SUPER);\n\t\tassertFalse(extendsClass.kind == BoundedReferenceType.SUPER);\n\t}\n\n\tpublic void testGetDeclaredInterfacesNoAdditions() {\n\t\tResolvedType[] rt1 = extendsClass.getDeclaredInterfaces();\n\t\tResolvedType[] rt2 = javaLangClass.getDeclaredInterfaces();\n\t\tassertEquals(\"same length\", rt1.length, rt2.length);\n\t\tfor (int i = 0; i < rt2.length; i++) {\n\t\t\tassertEquals(\"same methods\", rt1[i], rt2[i]);\n\t\t}\n\t}\n\n\tpublic void testGetDeclaredInterfacesWithInterfaceBounds() {\n\t\tResolvedType[] rt1 = extendsWithExtras.getDeclaredInterfaces();\n\t\tResolvedType[] rt2 = javaLangClass.getDeclaredInterfaces();\n\t\tassertEquals(\"one extra interface\", rt1.length, rt2.length + 1);\n\t\tfor (int i = 0; i < rt2.length; i++) {\n\t\t\tassertEquals(\"same methods\", rt1[i], rt2[i]);\n\t\t}\n\t\tassertEquals(\"Ljava/util/List;\", rt1[rt1.length - 1].getSignature());\n\t}\n\n\t// all other methods in signature are delegated to upper bound...\n\t// representative test\n\tpublic void testGetDeclaredMethodsExtends() {\n\t\tResolvedMember[] rm1 = extendsClass.getDeclaredMethods();\n\t\tResolvedMember[] rm2 = javaLangClass.getDeclaredMethods();\n\t\tassertEquals(\"same length\", rm1.length, rm2.length);\n\t\tfor (int i = 0; i < rm2.length; i++) {\n\t\t\tassertEquals(\"same methods\", rm1[i], rm2[i]);\n\t\t}\n\t}\n\n\tpublic void testGetDeclaredMethodsSuper() {\n\t\tResolvedMember[] rm1 = superClass.getDeclaredMethods();\n\t\tResolvedMember[] rm2 = javaLangObject.getDeclaredMethods();\n\t\tassertEquals(\"same length\", rm1.length, rm2.length);\n\t\tfor (int i = 0; i < rm2.length; i++) {\n\t\t\tassertEquals(\"same methods\", rm1[i], rm2[i]);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tBcelWorld world = new BcelWorld();\n\t\tjavaLangClass = (ReferenceType) world.resolve(UnresolvedType.forName(\"java/lang/Class\"));\n\t\tjavaLangObject = (ReferenceType) world.resolve(UnresolvedType.OBJECT);\n\t\textendsClass = new BoundedReferenceType(javaLangClass, true, world);\n\t\tsuperClass = new BoundedReferenceType(javaLangClass, false, world);\n\t\textendsWithExtras = new BoundedReferenceType(javaLangClass, true, world, new ReferenceType[] { (ReferenceType) world\n\t\t\t\t.resolve(UnresolvedType.forName(\"java/util/List\")) });\n\t}\n}\n",
    "size": 4090
  },
  {
    "file_id": "F97",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/CommonReferenceTypeTests.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport junit.framework.TestCase;\n\n// test cases for Adrian's additions to ReferenceType\n// XXX - couldn't find any unit test cases for the rest of the ReferenceType class\npublic abstract class CommonReferenceTypeTests extends TestCase {\n\n\tprivate World world;\n\n\tpublic abstract World getWorld();\n\n\tpublic void setUp() {\n\t\tworld = getWorld();\n\t}\n\n\tpublic void testUnresolvedTypeSignatureProcessing() {\n\t\tworld.setBehaveInJava5Way(true);\n\t\tUnresolvedType ut = null;\n\t\tut = UnresolvedType.forName(\"java.util.List<java.util.List<java.lang.String>>[]\").resolve(world);\n\t\tut = UnresolvedType.forSignature(\"[Pjava/util/List<Pjava/util/List<Ljava/lang/String;>;>;\").resolve(world);\n\t\tassertEquals(\"Signatures not equal \", \"[Pjava/util/List<Pjava/util/List<Ljava/lang/String;>;>;\", ut.getSignature());\n\t\tassertEquals(\"Names not equal \", \"java.util.List<java.util.List<java.lang.String>>[]\", ut.getName());\n\t}\n\n\tpublic void testArrays() {\n\t\tworld.setBehaveInJava5Way(true);\n\t\tUnresolvedType ut = null;\n\t\tut = UnresolvedType.forName(\"[Ljava.lang.String;\");\n\t\tassertEquals(\"[Ljava/lang/String;\",ut.getSignature());\n\t\tUnresolvedType reified = UnresolvedType.forSignature(ut.getSignature());\n\t\tResolvedType rt = world.resolve(reified);\n\t\tassertEquals(\"[Ljava/lang/String;\",rt.getSignature());\n\t\tassertEquals(\"java.lang.String[]\",rt.getName());\n\t\tassertFalse(rt.isMissing());\n\n\t\tut = UnresolvedType.forName(\"[[[[Ljava.lang.String;\");\n\t\tassertEquals(\"[[[[Ljava/lang/String;\",ut.getSignature());\n\t\treified = UnresolvedType.forSignature(ut.getSignature());\n\t\trt = world.resolve(reified);\n\t\tassertEquals(\"[[[[Ljava/lang/String;\",rt.getSignature());\n\t\tassertEquals(\"java.lang.String[][][][]\",rt.getName());\n\t\tassertTrue(rt.isArray());\n\t\tassertTrue(rt.getComponentType().isArray());\n\t\tassertFalse(rt.isMissing());\n\t}\n\n\tpublic void testIsRawTrue() {\n\t\tworld.setBehaveInJava5Way(true);\n\t\tUnresolvedType javaLangClass = UnresolvedType.forName(\"java.lang.Class\");\n\t\tResolvedType rtx = world.resolve(javaLangClass);\n\t\tassertTrue(\"Resolves to reference type\", (rtx instanceof ReferenceType));\n\t\tReferenceType rt = (ReferenceType) rtx;\n\t\tassertTrue(\"java.lang.Class is raw\", rt.isRawType());\n\t}\n\n\tpublic void testIsRawFalse() {\n\t\tworld.setBehaveInJava5Way(true);\n\t\tUnresolvedType javaLangObject = UnresolvedType.forName(\"java.lang.Object\");\n\t\tResolvedType rtx = world.resolve(javaLangObject);\n\t\tassertTrue(\"Resolves to reference type\", (rtx instanceof ReferenceType));\n\t\tReferenceType rt = (ReferenceType) rtx;\n\t\tassertFalse(\"java.lang.Object is  not raw\", rt.isRawType());\n\t}\n\n\tpublic void testIsGenericTrue() {\n\t\tworld.setBehaveInJava5Way(true);\n\t\tUnresolvedType javaLangClass = UnresolvedType.forName(\"java.lang.Class\");\n\t\tResolvedType rtx = world.resolve(javaLangClass);\n\t\tassertTrue(\"java.lang.Class has underpinning generic type\", rtx.getGenericType().isGenericType());\n\t}\n\n\tpublic void testIsGenericFalse() {\n\t\tworld.setBehaveInJava5Way(true);\n\t\tUnresolvedType javaLangObject = UnresolvedType.forName(\"java.lang.Object\");\n\t\tResolvedType rtx = world.resolve(javaLangObject);\n\t\tassertFalse(rtx.isGenericType());\n\t}\n\n}\n",
    "size": 3631
  },
  {
    "file_id": "F98",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/CommonsTraceFactoryTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2006 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster - initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.tools.CommonsTraceFactory;\nimport org.aspectj.weaver.tools.Trace;\n\nimport junit.framework.TestCase;\n\npublic class CommonsTraceFactoryTest extends TestCase {\n\n\tpublic void testGetTraceFactory() {\n\t\tCommonsTraceFactory factory = new CommonsTraceFactory();\n\t\tTrace trace = factory.getTrace(getClass());\n\t\tassertFalse(\"Tracing should be disbled by default\",trace.isTraceEnabled());\n\t}\n\n}\n",
    "size": 983
  },
  {
    "file_id": "F99",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/CommonsTraceTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2006 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster - initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.tools.CommonsTrace;\n\npublic class CommonsTraceTest extends AbstractTraceTest {\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\ttrace = new CommonsTrace(getClass());\n\t\ttrace.setTraceEnabled(true);\n\t}\n\n\tpublic void testCommonsTrace() {\n//\t\tCommonsTrace trace =\n\t\t\tnew CommonsTrace(getClass());\n\t}\n\n\tpublic void testSetTraceEnabled() {\n\t\tCommonsTrace trace = new CommonsTrace(getClass());\n\t\ttrace.setTraceEnabled(true);\n\t\t/* XXX Need to find out how to turn tracing on */\n//\t\tassertTrue(trace.isTraceEnabled());\n\t}\n\n}\n",
    "size": 1129
  },
  {
    "file_id": "F100",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/DefaultTraceFactoryTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2006 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster - initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.tools.DefaultTraceFactory;\nimport org.aspectj.weaver.tools.Trace;\n\nimport junit.framework.TestCase;\n\npublic class DefaultTraceFactoryTest extends TestCase {\n\n\tpublic void testGetTrace() {\n\t\tDefaultTraceFactory factory = new DefaultTraceFactory();\n\t\tTrace trace = factory.getTrace(getClass());\n\t\tassertFalse(\"Tracing should be disbled by default\",trace.isTraceEnabled());\n\t}\n\n//\tpublic void testIsEnabled() {\n//\t\tfail(\"Not yet implemented\");\n//\t}\n\n}\n",
    "size": 1048
  },
  {
    "file_id": "F101",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/DefaultTraceTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2006 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster - initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.tools.DefaultTrace;\n\npublic class DefaultTraceTest extends AbstractTraceTest {\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\ttrace = new DefaultTrace(getClass());\n\t\ttrace.setTraceEnabled(true);\n\t}\n\n\tpublic void testDefaultTrace() {\n//\t\tDefaultTrace trace =\n\t\t\tnew DefaultTrace(getClass());\n\t}\n\n\tpublic void testSetTraceEnabled() {\n\t\tDefaultTrace trace = new DefaultTrace(getClass());\n\t\ttrace.setTraceEnabled(true);\n\t\tassertTrue(trace.isTraceEnabled());\n\t}\n\n\tpublic void testSetPrintStream () {\n\t\tDefaultTrace trace = new DefaultTrace(getClass());\n\t\ttrace.setPrintStream(System.out);\n\t}\n}\n",
    "size": 1204
  },
  {
    "file_id": "F102",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/DumpTestCase.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2004 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.IMessageHolder;\nimport org.aspectj.bridge.Message;\nimport org.aspectj.bridge.MessageHandler;\n\nimport junit.framework.TestCase;\n\n/**\n * @author websterm\n *\n * Test Dump facility. Ensure it can be configured and files contain expected contents. Testcase\n * returns Dump configuration to orginal state.\n */\npublic class DumpTestCase extends TestCase {\n\n\tprivate File dumpFile;\n\tprivate IMessage.Kind savedDumpCondition;\n\n\tpublic DumpTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\n\t\tdumpFile = null;\n\t\tsavedDumpCondition = Dump.getDumpOnExit();\n\t}\n\n\tprotected void tearDown() throws Exception {\n\t\tsuper.tearDown();\n\n\t\tif (dumpFile != null && dumpFile.exists()) {\n\t\t\tboolean deleted = dumpFile.delete();\n\t\t\tassertTrue(\"Dump file '\" + dumpFile.getPath() + \"' could not be deleted\",deleted);\n\t\t}\n\t\tDump.setDumpOnExit(savedDumpCondition);\n\t}\n\n\tpublic void testSetDumpOnException () {\n\t\tDump.setDumpOnException(true);\n\t\tassertTrue(\"DumpOnException should be true\",Dump.getDumpOnException());\n\t}\n\n\tpublic void testSetDumpOnExit () {\n\t\tassertTrue(\"Should be able to set condition 'error'\",Dump.setDumpOnExit(\"error\"));\n\t\tassertTrue(\"Should be able to set condition 'warning'\",Dump.setDumpOnExit(\"warning\"));\n\t\tassertFalse(\"Should not be able to set condition 'junk'\",Dump.setDumpOnExit(\"junk\"));\n\t}\n\n\tpublic void testDump () {\n\t\tString fileName = Dump.dump(\"testDump()\");\n\t\tdumpFile = new File(fileName);\n\t\tassertTrue(\"Dump file '\" + fileName + \"' should exist\",dumpFile.exists());\n\t}\n\n\tpublic void testDumpWithException () {\n\t\tString message = \"testDumpWithException()\";\n\t\tString fileName = recursiveCall(message,100);\n\t\tdumpFile = new File(fileName);\n\t\tassertContents(dumpFile,\"Exception Information\",message);\n\t}\n\n\tpublic void testDumpOnExit () {\n\t\tDump.setDumpOnExit(\"abort\");\n\t\tDump.saveMessageHolder(null);\n\t\tString fileName = Dump.dumpOnExit();\n\t\tdumpFile = new File(fileName);\n\t\tassertTrue(\"Dump file '\" + fileName + \"' should exist\",dumpFile.exists());\n\t}\n\n\tpublic void testDumpOnExitExcluded () {\n\t\tDump.setDumpOnExit(\"abort\");\n\t\tIMessageHolder holder = new MessageHandler();\n\t\tDump.saveMessageHolder(holder);\n\t\tholder.handleMessage(new Message(\"testDumpOnExitExcluded()\",IMessage.ERROR,null,null));\n\t\tString fileName = Dump.dumpOnExit();\n\t\tdumpFile = new File(fileName);\n\t\tassertEquals(\"Dump '\" + fileName + \"' should be excluded\",Dump.DUMP_EXCLUDED,fileName);\n\t}\n\n\tpublic void testDumpOnExitIncluded () {\n\t\tDump.setDumpOnExit(\"error\");\n\t\tIMessageHolder holder = new MessageHandler();\n\t\tDump.saveMessageHolder(holder);\n\t\tIMessage error = new Message(\"testDumpOnExitIncluded()\",IMessage.ERROR,null,null);\n\t\tholder.handleMessage(error);\n\t\tString fileName = Dump.dumpOnExit();\n\t\tdumpFile = new File(fileName);\n\t\tassertContents(dumpFile,\"Compiler Messages\",error.getMessage());\n\t}\n\n\t/* Ensure dump file exists and contains certain contents under a given heading */\n\tpublic static void assertContents (File dumpFile, String heading, String contents) {\n\t\tassertTrue(\"Dump file '\" + dumpFile.getPath() + \"' should exist\",dumpFile.exists());\n\t\tassertTrue(\"Dump file '\" + dumpFile.getPath()+ \"' should contain '\" + contents + \"'\",fileContains(dumpFile,heading,contents));\n\t}\n\n\tprivate static boolean fileContains (File dumpFile, String heading, String contents) {\n\t\tboolean result = false;\n\n\t\ttry {\n\t\t\tBufferedReader reader = new BufferedReader(new FileReader(dumpFile));\n\t\t\tString currentHeading = \"\";\n\t\t\tString record;\n\t\t\twhile ((null != (record = reader.readLine())) && (result == false)) {\n\t\t\t\tif (record.startsWith(\"----\")) currentHeading = record;\n\t\t\t\telse if ((record.contains(contents)) && currentHeading.contains(heading)) result = true;\n\t\t\t}\n\t\t\treader.close();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tfail(ex.toString());\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/* Generate a big stack trace */\n\tprivate String recursiveCall (String message, int depth) {\n\t\tif (depth == 0) {\n\t\t\tThrowable th = new RuntimeException(message);\n\t\t\treturn Dump.dumpWithException(th);\n\t\t}\n\t\telse {\n\t\t\treturn recursiveCall(message,--depth);\n\t\t}\n\t}\n\n}\n",
    "size": 4784
  },
  {
    "file_id": "F103",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/GenericSignatureParserTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 1999-2001 Xerox Corporation,\n *               2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * ******************************************************************/\n package org.aspectj.weaver;\n\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.apache.bcel.classfile.Method;\nimport org.aspectj.apache.bcel.util.SyntheticRepository;\nimport org.aspectj.util.GenericSignatureParser;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Adrian Colyer\n * @author Andy Clement\n */\npublic class GenericSignatureParserTest extends TestCase {\n\n\tGenericSignatureParser parser;\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tparser = new GenericSignatureParser();\n\t}\n\n\tpublic void testClassSignatureParsingInJDK() throws Exception {\n\t\tSyntheticRepository repository = SyntheticRepository.getInstance();\n\t\tString[] testClasses = new String[] { \"java.lang.Comparable\", \"java.lang.Iterable\", \"java.lang.Class\", \"java.lang.Enum\",\n\t\t\t\t\"java.lang.InheritableThreadLocal\", \"java.lang.ThreadLocal\", \"java.util.Collection\", \"java.util.Comparator\",\n\t\t\t\t\"java.util.Enumeration\", \"java.util.Iterator\", \"java.util.List\", \"java.util.ListIterator\", \"java.util.Map\",\n\t\t\t\t\"java.util.Map$Entry\", \"java.util.Queue\", \"java.util.Set\", \"java.util.SortedMap\", \"java.util.SortedSet\" };\n\t\tfor (String testClass : testClasses) {\n\t\t\tJavaClass jc = repository.loadClass(testClass);\n\t\t\tString sig = jc.getGenericSignature();\n\t\t\tparser.parseAsClassSignature(sig);\n\t\t}\n\t}\n\n\tpublic void testMethodSignatureParsingInJDK() throws Exception {\n\t\tSyntheticRepository repository = SyntheticRepository.getInstance();\n\t\tString[] testClasses = new String[] { \"java.lang.Comparable\", \"java.lang.Iterable\", \"java.lang.Class\", \"java.lang.Enum\",\n\t\t\t\t\"java.lang.InheritableThreadLocal\", \"java.lang.ThreadLocal\", \"java.util.Collection\", \"java.util.Comparator\",\n\t\t\t\t\"java.util.Enumeration\", \"java.util.Iterator\", \"java.util.List\", \"java.util.ListIterator\", \"java.util.Map\",\n\t\t\t\t\"java.util.Map$Entry\", \"java.util.Queue\", \"java.util.Set\", \"java.util.SortedMap\", \"java.util.SortedSet\" };\n\t\tfor (String testClass : testClasses) {\n\t\t\tJavaClass jc = repository.loadClass(testClass);\n\t\t\tMethod[] methods = jc.getMethods();\n\t\t\tfor (Method method : methods) {\n\t\t\t\tString sig = method.getGenericSignature();\n\t\t\t\tif (sig != null)\n\t\t\t\t\tparser.parseAsMethodSignature(sig);\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "size": 2711
  },
  {
    "file_id": "F104",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/Java5ReflectionBasedReferenceTypeDelegateTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005-2017 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Andrew Clement          Initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.reflect.Field;\n\nimport org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest;\n\npublic class Java5ReflectionBasedReferenceTypeDelegateTest extends ReflectionBasedReferenceTypeDelegateTest {\n\n\t/**\n\t * Let's play about with a generic type and ensure we can work with it in a reflective world.\n\t */\n\tpublic void testResolveGeneric() {\n\t\tUnresolvedType collectionType = UnresolvedType.forName(\"java.util.Collection\");\n\t\tworld.resolve(collectionType).getRawType().resolve(world);\n\t\tResolvedMember[] methods = world.resolve(collectionType).getDeclaredMethods();\n\t\tint i = -1;\n\t\tfor (int j=0;j<methods.length;j++) {\n\t\t\tResolvedMember method = methods[j];\n\t\t\tif (method.getName().equals(\"toArray\") && method.getParameterSignature().equals(\"([TT;)\")) {\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t\tassertTrue(\"Couldn't find 'toArray' in the set of methods? \", i != -1);\n\t\t// String expectedSignature = \"java.lang.Object[] java.util.Collection.toArray(java.lang.Object[])\";\n\t\tString expectedSignature = \"([Ljava/lang/Object;)[Ljava/lang/Object;\";\n\n\t\tassertTrue(\"Expected signature of '\" + expectedSignature + \"' but it was '\" + methods[i].getSignatureErased(), methods[i]\n\t\t\t\t.getSignatureErased().equals(expectedSignature));\n\t}\n\n\t/**\n\t * Can we resolve the dreaded Enum type...\n\t */\n\tpublic void testResolveEnum() {\n\t\tResolvedType enumType = world.resolve(\"java.lang.Enum\");\n\t\tassertTrue(\"Should be the raw type but is \" + enumType.typeKind, enumType.isRawType());\n\t\tResolvedType theGenericEnumType = enumType.getGenericType();\n\t\tassertTrue(\"Should have a type variable \", theGenericEnumType.getTypeVariables().length > 0);\n\t\tTypeVariable tv = theGenericEnumType.getTypeVariables()[0];\n\t\tString expected = \"TypeVar E extends java.lang.Enum<E>\";\n\t\tassertTrue(\"Type variable should be '\" + expected + \"' but is '\" + tv + \"'\", tv.toString().equals(expected));\n\t}\n\n\tpublic void testResolveClass() {\n\t\tworld.resolve(\"java.lang.Class\").getGenericType();\n\t}\n\n\tpublic void testGenericInterfaceSuperclass_ReflectionWorldResolution() {\n\n\t\tUnresolvedType javaUtilMap = UnresolvedType.forName(\"java.util.Map\");\n\n\t\tReferenceType rawType = (ReferenceType) world.resolve(javaUtilMap);\n\t\tassertTrue(\"Should be the raw type ?!? \" + rawType.getTypekind(), rawType.isRawType());\n\n\t\tReferenceType genericType = rawType.getGenericType();\n\t\tassertTrue(\"Should be the generic type ?!? \" + genericType.getTypekind(), genericType.isGenericType());\n\n\t\tResolvedType rt = rawType.getSuperclass();\n\t\tassertTrue(\"Superclass for Map raw type should be Object but was \" + rt, rt.equals(UnresolvedType.OBJECT));\n\n\t\tResolvedType rt2 = genericType.getSuperclass();\n\t\tassertTrue(\"Superclass for Map generic type should be Object but was \" + rt2, rt2.equals(UnresolvedType.OBJECT));\n\t}\n\n\t/**\n\t * This is testing the optimization in the reflective annotation finder to verify that if you only want runtime\n\t * annotation info then we use reflection and don't go digging through the classfile bytes.\n\t */\n\tpublic void testAnnotationFinderClassRetention() throws Exception {\n\t\tResolvedType type = world.resolve(AnnoTesting.class.getName());\n\t\tResolvedMember[] ms = type.getDeclaredMethods();\n\n\t\tResolvedMember methodWithOnlyClassLevelAnnotation = ms[findMethod(\"a\", ms)];\n\t\tResolvedMember methodWithOnlyRuntimeLevelAnnotation = ms[findMethod(\"b\", ms)];\n\t\tResolvedMember methodWithClassAndRuntimeLevelAnnotations = ms[findMethod(\"c\", ms)];\n\t\tResolvedMember methodWithClassAndRuntimeLevelAnnotations2 = ms[findMethod(\"d\", ms)];\n\n\t\tassertTrue(methodWithOnlyClassLevelAnnotation.hasAnnotation(world.resolve(AnnoClass.class.getName())));\n\t\tassertTrue(methodWithOnlyRuntimeLevelAnnotation.hasAnnotation(world.resolve(AnnoRuntime.class.getName())));\n\n\t\t// This is the tricky scenario.\n\n\t\t// When asking about the runtime level annotations it should not go digging into bcel\n\t\tassertTrue(methodWithClassAndRuntimeLevelAnnotations.hasAnnotation(world.resolve(AnnoRuntime.class.getName())));\n\n\t\tField annotationsField = ResolvedMemberImpl.class.getDeclaredField(\"annotationTypes\");\n\t\tannotationsField.setAccessible(true);\n\t\tResolvedType[] annoTypes = (ResolvedType[])annotationsField.get(methodWithClassAndRuntimeLevelAnnotations);\n\n\t\t// Should only be the runtime one here\n\t\tassertEquals(1, annoTypes.length);\n\n\t\t// But when you do ask again and this time for class level, it should redo the unpack and pull both runtime and class out\n\t\tassertTrue(methodWithClassAndRuntimeLevelAnnotations.hasAnnotation(world.resolve(AnnoClass.class.getName())));\n\n\t\tannotationsField.setAccessible(true);\n\t\tannoTypes = (ResolvedType[])annotationsField.get(methodWithClassAndRuntimeLevelAnnotations);\n\n\t\t// Now both should be there\n\t\tassertEquals(2, annoTypes.length);\n\n\t\tassertTrue(methodWithClassAndRuntimeLevelAnnotations2.hasAnnotation(world.resolve(AnnoRuntime.class.getName())));\n\t\t// now ask for 'all annotations' via another route, this should reunpack and get them all\n\t\tResolvedType[] annotations = methodWithClassAndRuntimeLevelAnnotations2.getAnnotationTypes();\n\t\tassertEquals(2,annotations.length);\n\t}\n\n\t@Retention(RetentionPolicy.CLASS)\n\t@interface AnnoClass {}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@interface AnnoRuntime {}\n\n\tclass AnnoTesting {\n\n\t\t@AnnoClass\n\t\tpublic void a() {}\n\n\t\t@AnnoRuntime\n\t\tpublic void b() {}\n\n\t\t@AnnoClass @AnnoRuntime\n\t\tpublic void c() {}\n\n\t\t@AnnoClass @AnnoRuntime\n\t\tpublic void d() {}\n\n\t}\n\n}\n",
    "size": 6004
  },
  {
    "file_id": "F105",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/Jdk14TraceFactoryTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2006 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster - initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.tools.Jdk14TraceFactory;\nimport org.aspectj.weaver.tools.Trace;\n\nimport junit.framework.TestCase;\n\npublic class Jdk14TraceFactoryTest extends TestCase {\n\n\tpublic void testJdk14TraceFactory() {\n\t\tnew Jdk14TraceFactory();\n\t}\n\n\tpublic void testGetTrace() {\n\t\tJdk14TraceFactory factory = new Jdk14TraceFactory();\n\t\tTrace trace = factory.getTrace(getClass());\n\t\tassertFalse(\"Tracing should be disbled by default\",trace.isTraceEnabled());\n\t}\n\n}\n",
    "size": 1038
  },
  {
    "file_id": "F106",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/Jdk14TraceTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2006 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster - initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.tools.DefaultTrace;\nimport org.aspectj.weaver.tools.Jdk14Trace;\n\npublic class Jdk14TraceTest extends AbstractTraceTest {\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\ttrace = new Jdk14Trace(getClass());\n\t\ttrace.setTraceEnabled(true);\n\t}\n\n\tpublic void testJdk14Trace() {\n\t\tnew Jdk14Trace(getClass());\n\t}\n\n\tpublic void testSetTraceEnabled() {\n\t\tDefaultTrace trace = new DefaultTrace(getClass());\n\t\ttrace.setTraceEnabled(true);\n\t\tassertTrue(trace.isTraceEnabled());\n\t}\n\n}\n",
    "size": 1085
  },
  {
    "file_id": "F107",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/JoinPointSignatureIteratorTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2009 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.aspectj.weaver.reflect.ReflectionWorld;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Andy Clement\n */\npublic class JoinPointSignatureIteratorTest extends TestCase {\n\n\tprivate World getWorld() {\n\t\treturn new ReflectionWorld(getClass().getClassLoader());\n\t}\n\n\t/**\n\t * Checking the signatures for a dynamic proxy - which is created using erased information and so is completely generics unaware\n\t */\n\tpublic void testPr268419() {\n\t\tWorld w = getWorld();\n\t\tw.setBehaveInJava5Way(true);\n\n\t\t// The proxy class here is not generated, it is simply loaded up. $Proxy1 is in the java5-testsrc folder, but it\n\t\t// obeys the rules of a generated proxy in that it extends java.lang.reflect.Proxy\n\t\tResolvedType proxy = UnresolvedType.forName(\"$Proxy1\").resolve(w);\n\t\tassertNotNull(proxy);\n\n\t\t// The test hierarchy here (messageservice and genericservice) contains 2 methods. One is generic\n\t\t// and one is not. The aim of the test here is that the join point signatures generated for both\n\t\t// should be the same because of the use of a proxy.\n\n\t\tList l = proxy.getMethodsWithoutIterator(false, false, false);\n\t\tfor (Object object : l) {\n\t\t\tResolvedMember rm = (ResolvedMember) object;\n\t\t\tif (expectedResults.containsKey(rm.toString())) {\n\t\t\t\tSystem.out.println(\"\\nChecking: \" + rm);\n\t\t\t\tint i = 0;\n\t\t\t\tList<String> sigs = expectedResults.get(rm.toString());\n\t\t\t\tIterator jpsi = rm.getJoinPointSignatures(w);\n\t\t\t\twhile (jpsi.hasNext()) {\n\t\t\t\t\tResolvedMember sig = (ResolvedMember) jpsi.next();\n\t\t\t\t\tassertEquals(sigs.get(i).toString(), sig.toString());\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tif (i != sigs.size()) {\n\t\t\t\t\tfail(\"Expected \" + sigs.size() + \" signatures but got \" + i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rm.getName().equals(\"get1\") || rm.getName().equals(\"get2\")) {\n\t\t\t\t\tfail(\"\\nFound this unchecked get method \" + rm);\n\t\t\t\t\t// Iterator jpsi = rm.getJoinPointSignatures(w);\n\t\t\t\t\t// while (jpsi.hasNext()) {\n\t\t\t\t\t// ResolvedMember sig = (ResolvedMember) jpsi.next();\n\t\t\t\t\t// System.out.println(sig);\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static Map<String, List<String>> expectedResults = new HashMap<>();\n\n\tstatic {\n\t\tList<String> sigs = new ArrayList<>();\n\t\tsigs.add(\"java.lang.Object $Proxy1.get1(java.io.Serializable)\");\n\t\tsigs.add(\"java.lang.Object MessageService.get1(java.io.Serializable)\");\n\t\tsigs.add(\"java.lang.Object GenericService.get1(java.io.Serializable)\");\n\t\tsigs.add(\"java.lang.Object GenericService.get1(java.io.Serializable)\");\n\t\texpectedResults.put(\"java.lang.Object $Proxy1.get1(java.io.Serializable)\", sigs);\n\n\t\tsigs = new ArrayList<>();\n\t\tsigs.add(\"java.lang.Object $Proxy1.get2(java.io.Serializable)\");\n\t\tsigs.add(\"java.lang.Object MessageService.get2(java.io.Serializable)\");\n\t\tsigs.add(\"java.lang.Object GenericService.get2(java.io.Serializable)\");\n\t\tsigs.add(\"java.lang.Object GenericService.get2(java.io.Serializable)\");\n\t\texpectedResults.put(\"java.lang.Object $Proxy1.get2(java.io.Serializable)\", sigs);\n\n\t\tsigs = new ArrayList<>();\n\t\tsigs.add(\"java.lang.Object $Proxy1.get1(java.lang.Long)\");\n\t\texpectedResults.put(\"java.lang.Object $Proxy1.get1(java.lang.Long)\", sigs);\n\n\t\tsigs = new ArrayList<>();\n\t\tsigs.add(\"java.lang.Object GenericService.get1(java.io.Serializable)\");\n\t\texpectedResults.put(\"java.lang.Object GenericService.get1(java.io.Serializable)\", sigs);\n\n\t\tsigs = new ArrayList<>();\n\t\tsigs.add(\"java.lang.Object GenericService.get2(java.io.Serializable)\");\n\t\texpectedResults.put(\"java.lang.Object GenericService.get2(java.io.Serializable)\", sigs);\n\t}\n}\n",
    "size": 4118
  },
  {
    "file_id": "F108",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/LocaleTest.java",
    "text": "/* Copyright (c) 2002 Contributors.\n *\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n */\npackage org.aspectj.weaver;\n\nimport java.io.IOException;\nimport java.util.Locale;\n\nimport org.aspectj.apache.bcel.generic.Instruction;\nimport org.aspectj.apache.bcel.util.ByteSequence;\n\nimport junit.framework.TestCase;\n\npublic class LocaleTest extends TestCase {\n\n\tpublic LocaleTest(String name) {\n\t\tsuper(name);\n\t}\n\n\tpublic void testNormalLocale() {\n\t\tdoBipush();\n\t}\n\n\tpublic void testTurkishLocale() {\n\t\tLocale def = Locale.getDefault();\n\t\tLocale.setDefault(new Locale(\"tr\", \"\"));\n\t\ttry {\n\t\t\tdoBipush();\n\t\t} finally {\n\t\t\tLocale.setDefault(def);\n\t\t}\n\t}\n\n\tprivate static void doBipush() {\n\t\ttry {\n\t\t\tInstruction.readInstruction(\n\t\t\t\t\t\tnew ByteSequence(new byte[] {\n\t\t\t\t\t\t\t(byte)16, // bipush\n\t\t\t\t\t\t\t(byte) 3  // data for bipush\n\t\t\t\t\t\t\t}));\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e.getMessage());\n\t\t}\n\t}\n}\n\n",
    "size": 1168
  },
  {
    "file_id": "F109",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/Member15Test.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\n/**\n * @author colyer\n * @author clement\n */\npublic class Member15Test extends TestCase {\n\n\t  public void testCanBeParameterizedRegularMethod() {\n\t    \tBcelWorld world = new BcelWorld();\n\t    \tResolvedType javaLangClass = world.resolve(UnresolvedType.forName(\"java/lang/Class\"));\n\t    \tResolvedMember[] methods = javaLangClass.getDeclaredMethods();\n\t    \tResolvedMember getAnnotations = null;\n\t\t  for (ResolvedMember method : methods) {\n\t\t\t  if (method.getName().equals(\"getAnnotations\")) {\n\t\t\t\t  getAnnotations = method;\n\t\t\t\t  break;\n\t\t\t  }\n\t\t  }\n\t    \tif (getAnnotations != null) { // so can run on non-Java 5\n//\t    \t\tSystem.out.println(\"got it\");\n\t    \t\tassertFalse(getAnnotations.canBeParameterized());\n\t    \t}\n\t    }\n\n\t    public void testCanBeParameterizedGenericMethod() {\n\t    \tBcelWorld world = new BcelWorld();\n\t    \tworld.setBehaveInJava5Way(true);\n\t    \tResolvedType javaLangClass = world.resolve(UnresolvedType.forName(\"java.lang.Class\"));\n\t    \tjavaLangClass = javaLangClass.getGenericType();\n\t    \tif (javaLangClass == null) return;  // for < 1.5\n\t    \tResolvedMember[] methods = javaLangClass.getDeclaredMethods();\n\t    \tResolvedMember asSubclass = null;\n\t\t\tfor (ResolvedMember method : methods) {\n\t\t\t\tif (method.getName().equals(\"asSubclass\")) {\n\t\t\t\t\tasSubclass = method;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t    \tif (asSubclass != null) { // so can run on non-Java 5\n//\t    \t\tSystem.out.println(\"got it\");\n\t    \t\tassertTrue(asSubclass.canBeParameterized());\n\t    \t}\n\t    }\n\n\t    public void testCanBeParameterizedMethodInGenericType() {\n\t       \tBcelWorld world = new BcelWorld();\n\t       \tworld.setBehaveInJava5Way(true);\n\t    \tResolvedType javaUtilList = world.resolve(UnresolvedType.forName(\"java.util.List\"));\n\t    \tjavaUtilList = javaUtilList.getGenericType();\n\t    \tif (javaUtilList == null) return;  // for < 1.5\n\t    \tResolvedMember[] methods = javaUtilList.getDeclaredMethods();\n\t    \tResolvedMember add = null;\n\t\t\tfor (ResolvedMember method : methods) {\n\t\t\t\tif (method.getName().equals(\"add\")) {\n\t\t\t\t\tadd = method;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t    \tif (add != null) { // so can run on non-Java 5\n//\t    \t\tSystem.out.println(\"got it\");\n\t    \t\tassertTrue(add.canBeParameterized());\n\t    \t}\n\t    }\n\t    /*\n\t    public void testGenericReferenceTypeCreation() {\n\t    \tUnresolvedType genericType = UnresolvedType.forGenericTypeSignature(\"Lorg/aspectj/weaver/MemberTestCase15$One;\",\"<T:Ljava/lang/Object;>Ljava/lang/Object;\");\n\t    \tassertEquals(\"Porg/aspectj/weaver/MemberTestCase15$One<TT;>;\",genericType.getSignature());\n\t    \tassertEquals(\"Lorg/aspectj/weaver/MemberTestCase15$One;\",genericType.getErasureSignature());\n\t    }\n\n\t    public void testMemberSignatureCreation() {\n\t\t\tWorld world = new BcelWorld(\"../weaver5/bin/\");\n\t    \t//new ReflectionWorld(false, getClass().getClassLoader());\n\t       \tworld.setBehaveInJava5Way(true);\n\t       \tResolvedType one = world.resolve(\"org.aspectj.weaver.MemberTestCase15$One<java.lang.String>\");\n\t       \tassertNotNull(one);\n\t       \tassertFalse(one.isMissing());\n\n\t       \t// Look at the methods on the parameterized type One<String>\n\t       \tResolvedMember member = findMethod(\"getter\",one);\n\t       \tString erasedSignature = MemberImpl.typesToSignature(member.getReturnType(),member.getParameterTypes(),true);\n\t       \tassertEquals(\"()Ljava/lang/String;\",erasedSignature);\n\t       \tString nonErasedSignature = MemberImpl.typesToSignature(member.getReturnType(),member.getParameterTypes(),false);\n\t       \tassertEquals(\"()Ljava/lang/String;\",nonErasedSignature);\n\t       \terasedSignature = MemberImpl.typesToSignature(member.getReturnType(),member.getParameterTypes(),true);\n\t       \tassertEquals(\"()Ljava/lang/String;\",erasedSignature);\n\t       \tnonErasedSignature = MemberImpl.typesToSignature(member.getReturnType(),member.getParameterTypes(),false);\n\t       \tassertEquals(\"()Ljava/lang/String;\",nonErasedSignature);\n\n\t       \tmember = findMethod(\"getterTwo\",one);\n\t       \terasedSignature = MemberImpl.typesToSignature(member.getReturnType(),member.getParameterTypes(),true);\n\t       \tassertEquals(\"()Ljava/util/List;\",erasedSignature);\n\t       \tnonErasedSignature = MemberImpl.typesToSignature(member.getReturnType(),member.getParameterTypes(),false);\n\t       \tassertEquals(\"()Pjava/util/List<Ljava/lang/String;>;\",nonErasedSignature);\n\t       \tnonErasedSignature = MemberImpl.typesToSignature(member.getGenericReturnType(),member.getGenericParameterTypes(),true);\n\t       \tassertEquals(\"()Ljava/util/List;\",nonErasedSignature);\n\t       \tnonErasedSignature = MemberImpl.typesToSignature(member.getGenericReturnType(),member.getGenericParameterTypes(),false);\n\t       \tassertEquals(\"()Pjava/util/List<Ljava/lang/String;>;\",nonErasedSignature);\n\n\t       \t// Grab the generic type backing the parameterized type\n\t       \tResolvedType oneGeneric = one.getGenericType();\n\t       \tassertTrue(oneGeneric.isGenericType());\n\t       \tmember = findMethod(\"getterTwo\",oneGeneric);\n\t       \terasedSignature = MemberImpl.typesToSignature(member.getReturnType(),member.getParameterTypes(),true);\n\t       \tassertEquals(\"()Ljava/util/List;\",erasedSignature);\n\t       \terasedSignature = MemberImpl.typesToSignature(member.getReturnType(),member.getParameterTypes(),false);\n\t       \tassertEquals(\"()Ljava/util/List;\",erasedSignature);\n\t       \tnonErasedSignature = MemberImpl.typesToSignature(member.getReturnType(),member.getParameterTypes(),false);\n\t       \tassertEquals(\"()Pjava/util/List<TT;>;\",nonErasedSignature);\n\t       \tnonErasedSignature = MemberImpl.typesToSignature(member.getGenericReturnType(),member.getGenericParameterTypes(),false);\n\t       \tassertEquals(\"()Ljava/util/List;\",nonErasedSignature);\n\n\n\t       \tResolvedType oneRaw = oneGeneric.getRawType();\n\t       \tmember = findMethod(\"getterTwo\",oneRaw);\n\t    }\n\n\t    private ResolvedMember findMethod(String name, ResolvedType type) {\n\t       \tResolvedMember[] members = type.getDeclaredMethods();\n\t       \tfor (ResolvedMember member: members) {\n\t       \t\tif (member.getName().equals(name)) {\n\t       \t\t\treturn member;\n\t       \t\t}\n\t       \t}\n\t       \treturn null;\n\t    }\n\n\t    // testcode\n\t    class One<T> {\n\t    \tT t;\n\t    \tT getter() {\n\t    \t\treturn null;\n\t    \t}\n\t    \tList<T> getterTwo() {\n\t    \t\treturn null;\n\t    \t}\n\t    }\n\t    */\n}\n",
    "size": 6859
  },
  {
    "file_id": "F110",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/Member15TestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\n/**\n * @author colyer\n *\n */\npublic class Member15TestCase extends TestCase {\n\n\t  public void testCanBeParameterizedRegularMethod() {\n\t    \tBcelWorld world = new BcelWorld();\n\t    \tResolvedType javaLangClass = world.resolve(UnresolvedType.forName(\"java/lang/Class\"));\n\t    \tResolvedMember[] methods = javaLangClass.getDeclaredMethods();\n\t    \tResolvedMember getAnnotations = null;\n\t\t  for (ResolvedMember method : methods) {\n\t\t\t  if (method.getName().equals(\"getAnnotations\")) {\n\t\t\t\t  getAnnotations = method;\n\t\t\t\t  break;\n\t\t\t  }\n\t\t  }\n\t    \tif (getAnnotations != null) { // so can run on non-Java 5\n//\t    \t\tSystem.out.println(\"got it\");\n\t    \t\tassertFalse(getAnnotations.canBeParameterized());\n\t    \t}\n\t    }\n\n\t    public void testCanBeParameterizedGenericMethod() {\n\t    \tBcelWorld world = new BcelWorld();\n\t    \tworld.setBehaveInJava5Way(true);\n\t    \tResolvedType javaLangClass = world.resolve(UnresolvedType.forName(\"java.lang.Class\"));\n\t    \tjavaLangClass = javaLangClass.getGenericType();\n\t    \tif (javaLangClass == null) return;  // for < 1.5\n\t    \tResolvedMember[] methods = javaLangClass.getDeclaredMethods();\n\t    \tResolvedMember asSubclass = null;\n\t\t\tfor (ResolvedMember method : methods) {\n\t\t\t\tif (method.getName().equals(\"asSubclass\")) {\n\t\t\t\t\tasSubclass = method;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t    \tif (asSubclass != null) { // so can run on non-Java 5\n//\t    \t\tSystem.out.println(\"got it\");\n\t    \t\tassertTrue(asSubclass.canBeParameterized());\n\t    \t}\n\t    }\n\n\t    public void testCanBeParameterizedMethodInGenericType() {\n\t       \tBcelWorld world = new BcelWorld();\n\t       \tworld.setBehaveInJava5Way(true);\n\t    \tResolvedType javaUtilList = world.resolve(UnresolvedType.forName(\"java.util.List\"));\n\t    \tjavaUtilList = javaUtilList.getGenericType();\n\t    \tif (javaUtilList == null) return;  // for < 1.5\n\t    \tResolvedMember[] methods = javaUtilList.getDeclaredMethods();\n\t    \tResolvedMember add = null;\n\t\t\tfor (ResolvedMember method : methods) {\n\t\t\t\tif (method.getName().equals(\"add\")) {\n\t\t\t\t\tadd = method;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t    \tif (add != null) { // so can run on non-Java 5\n//\t    \t\tSystem.out.println(\"got it\");\n\t    \t\tassertTrue(add.canBeParameterized());\n\t    \t}\n\t    }\n\n}\n",
    "size": 2810
  },
  {
    "file_id": "F111",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/MemberTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n *                      2005 contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n *     Adrian Colyer, canBeParameterized tests\n * ******************************************************************/\n\npackage org.aspectj.weaver;\n\nimport java.lang.reflect.Modifier;\n\nimport org.aspectj.testing.util.TestUtil;\n\nimport junit.framework.TestCase;\n\n/**\n * This is a test case for all the portions of Member that don't require a world.\n */\npublic class MemberTestCase extends TestCase {\n\n\tpublic MemberTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\tpublic void testMethodConstruction() {\n\t\tMember s = TestUtils.methodFromString(\"void Foo.goo(int)\");\n\t\tMember t = MemberImpl.method(UnresolvedType.forName(\"Foo\"), 0, \"goo\", \"(I)V\");\n\t\tMember u = TestUtils.methodFromString(\"void Foo1.goo(int)\");\n\t\tMember v = TestUtils.methodFromString(\"int Foo.goo(int)\");\n\n\t\tTestUtil.assertCommutativeEquals(s, s, true);\n\t\tTestUtil.assertCommutativeEquals(t, t, true);\n\t\tTestUtil.assertCommutativeEquals(u, u, true);\n\t\tTestUtil.assertCommutativeEquals(v, v, true);\n\t\tTestUtil.assertCommutativeEquals(s, t, true);\n\t\tTestUtil.assertCommutativeEquals(s, u, false);\n\t\tTestUtil.assertCommutativeEquals(s, v, false);\n\t\tTestUtil.assertCommutativeEquals(t, u, false);\n\t\tTestUtil.assertCommutativeEquals(t, v, false);\n\t\tTestUtil.assertCommutativeEquals(u, v, false);\n\n\t\ts = TestUtils.fieldFromString(\"int Foo.goo\");\n\t\tt = MemberImpl.field(\"Foo\", 0, \"goo\", \"I\");\n\t\tu = TestUtils.fieldFromString(\"int Foo.goo1\");\n\t\tv = TestUtils.fieldFromString(\"long Foo.goo\");\n\n\t\tTestUtil.assertCommutativeEquals(s, s, true);\n\t\tTestUtil.assertCommutativeEquals(t, t, true);\n\t\tTestUtil.assertCommutativeEquals(u, u, true);\n\t\tTestUtil.assertCommutativeEquals(v, v, true);\n\t\tTestUtil.assertCommutativeEquals(s, t, true);\n\t\tTestUtil.assertCommutativeEquals(s, u, false);\n\t\tTestUtil.assertCommutativeEquals(s, v, false);\n\t\tTestUtil.assertCommutativeEquals(t, u, false);\n\t\tTestUtil.assertCommutativeEquals(t, v, false);\n\t\tTestUtil.assertCommutativeEquals(u, v, false);\n\t}\n\n\tpublic void testMethodContents() {\n\t\tMember m = TestUtils.methodFromString(\"void Foo.goo(int)\");\n\t\tkindTest(m, Member.METHOD);\n\t\tdeclaringTypeTest(m, \"Foo\");\n\t\tnameTest(m, \"goo\");\n\t\tparameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT });\n\t\treturnTypeTest(m, UnresolvedType.VOID);\n\t\tisInterfaceTest(m, false);\n\t\tisPrivateTest(m, false);\n\t\tisConstructorTest(m, false);\n\t\tisStaticTest(m, false);\n\n\t\tm = TestUtils.methodFromString(\"interface java.lang.Object java.util.Iterator.next()\");\n\t\tkindTest(m, Member.METHOD);\n\t\tdeclaringTypeTest(m, \"java.util.Iterator\");\n\t\tnameTest(m, \"next\");\n\t\tparameterTypesTest(m, UnresolvedType.NONE);\n\t\treturnTypeTest(m, UnresolvedType.OBJECT);\n\t\tisInterfaceTest(m, true);\n\t\tisPrivateTest(m, false);\n\t\tisConstructorTest(m, false);\n\t\tisStaticTest(m, false);\n\n\t\tm = TestUtils.methodFromString(\"void Foo.<init>(int, java.lang.Object)\");\n\t\tkindTest(m, Member.CONSTRUCTOR);\n\t\tdeclaringTypeTest(m, \"Foo\");\n\t\tnameTest(m, \"<init>\");\n\t\tparameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT, UnresolvedType.OBJECT });\n\t\treturnTypeTest(m, UnresolvedType.VOID);\n\t\tisInterfaceTest(m, false);\n\t\tisPrivateTest(m, false);\n\t\tisConstructorTest(m, true);\n\t\tisStaticTest(m, false);\n\n\t\tm = TestUtils.methodFromString(\"private double Foo.sqrt(double)\");\n\t\tkindTest(m, Member.METHOD);\n\t\tdeclaringTypeTest(m, \"Foo\");\n\t\tnameTest(m, \"sqrt\");\n\t\tparameterTypesTest(m, new UnresolvedType[] { UnresolvedType.DOUBLE });\n\t\treturnTypeTest(m, UnresolvedType.DOUBLE);\n\t\tisInterfaceTest(m, false);\n\t\tisPrivateTest(m, true);\n\t\tisConstructorTest(m, false);\n\t\tisStaticTest(m, false);\n\n\t\tm = TestUtils.methodFromString(\"static int java.lang.Math.max(int, int)\");\n\t\tkindTest(m, Member.METHOD);\n\t\tdeclaringTypeTest(m, \"java.lang.Math\");\n\t\tnameTest(m, \"max\");\n\t\tparameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT, UnresolvedType.INT });\n\t\treturnTypeTest(m, UnresolvedType.INT);\n\t\tisInterfaceTest(m, false);\n\t\tisPrivateTest(m, false);\n\t\tisConstructorTest(m, false);\n\t\tisStaticTest(m, true);\n\t}\n\n\tpublic void testFieldContents() {\n\t\tMember m = TestUtils.fieldFromString(\"int Foo.goo\");\n\t\tkindTest(m, Member.FIELD);\n\t\tdeclaringTypeTest(m, \"Foo\");\n\t\tnameTest(m, \"goo\");\n\t\tparameterTypesTest(m, UnresolvedType.NONE);\n\t\treturnTypeTest(m, UnresolvedType.INT);\n\t\tisInterfaceTest(m, false);\n\t\tisPrivateTest(m, false);\n\t\tisConstructorTest(m, false);\n\t\tisStaticTest(m, false);\n\n\t\tm = TestUtils.fieldFromString(\"static java.util.Iterator goo.Bar.i\");\n\t\tkindTest(m, Member.FIELD);\n\t\tdeclaringTypeTest(m, \"goo.Bar\");\n\t\tnameTest(m, \"i\");\n\t\tparameterTypesTest(m, UnresolvedType.NONE);\n\t\treturnTypeTest(m, UnresolvedType.forName(\"java.util.Iterator\"));\n\t\tisInterfaceTest(m, false);\n\t\tisPrivateTest(m, false);\n\t\tisConstructorTest(m, false);\n\t\tisStaticTest(m, true);\n\t}\n\n\tprivate void isStaticTest(Member m, boolean b) {\n\t\tassertEquals(m + \" is static\", b, Modifier.isStatic(m.getModifiers()));\n\t}\n\n\tprivate void isConstructorTest(Member m, boolean b) {\n\t\tassertEquals(m + \" is constructor\", b, m.getKind() == Member.CONSTRUCTOR);\n\t}\n\n\tprivate void isPrivateTest(Member m, boolean b) {\n\t\tassertEquals(m + \" is private\", b, Modifier.isPrivate(m.getModifiers()));\n\t}\n\n\tprivate void isInterfaceTest(Member m, boolean b) {\n\t\tassertEquals(m + \" is interface\", b, Modifier.isInterface(m.getModifiers()));\n\t}\n\n\tprivate void returnTypeTest(Member m, UnresolvedType returnType) {\n\t\tassertEquals(m + \" return type\", returnType, m.getReturnType());\n\t}\n\n\tprivate void parameterTypesTest(Member m, UnresolvedType[] paramTypes) {\n\t\tTestUtil.assertArrayEquals(m + \" parameters\", paramTypes, m.getParameterTypes());\n\t}\n\n\tprivate void nameTest(Member m, String name) {\n\t\tassertEquals(m + \" name\", name, m.getName());\n\t}\n\n\tprivate void declaringTypeTest(Member m, String declaringName) {\n\t\tassertEquals(m + \" declared in\", UnresolvedType.forName(declaringName), m.getDeclaringType());\n\t}\n\n\tprivate void kindTest(Member m, MemberKind kind) {\n\t\tassertEquals(m + \" kind\", kind, m.getKind());\n\t}\n\n}\n",
    "size": 6418
  },
  {
    "file_id": "F112",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/ParameterizedReferenceTypeTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\n/**\n * @author colyer\n * For a parameterized reference type, the methods that return members\n *  - getDeclaredFields\n *  - getDeclaredMethods\n *  - getDeclaredInterfaces\n *  - getDeclaredPointcuts\n *  should have any type variables substituted by the given type parameter before\n *  being returned.\n */\npublic class ParameterizedReferenceTypeTestCase extends TestCase {\n\n\tBcelWorld world;\n\tReferenceType listOfString;\n\n\tpublic void testDeclaredMethodWithParameter() {\n\t\tResolvedMember[] methods = listOfString.getDeclaredMethods();\n\t\tResolvedMember add = null;\n\t\tfor (ResolvedMember resolvedMember : methods) {\n\t\t\tif (resolvedMember.getName().equals(\"add\")) {\n\t\t\t\tif (resolvedMember.getParameterTypes().length == 1) {\n\t\t\t\t\tadd = resolvedMember;\n\t\t\t\t\tSystem.out.println(add);\n//\t\t\t\t\tj8: boolean java.util.List<java.lang.String>.add(java.lang.Object)\n//\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tUnresolvedType parameterType = add.getParameterTypes()[0];\n\t\tassertEquals(\"Ljava/lang/String;\",parameterType.getSignature());\n\n\t\tResolvedMember get = null;\n\t\tfor (ResolvedMember method : methods) {\n\t\t\tif (method.getName().equals(\"get\")) {\n\t\t\t\tif (method.getParameterTypes().length == 1) {\n\t\t\t\t\tget = method;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tUnresolvedType returnType = get.getReturnType();\n\t\tassertEquals(\"Ljava/lang/String;\",returnType.getSignature());\n\n\t}\n\n\tpublic void testDeclaredMethodWithParameterizedReturnType() {\n\t\tResolvedMember[] methods = listOfString.getDeclaredMethods();\n\t\tResolvedMember iterator = null;\n\t\tfor (ResolvedMember method : methods) {\n\t\t\tif (method.getName().equals(\"iterator\")) {\n\t\t\t\titerator = method;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tUnresolvedType returnType = iterator.getReturnType();\n\t\tassertEquals(\"Pjava/util/Iterator<Ljava/lang/String;>;\",returnType.getSignature());\n\n\t}\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tworld = new BcelWorld();\n\t\tworld.setBehaveInJava5Way(true);\n\t\tlistOfString = (ReferenceType)\n\t\t\tTypeFactory.createTypeFromSignature(\"Pjava/util/List<Ljava/lang/String;>;\").resolve(world);\n\t}\n}\n",
    "size": 2642
  },
  {
    "file_id": "F113",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/ReferenceTypeTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\nimport org.aspectj.util.PartialOrder;\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\n// test cases for Adrian's additions to ReferenceType\n// XXX - couldn't find any unit test cases for the rest of the ReferenceType class\n@SuppressWarnings({ \"unused\", \"rawtypes\", \"unchecked\" })\npublic class ReferenceTypeTestCase extends TestCase {\n\n\tpublic void testIsRawTrue() {\n\t\tBcelWorld world = new BcelWorld();\n\t\tworld.setBehaveInJava5Way(true);\n\t\tUnresolvedType javaLangClass = UnresolvedType.forName(\"java.lang.Class\");\n\t\tResolvedType rtx = world.resolve(javaLangClass);\n\t\tassertTrue(\"Resolves to reference type\", (rtx instanceof ReferenceType));\n\t\tReferenceType rt = (ReferenceType) rtx;\n\t\tassertTrue(\"java.lang.Class is raw\", rt.isRawType());\n\t}\n\n\tpublic void testIsRawFalse() {\n\t\tBcelWorld world = new BcelWorld();\n\t\tworld.setBehaveInJava5Way(true);\n\t\tUnresolvedType javaLangObject = UnresolvedType.forName(\"java.lang.Object\");\n\t\tResolvedType rtx = world.resolve(javaLangObject);\n\t\tassertTrue(\"Resolves to reference type\", (rtx instanceof ReferenceType));\n\t\tReferenceType rt = (ReferenceType) rtx;\n\t\tassertFalse(\"java.lang.Object is  not raw\", rt.isRawType());\n\t}\n\n\tpublic void testIsGenericTrue() {\n\t\tBcelWorld world = new BcelWorld();\n\t\tworld.setBehaveInJava5Way(true);\n\t\tUnresolvedType javaLangClass = UnresolvedType.forName(\"java.lang.Class\");\n\t\tResolvedType rtx = world.resolve(javaLangClass);\n\t\tassertTrue(\"java.lang.Class has underpinning generic type\", rtx.getGenericType().isGenericType());\n\t}\n\n\tpublic void testIsGenericFalse() {\n\t\tBcelWorld world = new BcelWorld();\n\t\tworld.setBehaveInJava5Way(true);\n\t\tUnresolvedType javaLangObject = UnresolvedType.forName(\"java.lang.Object\");\n\t\tResolvedType rtx = world.resolve(javaLangObject);\n\t\tassertFalse(rtx.isGenericType());\n\t}\n\n\tBcelWorld world;\n\n\t@Override\n\tpublic void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tworld = new BcelWorld();\n\t\tworld.setBehaveInJava5Way(true);\n\t}\n\n\tpublic void testCoercion01() {\n\t\tReferenceType listOfString = (ReferenceType) world.resolve(UnresolvedType\n\t\t\t\t.forSignature(\"Pjava/util/List<Ljava/lang/String;>;\"));\n\t\tReferenceType listOfInteger = (ReferenceType) world.resolve(UnresolvedType\n\t\t\t\t.forSignature(\"Pjava/util/List<Ljava/lang/Integer;>;\"));\n\t\tassertFalse(listOfInteger.isAssignableFrom(listOfString));\n\t\tassertFalse(listOfString.isAssignableFrom(listOfInteger));\n\t\tassertFalse(listOfInteger.isCoerceableFrom(listOfString));\n\t\tassertFalse(listOfString.isCoerceableFrom(listOfInteger));\n\t}\n\n\tpublic void testAssignable01() {\n\t\tList list = new ArrayList();\n\t\tList<String> listOfString = new ArrayList<>();\n\t\tList<?> listOfSomething = new ArrayList<Integer>();\n\t\tList<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();\n\t\tList<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();\n\t\t// interfaces too List<? extends A,B>\n\n\t\tReferenceType ajList = resolve(\"Ljava/util/List;\");\n\t\tReferenceType ajListOfString = resolve(\"Pjava/util/List<Ljava/lang/String;>;\");\n\t\tReferenceType ajListOfSomething = resolve(\"Pjava/util/List<*>;\");\n\t\tReferenceType ajListOfSomethingNumberish = resolve(\"Pjava/util/List<+Ljava/lang/Number;>;\");\n\t\tReferenceType ajListOfSomethingSuperDouble = resolve(\"Pjava/util/List<-Ljava/lang/Double;>;\");\n\n\t\t// try and write the java equivalent, if it succeeds then check isAssignableFrom() is true\n\t\t// if the java is only correct with a cast, check isCoerceableFrom()\n\t\tlist = listOfString;\n\t\tassertTrue(ajList.isAssignableFrom(ajListOfString));\n\t\tlist = listOfSomething;\n\t\tassertTrue(ajList.isAssignableFrom(ajListOfSomething));\n\t\tlist = listOfSomethingNumberish;\n\t\tassertTrue(ajList.isAssignableFrom(ajListOfSomething));\n\t\tlist = listOfSomethingSuperDouble;\n\t\tassertTrue(ajList.isAssignableFrom(ajListOfSomethingSuperDouble));\n\n\t\tlistOfString = list; // unchecked conversion to List<String>\n\t\tassertFalse(ajListOfString.isAssignableFrom(ajList));\n\t\tassertTrue(ajListOfString.isCoerceableFrom(ajListOfSomething));\n\t\t// error: listOfString = listOfSomething;\n\t\tassertFalse(ajListOfString.isAssignableFrom(ajListOfSomething));\n\t\t// error: listOfString = listOfSomethingNumberish;\n\t\tassertFalse(ajListOfString.isAssignableFrom(ajListOfSomethingNumberish));\n\t\t// error: listOfString = listOfSomethingSuperDouble;\n\t\tassertFalse(ajListOfString.isAssignableFrom(ajListOfSomethingSuperDouble));\n\t\t// error: listOfString = (List<String>) listOfSomethingSuperDouble;\n\t\tassertFalse(ajListOfString.isCoerceableFrom(ajListOfSomethingSuperDouble));\n\n\t\tlistOfSomething = list;\n\t\tassertTrue(ajListOfSomething.isAssignableFrom(ajList));\n\t\tlistOfSomething = listOfString;\n\t\tassertTrue(ajListOfSomething.isAssignableFrom(ajListOfString));\n\t\tlistOfSomething = listOfSomethingNumberish;\n\t\tassertTrue(ajListOfSomething.isAssignableFrom(ajListOfSomething));\n\t\tlistOfSomething = listOfSomethingSuperDouble;\n\t\tassertTrue(ajListOfSomething.isAssignableFrom(ajListOfSomethingSuperDouble));\n\n\t\tlistOfSomethingNumberish = list; // unchecked conversion\n\t\tassertFalse(ajListOfSomethingNumberish.isAssignableFrom(ajList));\n\t\tassertTrue(ajListOfSomethingNumberish.isCoerceableFrom(ajList));\n\t\t// error: listOfSomethingNumberish = listOfString;\n\t\tassertFalse(ajListOfSomethingNumberish.isAssignableFrom(ajListOfString));\n\t\tassertFalse(ajListOfSomethingNumberish.isCoerceableFrom(ajListOfString));\n\t\t// error: listOfSomethingNumberish = listOfSomething;\n\t\tassertFalse(ajListOfSomethingNumberish.isAssignableFrom(ajListOfSomething));\n\t\tlistOfSomethingNumberish = (List<? extends Number>) listOfSomething;\n\t\tassertTrue(ajListOfSomethingNumberish.isCoerceableFrom(ajListOfSomething));\n\t\t// error: listOfSomethingNumberish = listOfSomethingSuperDouble;\n\t\tassertFalse(ajListOfSomethingNumberish.isAssignableFrom(ajListOfSomethingSuperDouble));\n\t\t// listOfSomethingNumberish = (List<? extends Number>) listOfSomethingSuperDouble;\n\t\t// assertTrue(ajListOfSomethingNumberish.isCoerceableFrom(ajListOfSomethingSuperDouble));\n\t}\n\n\tclass C<E extends Number> {\n\t\tvoid m1(List<Integer> e) {\n\t\t}\n\n\t\tvoid m2(List<? extends Number> e) {\n\t\t}\n\n\t\tvoid m3(List<Number> e) {\n\t\t}\n\n\t\tvoid m4(List<?> e) {\n\t\t}\n\n\t\tvoid m5(List<E> e) {\n\t\t}\n\n\t\tvoid m6(List<? extends E> e) {\n\t\t}\n\n\t\tvoid m7(List<? extends List<? extends E>> e) {\n\t\t}\n\n\t\tvoid m8(List e) {\n\t\t}\n\n\t\tvoid m9(E e) {\n\t\t}\n\t}\n\n\tclass A1 {\n\t}\n\n\tclass B1 extends A1 {\n\t}\n\n\tclass C1 extends B1 {\n\t}\n\n\tclass D1 extends C1 {\n\t}\n\n\tclass D2<E2 extends C1> {\n\t\tvoid m5(List<E2> e) {\n\t\t}\n\t}\n\n\tpublic void testAssignable02() {\n\t\tList list = new ArrayList();\n\t\tList arraylist = null;\n\t\tList<String> listOfString = new ArrayList<>();\n\t\tList<?> listOfSomething = new ArrayList<Integer>();\n\t\tList<?> arrayListOfSomething = null;\n\t\tList<Number> listOfNumber = null;\n\t\tArrayList<Number> arrayListOfNumber = null;\n\t\tList<? extends Number> arrayListOfSomethingNumberish = null;\n\t\tList<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();\n\t\tList<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();\n\t\tList<Integer> listOfInteger = new ArrayList<>();\n\t\tArrayList<String> arrayListOfString;\n\t\tArrayList<Integer> arraylistOfInteger;\n\t\t// interfaces too List<? extends A,B>\n\n\t\tReferenceType ajArrayListOfString = resolve(\"Pjava/util/ArrayList<Ljava/lang/String;>;\");\n\t\tReferenceType ajArrayListOfInteger = resolve(\"Pjava/util/ArrayList<Ljava/lang/Integer;>;\");\n\t\tReferenceType ajArrayListOfNumber = resolve(\"Pjava/util/ArrayList<Ljava/lang/Number;>;\");\n\t\tReferenceType ajArrayListOfSomethingNumberish = resolve(\"Pjava/util/ArrayList<+Ljava/lang/Number;>;\");\n\t\tReferenceType ajList = resolve(\"Ljava/util/List;\");\n\t\tReferenceType ajArrayList = resolve(\"Ljava/util/ArrayList;\");\n\t\tReferenceType ajListOfString = resolve(\"Pjava/util/List<Ljava/lang/String;>;\");\n\t\tReferenceType ajListOfSomething = resolve(\"Pjava/util/List<*>;\");\n\t\tReferenceType ajArrayListOfSomething = resolve(\"Pjava/util/ArrayList<*>;\");\n\t\tReferenceType ajListOfSomethingNumberish = resolve(\"Pjava/util/List<+Ljava/lang/Number;>;\");\n\t\tReferenceType ajListOfSomethingSuperDouble = resolve(\"Pjava/util/List<-Ljava/lang/Double;>;\");\n\t\tReferenceType ajListOfInteger = resolve(\"Pjava/util/List<Ljava/lang/Integer;>;\");\n\t\tReferenceType ajListOfNumber = resolve(\"Pjava/util/List<Ljava/lang/Number;>;\");\n\t\t// Effectively, whether the advice matches is based on whether what we pass at the joinpoint could\n\t\t// be bound to the specification in the args() pointcut\n\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\n\n\t\t// void around(): execution(* C.m1(..)) && args(ArrayList<Integer>){}//: Should runtime check (it does!)\n\t\tArrayList<Integer> x = (ArrayList<Integer>) listOfInteger;\n\t\tassertFalse(ajArrayListOfInteger.isAssignableFrom(ajListOfInteger));\n\t\tassertTrue(ajArrayListOfInteger.isCoerceableFrom(ajListOfInteger));\n\n\t\t// void around(): execution(* C.m1(..)) && args(List<Number>){} // Should not match (it does not!)\n\t\t// error: listOfNumber = listOfInteger;\n\t\tassertFalse(ajListOfNumber.isAssignableFrom(ajListOfInteger));\n\t\tassertFalse(ajListOfNumber.isCoerceableFrom(ajListOfInteger));\n\n\t\t// void around(): execution(* C.m1(..)) && args(ArrayList<Number>){} // Should not match (it does not)\n\t\t// error: arrayListOfNumber = listOfInteger;\n\t\tassertFalse(ajArrayListOfNumber.isAssignableFrom(ajListOfInteger));\n\t\tassertFalse(ajArrayListOfNumber.isCoerceableFrom(ajListOfInteger));\n\n\t\t// void around(): execution(* C.m1(..)) && args(List<? extends Number>){} // Should match (it does)\n\t\tlistOfSomethingNumberish = listOfInteger;\n\t\tassertTrue(ajListOfSomethingNumberish.isAssignableFrom(ajListOfInteger));\n\n\t\t// void around(): execution(* C.m1(..)) && args(ArrayList<? extends Number>){}// Should runtime check (it does!)\n\t\tarrayListOfSomethingNumberish = listOfInteger;\n\t\tassertFalse(ajArrayListOfSomethingNumberish.isAssignableFrom(ajListOfInteger));\n\t\tassertTrue(ajArrayListOfSomethingNumberish.isCoerceableFrom(ajListOfInteger));\n\n\t\t// void around(): execution(* C.m1(..)) && args(List){}// Should match (it does)\n\t\tlist = listOfInteger;\n\t\tassertTrue(ajList.isAssignableFrom(ajListOfInteger));\n\n\t\t// void around(): execution(* C.m1(..)) && args(ArrayList){}//: Should runtime check (it does not match!)\n\t\tarraylist = listOfInteger;\n\t\tassertFalse(ajArrayList.isAssignableFrom(ajListOfInteger));\n\t\tassertTrue(ajArrayList.isCoerceableFrom(ajListOfInteger));\n\n\t\t// void around(): execution(* C.m1(..)) && args(List<?>){}// Should match (it does)\n\t\tlistOfSomething = listOfInteger;\n\t\tassertTrue(ajListOfSomething.isAssignableFrom(ajListOfInteger));\n\n\t\t// void around(): execution(* C.m1(..)) && args(ArrayList<?>){}// Should runtime check (it does not match!)\n\t\tarrayListOfSomething = listOfInteger;\n\t\tassertFalse(ajArrayListOfSomething.isAssignableFrom(ajListOfInteger));\n\t\tassertTrue(ajArrayListOfSomething.isCoerceableFrom(ajListOfInteger));\n\n\t\t// void around(): execution(* C.m1(..)) && args(ArrayList<String>){}// Should not match (it does not match!)\n\t\t// error: arrayListOfString = listOfInteger;\n\t\tassertFalse(ajArrayListOfString.isAssignableFrom(ajListOfInteger));\n\t\tassertFalse(ajArrayListOfString.isCoerceableFrom(ajListOfInteger));\n\t}\n\n\tpublic void testAssignable03_method_m2() {\n\t\tList list = new ArrayList();\n\t\tList arraylist = null;\n\t\tList<String> listOfString = new ArrayList<>();\n\t\tList<?> listOfSomething = new ArrayList<Integer>();\n\t\tList<?> arrayListOfSomething = null;\n\t\tList<Number> listOfNumber = null;\n\t\tList<Number> arrayListOfNumber = null;\n\t\tList<Integer> arrayListOfInteger = null;\n\t\tList<? extends Number> arrayListOfSomethingNumberish = null;\n\t\tList<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();\n\t\tList<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();\n\t\tList<Integer> listOfInteger = new ArrayList<>();\n\t\tArrayList<String> arrayListOfString;\n\t\tArrayList<Integer> arraylistOfInteger;\n\t\t// interfaces too List<? extends A,B>\n\n\t\tReferenceType ajArrayListOfString = resolve(\"Pjava/util/ArrayList<Ljava/lang/String;>;\");\n\t\tReferenceType ajArrayListOfInteger = resolve(\"Pjava/util/ArrayList<Ljava/lang/Integer;>;\");\n\t\tReferenceType ajArrayListOfNumber = resolve(\"Pjava/util/ArrayList<Ljava/lang/Number;>;\");\n\t\tReferenceType ajArrayListOfSomethingNumberish = resolve(\"Pjava/util/ArrayList<+Ljava/lang/Number;>;\");\n\t\tReferenceType ajList = resolve(\"Ljava/util/List;\");\n\t\tReferenceType ajArrayList = resolve(\"Ljava/util/ArrayList;\");\n\t\tReferenceType ajListOfString = resolve(\"Pjava/util/List<Ljava/lang/String;>;\");\n\t\tReferenceType ajListOfSomething = resolve(\"Pjava/util/List<*>;\");\n\t\tReferenceType ajArrayListOfSomething = resolve(\"Pjava/util/ArrayList<*>;\");\n\t\tReferenceType ajListOfSomethingNumberish = resolve(\"Pjava/util/List<+Ljava/lang/Number;>;\");\n\t\tReferenceType ajListOfSomethingSuperDouble = resolve(\"Pjava/util/List<-Ljava/lang/Double;>;\");\n\t\tReferenceType ajListOfInteger = resolve(\"Pjava/util/List<Ljava/lang/Integer;>;\");\n\t\tReferenceType ajListOfNumber = resolve(\"Pjava/util/List<Ljava/lang/Number;>;\");\n\n\t\t// void m2(List<? extends Number> e) {}\n\n\t\t// comment 11\n\t\t// void around(): execution(* C.m2(..)) && args(List<Integer>){} //: Should not match (but it does) ERROR\n\t\tlistOfInteger = (List<Integer>) listOfSomethingNumberish;\n\t\tassertFalse(ajListOfInteger.isAssignableFrom(ajListOfSomethingNumberish));\n\t\tassertTrue(ajListOfInteger.isCoerceableFrom(ajListOfSomethingNumberish));\n\n\t\t// void around(): execution(* C.m2(..)) && args(ArrayList<Integer>){}//: Should not match (but it does!) ERROR\n\t\tarrayListOfInteger = (ArrayList<Integer>) listOfSomethingNumberish;\n\t\tassertFalse(ajArrayListOfInteger.isAssignableFrom(ajListOfSomethingNumberish));\n\t\tassertTrue(ajArrayListOfInteger.isCoerceableFrom(ajListOfSomethingNumberish));\n\n\t\t// void around(): execution(* C.m2(..)) && args(List<Number>){} //: Should not match (but it does) ERROR\n\t\tlistOfNumber = (List<Number>) listOfSomethingNumberish;\n\t\tassertFalse(ajListOfNumber.isAssignableFrom(ajListOfSomethingNumberish));\n\t\tassertTrue(ajListOfNumber.isCoerceableFrom(ajListOfSomethingNumberish));\n\n\t\t// void around(): execution(* C.m2(..)) && args(ArrayList<Number>){}//: Should not runtime check (but it does!) ERROR\n\t\tarrayListOfNumber = (ArrayList<Number>) listOfSomethingNumberish;\n\t\tassertFalse(ajArrayListOfNumber.isAssignableFrom(ajListOfSomethingNumberish));\n\t\tassertTrue(ajArrayListOfNumber.isCoerceableFrom(ajListOfSomethingNumberish));\n\n\t\t// void around(): execution(* C.m2(..)) && args(List<? extends Number>){}//: Should match (it does)\n\t\tlistOfSomethingNumberish = listOfSomethingNumberish;\n\t\tassertTrue(ajListOfSomethingNumberish.isAssignableFrom(ajListOfSomethingNumberish));\n\n\t\t// void around(): execution(* C.m2(..)) && args(ArrayList<? extends Number>){}//: Should runtime check (it does!)\n\t\tarrayListOfSomethingNumberish = listOfSomethingNumberish;\n\t\tassertFalse(ajArrayListOfSomethingNumberish.isAssignableFrom(ajListOfSomethingNumberish));\n\t\tassertTrue(ajArrayListOfSomethingNumberish.isCoerceableFrom(ajListOfSomethingNumberish));\n\n\t\t// void around(): execution(* C.m2(..)) && args(List){}//: Should match (it does)\n\t\tlist = listOfSomethingNumberish;\n\t\tassertTrue(ajList.isAssignableFrom(ajListOfSomethingNumberish));\n\n\t\t// void around(): execution(* C.m2(..)) && args(ArrayList){}//: Should runtime check (it does not match!) ERROR\n\t\tarraylist = listOfSomethingNumberish;\n\t\tassertFalse(ajArrayList.isAssignableFrom(ajListOfSomethingNumberish));\n\t\tassertTrue(ajArrayList.isCoerceableFrom(ajListOfSomethingNumberish));\n\n\t\t// void around(): execution(* C.m2(..)) && args(List<?>){}//: Should match (it does)\n\t\tlistOfSomething = listOfSomethingNumberish;\n\t\tassertTrue(ajListOfSomething.isAssignableFrom(ajListOfSomethingNumberish));\n\n\t\t// void around(): execution(* C.m2(..)) && args(ArrayList<?>){}//: Should runtime check (it does!)\n\t\tarrayListOfSomething = listOfSomethingNumberish;\n\t\tassertFalse(ajArrayListOfSomething.isAssignableFrom(ajListOfSomethingNumberish));\n\t\tassertTrue(ajArrayListOfSomething.isCoerceableFrom(ajListOfSomethingNumberish));\n\n\t\t// void around(): execution(* C.m2(..)) && args(ArrayList<String>){}//: Should not match (it does not match!)\n\t\t// error: arrayListOfString = listOfSomethingNumberish;\n\t\tassertFalse(ajArrayListOfString.isAssignableFrom(ajListOfSomethingNumberish));\n\t\tassertFalse(ajArrayListOfString.isCoerceableFrom(ajListOfSomethingNumberish));\n\t}\n\n\tpublic void testAssignable04_method_m3() {\n\t\tList list = new ArrayList();\n\t\tArrayList arraylist = null;\n\t\tList<String> listOfString = new ArrayList<>();\n\t\tList<?> listOfSomething = new ArrayList<Integer>();\n\t\tList<?> arrayListOfSomething = null;\n\t\tList<Number> listOfNumber = null;\n\t\tList<Number> arrayListOfNumber = null;\n\t\tArrayList<Integer> arrayListOfInteger = null;\n\t\tList<? extends Number> arrayListOfSomethingNumberish = null;\n\t\tList<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();\n\t\tList<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();\n\t\tList<Integer> listOfInteger = new ArrayList<>();\n\t\tList arrayList = null;\n\t\tArrayList<String> arrayListOfString;\n\t\tArrayList<Integer> arraylistOfInteger;\n\t\t// interfaces too List<? extends A,B>\n\n\t\tReferenceType ajArrayListOfString = resolve(\"Pjava/util/ArrayList<Ljava/lang/String;>;\");\n\t\tReferenceType ajArrayListOfInteger = resolve(\"Pjava/util/ArrayList<Ljava/lang/Integer;>;\");\n\t\tReferenceType ajArrayListOfNumber = resolve(\"Pjava/util/ArrayList<Ljava/lang/Number;>;\");\n\t\tReferenceType ajArrayListOfSomethingNumberish = resolve(\"Pjava/util/ArrayList<+Ljava/lang/Number;>;\");\n\t\tReferenceType ajList = resolve(\"Ljava/util/List;\");\n\t\tReferenceType ajArrayList = resolve(\"Ljava/util/ArrayList;\");\n\t\tReferenceType ajListOfString = resolve(\"Pjava/util/List<Ljava/lang/String;>;\");\n\t\tReferenceType ajListOfSomething = resolve(\"Pjava/util/List<*>;\");\n\t\tReferenceType ajArrayListOfSomething = resolve(\"Pjava/util/ArrayList<*>;\");\n\t\tReferenceType ajListOfSomethingNumberish = resolve(\"Pjava/util/List<+Ljava/lang/Number;>;\");\n\t\tReferenceType ajListOfSomethingSuperDouble = resolve(\"Pjava/util/List<-Ljava/lang/Double;>;\");\n\t\tReferenceType ajListOfInteger = resolve(\"Pjava/util/List<Ljava/lang/Integer;>;\");\n\t\tReferenceType ajListOfNumber = resolve(\"Pjava/util/List<Ljava/lang/Number;>;\");\n\n\t\t// void m3(List<Number> e) { }\n\n\t\t// void around(): execution(* C.m3(..)) && args(List<Integer>){} //: Should not match (it does not)\n\t\t// error: listOfInteger = listOfNumber;\n\t\tassertFalse(ajListOfInteger.isAssignableFrom(ajListOfNumber));\n\t\tassertFalse(ajListOfInteger.isCoerceableFrom(ajListOfNumber));\n\n\t\t// void around(): execution(* C.m3(..)) && args(ArrayList<Integer>){}//: Should not match (it does not)\n\t\t// error: arrayListOfInteger = listOfNumber;\n\t\tassertFalse(ajArrayListOfInteger.isAssignableFrom(ajListOfNumber));\n\t\tassertFalse(ajArrayListOfInteger.isCoerceableFrom(ajListOfNumber));\n\n\t\t// void around(): execution(* C.m3(..)) && args(List<Number>){}//: Should match (it does)\n\t\tlistOfNumber = listOfNumber;\n\t\tassertTrue(ajListOfNumber.isAssignableFrom(ajListOfNumber));\n\n\t\t// void around(): execution(* C.m3(..)) && args(ArrayList<Number>){}//: Should runtime match (it does)\n\t\tarrayListOfNumber = listOfNumber;\n\t\tassertFalse(ajArrayListOfNumber.isAssignableFrom(ajListOfNumber));\n\t\tassertTrue(ajArrayListOfNumber.isCoerceableFrom(ajListOfNumber));\n\n\t\t// void around(): execution(* C.m3(..)) && args(List<? extends Number>){}//: Should match (it does)\n\t\tlistOfSomethingNumberish = listOfNumber;\n\t\tassertTrue(ajListOfSomethingNumberish.isAssignableFrom(ajListOfNumber));\n\n\t\t// void around(): execution(* C.m3(..)) && args(ArrayList<? extends Number>){}//: Should runtime check (it does!)\n\t\tarrayListOfSomethingNumberish = listOfNumber;\n\t\tassertFalse(ajArrayListOfSomethingNumberish.isAssignableFrom(ajListOfNumber));\n\t\tassertTrue(ajArrayListOfSomethingNumberish.isCoerceableFrom(ajListOfNumber));\n\n\t\t// void around(): execution(* C.m3(..)) && args(List){}//: Should match (it does)\n\t\tlist = listOfNumber;\n\t\tassertTrue(ajList.isAssignableFrom(ajListOfNumber));\n\n\t\t// void around(): execution(* C.m3(..)) && args(ArrayList){}//: Should runtime check (it does not match!) ERROR\n\t\tarrayList = listOfNumber;\n\t\tassertFalse(ajArrayList.isAssignableFrom(ajListOfNumber));\n\t\tassertTrue(ajArrayList.isCoerceableFrom(ajListOfNumber));\n\n\t\t// void around(): execution(* C.m3(..)) && args(List<?>){}//: Should match (it does)\n\t\tlistOfSomething = listOfNumber;\n\t\tassertTrue(ajListOfSomething.isAssignableFrom(ajListOfNumber));\n\n\t\t// void around(): execution(* C.m3(..)) && args(ArrayList<?>){}//: Should runtime check (it does!)\n\t\tarrayListOfSomething = listOfNumber;\n\t\tassertFalse(ajArrayListOfSomething.isAssignableFrom(ajListOfNumber));\n\t\tassertTrue(ajArrayListOfSomething.isCoerceableFrom(ajListOfNumber));\n\n\t\t// void around(): execution(* C.m3(..)) && args(ArrayList<String>){}//: Should not match (it does not match!)\n\t\t// error: arrayListOfString = listOfNumber;\n\t\tassertFalse(ajArrayListOfString.isAssignableFrom(ajListOfNumber));\n\t\tassertFalse(ajArrayListOfString.isCoerceableFrom(ajListOfNumber));\n\n\t}\n\n\tstatic class ClassA<T> {\n\t}\n\n\tinterface IMarker<H> {\n\t}\n\n\tstatic class ClassB<T> implements IMarker<ClassA<T>> {\n\t}\n\n\tstatic class ClassC<T> implements IMarker<T> {\n\t}\n\n\tpublic void testAssignability_pr267559() {\n\t\tClassB cb = new ClassB();\n\t\tClassB cb2 = new ClassB();\n\n\t\tReferenceType rcb = resolve(\"Lorg/aspectj/weaver/ReferenceTypeTestCase$ClassB;\");\n\t\tReferenceType rcb2 = resolve(\"Lorg/aspectj/weaver/ReferenceTypeTestCase$ClassB;\");\n\t\tboolean b = rcb.isAssignableFrom(rcb2);\n\t\tassertTrue(b);\n\t\tb = rcb2.isAssignableFrom(rcb);\n\t\tassertTrue(b);\n\n\t\trcb = resolve(\"Porg/aspectj/weaver/ReferenceTypeTestCase$IMarker<Porg/aspectj/weaver/ReferenceTypeTestCase$ClassA<TT;>;>;\");\n\t\trcb2 = resolve(\"Lorg/aspectj/weaver/ReferenceTypeTestCase$ClassB;\");\n\t\tb = rcb.isAssignableFrom(rcb2);\n\t\tassertTrue(b);\n\t}\n\n\tpublic void testAssignable03_method_m4() {\n\t\tList list = new ArrayList();\n\t\tList arraylist = null;\n\t\tList<String> listOfString = new ArrayList<>();\n\t\tList<?> listOfSomething = new ArrayList<Integer>();\n\t\tList<?> arrayListOfSomething = null;\n\t\tList<Number> listOfNumber = null;\n\t\tList<Number> arrayListOfNumber = null;\n\t\tList<? extends Number> arrayListOfSomethingNumberish = null;\n\t\tList<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();\n\t\tList<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();\n\t\tList<Integer> listOfInteger = new ArrayList<>();\n\t\tList<String> arrayListOfString;\n\t\tList<Integer> arraylistOfInteger;\n\t\t// interfaces too List<? extends A,B>\n\n\t\tReferenceType ajArrayListOfString = resolve(\"Pjava/util/ArrayList<Ljava/lang/String;>;\");\n\t\tReferenceType ajArrayListOfInteger = resolve(\"Pjava/util/ArrayList<Ljava/lang/Integer;>;\");\n\t\tReferenceType ajArrayListOfNumber = resolve(\"Pjava/util/ArrayList<Ljava/lang/Number;>;\");\n\t\tReferenceType ajArrayListOfSomethingNumberish = resolve(\"Pjava/util/ArrayList<+Ljava/lang/Number;>;\");\n\t\tReferenceType ajList = resolve(\"Ljava/util/List;\");\n\t\tReferenceType ajArrayList = resolve(\"Ljava/util/ArrayList;\");\n\t\tReferenceType ajListOfString = resolve(\"Pjava/util/List<Ljava/lang/String;>;\");\n\t\tReferenceType ajListOfSomething = resolve(\"Pjava/util/List<*>;\");\n\t\tReferenceType ajArrayListOfSomething = resolve(\"Pjava/util/ArrayList<*>;\");\n\t\tReferenceType ajListOfSomethingNumberish = resolve(\"Pjava/util/List<+Ljava/lang/Number;>;\");\n\t\tReferenceType ajListOfSomethingSuperDouble = resolve(\"Pjava/util/List<-Ljava/lang/Double;>;\");\n\t\tReferenceType ajListOfInteger = resolve(\"Pjava/util/List<Ljava/lang/Integer;>;\");\n\t\tReferenceType ajListOfNumber = resolve(\"Pjava/util/List<Ljava/lang/Number;>;\");\n\n\t\t// void m4(List<?> e) {}\n\n\t\t// void around(): execution(* C.m4(..)) && args(List<Integer>){} //: Should match with unchecked warning\n\t\tlistOfInteger = (List<Integer>) listOfSomething;\n\t\tassertFalse(ajListOfInteger.isAssignableFrom(ajListOfSomething));\n\t\tassertTrue(ajListOfInteger.isCoerceableFrom(ajListOfSomething));\n\n\t\t// void around(): execution(* C.m4(..)) && args(ArrayList<Integer>){} // Should match with unchecked warning\n\t\tarraylistOfInteger = (ArrayList<Integer>) listOfSomething;\n\t\tassertFalse(ajArrayListOfInteger.isAssignableFrom(ajListOfSomething));\n\t\tassertTrue(ajArrayListOfInteger.isCoerceableFrom(ajListOfSomething));\n\n\t\t// void around(): execution(* C.m4(..)) && args(List<Number>){} // Should match with unchecked warning\n\t\tlistOfNumber = (List<Number>) listOfSomething;\n\t\tassertFalse(ajListOfNumber.isAssignableFrom(ajListOfSomething));\n\t\tassertTrue(ajListOfNumber.isCoerceableFrom(ajListOfSomething));\n\n\t\t// void around(): execution(* C.m4(..)) && args(ArrayList<Number>){} // Should match with unchecked warning\n\t\tarrayListOfNumber = (ArrayList<Number>) listOfSomething;\n\t\tassertFalse(ajArrayListOfNumber.isAssignableFrom(ajListOfSomething));\n\t\tassertTrue(ajArrayListOfNumber.isCoerceableFrom(ajListOfSomething));\n\n\t\t// void around(): execution(* C.m4(..)) && args(List<? extends Number>){} // Should match with unchecked warning\n\t\tlistOfSomethingNumberish = (List<? extends Number>) listOfSomething;\n\t\tassertFalse(ajListOfSomethingNumberish.isAssignableFrom(ajListOfSomething));\n\t\tassertTrue(ajListOfSomethingNumberish.isCoerceableFrom(ajListOfSomething));\n\n\t\t// void around(): execution(* C.m4(..)) && args(ArrayList<? extends Number>){} // Should match with unchecked warning\n\t\tarrayListOfSomethingNumberish = (ArrayList<? extends Number>) listOfSomething;\n\t\tassertFalse(ajArrayListOfSomethingNumberish.isAssignableFrom(ajListOfSomething));\n\t\tassertTrue(ajArrayListOfSomethingNumberish.isCoerceableFrom(ajListOfSomething));\n\n\t\t// void around(): execution(* C.m4(..)) && args(List){} // Should match\n\t\tlist = listOfSomething;\n\t\tassertTrue(ajList.isAssignableFrom(ajListOfSomething));\n\n\t\t// void around(): execution(* C.m4(..)) && args(ArrayList){} // Should runtime check\n\t\tarraylist = listOfSomething;\n\t\tassertFalse(ajArrayList.isAssignableFrom(ajListOfSomething));\n\t\tassertTrue(ajArrayList.isCoerceableFrom(ajListOfSomething));\n\n\t\t// void around(): execution(* C.m4(..)) && args(List<?>){}//: Should match\n\t\tlist = listOfSomething;\n\t\tassertTrue(ajList.isAssignableFrom(ajListOfSomething));\n\n\t\t// void around(): execution(* C.m4(..)) && args(ArrayList<?>){} // Should runtime check\n\t\tarrayListOfSomething = listOfSomething;\n\t\tassertFalse(ajArrayListOfSomething.isAssignableFrom(ajListOfSomething));\n\t\tassertTrue(ajArrayListOfSomething.isCoerceableFrom(ajListOfSomething));\n\n\t\t// void around(): execution(* C.m4(..)) && args(ArrayList<String>){} // Should match with unchecked warning\n\t\tarrayListOfString = (ArrayList<String>) listOfSomething;\n\t\tassertFalse(ajArrayListOfString.isAssignableFrom(ajListOfSomething));\n\t\tassertTrue(ajArrayListOfString.isCoerceableFrom(ajListOfSomething));\n\t}\n\n\t// copy of the real one in BcelClassWeaver\n\tpublic static class IfaceInitList implements PartialOrder.PartialComparable {\n\t\tfinal ResolvedType onType;\n\t\tList<ConcreteTypeMunger> list = new ArrayList<>();\n\n\t\tIfaceInitList(ResolvedType onType) {\n\t\t\tthis.onType = onType;\n\t\t}\n\n\t\tpublic int compareTo(Object other) {\n\t\t\tIfaceInitList o = (IfaceInitList) other;\n\t\t\tif (onType.isAssignableFrom(o.onType)) {\n\t\t\t\treturn +1;\n\t\t\t} else if (o.onType.isAssignableFrom(onType)) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic int fallbackCompareTo(Object other) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic void testExpensiveAssignableChecks_309336() {\n\t\tList objects = new ArrayList();\n\t\tReferenceType rcb = resolve(\"Lorg/aspectj/weaver/ReferenceTypeTestCase$Foo;\");\n\t\tReferenceType i = (ReferenceType) rcb.getDeclaredInterfaces()[0];\n\t\twhile (i != null && i.isInterface()) {\n\t\t\tobjects.add(Math.abs(new Random(12).nextInt(objects.size() + 1)), new IfaceInitList(i));\n\t\t\tResolvedType[] rt = i.getDeclaredInterfaces();\n\t\t\ti = rt == null || rt.length == 0 ? null : (ReferenceType) rt[0];\n\t\t}\n\t\tfor (int loop = 0; loop < 10; loop++) {\n\t\t\t// ReferenceType.r = 0;\n\t\t\tlong stime = System.nanoTime();\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tList objects2 = new ArrayList(objects);\n\t\t\t\tPartialOrder.sort(objects2);\n\t\t\t}\n\t\t\tlong etime = System.nanoTime();\n\t\t\tSystem.err.println(\"Took \" + ((etime - stime) / 1000000) + \"ms: calls \");// + ReferenceType.r);\n\t\t}\n\t\t// could do with asserting something... basically we are just checking we didn't run out of memory doing the sorts above!\n\t}\n\n\tpublic interface Operator14<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable, E5 extends Throwable, E6 extends Throwable, E7 extends Throwable, E8 extends Throwable, E9 extends Throwable, E10 extends Throwable, E11 extends Throwable, E12 extends Throwable, E13 extends Throwable, E14 extends Throwable> {\n\t\tT execute(String aArg) throws E1, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11, E12, E13, E14, RemoteException;\n\t}\n\n\tpublic interface Operator13<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable, E5 extends Throwable, E6 extends Throwable, E7 extends Throwable, E8 extends Throwable, E9 extends Throwable, E10 extends Throwable, E11 extends Throwable, E12 extends Throwable, E13 extends Throwable>\n\t\t\textends Operator14<T, E1, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11, E12, E13, E13> {\n\t}\n\n\tpublic interface Operator12<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable, E5 extends Throwable, E6 extends Throwable, E7 extends Throwable, E8 extends Throwable, E9 extends Throwable, E10 extends Throwable, E11 extends Throwable, E12 extends Throwable>\n\t\t\textends Operator13<T, E1, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11, E12, E12> {\n\t}\n\n\tpublic interface Operator11<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable, E5 extends Throwable, E6 extends Throwable, E7 extends Throwable, E8 extends Throwable, E9 extends Throwable, E10 extends Throwable, E11 extends Throwable>\n\t\t\textends Operator12<T, E1, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11, E11> {\n\t}\n\n\tpublic interface Operator10<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable, E5 extends Throwable, E6 extends Throwable, E7 extends Throwable, E8 extends Throwable, E9 extends Throwable, E10 extends Throwable>\n\t\t\textends Operator11<T, E1, E2, E3, E4, E5, E6, E7, E8, E9, E10, E10> {\n\n\t}\n\n\tpublic interface Operator9<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable, E5 extends Throwable, E6 extends Throwable, E7 extends Throwable, E8 extends Throwable, E9 extends Throwable>\n\t\t\textends Operator10<T, E1, E2, E3, E4, E5, E6, E7, E8, E9, E9> {\n\t}\n\n\tpublic interface Operator8<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable, E5 extends Throwable, E6 extends Throwable, E7 extends Throwable, E8 extends Throwable>\n\t\t\textends Operator9<T, E1, E2, E3, E4, E5, E6, E7, E8, E8> {\n\t}\n\n\tpublic interface Operator7<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable, E5 extends Throwable, E6 extends Throwable, E7 extends Throwable>\n\t\t\textends Operator8<T, E1, E2, E3, E4, E5, E6, E7, E7> {\n\t}\n\n\tpublic interface Operator6<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable, E5 extends Throwable, E6 extends Throwable>\n\t\t\textends Operator7<T, E1, E2, E3, E4, E5, E6, E6> {\n\n\t}\n\n\tpublic interface Operator5<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable, E5 extends Throwable>\n\t\t\textends Operator6<T, E1, E2, E3, E4, E5, E5> {\n\t}\n\n\tpublic interface Operator4<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable, E4 extends Throwable> extends\n\t\t\tOperator5<T, E1, E2, E3, E4, E4> {\n\t}\n\n\tpublic interface Operator3<T, E1 extends Throwable, E2 extends Throwable, E3 extends Throwable> extends\n\t\t\tOperator4<T, E1, E2, E3, E3> {\n\t}\n\n\tpublic interface Operator2<T, E1 extends Throwable, E2 extends Throwable> extends Operator3<T, E1, E2, E2> {\n\n\t}\n\n\tpublic interface Operator1<T, E1 extends Throwable> extends Operator2<T, E1, E1> {\n\t}\n\n\tpublic interface Operator<T> extends Operator1<T, RuntimeException> {\n\t}\n\n\tclass Foo implements Operator<String> {\n\t\tpublic String execute(String aArg) throws NullPointerException, RemoteException {\n\t\t\tSystem.out.println(\"Doh!\");\n\t\t\treturn aArg;\n\t\t}\n\t}\n\n\t// public void testAssignable_method_m5() {\n\t// List list = new ArrayList();\n\t// ArrayList arraylist = null;\n\t// List<String> listOfString = new ArrayList<String>();\n\t// List<?> listOfSomething = new ArrayList<Integer>();\n\t// ArrayList<?> arrayListOfSomething = null;\n\t// List<Number> listOfNumber = null;\n\t// ArrayList<Number> arrayListOfNumber = null;\n\t// ArrayList<? extends Number> arrayListOfSomethingNumberish = null;\n\t// List<? extends Number> listOfSomethingNumberish = new ArrayList<Integer>();\n\t// List<? super Double> listOfSomethingSuperDouble = new ArrayList<Number>();\n\t// List<Integer> listOfInteger = new ArrayList<Integer>();\n\t// ArrayList<String> arrayListOfString;\n\t// ArrayList<Integer> arraylistOfInteger;\n\t// // interfaces too List<? extends A,B>\n\t//\n\t// ReferenceType ajArrayListOfString = resolve(\"Pjava/util/ArrayList<Ljava/lang/String;>;\");\n\t// ReferenceType ajArrayListOfInteger = resolve(\"Pjava/util/ArrayList<Ljava/lang/Integer;>;\");\n\t// ReferenceType ajArrayListOfNumber = resolve(\"Pjava/util/ArrayList<Ljava/lang/Number;>;\");\n\t// ReferenceType ajArrayListOfSomethingNumberish = resolve(\"Pjava/util/ArrayList<+Ljava/lang/Number;>;\");\n\t// ReferenceType ajList = resolve(\"Ljava/util/List;\");\n\t// ReferenceType ajArrayList = resolve(\"Ljava/util/ArrayList;\");\n\t// ReferenceType ajListOfString = resolve(\"Pjava/util/List<Ljava/lang/String;>;\");\n\t// ReferenceType ajListOfSomething = resolve(\"Pjava/util/List<*>;\");\n\t// ReferenceType ajArrayListOfSomething = resolve(\"Pjava/util/ArrayList<*>;\");\n\t// ReferenceType ajListOfSomethingNumberish = resolve(\"Pjava/util/List<+Ljava/lang/Number;>;\");\n\t// ReferenceType ajListOfSomethingSuperDouble = resolve(\"Pjava/util/List<-Ljava/lang/Double;>;\");\n\t// ReferenceType ajListOfInteger = resolve(\"Pjava/util/List<Ljava/lang/Integer;>;\");\n\t// ReferenceType ajListOfNumber = resolve(\"Pjava/util/List<Ljava/lang/Number;>;\");\n\t// ReferenceType ajListOfEextendsNumber = resolve(\"Pjava/util/List<+TE\")\n\t//\n\t// // class C<E extends Number> {\n\t// // void m5(List<E> e) { }\n\t// //\n\t// // void around(): execution(* C.m5(..)) && args(List<Integer>){} Should not match (but it does) ERROR\n\t//\n\t// // void around(): execution(* C.m5(..)) && args(ArrayList<Integer>){}//: Should not match (but it does!) ERROR\n\t// // void around(): execution(* C.m5(..)) && args(List<Number>){}//: Should not match (but it does!) ERROR\n\t// // void around(): execution(* C.m5(..)) && args(ArrayList<Number>){}//: Should not match (it does) ERROR\n\t// // void around(): execution(* C.m5(..)) && args(List<? extends Number>){}//: Should match (it does)\n\t// // void around(): execution(* C.m5(..)) && args(ArrayList<? extends Number>){}//: Should runtime check (it does!)\n\t// // void around(): execution(* C.m5(..)) && args(List){}//: Should match (it does)\n\t// // void around(): execution(* C.m5(..)) && args(ArrayList){}//: Should runtime check (it does not match!) ERROR\n\t// // void around(): execution(* C.m5(..)) && args(List<?>){}//: Should match (it does)\n\t// // void around(): execution(* C.m5(..)) && args(ArrayList<?>){}//: Should runtime check (it does not match!)\n\t// // void around(): execution(* C.m5(..)) && args(ArrayList<String>){}//: Should not match (it does not match!)\n\t// //\n\t// // // void around(): execution(* D2.m5(..)) && args(List<D1>){} //: Should\n\t// // not match (but it does) ERROR\n\t// // // void around(): execution(* D2.m5(..)) && args(ArrayList<D1>){}//:\n\t// // Should not match (but it does!) ERROR\n\t// // // void around(): execution(* D2.m5(..)) && args(List<C1>){}//: Should\n\t// // not match (but it does!) ERROR\n\t// // // void around(): execution(* D2.m5(..)) && args(ArrayList<C1>){}//:\n\t// // Should not match (it does) ERROR\n\t// // // void around(): execution(* D2.m5(..)) && args(List<? extends B1>){}//:\n\t// // Should match (it does)\n\t// // // void around(): execution(* D2.m5(..)) && args(ArrayList<? extends\n\t// // B1>){}//: Should runtime check (it does!)\n\t// // // void around(): execution(* D2.m5(..)) && args(List<? extends C1>){}//:\n\t// // Should match (it does)\n\t// // // void around(): execution(* D2.m5(..)) && args(ArrayList<? extends\n\t// // C1>){}//: Should runtime check (it does!)\n\t// // // void around(): execution(* D2.m5(..)) && args(List){}//: Should match\n\t// // (it does)\n\t// // // void around(): execution(* D2.m5(..)) && args(ArrayList){}//: Should\n\t// // runtime check (it does not match!) ERROR\n\t// // // void around(): execution(* D2.m5(..)) && args(List<?>){}//: Should\n\t// // match (it does)\n\t// // // void around(): execution(* D2.m5(..)) && args(ArrayList<?>){}//:\n\t// // Should runtime check (it does not match!)\n\t// // // void around(): execution(* D2.m5(..)) && args(ArrayList<String>){}//:\n\t// // Should not match (it does not match!)\n\t// //\n\t// // // void around(): execution(* C.m6(..)) && args(List<Integer>){} //:\n\t// // Should not match (but it does) ERROR\n\t// // // void around(): execution(* C.m6(..)) && args(ArrayList<Integer>){}//:\n\t// // Should not match (but it does!) ERROR\n\t// // // void around(): execution(* C.m6(..)) && args(List<Number>){}//: Should\n\t// // not match (but it does!) ERROR\n\t// // // void around(): execution(* C.m6(..)) && args(ArrayList<Number>){}//:\n\t// // Should not match (it does) ERROR\n\t// // // void around(): execution(* C.m6(..)) && args(List<? extends\n\t// // Number>){}//: Should match (it does)\n\t// // // void around(): execution(* C.m6(..)) && args(ArrayList<? extends\n\t// // Number>){}//: Should runtime check (it does!)\n\t// // // void around(): execution(* C.m6(..)) && args(List){}//: Should match\n\t// // (it does)\n\t// // // void around(): execution(* C.m6(..)) && args(ArrayList){}//: Should\n\t// // runtime check (it does not match!)\n\t// // // void around(): execution(* C.m6(..)) && args(List<?>){}//: Should\n\t// // match (it does)\n\t// // // void around(): execution(* C.m6(..)) && args(ArrayList<?>){}//: Should\n\t// // runtime check (it does not match!)\n\t// // // void around(): execution(* C.m6(..)) && args(ArrayList<String>){}//:\n\t// // Should not match (it does not match!)\n\t// //\n\t// // // void around(): execution(* C.m7(..)) && args(List<List<Integer>>){}\n\t// // //: Should not match (but it does) ERROR\n\t// // // void around(): execution(* C.m7(..)) &&\n\t// // args(ArrayList<List<Integer>>){}//: Should not match (but it does!) ERROR\n\t// // // void around(): execution(* C.m7(..)) && args(List<List<Number>>){}//:\n\t// // Should not match (but it does!) ERROR\n\t// // // void around(): execution(* C.m7(..)) &&\n\t// // args(ArrayList<List<Number>>){}//: Should not match (but it does) ERROR\n\t// // // void around(): execution(* C.m7(..)) && args(List<? extends\n\t// // List<Number>>){}//: Should not match (but it does) ERROR\n\t// // // void around(): execution(* C.m7(..)) && args(ArrayList< ? extends\n\t// // List<Number>>){}//: Should not match (but it does!) ERROR\n\t// // // void around(): execution(* C.m7(..)) && args(List< ? extends List<?\n\t// // extends Number>>){}//: Should match (it does!)\n\t// // // void around(): execution(* C.m7(..)) && args(ArrayList< ? extends\n\t// // List<? extends Number>>){}//: Should match (it does!)\n\t// // // void around(): execution(* C.m7(..)) && args(List){}//: Should match\n\t// // (it does)\n\t// // // void around(): execution(* C.m7(..)) && args(ArrayList){}//: Should\n\t// // runtime check (it does not match!)\n\t// // // void around(): execution(* C.m7(..)) && args(List<?>){}//: Should\n\t// // match (it does)\n\t// // // void around(): execution(* C.m7(..)) && args(ArrayList<?>){}//: Should\n\t// // runtime check (it does!)\n\t// // // void around(): execution(* C.m7(..)) &&\n\t// // args(ArrayList<List<String>>){}//: Should not match (it does not match!)\n\t// //\n\t// // // void around(): execution(* C.m8(..)) && args(List<Integer>){} //:\n\t// // Should match with unchecked conversion (it does)\n\t// // // void around(): execution(* C.m8(..)) && args(ArrayList<Integer>){}//:\n\t// // Should runtime check with unchecked conversion (it does!)\n\t// // // void around(): execution(* C.m8(..)) && args(List<Number>){}//: Should\n\t// // match with unchecked conversion (it does!)\n\t// // // void around(): execution(* C.m8(..)) && args(ArrayList<Number>){}//:\n\t// // Should runtime check with unchecked conversion (it does)\n\t// // // void around(): execution(* C.m8(..)) && args(List<? extends\n\t// // Number>){}//: Should match with unchecked conversion (it does!)\n\t// // // void around(): execution(* C.m8(..)) && args(ArrayList<? extends\n\t// // Number>){}//: Should runtime check with unchecked conversion (it does)\n\t// // // void around(): execution(* C.m8(..)) && args(List){}//: Should match\n\t// // (it does)\n\t// // // void around(): execution(* C.m8(..)) && args(ArrayList){}//: Should\n\t// // runtime check (it does!)\n\t// // // void around(): execution(* C.m8(..)) && args(List<?>){}//: Should\n\t// // match (it does)\n\t// // // void around(): execution(* C.m8(..)) && args(ArrayList<?>){}//: Should\n\t// // runtime check (it does!)\n\t// // // void around(): execution(* C.m8(..)) && args(ArrayList<String>){}//:\n\t// // Should not match (it does not match!)\n\t// //\n\t// // // void around(): execution(* C.m9(..)) && args(List<Integer>){} //:\n\t// // Should not match (but it does) ERROR\n\t// // // void around(): execution(* C.m9(..)) && args(ArrayList<Integer>){}//:\n\t// // Should not match (it does not match!)\n\t// // // void around(): execution(* C.m9(..)) && args(Number){}//: Should match\n\t// // (it does!)\n\t// // // void around(): execution(* C.m9(..)) && args(Integer){}//: Should\n\t// // runtime check (it does)\n\t// // // void around(): execution(* C.m9(..)) && args(List<? extends\n\t// // Number>){}//: Should not match (but it does) ERROR\n\t// // // void around(): execution(* C.m9(..)) && args(ArrayList<? extends\n\t// // Number>){}//: Should not match (it does not match!)\n\t// // // void around(): execution(* C.m9(..)) && args(List){}//: Should not\n\t// // match (but it does) ERROR\n\t// // // void around(): execution(* C.m9(..)) && args(ArrayList){}//: Should\n\t// // not match (it does not match!)\n\t// // // void around(): execution(* C.m9(..)) && args(List<?>){}//: Should not\n\t// // match (but it does) ERROR\n\t// // // void around(): execution(* C.m9(..)) && args(ArrayList<?>){}//: Should\n\t// // not match (it does not match!)\n\t// // // void around(): execution(* C.m9(..)) && args(String){}//: Should not\n\t// // match (it does not match!)\n\t//\n\t// }\n\n\tprivate ReferenceType resolve(String sig) {\n\t\treturn (ReferenceType) world.resolve(UnresolvedType.forSignature(sig));\n\t}\n}\n",
    "size": 43444
  },
  {
    "file_id": "F114",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/ResolvedMemberSignatures15TestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport java.lang.reflect.Modifier;\n\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\npublic class ResolvedMemberSignatures15TestCase extends TestCase {\n\n\tWorld world;\n\tUnresolvedType baseType;\n\tUnresolvedType derivedType;\n\n\t// STATIC METHODS\n\n\tpublic void testBaseOnlyStaticMethod() {\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\n\t\t\t\t\t\t\t\t   (Modifier.PUBLIC | Modifier.STATIC),\n\t\t\t\t\t\t\t\t   UnresolvedType.forSignature(\"V\"),\n\t\t\t\t\t\t\t\t   \"onlyBase\", UnresolvedType.NONE);\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 member\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[0].getDeclaringType().getSignature());\n\n\t\ttoFind = new MemberImpl(Member.METHOD, derivedType,\n\t\t\t\t   (Modifier.PUBLIC | Modifier.STATIC),\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\n\t\t\t\t   \"onlyBase\", UnresolvedType.NONE);\n\t\tfoundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\t// this looks odd but we need both because of the way calls to inherited static methods\n\t\t// are rendered in bytecode when written as obj.foo(); - the bytecode says it is a call\n\t\t// to obj.getClass().foo() even if the static method is defined in a super type.\n\t\tassertEquals(\"found 2 members\",2,foundMembers.length);\n\t\tStringBuilder s= new StringBuilder();\n\t\tfor (ResolvedMember rm: foundMembers) {\n\t\t\ts.append(rm.toString()+\" \");\n\t\t}\n\t\tassertEquals(\"Expected derived but was \"+foundMembers[0]+\". All=\"+s,\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t\tassertEquals(\"Expected base but was \"+foundMembers[1]+\". All=\"+s,\"Lfluffy/Base;\",foundMembers[1].getDeclaringType().getSignature());\n\t}\n\n\tpublic void testBothStaticMethod() {\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\n\t\t\t\t   (Modifier.PUBLIC | Modifier.STATIC),\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\n\t\t\t\t   \"both\",\n\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t   );\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 member\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[0].getDeclaringType().getSignature());\n\n\t\ttoFind = new MemberImpl(Member.METHOD,derivedType,\n\t\t\t\t\t\t\t(Modifier.PUBLIC | Modifier.STATIC),\n\t\t\t\t\t\t\tUnresolvedType.forSignature(\"V\"),\n\t\t\t\t\t\t\t\"both\",\n\t\t\t\t\t\t\tnew UnresolvedType[0]\n\t\t\t\t\t\t\t);\n\t\tfoundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 members\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t}\n\n\tpublic void testDerivedStaticMethod() {\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\n\t\t\t\t   (Modifier.PUBLIC | Modifier.STATIC),\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\n\t\t\t\t   \"onlyDerived\",\n\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t   );\n\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found nothing\",0,foundMembers.length);\n\n\t\ttoFind = new MemberImpl(Member.METHOD,derivedType,\n\t\t\t\t\t\t\t(Modifier.PUBLIC | Modifier.STATIC),\n\t\t\t\t\t\t\tUnresolvedType.forSignature(\"V\"),\n\t\t\t\t\t\t\t\"onlyDerived\",\n\t\t\t\t\t\t\tnew UnresolvedType[0]\n\t\t\t\t\t\t\t);\n\t\tfoundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 members\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t}\n\n\t// NON-STATIC METHODS\n\n\tpublic void testBaseOnlyMethod() {\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\n\t\t\t\t\t\t\t\t   Modifier.PUBLIC,\n\t\t\t\t\t\t\t\t   UnresolvedType.forSignature(\"V\"),\n\t\t\t\t\t\t\t\t   \"onlyBaseNonStatic\",\n\t\t\t\t\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t\t\t\t\t   );\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 member\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[0].getDeclaringType().getSignature());\n\n\t\ttoFind = new MemberImpl(Member.METHOD,derivedType,\n\t\t\t\t   Modifier.PUBLIC,\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\n\t\t\t\t   \"onlyBaseNonStatic\",\n\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t   );\n\t\tfoundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 2 members\",2,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[1].getDeclaringType().getSignature());\n\n\t}\n\n\tpublic void testBothMethod() {\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\n\t\t\t\t   Modifier.PUBLIC, UnresolvedType.forSignature(\"V\"),\n\t\t\t\t   \"bothNonStatic\", UnresolvedType.NONE);\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 member\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[0].getDeclaringType().getSignature());\n\n\t\ttoFind = new MemberImpl(Member.METHOD,derivedType,\n\t\t\t\t\t\t\tModifier.PUBLIC, UnresolvedType.forSignature(\"V\"),\n\t\t\t\t\t\t\t\"bothNonStatic\", UnresolvedType.NONE);\n\t\tfoundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 2 members\",2,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[1].getDeclaringType().getSignature());\n\t}\n\n\tpublic void testDerivedMethod() {\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\n\t\t\t\t   Modifier.PUBLIC,\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\n\t\t\t\t   \"onlyDerivedNonStatic\",\n\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t   );\n\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found nothing\",0,foundMembers.length);\n\n\t\ttoFind = new MemberImpl(Member.METHOD,derivedType,\n\t\t\t\t\t\t\tModifier.PUBLIC,\n\t\t\t\t\t\t\tUnresolvedType.forSignature(\"V\"),\n\t\t\t\t\t\t\t\"onlyDerivedNonStatic\",\n\t\t\t\t\t\t\tnew UnresolvedType[0]\n\t\t\t\t\t\t\t);\n\t\tfoundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 members\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t}\n\n\tpublic void testChangingThrowsClause() {\n\t\tMember toFind = new MemberImpl(Member.METHOD,derivedType,\n\t\t\t\t   Modifier.PUBLIC,\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\n\t\t\t\t   \"m\",\n\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t   );\n\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 2 members\",2,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[1].getDeclaringType().getSignature());\n\n\t\tassertEquals(\"throws CloneNotSupported\",1,foundMembers[1].getExceptions().length);\n\t\tassertEquals(\"doesn't throw anything\",0,foundMembers[0].getExceptions().length);\n\t}\n\n\t// CONSTRUCTORS\n\n\t public void testNoWalkUpMatchingConstructor() {\n\t\tMember toFind = new MemberImpl(Member.CONSTRUCTOR,derivedType,\n\t\t\t\t   Modifier.PUBLIC,\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\n\t\t\t\t   \"<init>\",\n\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t   );\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 members\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t }\n\n\t public void testNoWalkUpNoMatchingConstructor() {\n\t\tMember toFind = new MemberImpl(Member.CONSTRUCTOR,derivedType,\n\t\t\t\t   Modifier.PUBLIC,\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\n\t\t\t\t   \"<init>\",\n\t\t\t\t   new UnresolvedType[] {UnresolvedType.forSignature(\"I\")}\n\t\t\t\t   );\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"No matches\",0,foundMembers.length);\n\t }\n\n\t// FIELDS\n\n\tpublic void testBaseOnlyField() {\n\t\tMember toFind = new MemberImpl(Member.FIELD,baseType,\n\t\t\t\t\t\t\t\t   Modifier.PUBLIC,\n\t\t\t\t\t\t\t\t   UnresolvedType.forSignature(\"I\"),\n\t\t\t\t\t\t\t\t   \"onlyBase\",\n\t\t\t\t\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t\t\t\t\t   );\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 member\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[0].getDeclaringType().getSignature());\n\n\t\ttoFind = new MemberImpl(Member.FIELD,derivedType,\n\t\t\t\t   Modifier.PUBLIC,\n\t\t\t\t   UnresolvedType.forSignature(\"I\"),\n\t\t\t\t   \"onlyBase\",\n\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t   );\n\t\tfoundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 2 members\",2,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[1].getDeclaringType().getSignature());\n\t}\n\n\tpublic void testBothField() {\n\t\tMember toFind = new MemberImpl(Member.FIELD,baseType,\n\t\t\t\t   Modifier.PUBLIC,\n\t\t\t\t   UnresolvedType.forSignature(\"I\"),\n\t\t\t\t   \"both\",\n\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t   );\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 member\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[0].getDeclaringType().getSignature());\n\n\t\ttoFind = new MemberImpl(Member.FIELD,derivedType,\n\t\t\t\t\t\t\tModifier.PUBLIC,\n\t\t\t\t\t\t\tUnresolvedType.forSignature(\"I\"),\n\t\t\t\t\t\t\t\"both\",\n\t\t\t\t\t\t\tnew UnresolvedType[0]\n\t\t\t\t\t\t\t);\n\t\tfoundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 members\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t}\n\n\tpublic void testDerivedField() {\n\t\tMember toFind = new MemberImpl(Member.FIELD,baseType,\n\t\t\t\t   Modifier.PUBLIC,\n\t\t\t\t   UnresolvedType.forSignature(\"I\"),\n\t\t\t\t   \"onlyDerived\",\n\t\t\t\t   new UnresolvedType[0]\n\t\t\t\t   );\n\n\t\tResolvedMember[] foundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found nothing\",0,foundMembers.length);\n\n\t\ttoFind = new MemberImpl(Member.FIELD,derivedType,\n\t\t\t\t\t\t\tModifier.PUBLIC,\n\t\t\t\t\t\t\tUnresolvedType.forSignature(\"I\"),\n\t\t\t\t\t\t\t\"onlyDerived\",\n\t\t\t\t\t\t\tnew UnresolvedType[0]\n\t\t\t\t\t\t\t);\n\t\tfoundMembers = ResolvedMemberImpl.getJoinPointSignatures(toFind, world);\n\t\tassertEquals(\"found 1 members\",1,foundMembers.length);\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\n\t}\n\n\tprotected void setUp() throws Exception {\n\t\tworld = new BcelWorld();\n\t\tworld.setBehaveInJava5Way(true);\n\t\tbaseType = UnresolvedType.forSignature(\"Lfluffy/Base;\");\n\t\tderivedType = UnresolvedType.forSignature(\"Lfluffy/Derived;\");\n\t}\n\n}\n",
    "size": 11022
  },
  {
    "file_id": "F115",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/TestShadow.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver;\n\nimport org.aspectj.bridge.ISourceLocation;\nimport org.aspectj.weaver.ast.Var;\n\npublic class TestShadow extends Shadow {\n\n\tprivate final World world;\n\tprivate final UnresolvedType thisType;\n\n\tpublic TestShadow(Kind kind, Member signature, UnresolvedType thisType, World world) {\n\t\tsuper(kind, signature, null);\n\t\tthis.world = world;\n\t\tthis.thisType = thisType;\n\t}\n\n\tpublic World getIWorld() {\n\t\treturn world;\n\t}\n\n\t/** this is subtly wrong. ha ha */\n\tpublic UnresolvedType getEnclosingType() {\n\t\treturn thisType;\n\t}\n\n\tpublic Var getThisVar() {\n\t\t// we should thorw if we don't have a this\n\t\treturn new Var(getThisType().resolve(world));\n\t}\n\n\tpublic Var getTargetVar() {\n\t\tif (!hasTarget())\n\t\t\tthrow new RuntimeException(\"bad\");\n\t\treturn new Var(getTargetType().resolve(world));\n\t}\n\n\tpublic Var getArgVar(int i) {\n\t\treturn new Var(getArgType(i).resolve(world));\n\t}\n\n\tpublic Var getThisEnclosingJoinPointStaticPartVar() {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic Var getThisJoinPointStaticPartVar() {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic Var getThisAspectInstanceVar(ResolvedType aspectType) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic Var getThisJoinPointVar() {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic ISourceLocation getSourceLocation() {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\tpublic Member getEnclosingCodeSignature() {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see org.aspectj.weaver.Shadow#getKindedAnnotationVar()\n\t */\n\tpublic Var getKindedAnnotationVar(UnresolvedType annotationType) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see org.aspectj.weaver.Shadow#getWithinAnnotationVar()\n\t */\n\tpublic Var getWithinAnnotationVar(UnresolvedType annotationType) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see org.aspectj.weaver.Shadow#getWithinCodeAnnotationVar()\n\t */\n\tpublic Var getWithinCodeAnnotationVar(UnresolvedType annotationType) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see org.aspectj.weaver.Shadow#getThisAnnotationVar()\n\t */\n\tpublic Var getThisAnnotationVar(UnresolvedType annotationType) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see org.aspectj.weaver.Shadow#getTargetAnnotationVar()\n\t */\n\tpublic Var getTargetAnnotationVar(UnresolvedType annotationType) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see org.aspectj.weaver.Shadow#getArgAnnotationVar(int)\n\t */\n\tpublic Var getArgAnnotationVar(int i, UnresolvedType annotationType) {\n\t\tthrow new RuntimeException(\"unimplemented\");\n\t}\n\n}\n",
    "size": 3297
  },
  {
    "file_id": "F116",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/TraceFactoryTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2006 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Matthew Webster - initial implementation\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.tools.Trace;\nimport org.aspectj.weaver.tools.TraceFactory;\n\nimport junit.framework.TestCase;\n\npublic class TraceFactoryTest extends TestCase {\n\n\tpublic void testGetTraceFactory() {\n\t\tTraceFactory traceFactory = TraceFactory.getTraceFactory();\n\t\tassertNotNull(traceFactory);\n\t}\n\n\tpublic void testGetTrace() {\n\t\tTraceFactory traceFactory = TraceFactory.getTraceFactory();\n\t\tTrace trace = traceFactory.getTrace(getClass());\n\t\tassertNotNull(trace);\n\t}\n\n}\n",
    "size": 1050
  },
  {
    "file_id": "F117",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/TypeVariableReferenceTypeTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\n/**\n * @author colyer\n *\n */\npublic class TypeVariableReferenceTypeTestCase extends TestCase {\n\n\tReferenceType javaLangClass;\n\tReferenceType jlNumber;\n\tReferenceType javaLangObject;\n\tBoundedReferenceType extendsClass;\n\tBoundedReferenceType superClass;\n\tBoundedReferenceType extendsWithExtras;\n\tBcelWorld world;\n\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tworld = new BcelWorld(\"../bin\");\n\t\tworld.setBehaveInJava5Way(true);\n\t\tjavaLangClass = (ReferenceType) world.resolve(UnresolvedType.forName(\"java/lang/Class\"));\n\t\tjlNumber = (ReferenceType) world.resolve(UnresolvedType.forSignature(\"Ljava/lang/Number;\"));\n\t\tjavaLangObject = (ReferenceType) world.resolve(UnresolvedType.OBJECT);\n\t\textendsClass = new BoundedReferenceType(javaLangClass, true, world);\n\t\tsuperClass = new BoundedReferenceType(javaLangClass, false, world);\n\t\textendsWithExtras = new BoundedReferenceType(javaLangClass, true, world, new ReferenceType[] { (ReferenceType) world\n\t\t\t\t.resolve(UnresolvedType.forName(\"java/util/List\")) });\n\t}\n\n\tpublic void testConstructionByNameAndVariable() {\n\t\tTypeVariable tv = new TypeVariable(\"T\", javaLangClass);\n\t\tTypeVariableReferenceType tvrt = new TypeVariableReferenceType(tv, world);\n\t\tassertEquals(\"T\", tvrt.getTypeVariable().getName());\n\t\tassertEquals(javaLangClass, tvrt.getTypeVariable().getUpperBound());\n\t}\n\n\tpublic void testBounds() {\n\t\t// Load up the testclass from below\n\t\tResolvedType testerClass = world.resolve(Tester1.class.getName());\n\t\tResolvedType genericTesterClass = testerClass.getGenericType();\n\n\t\t// Check the declaration type variable\n\t\tTypeVariable[] typevars = genericTesterClass.getTypeVariables();\n\t\tTypeVariable typevar = typevars[0];\n\t\tassertEquals(jlNumber, typevar.getUpperBound());\n\t\tassertEquals(\"T\", typevar.getName());\n\t\tResolvedMember member = genericTesterClass.getDeclaredMethods()[1];\n\n\t\t// getParameterTypes() returning the erased parameter\n\t\tUnresolvedType param = member.getParameterTypes()[0];\n\t\tassertEquals(jlNumber, param);\n\n\t\t// Check the type variable reference\n\t\tTypeVariableReferenceType tvReference = (TypeVariableReferenceType) member.getGenericParameterTypes()[0];\n\t\tassertEquals(\"T\", tvReference.getTypeVariableName());\n\t\tassertEquals(jlNumber, tvReference.getUpperBound());\n\t\tassertEquals(jlNumber, tvReference.getDelegate().getResolvedTypeX());\n\t}\n\n\tclass Tester1<T extends Number> {\n\t\tpublic void method(T t) {\n\t\t}\n\t}\n\n}\n",
    "size": 3028
  },
  {
    "file_id": "F118",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/TypeVariableTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\npublic class TypeVariableTestCase extends TestCase {\n\n\tprivate UnresolvedType javaLangNumber;\n\tprivate UnresolvedType javaLangDouble;\n\tprivate UnresolvedType javaUtilList;\n\tprivate UnresolvedType javaIoSerializable;\n\tprivate World world;\n\n\tpublic void testName() {\n\t\tTypeVariable tv = new TypeVariable(\"T\");\n\t\tassertEquals(\"T\", tv.getName());\n\t}\n\n\tpublic void testDefaultBounds() {\n\t\tTypeVariable tv = new TypeVariable(\"T\");\n\t\tassertEquals(\"Object\", UnresolvedType.OBJECT, tv.getFirstBound());\n\t\tassertNull(tv.getUpperBound());\n\t\tassertEquals(\"no additional bounds\", 0, tv.getSuperInterfaces().length);\n\t}\n\n\tpublic void testUpperBound() {\n\t\tTypeVariable tv = new TypeVariable(\"N\", javaLangNumber);\n\t\tassertEquals(\"java.lang.Number\", javaLangNumber, tv.getUpperBound());\n\t}\n\n\tpublic void testAdditionalUpperBounds() {\n\t\tTypeVariable tv = new TypeVariable(\"E\", UnresolvedType.OBJECT, new UnresolvedType[] { javaUtilList });\n\t\tassertEquals(\"1 additional bound\", 1, tv.getSuperInterfaces().length);\n\t\tassertEquals(\"java.util.List\", javaUtilList, tv.getSuperInterfaces()[0]);\n\n\t\ttv = new TypeVariable(\"E\", null, new UnresolvedType[] { javaUtilList });\n\t\tassertEquals(\"1 additional bound\", 1, tv.getSuperInterfaces().length);\n\t\tassertEquals(\"java.util.List\", javaUtilList, tv.getSuperInterfaces()[0]);\n\t}\n\n\tpublic void testResolution() {\n\t\tTypeVariable tv = new TypeVariable(\"T\", javaLangNumber, new UnresolvedType[] { javaUtilList });\n\t\ttv.resolve(world);\n\t\tassertEquals(\"resolved number\", javaLangNumber.resolve(world), tv.getUpperBound());\n\t\tassertEquals(\"resolved list\", javaUtilList.resolve(world), tv.getSuperInterfaces()[0]);\n\t}\n\n\tpublic void testBindWithoutResolve() {\n\t\tTypeVariable tv = new TypeVariable(\"X\");\n\t\ttry {\n\t\t\ttv.canBeBoundTo(null);\n\t\t\tfail(\"Should throw illegal state exception\");\n\t\t} catch (IllegalStateException ex) {\n\t\t}\n\t}\n\n\tpublic void testCanBindToUpperMatch() {\n\t\tTypeVariable tv = new TypeVariable(\"X\", javaLangNumber);\n\t\ttv.resolve(world);\n\t\tassertTrue(tv.canBeBoundTo(javaLangDouble.resolve(world)));\n\t}\n\n\tpublic void testCanBindToUpperFail() {\n\t\tTypeVariable tv = new TypeVariable(\"X\", javaLangNumber);\n\t\ttv.resolve(world);\n\t\tassertFalse(tv.canBeBoundTo(UnresolvedType.OBJECT.resolve(world)));\n\t}\n\n\tpublic void testCanBindToInterfaceMatch() {\n\t\tTypeVariable tv = new TypeVariable(\"T\", javaLangNumber, new UnresolvedType[] { javaIoSerializable });\n\t\ttv.resolve(world);\n\t\tassertTrue(tv.canBeBoundTo(javaLangDouble.resolve(world)));\n\t}\n\n\tpublic void testCanBindToInterfaceFail() {\n\t\tTypeVariable tv = new TypeVariable(\"T\", javaLangNumber, new UnresolvedType[] { javaUtilList });\n\t\ttv.resolve(world);\n\t\tassertFalse(tv.canBeBoundTo(javaLangDouble.resolve(world)));\n\t}\n\n\t// ---\n\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tjavaLangNumber = UnresolvedType.forSignature(\"Ljava/lang/Number;\");\n\t\tjavaLangDouble = UnresolvedType.forSignature(\"Ljava/lang/Double;\");\n\t\tjavaIoSerializable = UnresolvedType.forSignature(\"Ljava/io/Serializable;\");\n\t\tjavaUtilList = UnresolvedType.forSignature(\"Ljava/util/List;\");\n\t\tworld = new BcelWorld();\n\t}\n\n\t@Override\n\tprotected void tearDown() throws Exception {\n\t\tsuper.tearDown();\n\t}\n\n}\n",
    "size": 3782
  },
  {
    "file_id": "F119",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/TypeXTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver;\n\nimport org.aspectj.testing.util.TestUtil;\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\n/**\n * This is a test case for all the portions of UnresolvedType that don't require a world.\n */\npublic class TypeXTestCase extends TestCase {\n\n    public TypeXTestCase(String name) {\n        super(name);\n    }\n\n    public void testUnresolvedTypes() {\n        // basic equality\n        String[] testNames =\n            new String[] {\"int\", \"long\", \"int[]\", \"boolean[][]\",\n                           \"java.lang.String\", \"java.lang.String[]\", \"void\" };\n        String[] testSigs =\n            new String[] {\"I\", \"J\", \"[I\", \"[[Z\",\n                            \"Ljava/lang/String;\", \"[Ljava/lang/String;\", \"V\" };\n\n        String[] componentNames =\n            new String[] {null, null, \"int\", \"boolean[]\",\n                            null, \"java.lang.String\", null };\n\n        int[] sizes = new int[] {1, 2, 1, 1, 1, 1, 0};\n\n        boolean[] isPrimitive =\n            new boolean[] { true, true, false, false, false, false, true };\n\n        nameSignatureTest(testNames, testSigs);\n        arrayTest(UnresolvedType.forNames(testNames), componentNames);\n        arrayTest(UnresolvedType.forSignatures(testSigs), componentNames);\n\n        sizeTest(UnresolvedType.forNames(testNames), sizes);\n        sizeTest(UnresolvedType.forSignatures(testSigs), sizes);\n\n        isPrimitiveTest(UnresolvedType.forSignatures(testSigs), isPrimitive);\n    }\n\n    public void testNameAndSigWithInners() {\n    \tUnresolvedType t = UnresolvedType.forName(\"java.util.Map$Entry\");\n    \tassertEquals(t.getName(), \"java.util.Map$Entry\");\n    \tassertEquals(t.getSignature(), \"Ljava/util/Map$Entry;\");\n    \tassertEquals(t.getOutermostType(), UnresolvedType.forName(\"java.util.Map\"));\n    \tassertEquals(UnresolvedType.forName(\"java.util.Map\").getOutermostType(), UnresolvedType.forName(\"java.util.Map\"));\n    }\n\n\tpublic void testNameAndSigWithParameters() {\n\t\tUnresolvedType t = UnresolvedType.forName(\"java.util.List<java.lang.String>\");\n\t\tassertEquals(t.getName(),\"java.util.List<java.lang.String>\");\n\t\tassertEquals(t.getSignature(),\"Pjava/util/List<Ljava/lang/String;>;\");\n\t\tt = UnresolvedType.forSignature(\"Pjava/util/List<Ljava/lang/String;>;\");\n\t\tassertEquals(t.getName(),\"java.util.List<java.lang.String>\");\n\t\tassertEquals(t.getSignature(),\"Pjava/util/List<Ljava/lang/String;>;\");\n\t\tt = UnresolvedType.forName(\"java.util.Map<java.util.String,java.util.List<java.lang.Integer>>\");\n\t\tassertEquals(t.getName(),\"java.util.Map<java.util.String,java.util.List<java.lang.Integer>>\");\n\t\tassertEquals(t.getSignature(),\"Pjava/util/Map<Ljava/util/String;Pjava/util/List<Ljava/lang/Integer;>;>;\");\n\t\tt = UnresolvedType.forSignature(\"Pjava/util/Map<Ljava/util/String;Pjava/util/List<Ljava/lang/Integer;>;>;\");\n\t\tassertEquals(t.getName(),\"java.util.Map<java.util.String,java.util.List<java.lang.Integer>>\");\n\t\tassertEquals(t.getSignature(),\"Pjava/util/Map<Ljava/util/String;Pjava/util/List<Ljava/lang/Integer;>;>;\");\n\t}\n\n\t/**\n\t * Verify UnresolvedType signature processing creates the right kind of UnresolvedType's from a signature.\n\t *\n\t * For example, calling UnresolvedType.dump() for\n\t *   \"Ljava/util/Map<Ljava/util/List<Ljava/lang/String;>;Ljava/lang/String;>;\"\n\t * results in:\n\t *   UnresolvedType:  signature=Ljava/util/Map<Ljava/util/List<Ljava/lang/String;>;Ljava/lang/String;>; parameterized=true #params=2\n     *     UnresolvedType:  signature=Ljava/util/List<Ljava/lang/String;>; parameterized=true #params=1\n     *       UnresolvedType:  signature=Ljava/lang/String; parameterized=false #params=0\n     *     UnresolvedType:  signature=Ljava/lang/String; parameterized=false #params=0\n\t */\n\tpublic void testTypexGenericSignatureProcessing() {\n\t\tUnresolvedType tx = null;\n\n\t\ttx = UnresolvedType.forSignature(\"Pjava/util/Set<Ljava/lang/String;>;\");\n\t\tcheckTX(tx,true,1);\n\n\t\ttx = UnresolvedType.forSignature(\"Pjava/util/Set<Pjava/util/List<Ljava/lang/String;>;>;\");\n\t\tcheckTX(tx,true,1);\n\n\t\ttx = UnresolvedType.forSignature(\"Pjava/util/Map<Pjava/util/List<Ljava/lang/String;>;Ljava/lang/String;>;\");\n\t\tcheckTX(tx,true,2);\n\t\tcheckTX(tx.getTypeParameters()[0],true,1);\n\t\tcheckTX(tx.getTypeParameters()[1],false,0);\n//\t\tSystem.err.println(tx.dump());\n\t}\n\n\tpublic void testTypeXForParameterizedTypes() {\n\t\tWorld world = new BcelWorld();\n\t\tUnresolvedType stringType = UnresolvedType.forName(\"java/lang/String\");\n\t\tResolvedType listOfStringType =\n\t\t\tTypeFactory.createParameterizedType(\n\t\t\t\t\t\t\tUnresolvedType.forName(\"java/util/List\").resolve(world),\n\t\t\t\t\t\t\tnew UnresolvedType[] {stringType},\n\t\t\t\t\t\t\tworld);\n\t\tassertEquals(\"1 type param\",1,listOfStringType.typeParameters.length);\n\t\tassertEquals(stringType,listOfStringType.typeParameters[0]);\n\t\tassertTrue(listOfStringType.isParameterizedType());\n\t\tassertFalse(listOfStringType.isGenericType());\n\t}\n\n\tpublic void testTypeFactoryForParameterizedTypes() {\n\t\tUnresolvedType enumOfSimpleType =\n\t\t\tTypeFactory.createTypeFromSignature(\"Pjava/lang/Enum<Ljava/lang/String;>;\");\n\t\tassertEquals(1, enumOfSimpleType.getTypeParameters().length);\n\n\t\tUnresolvedType enumOfNestedType =\n\t\t\tTypeFactory.createTypeFromSignature(\"Pjava/lang/Enum<Ljavax/jws/soap/SOAPBinding$ParameterStyle;>;\");\n\t\tassertEquals(1, enumOfNestedType.getTypeParameters().length);\n\n\t\t// is this signature right?\n\t\tUnresolvedType nestedTypeOfParameterized =\n\t\t\tTypeFactory.createTypeFromSignature(\"PMyInterface<Ljava/lang/String;>$MyOtherType;\");\n\t\tassertEquals(0, nestedTypeOfParameterized.getTypeParameters().length);\n\n\t\t// how about this one? is this valid?\n\t\tUnresolvedType doublyNestedTypeSignatures =\n\t\t\tTypeFactory.createTypeFromSignature(\"PMyInterface<Ljava/lang/String;Ljava/lang/String;>$MyOtherType<Ljava/lang/Object;>;\");\n\t\tassertEquals(1, doublyNestedTypeSignatures.getTypeParameters().length);\n\n\t}\n\n\tprivate void checkTX(UnresolvedType tx,boolean shouldBeParameterized,int numberOfTypeParameters) {\n\t\tassertTrue(\"Expected parameterization flag to be \"+shouldBeParameterized,tx.isParameterizedType()==shouldBeParameterized);\n\t\tif (numberOfTypeParameters==0) {\n\t\t\tUnresolvedType[] params = tx.getTypeParameters();\n\t\t\tassertTrue(\"Expected 0 type parameters but found \"+params.length, params.length==0);\n\t    } else {\n\t\t\t\tassertTrue(\"Expected #type parameters to be \"+numberOfTypeParameters,tx.getTypeParameters().length==numberOfTypeParameters);\n\t    }\n\t}\n\n\n    private void isPrimitiveTest(UnresolvedType[] types, boolean[] isPrimitives) {\n        for (int i = 0, len = types.length; i < len; i++) {\n            UnresolvedType type = types[i];\n            boolean b = isPrimitives[i];\n            assertEquals(type + \" is primitive: \", b, type.isPrimitiveType());\n        }\n    }\n\n    private void sizeTest(UnresolvedType[] types, int[] sizes) {\n        for (int i = 0, len = types.length; i < len; i++) {\n            UnresolvedType type = types[i];\n            int size = sizes[i];\n            assertEquals(\"size of \" + type + \": \", size, type.getSize());\n        }\n    }\n\n    private void arrayTest(UnresolvedType[] types, String[] components) {\n        for (int i = 0, len = types.length; i < len; i++) {\n            UnresolvedType type = types[i];\n            String component = components[i];\n            assertEquals(type + \" is array: \", component != null, type.isArray());\n            if (component != null)\n                assertEquals(type + \" componentType: \", component,\n                    type.getComponentType().getName());\n        }\n    }\n\n    private void nameSignatureTest(String[] ns, String[] ss) {\n        for (int i = 0, len = ns.length; i < len; i++) {\n            String n = ns[i];\n            String s = ss[i];\n            UnresolvedType tn = UnresolvedType.forName(n);\n            UnresolvedType ts = UnresolvedType.forSignature(s);\n\n            assertEquals(\"forName(n).getName()\", n,\n                tn.getName());\n            assertEquals(\"forSignature(s).getSignature()\", s,\n                ts.getSignature());\n            assertEquals(\"forName(n).getSignature()\", s,\n                tn.getSignature());\n            assertEquals(\"forSignature(n).getName()\", n,\n                ts.getName());\n\n            TestUtil.assertCommutativeEquals(tn, tn, true);\n            TestUtil.assertCommutativeEquals(ts, ts, true);\n            TestUtil.assertCommutativeEquals(tn, ts, true);\n\n            for (int j = 0; j < len; j++) {\n                if (i == j) continue;\n                UnresolvedType tn1 = UnresolvedType.forName(ns[j]);\n                UnresolvedType ts1 = UnresolvedType.forSignature(ss[j]);\n                TestUtil.assertCommutativeEquals(tn, tn1, false);\n                TestUtil.assertCommutativeEquals(ts, tn1, false);\n                TestUtil.assertCommutativeEquals(tn, ts1, false);\n                TestUtil.assertCommutativeEquals(ts, ts1, false);\n            }\n        }\n    }\n\n\n}\n",
    "size": 9397
  },
  {
    "file_id": "F120",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/WeaverMessagesTestCase.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2004 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.aspectj.weaver;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.MissingResourceException;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Adrian Colyer\n */\npublic class WeaverMessagesTestCase extends TestCase {\n\n\tpublic void testAllMessagesDefined() {\n\n\t\tClass<?> wmClass = WeaverMessages.class;\n\t\tField[] fields = wmClass.getDeclaredFields();\n\t\tList<String> fieldList = new ArrayList<>();\n\t\tfor (Field f : fields) {\n\t\t\tif (f.getType() == String.class) {\n\t\t\t\ttry {\n\t\t\t\t\tString key = (String) f.get(null);\n//\t\t\t\t\tString value = WeaverMessages.format(key);\n\t\t\t\t\tassertFalse(\"Each key should be unique\", fieldList.contains(key));\n\t\t\t\t\tfieldList.add(key);\n//\t\t\t\t\tSystem.out.println(key + \",\" + value);\n\t\t\t\t} catch (IllegalAccessException ex) {\n\t\t\t\t} catch (MissingResourceException mrEx) {\n\t\t\t\t\tfail(\"Missing resource: \" + mrEx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "size": 1466
  },
  {
    "file_id": "F121",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/WeaverModuleTests.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\npackage org.aspectj.weaver;\n\nimport org.aspectj.matcher.tools.ReflectionWorldAdvancedPointcutExpressionTest;\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.bcel.AfterReturningWeaveTestCase;\nimport org.aspectj.weaver.bcel.AfterThrowingWeaveTestCase;\nimport org.aspectj.weaver.bcel.AfterWeaveTestCase;\nimport org.aspectj.weaver.bcel.ArgsWeaveTestCase;\nimport org.aspectj.weaver.bcel.AroundArgsWeaveTestCase;\nimport org.aspectj.weaver.bcel.AroundWeaveTestCase;\nimport org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXTestCase;\nimport org.aspectj.weaver.bcel.BcelWorldReferenceTypeTest;\nimport org.aspectj.weaver.bcel.BeforeWeaveTestCase;\nimport org.aspectj.weaver.bcel.CheckerTestCase;\nimport org.aspectj.weaver.bcel.ClassLoaderRepositoryTest;\nimport org.aspectj.weaver.bcel.FieldSetTestCase;\nimport org.aspectj.weaver.bcel.HierarchyDependsTestCase;\nimport org.aspectj.weaver.bcel.IdWeaveTestCase;\nimport org.aspectj.weaver.bcel.JImageTestCase;\nimport org.aspectj.weaver.bcel.MegaZipTestCase;\nimport org.aspectj.weaver.bcel.MoveInstructionsWeaveTestCase;\nimport org.aspectj.weaver.bcel.NonstaticWeaveTestCase;\nimport org.aspectj.weaver.bcel.PatternWeaveTestCase;\nimport org.aspectj.weaver.bcel.PointcutResidueTestCase;\nimport org.aspectj.weaver.bcel.TjpWeaveTestCase;\nimport org.aspectj.weaver.bcel.TraceJarWeaveTestCase;\nimport org.aspectj.weaver.bcel.UtilityTestCase;\nimport org.aspectj.weaver.bcel.WeaveOrderTestCase;\nimport org.aspectj.weaver.bcel.WorldTestCase;\nimport org.aspectj.weaver.bcel.ZipTestCase;\nimport org.aspectj.weaver.patterns.AnnotationPatternMatchingTestCase;\nimport org.aspectj.weaver.patterns.AnnotationPatternTestCase;\nimport org.aspectj.weaver.patterns.ConcretizationTestCase;\nimport org.aspectj.weaver.patterns.WildTypePatternResolutionTestCase;\nimport org.aspectj.weaver.patterns.bcel.BcelAndOrNotTestCase;\nimport org.aspectj.weaver.patterns.bcel.BcelBindingTestCase;\nimport org.aspectj.weaver.patterns.bcel.BcelModifiersPatternTestCase;\nimport org.aspectj.weaver.patterns.bcel.BcelParserTestCase;\nimport org.aspectj.weaver.patterns.bcel.BcelSignaturePatternTestCase;\nimport org.aspectj.weaver.patterns.bcel.BcelTypePatternListTestCase;\nimport org.aspectj.weaver.patterns.bcel.BcelTypePatternTestCase;\nimport org.aspectj.weaver.patterns.bcel.BcelWithinTestCase;\nimport org.aspectj.weaver.reflect.ReflectionWorldReferenceTypeTest;\nimport org.aspectj.weaver.reflect.ReflectionWorldTest;\nimport org.aspectj.weaver.tools.Java15PointcutExpressionTest;\nimport org.aspectj.weaver.tools.PointcutDesignatorHandlerTest;\nimport org.aspectj.weaver.tools.PointcutExpressionTest;\nimport org.aspectj.weaver.tools.PointcutParserTest;\nimport org.aspectj.weaver.tools.ReadingAttributesTest;\nimport org.aspectj.weaver.tools.TypePatternMatcherTest;\nimport org.aspectj.weaver.tools.cache.DefaultCacheKeyResolverTest;\nimport org.aspectj.weaver.tools.cache.DefaultFileCacheBackingTest;\nimport org.aspectj.weaver.tools.cache.FlatFileCacheBackingTest;\nimport org.aspectj.weaver.tools.cache.SimpleClassCacheTest;\nimport org.aspectj.weaver.tools.cache.WeavedClassCacheTest;\nimport org.aspectj.weaver.tools.cache.ZippedFileCacheBackingTest;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\n\npublic class WeaverModuleTests extends TestCase {\n\n\tpublic static Test suite() {\n\t\tTestSuite suite = new TestSuite(WeaverModuleTests.class.getName());\n\t\tsuite.addTestSuite(BoundedReferenceTypeTestCase.class);\n\t\tsuite.addTestSuite(CommonsTraceFactoryTest.class);\n\t\tsuite.addTestSuite(CommonsTraceTest.class);\n\t\tsuite.addTestSuite(DefaultTraceFactoryTest.class);\n\t\tsuite.addTestSuite(DefaultTraceTest.class);\n\t\tsuite.addTestSuite(DumpTestCase.class);\n\t\tsuite.addTestSuite(GenericSignatureParserTest.class);\n\t\tsuite.addTestSuite(Java5ReflectionBasedReferenceTypeDelegateTest.class);\n\t\tsuite.addTestSuite(Jdk14TraceFactoryTest.class);\n\t\tsuite.addTestSuite(Jdk14TraceTest.class);\n\t\tsuite.addTestSuite(JoinPointSignatureIteratorTest.class);\n\t\tsuite.addTestSuite(LocaleTest.class);\n\t\tsuite.addTestSuite(Member15Test.class);\n\t\tsuite.addTestSuite(Member15TestCase.class);\n\t\tsuite.addTestSuite(MemberTestCase.class);\n\t\tsuite.addTestSuite(ParameterizedReferenceTypeTestCase.class);\n\t\tsuite.addTestSuite(ReferenceTypeTestCase.class);\n\t\tsuite.addTestSuite(ResolvedMemberSignatures15TestCase.class);\n\t\tsuite.addTestSuite(TraceFactoryTest.class);\n\t\tsuite.addTestSuite(TypeVariableTestCase.class);\n\t\tsuite.addTestSuite(WeaverMessagesTestCase.class);\n\n\t\tsuite.addTestSuite(AfterReturningWeaveTestCase.class);\n\t\tsuite.addTestSuite(AfterThrowingWeaveTestCase.class);\n\t\tsuite.addTestSuite(AfterWeaveTestCase.class);\n\t\tsuite.addTestSuite(ArgsWeaveTestCase.class);\n\t\tsuite.addTestSuite(AroundArgsWeaveTestCase.class);\n\t\tsuite.addTestSuite(AroundWeaveTestCase.class);\n\t\tsuite.addTestSuite(BcelGenericSignatureToTypeXTestCase.class);\n\t\tsuite.addTestSuite(BcelWorldReferenceTypeTest.class);\n\t\tsuite.addTestSuite(BeforeWeaveTestCase.class);\n\t\tsuite.addTestSuite(CheckerTestCase.class);\n\t\tsuite.addTestSuite(ClassLoaderRepositoryTest.class);\n\t\tsuite.addTestSuite(FieldSetTestCase.class);\n\t\tsuite.addTestSuite(HierarchyDependsTestCase.class);\n\t\tsuite.addTestSuite(IdWeaveTestCase.class);\n        if (LangUtil.isVMGreaterOrEqual(9)) {\n        \tsuite.addTestSuite(JImageTestCase.class);\n        }\n\t\tsuite.addTestSuite(MegaZipTestCase.class);\n\t\tsuite.addTestSuite(MoveInstructionsWeaveTestCase.class);\n\t\tsuite.addTestSuite(NonstaticWeaveTestCase.class);\n\t\tsuite.addTestSuite(PatternWeaveTestCase.class);\n\t\tsuite.addTestSuite(PointcutResidueTestCase.class);\n\t\tsuite.addTestSuite(TjpWeaveTestCase.class);\n\t\tsuite.addTestSuite(TraceJarWeaveTestCase.class);\n\t\tsuite.addTestSuite(UtilityTestCase.class);\n\t\tsuite.addTestSuite(WeaveOrderTestCase.class);\n\t\tsuite.addTestSuite(WorldTestCase.class);\n\t\tsuite.addTestSuite(ZipTestCase.class);\n\t\tsuite.addTestSuite(TypeXTestCase.class);\n\n\t\tsuite.addTestSuite(AnnotationPatternMatchingTestCase.class);\n\t\tsuite.addTestSuite(AnnotationPatternTestCase.class);\n\t\tsuite.addTestSuite(ConcretizationTestCase.class);\n\t\tsuite.addTestSuite(WildTypePatternResolutionTestCase.class);\n\n\t\tsuite.addTestSuite(BcelAndOrNotTestCase.class);\n\t\tsuite.addTestSuite(BcelBindingTestCase.class);\n\t\tsuite.addTestSuite(BcelModifiersPatternTestCase.class);\n\t\tsuite.addTestSuite(BcelParserTestCase.class);\n\t\tsuite.addTestSuite(BcelSignaturePatternTestCase.class);\n\t\tsuite.addTestSuite(BcelTypePatternListTestCase.class);\n\t\tsuite.addTestSuite(BcelTypePatternTestCase.class);\n\t\tsuite.addTestSuite(BcelWithinTestCase.class);\n\n\t\tsuite.addTestSuite(ReflectionWorldReferenceTypeTest.class);\n\t\tsuite.addTestSuite(ReflectionWorldTest.class);\n\n\t\tsuite.addTestSuite(Java15PointcutExpressionTest.class);\n\t\tsuite.addTestSuite(PointcutDesignatorHandlerTest.class);\n\t\tsuite.addTestSuite(PointcutExpressionTest.class);\n\t\tsuite.addTestSuite(PointcutParserTest.class);\n\t\tsuite.addTestSuite(ReadingAttributesTest.class);\n\t\tsuite.addTestSuite(TypePatternMatcherTest.class);\n\n\t\tsuite.addTestSuite(DefaultCacheKeyResolverTest.class);\n\t\tsuite.addTestSuite(DefaultFileCacheBackingTest.class);\n\t\tsuite.addTestSuite(FlatFileCacheBackingTest.class);\n\t\tsuite.addTestSuite(SimpleClassCacheTest.class);\n\t\tsuite.addTestSuite(WeavedClassCacheTest.class);\n\t\tsuite.addTestSuite(ZippedFileCacheBackingTest.class);\n\n\t\tsuite.addTestSuite(ReflectionWorldAdvancedPointcutExpressionTest.class);\n\t\tsuite.addTestSuite(TypeVariableReferenceTypeTestCase.class);\n\n\t\treturn suite;\n\t}\n\n\tpublic WeaverModuleTests(String name) {\n\t\tsuper(name);\n\t}\n\n}\n",
    "size": 8065
  },
  {
    "file_id": "F122",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/WeaverTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver;\n\nimport java.io.File;\n\nimport org.aspectj.util.FileUtil;\n\nimport junit.framework.TestCase;\n\npublic abstract class WeaverTestCase extends TestCase {\n\n\tpublic static final String TESTDATA_PATH = \"../weaver/testdata\";\n\tpublic static final String OUTDIR_PATH = \"../weaver/out\";\n\n\t/** @return File outDir (writable) or null if unable to write */\n\tpublic static File getOutdir() {\n\t\tFile result = new File(OUTDIR_PATH);\n\t\tif (result.mkdirs() || (result.canWrite() && result.isDirectory())) {\n\t\t\treturn result;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** best efforts to delete the output directory and any contents */\n\tpublic static void removeOutDir() {\n\t\tFile outDir = getOutdir();\n\t\tif (null != outDir) {\n\t\t\tFileUtil.deleteContents(outDir);\n\t\t\toutDir.delete();\n\t\t}\n\t}\n\n\tpublic WeaverTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n}\n",
    "size": 1374
  },
  {
    "file_id": "F123",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/AfterReturningWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\n\nimport org.aspectj.weaver.ShadowMunger;\n\npublic class AfterReturningWeaveTestCase extends WeaveTestCase {\n    {\n        regenerate = false;\n    }\n\n    public AfterReturningWeaveTestCase(String name) {\n        super(name);\n    }\n\n    public void testAfterReturning() throws IOException {\n        weaveTest(\n            getStandardTargets(),\n            \"AfterReturning\",\n            makeAdviceAll(\"afterReturning\"));\n    }\n\n    public void testAfterReturningParam() throws IOException {\n        weaveTest(\n            getStandardTargets(),\n            \"AfterReturningParam\",\n            makeAdviceField(\"afterReturning\", \"java.lang.Object\"));\n    }\n    public void testAfterReturningCheckcastParam() throws IOException {\n        weaveTest(\n            getStandardTargets(),\n            \"AfterReturningCheckcastParam\",\n            makeAdviceField(\"afterReturning\", \"java.rmi.server.LogStream\"));\n    }\n\n    public void testAfterReturningConversionParam() throws IOException {\n        String mungerString =\n            \"afterReturning(): call(int *.*(..)) -> \"\n                + \"static void Aspect.ajc_afterReturning_field_get(java.lang.Object)\";\n        ShadowMunger cm = makeConcreteAdvice(mungerString, 1);\n\n        weaveTest(\"FancyHelloWorld\", \"AfterReturningConversionParam\", cm);\n    }\n\n}\n",
    "size": 1894
  },
  {
    "file_id": "F124",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/AfterThrowingWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\n\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ShadowMunger;\n\npublic class AfterThrowingWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic AfterThrowingWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\tpublic void testAfterThrowing() throws IOException {\n\t\tweaveTest(getStandardTargets(), \"AfterThrowing\", makeAdviceAll(\"afterThrowing\"));\n\t}\n\n\tpublic void testAfterThrowingParam() throws IOException {\n\t\tBcelWorld world = new BcelWorld();\n\n\t\tShadowMunger myMunger = BcelTestUtils.shadowMunger(world,\n\t\t\t\t\"afterThrowing(): get(* *.out) -> static void Aspect.ajc_afterThrowing_field_get(java.lang.Throwable)\",\n\t\t\t\tAdvice.ExtraArgument);\n\t\tShadowMunger cm = myMunger.concretize(ResolvedType.MISSING, world, null);\n\n\t\tweaveTest(getStandardTargets(), \"AfterThrowingParam\", cm);\n\t}\n\n}\n",
    "size": 1455
  },
  {
    "file_id": "F125",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/AfterWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\n\npublic class AfterWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic AfterWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\n\tpublic void testAfter() throws IOException {\n\t\tweaveTest(getStandardTargets(), \"After\", makeAdviceAll(\"after\"));\n\t}\n}\n",
    "size": 867
  },
  {
    "file_id": "F126",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/ArgsWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionHandle;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.MemberImpl;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.UnresolvedType;\n\n/**.\n */\npublic class ArgsWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic ArgsWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\n    public void testAfterReturningArgs() throws IOException {\n        weaveTest(\"HelloWorld\", \"ArgsAfterReturningHelloWorld\", makeArgsMunger(\"afterReturning\"));\n    }\n\n\n    public void testFancyAfterReturningArgs() throws IOException {\n        weaveTest(\"FancyHelloWorld\", \"ArgsAfterReturningFancyHelloWorld\", makeArgsMunger(\"afterReturning\"));\n    }\n\n    public void testThrowing() throws IOException {\n        weaveTest(\"HelloWorld\", \"ArgsAfterThrowingHelloWorld\", makeArgsMunger(\"afterThrowing\"));\n    }\n\n    public void testLots() throws IOException {\n        List<ShadowMunger> l = new ArrayList<>();\n\n        BcelAdvice p1 =\n            makeArgsMunger(\"before\");\n\n        BcelAdvice p2 =\n            makeArgsMunger(\"afterThrowing\");\n\n        BcelAdvice p3 =\n            makeArgsMunger(\"afterReturning\");\n\n        l.add(p1);\n        l.add(p2);\n        l.add(p3);\n\n        weaveTest(\"HelloWorld\", \"ArgsBeforeAfterHelloWorld\", addLexicalOrder(l));\n    }\n\n\t/* private */ InstructionList getArgsAdviceTag(BcelShadow shadow, String where) {\n\t\tString methodName =\n\t\t\t\"ajc_\" + where + \"_\" + shadow.getKind().toLegalJavaIdentifier();\n\t\tInstructionFactory fact = shadow.getFactory();\n\t\tInstructionList il = new InstructionList();\n\n\n        il.append(\n            BcelRenderer.renderExpr(\n                fact,\n                new BcelWorld(),\n                shadow.getArgVar(0),\n                Type.OBJECT));\n\n        il.append(\n            fact.createInvoke(\n                \"Aspect\",\n                methodName,\n                Type.VOID,\n                new Type[] { Type.OBJECT },\n                Constants.INVOKESTATIC));\n\n\t\treturn il;\n\t}\n\n    private BcelAdvice makeArgsMunger(final String kindx) {\n    \tResolvedType rtx = world.resolve(UnresolvedType.forName(\"Aspect\"),true);\n    \tassertTrue(\"Cant find required type Aspect\",!rtx.isMissing());\n        return new BcelAdvice(AdviceKind.stringToKind(kindx), makePointcutNoZeroArg(),\n        \t\t\tMemberImpl.method(UnresolvedType.forName(\"Aspect\"), 0, \"foo\", \"()V\"), 0, -1, -1, null,\n        \t\t\trtx) {\n            @Override\n\t\t\tpublic void specializeOn(Shadow shadow) {\n                super.specializeOn(shadow);\n                shadow.getArgVar(0);\n            }\n            @Override\n\t\t\tpublic InstructionList getAdviceInstructions(BcelShadow shadow, BcelVar extraVar, InstructionHandle fk) {\n                return getArgsAdviceTag(shadow, kindx);\n            }\n        };\n    }\n\n}\n",
    "size": 3734
  },
  {
    "file_id": "F127",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/AroundArgsWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\n\nimport org.aspectj.weaver.ShadowMunger;\n\npublic class AroundArgsWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic AroundArgsWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n    public void testWeave() throws IOException\n    {\n    \tString label = \"AroundArgs\";\n    \tShadowMunger p =\n                makeConcreteAdvice(\n\t\t\t\t\t\"around(list) : \"\n\t\t\t\t\t+ \"(call(public * add(..)) && target(list)) -> \"\n\t\t\t\t\t+ \"static boolean Aspect.ajc_around0\"\n\t\t\t\t\t+ \"(java.util.ArrayList, org.aspectj.runtime.internal.AroundClosure)\");\n        weaveTest(new String[] {\"DynamicHelloWorld\"}, label, p);\n\n    }\n}\n",
    "size": 1214
  },
  {
    "file_id": "F128",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/AroundWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.MemberImpl;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.UnresolvedType;\n\npublic class AroundWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic AroundWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\tpublic void testAround() throws IOException {\n\t\taroundTest(\"Around\", true);\n\t}\n\n\tpublic void testAroundAll() throws IOException {\n\t\taroundTest(\"AroundAll\", false);\n\t}\n\n    public void testAroundAndOthers() throws IOException {\n    \taroundTestAndOthers(\"AroundAndOthers\", true);\n    }\n\n    public void testAroundAllAndOthers() throws IOException {\n    \taroundTestAndOthers(\"AroundAllAndOthers\", false);\n    }\n\n\n    private BcelAdvice makeAroundMunger(final boolean matchOnlyPrintln) {\n        BcelWorld world = super.world;\n        final Member sig =\n            MemberImpl.method(\n                UnresolvedType.forName(\"Aspect\"),\n                Modifier.STATIC,\n                \"ajc_around\",\n                \"(Lorg/aspectj/runtime/internal/AroundClosure;)Ljava/lang/Object;\");\n\n        return new BcelAdvice(\n        \tAdviceKind.stringToKind(\"around\"),\n        \tmatchOnlyPrintln ? makePointcutPrintln() : makePointcutAll(),\n\t        sig, 0, -1, -1, null, UnresolvedType.forName(\"Aspect\").resolve(world))\n\t    {\n            @Override\n\t\t\tpublic void specializeOn(Shadow s) {\n            \tsuper.specializeOn(s);\n                ((BcelShadow) s).initializeForAroundClosure();\n            }\n        };\n    }\n\n\tprivate void aroundTest(String outName, final boolean matchOnlyPrintln) throws IOException {\n\t\tweaveTest(getStandardTargets(), outName, makeAroundMunger(matchOnlyPrintln));\n\t}\n\n    private void aroundTestAndOthers(String outName, final boolean matchOnlyPrintln)\n            throws IOException\n    {\n\n\t\t// the afterReturning was taken out to avoid circular advice dependency\n\n\t\tList<ShadowMunger> l = new ArrayList<>(makeAdviceAll(\"before\", matchOnlyPrintln));\n        //l.addAll(makeAdviceAll(\"afterReturning\", matchOnlyPrintln));\n\n        l.add(makeAroundMunger(matchOnlyPrintln));\n\n        l.addAll(makeAdviceAll(\"before\", matchOnlyPrintln));\n        //l.addAll(makeAdviceAll(\"afterReturning\", matchOnlyPrintln));\n\n        l.add(makeAroundMunger(matchOnlyPrintln));\n        weaveTest(getStandardTargets(), outName, addLexicalOrder(l));\n    }\n\n}\n",
    "size": 3117
  },
  {
    "file_id": "F129",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.util.Arrays;\n\nimport org.aspectj.apache.bcel.Repository;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.apache.bcel.classfile.Signature;\nimport org.aspectj.util.GenericSignature;\nimport org.aspectj.util.GenericSignature.ClassSignature;\nimport org.aspectj.util.GenericSignatureParser;\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.UnresolvedType;\n\nimport junit.framework.TestCase;\n\n/**\n * @author colyer\n *\n */\npublic class BcelGenericSignatureToTypeXTestCase extends TestCase {\n\n\tpublic final GenericSignature.ClassSignature getGenericClassTypeSignature(JavaClass jClass) {\n\t\tSignature sig = jClass.getSignatureAttribute();\n\t\tif (sig != null) {\n\t\t\tGenericSignatureParser parser = new GenericSignatureParser();\n\t\t\tClassSignature classSig = parser.parseAsClassSignature(sig.getSignature());\n\t\t\treturn classSig;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void testEnumFromHell() throws Exception {\n\t\tBcelWorld world = new BcelWorld();\n\t\tJavaClass javaLangEnum = Repository.lookupClass(\"java/lang/Enum\");\n\t\tGenericSignature.ClassSignature cSig = getGenericClassTypeSignature(javaLangEnum);\n\t\tUnresolvedType superclass = BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(cSig.superclassSignature,\n\t\t\t\tcSig.formalTypeParameters, world);\n\t\tassertEquals(\"Ljava/lang/Object;\", superclass.getSignature());\n\t\tSystem.out.println(Arrays.toString(cSig.superInterfaceSignatures));\n\t\tif (LangUtil.isVMGreaterOrEqual(12)) {\n\t\t\t// [Ljava/lang/constant/Constable;, Ljava/lang/Comparable<TE;>;, Ljava/io/Serializable;]\n\t\t\tassertEquals(\"3 superinterfaces but \"+Arrays.toString(cSig.superInterfaceSignatures), 3, cSig.superInterfaceSignatures.length);\n\t\t} else {\n\t\t\tassertEquals(\"2 superinterfaces\", 2, cSig.superInterfaceSignatures.length);\n\t\t}\n\t\tint idx = LangUtil.isVMGreaterOrEqual(12)?1:0;\n\t\tUnresolvedType comparable = BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(cSig.superInterfaceSignatures[idx++],\n\t\t\t\tcSig.formalTypeParameters, world);\n\t\tassertEquals(\"Pjava/lang/Comparable<TE;>;\", comparable.getSignature());\n\t\tUnresolvedType serializable = BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(\n\t\t\t\tcSig.superInterfaceSignatures[idx++], cSig.formalTypeParameters, world);\n\t\tassertEquals(\"Ljava/io/Serializable;\", serializable.getSignature());\n\t}\n\n\tpublic void testColonColon() throws Exception {\n\t\tBcelWorld world = new BcelWorld();\n\t\tGenericSignature.ClassSignature cSig = new GenericSignatureParser()\n\t\t\t\t.parseAsClassSignature(\"<T::Ljava/io/Serializable;>Ljava/lang/Object;Ljava/lang/Comparable<TT;>;\");\n\t\tUnresolvedType resolved = BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(cSig.superclassSignature,\n\t\t\t\tcSig.formalTypeParameters, world);\n\t\tassertEquals(\"Ljava/lang/Object;\", resolved.getSignature());\n\t\tBcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(cSig.superInterfaceSignatures[0], cSig.formalTypeParameters,\n\t\t\t\tworld);\n\n\t}\n\n}\n",
    "size": 3476
  },
  {
    "file_id": "F130",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/BcelTestUtils.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Andy Clement     initial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.TestUtils;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.patterns.FormalBinding;\nimport org.aspectj.weaver.patterns.Pointcut;\nimport org.aspectj.weaver.patterns.SimpleScope;\n\npublic class BcelTestUtils {\n\t/**\n\t * Moved from BcelWorld to here\n\t *\n\t * Parse a string into advice.\n\t *\n\t * <blockquote>\n\t *\n\t * <pre>\n\t * Kind ( Id , ... ) : Pointcut -&gt; MethodSignature\n\t * </pre>\n\t *\n\t * </blockquote>\n\t */\n\tpublic static Advice shadowMunger(World w, String str, int extraFlag) {\n\t\tstr = str.trim();\n\t\tint start = 0;\n\t\tint i = str.indexOf('(');\n\t\tAdviceKind kind = AdviceKind.stringToKind(str.substring(start, i));\n\t\tstart = ++i;\n\t\ti = str.indexOf(')', i);\n\t\tString[] ids = TestUtils.parseIds(str.substring(start, i).trim());\n\t\t// start = ++i;\n\n\t\ti = str.indexOf(':', i);\n\t\tstart = ++i;\n\t\ti = str.indexOf(\"->\", i);\n\t\tPointcut pointcut = Pointcut.fromString(str.substring(start, i).trim());\n\t\tMember m = TestUtils.methodFromString(str.substring(i + 2, str.length()).trim());\n\n\t\t// now, we resolve\n\t\tUnresolvedType[] types = m.getParameterTypes();\n\t\tFormalBinding[] bindings = new FormalBinding[ids.length];\n\t\tfor (int j = 0, len = ids.length; j < len; j++) {\n\t\t\tbindings[j] = new FormalBinding(types[j], ids[j], j, 0, 0);\n\t\t}\n\n\t\tPointcut p = pointcut.resolve(new SimpleScope(w, bindings));\n\n\t\treturn new BcelAdvice(kind, p, m, extraFlag, 0, 0, null, null);\n\t}\n}\n",
    "size": 2090
  },
  {
    "file_id": "F131",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/BcelWorldReferenceTypeTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002-2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.weaver.CommonReferenceTypeTests;\nimport org.aspectj.weaver.World;\n\npublic class BcelWorldReferenceTypeTest extends CommonReferenceTypeTests {\n\n\tpublic World getWorld() {\n\t\treturn new BcelWorld();\n\t}\n\n}\n",
    "size": 761
  },
  {
    "file_id": "F132",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/BeforeWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\n\npublic class BeforeWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic BeforeWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\n\tpublic void testBefore() throws IOException {\n\t\tweaveTest(getStandardTargets(), \"Before\", makeAdviceAll(\"before\"));\n\t}\n}\n",
    "size": 872
  },
  {
    "file_id": "F133",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/CheckerTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\n\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.MessageHandler;\nimport org.aspectj.weaver.Checker;\nimport org.aspectj.weaver.patterns.DeclareErrorOrWarning;\n\npublic class CheckerTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic CheckerTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\n    public void testStaticTjp() throws IOException {\n    \tChecker checker = new Checker(\n    \t\tnew DeclareErrorOrWarning(true, makePointcutPrintln(), \"hey, we found a println\"));\n\n    \tMessageHandler handler = new MessageHandler();\n    \tworld.setMessageHandler(handler);\n\n        weaveTest(\"HelloWorld\", \"IdHelloWorld\", checker);\n        assertEquals(1, handler.numMessages(IMessage.ERROR, false));\n\n        handler = new MessageHandler();\n    \tworld.setMessageHandler(handler);\n        weaveTest(\"FancyHelloWorld\", \"IdFancyHelloWorld\", checker);\n        assertEquals(3, handler.numMessages(IMessage.ERROR, false));\n    }\n}\n",
    "size": 1538
  },
  {
    "file_id": "F134",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/ClassLoaderRepositoryTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2006 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Andy Clement     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.File;\nimport java.lang.ref.Reference;\nimport java.lang.reflect.Field;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.Enumeration;\nimport java.util.Map;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\nimport org.aspectj.apache.bcel.util.ClassLoaderRepository;\n\nimport junit.framework.TestCase;\n\n/** NOT YET INCLUDED IN A FULL TEST RUN - WORK IN PROGRESS CHECKING CLASSLOADERREPOSITORY OPTIMIZATIONS */\npublic class ClassLoaderRepositoryTest extends TestCase {\n\tprivate File f;\n\tprivate ZipFile zf;\n\tprivate Enumeration entries;\n\tprivate Map map;\n\n\tpublic void setUp() throws Exception {\n    \tf = new File(\"../lib/aspectj/lib/aspectjtools.jar\");\n\t\tassertTrue(\"Couldn't find aspectjtools to test.  Tried: \"+f.getAbsolutePath(),f.exists());\n\t\tzf = new ZipFile(f);\n\t\tentries = zf.entries();\n//\t\tClassLoaderRepository.sharedCacheCompactFrequency = 16384;\n\t\tmap = getSharedMap();\n\t}\n\n\tpublic void tearDown() {\n\t\t new ClassLoaderRepository((ClassLoader) null).reset();\n\t}\n\n\tprivate ClassLoaderRepository setupRepository() throws Exception {\n    \tClassLoader cl = Thread.currentThread().getContextClassLoader();\n\t\tClassLoader res = new URLClassLoader(new URL[]{f.toURI().toURL()},cl);\n\t\tClassLoaderRepository rep = new ClassLoaderRepository(res);\n\t\treturn rep;\n\t}\n\n\t private void compareTwoRepositories() throws Exception {\n\t\tClassLoaderRepository rep1 = setupRepository();\n\t\tClassLoaderRepository rep2 = setupRepository();\n\t\tint i = 0;\n\t\twhile (entries.hasMoreElements()) {\n\t\t\tZipEntry zfe = (ZipEntry)entries.nextElement();\n\t\t\tString classfileName = zfe.getName();\n\t\t\tif (classfileName.endsWith(\".class\")) {\n\t\t\t\tString clazzname = classfileName.substring(0,classfileName.length()-6).replace('/','.');\n\n\t\t\t\t// twice by each\n\t\t\t\trep1.loadClass(clazzname);\n\t\t\t\trep1.loadClass(clazzname);\n\t\t\t\trep2.loadClass(clazzname);\n\t\t\t\trep2.loadClass(clazzname);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tSystem.err.println(\"Successfully compared \"+i+\" entries!!\");\n\t\tSystem.err.println(rep1.report());\n\t\tSystem.err.println(rep2.report());\n    }\n\n//\t private void loadOnce() throws Exception {\n//\t\tClassLoaderRepository rep = setupRepository();\n//\t\twhile (entries.hasMoreElements()) {\n//\t\t\tZipEntry zfe = (ZipEntry) entries.nextElement();\n//\t\t\tString classfileName = zfe.getName();\n//\t\t\tif (classfileName.endsWith(\".class\")) {\n//\t\t\t\tString clazzname = classfileName.substring(0,\n//\t\t\t\t\t\tclassfileName.length() - 6).replace('/', '.');\n//\n//\t\t\t\trep.loadClass(clazzname);\n//\t\t\t}\n//\t\t}\n//\t}\n\n\t public void testMultiThreaded() throws Throwable {\n\t\t ClassLoaderRepository.useSharedCache=true;\n//\t\t ClassLoaderRepository.sharedCacheCompactFrequency = 200;\n\t\t //loadOnce();\n\t\t TestThread threads[] = new TestThread[6];\n\t\t for (int i=0; i<threads.length; i++) {\n\t\t\t threads[i] = new TestThread((i%3)*1000);\n\t\t\t threads[i].start();\n\t\t }\n\t\t for (TestThread thread : threads) {\n\t\t\t thread.join();\n\t\t\t if (thread.getFailure() != null) {\n\t\t\t\t throw thread.getFailure();\n\t\t\t }\n\t\t }\n\t }\n\n\t private class TestThread extends Thread {\n\t\t public Throwable failure = null;\n\t\t Enumeration entries;\n\n\t\t // ensure the threads are loading DIFFERENT shared classes at the same time...\n\t\t public TestThread(int skip) {\n\t\t\tentries = zf.entries();\n\t\t\tfor (int i=0; i<skip && entries.hasMoreElements(); i++) {\n\t\t\t\tentries.nextElement();\n\t\t\t}\n\t\t }\n\n\t\t public void run() {\n\t\t\t try {\n\t\t\t\tClassLoaderRepository rep = setupRepository();\n\t\t\t\tint i = 0;\n\t\t\t\twhile (entries.hasMoreElements()) {\n\t\t\t\t\tZipEntry zfe = (ZipEntry)entries.nextElement();\n\t\t\t\t\tString classfileName = zfe.getName();\n\t\t\t\t\tif (classfileName.endsWith(\".class\")) {\n\t\t\t\t\t\tString clazzname = classfileName.substring(0,classfileName.length()-6).replace('/','.');\n\t\t\t\t\t\trep.loadClass(clazzname);\n\t\t\t\t\t\trep.loadClass(clazzname);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.err.println(\"Thread finished: \"+rep.report());\n\t\t\t } catch (Throwable t) {\n\t\t\t\t failure = t;\n\t\t\t }\n\t \t}\n\t\tpublic Throwable getFailure() {\n\t\t\treturn failure;\n\t\t}\n\t }\n\n\t public void testNotSharedRepository() throws  Exception {\n    \tClassLoaderRepository.useSharedCache=false;\n    \tcompareTwoRepositories();\n\t }\n\n\t public void testSharedUrlRepository() throws  Exception {\n\t\tClassLoaderRepository.useSharedCache=true;\n\t\tcompareTwoRepositories();\n//\t\tClassLoaderRepository.compactSharedCache();\n    }\n\n\tpublic void testPurgeUrlRepository() throws  Exception {\n\t\tClassLoaderRepository.useSharedCache = true;\n\t\tClassLoaderRepository rep = setupRepository();\n\t\tReference ref = null;\n\n\t\twhile (ref==null && entries.hasMoreElements()) {\n\t\t\tZipEntry zfe = (ZipEntry)entries.nextElement();\n\t\t\tString classfileName = zfe.getName();\n\t\t\tif (classfileName.endsWith(\".class\")) {\n\t\t\t\tString clazzname = classfileName.substring(0,classfileName.length()-6).replace('/','.');\n\n\t\t\t\trep.loadClass(clazzname);\n\t\t\t\tassertEquals(\"expected one entry in shared URL cache \"+map.size()+\": \"+map, 1, map.size());\n\t\t\t\tref = (Reference)map.values().iterator().next();\n\t\t\t\tref.clear();\n\t\t\t\tref.enqueue();\n\t\t\t\tmap.size();//force purge\n\t\t\t}\n\t\t}\n\t\tassertEquals(\"expected empty shared URL cache \"+map.size(), 0, map.size());\n\t}\n\n\tpublic void testAutoPurgeUrlRepository() throws  Exception {\n\t\tClassLoaderRepository.useSharedCache = true;\n\t\tassertEquals(\"expected empty shared URL cache \"+map.size(), 0, map.size());\n\t\tClassLoaderRepository rep = setupRepository();\n\t\tReference ref = null;\n\t\tint i = 0;\n\n\t\twhile (i<3 && entries.hasMoreElements()) {\n\t\t\tZipEntry zfe = (ZipEntry)entries.nextElement();\n\t\t\tString classfileName = zfe.getName();\n\t\t\tif (classfileName.endsWith(\".class\")) {\n\t\t\t\tString clazzname = classfileName.substring(0,classfileName.length()-6).replace('/','.');\n\n\t\t\t\trep.loadClass(clazzname);\n\t\t\t\tref = (Reference)map.values().iterator().next();\n\t\t\t\tref.clear();\n\t\t\t\tref.enqueue();\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tassertTrue(\"expected smaller shared URL cache \"+map.size(), map.size()<3);\n\t}\n\n\tprivate Field getSharedMapField() throws Exception {\n\t\tField field = ClassLoaderRepository.class.getDeclaredField(\"sharedCache\");\n\t\tfield.setAccessible(true);\n\t\treturn field;\n\t}\n\n\tprivate Map getSharedMap() throws Exception {\n\t\treturn (Map)getSharedMapField() .get(null);\n\t}\n}\n\n",
    "size": 6682
  },
  {
    "file_id": "F135",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/ClasspathManagerTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2019 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.regex.Pattern;\n\nimport org.aspectj.apache.bcel.classfile.ClassFormatException;\nimport org.aspectj.apache.bcel.classfile.ClassParser;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.bridge.AbortException;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.IMessage.Kind;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.TypeFactory;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.bcel.ClassPathManager.ClassFile;\n\nimport junit.framework.TestCase;\n\n/**\n * Should run these tests 3 times on each JDK level (8, 9, 11). On each one 3 of the tests should pass indicating that\n * JDK can successfully access system types in each JDK level.\n *\n * @author Andy Clement\n */\npublic class ClasspathManagerTestCase extends TestCase {\n\n\t// Works on my machine where all jvms under ~/jvms\n\tprivate static final String java18_rtjar = findJvm(\"j.*18.*\", \"rt.jar\");\n\tprivate static final String java9_jrtfsjar = findJvm(\"j.*9.*\", \"jrt-fs.jar\");\n\tprivate static final String java11_jrtfsjar = findJvm(\"j.*11.*\", \"jrt-fs.jar\");\n\n\tprivate static String findJvm(String pattern, String jar) {\n\t\tString start = System.getProperty(\"user.home\") + \"/jvms\";\n\t\tif (new File(start).isDirectory()) {\n\t\t\tfor (File f : Objects.requireNonNull(new File(start).listFiles())) {\n\t\t\t\tif (f.isDirectory() && Pattern.matches(pattern, f.getName())) {\n\t\t\t\t\tFile result = walk(f, jar);\n\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\tSystem.out.println(\"For \" + pattern + \" found \" + result.getAbsolutePath());\n\t\t\t\t\t\treturn result.getAbsolutePath();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static File walk(File dir, String jar) {\n\t\tFile[] fs = dir.listFiles();\n\t\tif (fs != null) {\n\t\t\tfor (File f : fs) {\n\t\t\t\tif (f.getName().equals(jar))\n\t\t\t\t\treturn f;\n\t\t\t\telse if (f.isDirectory()) {\n\t\t\t\t\tFile s = walk(f, jar);\n\t\t\t\t\tif (s != null)\n\t\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void testInstructions() {\n\t\tSystem.out.println(\n\t\t\t\"This test is mostly for stand-alone usage (rename 'xtest*' to 'test*'), \" +\n\t\t\t\t\"as it needs execution on multiple JDK levels\"\n\t\t);\n\t}\n\n\t/**\n\t * See <a href=\"https://github.com/eclipse-aspectj/aspectj/issues/306\">GitHub issue 306</a>\n\t */\n\tpublic void testUnfoundClassPerformance() {\n\t\tfinal int ROUNDS = 10_000;\n\t\tfinal int MAX_TIME = 500;\n\n\t\tList<String> classPath = Arrays.asList(System.getProperty(\"java.class.path\").split(File.pathSeparator));\n\t\t//System.out.println(classPath);\n\t\tClassPathManager classPathManager = new ClassPathManager(classPath, null);\n\t\tUnresolvedType unresolvedType = TypeFactory.createTypeFromSignature(\"Ljava/lang/String;\");\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\tfor (int i = 0; i < ROUNDS; i++)\n\t\t\tclassPathManager.find(unresolvedType);\n\t\tlong duration = System.currentTimeMillis() - startTime;\n\n\t\tassertTrue(\n\t\t\tString.format(\"Duration for %d rounds should be < %d ms, but was %d ms\", ROUNDS, MAX_TIME, duration),\n\t\t\tduration < MAX_TIME\n\t\t);\n\t}\n\n\tpublic void xtestSanity18accessing18RTJAR() {\n\t\tif (LangUtil.getVmVersion() > 8)\n\t\t\tfail(\"Must be Java 8\");\n\t\tList<String> classpath = new ArrayList<>();\n\t\tclasspath.add(java18_rtjar);\n\t\tClassPathManager cpm = new ClassPathManager(classpath, new MH());\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/Object;\"));\n\t\tassertNotNull(t);\n\t}\n\n\tpublic void xtestJava18accessing11JRT() throws ClassFormatException, IOException {\n\t\tif (LangUtil.getVmVersion() > 8)\n\t\t\tfail(\"Must be Java 8\");\n\t\tList<String> classpath = new ArrayList<>();\n\t\tclasspath.add(java11_jrtfsjar);\n\t\tClassPathManager cpm = new ClassPathManager(classpath, new MH());\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/String;\"));\n\t\tassertNotNull(t);\n\t\tClassParser classParser = new ClassParser(t.getInputStream(), t.getPath());\n\t\tJavaClass clazz = classParser.parse();\n\t\t// isBlank() exists on Java 11\n\t\tlong c = Arrays.stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\n\t\tassertEquals(1, c);\n\t}\n\n\tpublic void xtestJava18accessing19JRT() throws ClassFormatException, IOException {\n\t\tif (LangUtil.getVmVersion() > 8)\n\t\t\tfail(\"Must be Java 8\");\n\t\tList<String> classpath = new ArrayList<>();\n\t\tclasspath.add(java9_jrtfsjar);\n\t\tClassPathManager cpm = new ClassPathManager(classpath, new MH());\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/String;\"));\n\t\tassertNotNull(t);\n\t\tClassParser classParser = new ClassParser(t.getInputStream(), t.getPath());\n\t\tJavaClass clazz = classParser.parse();\n\t\t// isBlank() exists on Java 11, but not on Java9\n\t\tlong c = Arrays.stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\n\t\tassertEquals(0, c);\n\t}\n\n\n\tpublic void xtestSanity19accessing18RTJAR() {\n\t\tassertEquals(9.0, LangUtil.getVmVersion());\n\t\tList<String> classpath = new ArrayList<>();\n\t\tclasspath.add(java18_rtjar);\n\t\tClassPathManager cpm = new ClassPathManager(classpath, new MH());\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/Object;\"));\n\t\tassertNotNull(t);\n\t}\n\n\tpublic void xtestJava19accessing11JRT() throws ClassFormatException, IOException {\n\t\tassertEquals(9.0, LangUtil.getVmVersion());\n\t\tList<String> classpath = new ArrayList<>();\n\t\tclasspath.add(java11_jrtfsjar);\n\t\tClassPathManager cpm = new ClassPathManager(classpath, new MH());\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/String;\"));\n\t\tassertNotNull(t);\n\t\tClassParser classParser = new ClassParser(t.getInputStream(), t.getPath());\n\t\tJavaClass clazz = classParser.parse();\n\t\t// isBlank() exists on Java 11\n\t\tlong c = Arrays.stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\n\t\tassertEquals(1, c);\n\t}\n\n\tpublic void xtestJava19accessing19JRT() throws ClassFormatException, IOException {\n\t\tassertEquals(9.0, LangUtil.getVmVersion());\n\t\tList<String> classpath = new ArrayList<>();\n\t\tclasspath.add(java9_jrtfsjar);\n\t\tClassPathManager cpm = new ClassPathManager(classpath, new MH());\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/String;\"));\n\t\tassertNotNull(t);\n\t\tClassParser classParser = new ClassParser(t.getInputStream(), t.getPath());\n\t\tJavaClass clazz = classParser.parse();\n\t\t// isBlank() exists on Java 11, but not on Java9\n\t\tlong c = Arrays.stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\n\t\tassertEquals(0, c);\n\t}\n\n\tpublic void xtestSanity11accessing18RTJAR() {\n\t\tassertEquals(11.0, LangUtil.getVmVersion());\n\t\tList<String> classpath = new ArrayList<>();\n\t\tclasspath.add(java18_rtjar);\n\t\tClassPathManager cpm = new ClassPathManager(classpath, new MH());\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/Object;\"));\n\t\tassertNotNull(t);\n\t}\n\n\tpublic void xtestJava11accessing11JRT() throws ClassFormatException, IOException {\n\t\tassertEquals(11.0, LangUtil.getVmVersion());\n\t\tList<String> classpath = new ArrayList<>();\n\t\tclasspath.add(java11_jrtfsjar);\n\t\tClassPathManager cpm = new ClassPathManager(classpath, new MH());\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/String;\"));\n\t\tassertNotNull(t);\n\t\tClassParser classParser = new ClassParser(t.getInputStream(), t.getPath());\n\t\tJavaClass clazz = classParser.parse();\n\t\t// isBlank() exists on Java 11\n\t\tlong c = Arrays.stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\n\t\tassertEquals(1, c);\n\t}\n\n\tpublic void xtestJava11accessing19JRT() throws ClassFormatException, IOException {\n\t\tassertEquals(11.0, LangUtil.getVmVersion());\n\t\tList<String> classpath = new ArrayList<>();\n\t\tclasspath.add(java9_jrtfsjar);\n\t\tClassPathManager cpm = new ClassPathManager(classpath, new MH());\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/String;\"));\n\t\tassertNotNull(t);\n\t\tClassParser classParser = new ClassParser(t.getInputStream(), t.getPath());\n\t\tJavaClass clazz = classParser.parse();\n\t\t// isBlank() exists on Java 11, but not on Java9\n\t\tlong c = Arrays.stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\n\t\tassertEquals(0, c);\n\t}\n\n\tstatic class MH implements IMessageHandler {\n\n\t\t@Override\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\n\t\t\tSystem.out.println(message);\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isIgnoring(Kind kind) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void dontIgnore(Kind kind) {}\n\n\t\t@Override\n\t\tpublic void ignore(Kind kind) {}\n\n\t}\n}\n",
    "size": 9022
  },
  {
    "file_id": "F136",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/ExtensibleURLClassLoaderTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2023 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport junit.framework.TestCase;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\n\npublic class ExtensibleURLClassLoaderTest extends TestCase {\n  /**\n   * Simple regression test for <a href=\"https://github.com/eclipse-aspectj/aspectj/issues/266\">GitHub issue 266</a>\n   */\n  public void testClassNotFoundExceptionHasRootCauseOnIOException() throws URISyntaxException, MalformedURLException {\n    ExtensibleURLClassLoader extensibleURLClassLoader = new MockExtensibleURLClassLoader(\n      new URL[] { new URI(\"file://dummy\").toURL() },\n      null\n    );\n    ClassNotFoundException classNotFoundException = null;\n    try {\n      extensibleURLClassLoader.findClass(getClass().getName().replace('.', '/'));\n    } catch (ClassNotFoundException e) {\n      classNotFoundException = e;\n    }\n    assertNotNull(classNotFoundException);\n    Throwable cause = classNotFoundException.getCause();\n    assertNotNull(cause);\n    assertTrue(cause instanceof IOException);\n    assertEquals(\"uh-oh\", cause.getMessage());\n  }\n\n  static class MockExtensibleURLClassLoader extends ExtensibleURLClassLoader {\n    public MockExtensibleURLClassLoader(URL[] urls, ClassLoader parent) {\n      super(urls, parent);\n    }\n\n    @Override\n    protected byte[] getBytes(String name) throws IOException {\n      throw new IOException(\"uh-oh\");\n    }\n  }\n}\n",
    "size": 1896
  },
  {
    "file_id": "F137",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/FieldSetTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\n\npublic class FieldSetTestCase extends WeaveTestCase {\n    {\n        regenerate = false;\n    }\n\n    public FieldSetTestCase(String name) {\n        super(name);\n    }\n\n    public void testBefore() throws IOException {\n        weaveTest(\n\t\t\t\"FieldyHelloWorld\",\n            \"FieldSet\",\n           makeAdviceAll(\"before\")\n            );\n    }\n}\n",
    "size": 941
  },
  {
    "file_id": "F138",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/HierarchyDependsTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport junit.framework.TestCase;\n\n\npublic class HierarchyDependsTestCase extends TestCase {\n\n\tpublic HierarchyDependsTestCase(String arg0) {\n\t\tsuper(arg0);\n\t}\n\n\tpublic void testToDo() {}\n\n\t/**\n\t * XXX not currently used, fix tests when using\n\tpublic void testHierarchyDepends() {\n\t\tBcelWorld world = new BcelWorld();\n\t\tTypePatternQuestions questions = new TypePatternQuestions();\n\t\tResolvedType runnableType = world.resolve(\"java.lang.Runnable\");\n\t\tResolvedType numberType = world.resolve(\"java.lang.Number\");\n\t\tResolvedType integerType = world.resolve(\"java.lang.Integer\");\n\t\tResolvedType stringType = world.resolve(\"java.lang.String\");\n\n\n\t\tTypePattern numberPattern = new ExactTypePattern(numberType, false);\n\t\tquestions.askQuestion(numberPattern, integerType, TypePattern.STATIC);\n\t\tquestions.askQuestion(numberPattern, integerType, TypePattern.DYNAMIC);\n\t\tassertNull(questions.anyChanges());\n\n\t\tJavaClass saveClass = integerType.getJavaClass();\n\t\tintegerType.replaceJavaClass(stringType.getJavaClass());\n\t\tassertNotNull(questions.anyChanges());\n\n\t\tintegerType.replaceJavaClass(saveClass);\n\t\tassertNull(questions.anyChanges());\n\n\t\tTypePattern runnablePattern = new ExactTypePattern(runnableType, false);\n\t\tquestions.askQuestion(runnablePattern, stringType, TypePattern.DYNAMIC);\n\t\tassertNull(questions.toString(), questions.anyChanges());\n\n\t\tsaveClass = stringType.getJavaClass();\n\t\tstringType.replaceJavaClass(numberType.getJavaClass());\n\t\tassertNotNull(questions.toString(), questions.anyChanges());\n\n\t\tstringType.replaceJavaClass(saveClass);\n\t\tassertNull(questions.toString(), questions.anyChanges());\n\t}\n\t*/\n}\n\n",
    "size": 2190
  },
  {
    "file_id": "F139",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/IdWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.patterns.Pointcut;\n\npublic class IdWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic IdWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\tpublic void testFancyId() throws IOException {\n\t\tfinal List l = new ArrayList();\n\t\tPointcut pointcut2 = makePointcutAll();\n\t\tBcelAdvice p = new BcelAdvice(null, pointcut2, null, 0, -1, -1, null, null) {\n\t\t\tpublic boolean match(Shadow shadow, World world) {\n\t\t\t\tif (super.match(shadow, world)) {\n\t\t\t\t\tl.add(shadow);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tweaveTest(new String[] { \"FancyHelloWorld\" }, \"Id2\", p);\n\n\t\tcheckShadowSet(l, new String[] { \"method-call(void java.io.PrintStream.println(java.lang.Object))\",\n\t\t\t\t\"method-call(void java.io.PrintStream.println(java.lang.String))\",\n\t\t\t\t\"method-call(java.lang.StringBuffer java.lang.StringBuffer.append(int))\",\n\t\t\t\t\"method-call(java.lang.String java.lang.StringBuffer.toString())\",\n\t\t\t\t\"method-execution(java.lang.String FancyHelloWorld.getName())\",\n\t\t\t\t\"field-get(java.io.PrintStream java.lang.System.out)\",\n\t\t\t\t\"method-call(void java.io.PrintStream.println(java.lang.String))\",\n\t\t\t\t\"method-execution(void FancyHelloWorld.main(java.lang.String[]))\", \"method-call(int java.lang.String.hashCode())\",\n\t\t\t\t\"constructor-execution(void FancyHelloWorld.<init>())\",\n\t\t\t\t\"constructor-call(void java.lang.StringBuffer.<init>(java.lang.String))\" });\n\t}\n\n\tpublic void testId() throws IOException {\n\t\tfinal List l = new ArrayList();\n\t\tBcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\n\t\t\tpublic boolean implementOn(Shadow shadow) {\n\t\t\t\tl.add(shadow);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tweaveTest(new String[] { \"HelloWorld\" }, \"Id2\", p);\n\n\t\tcheckShadowSet(l, new String[] { \"method-execution(void HelloWorld.main(java.lang.String[]))\",\n\t\t\t\t\"method-call(void java.io.PrintStream.println(java.lang.String))\",\n\t\t\t\t\"field-get(java.io.PrintStream java.lang.System.out)\", \"constructor-execution(void HelloWorld.<init>())\", });\n\t}\n\n\t// this test requires that Trace has been unzipped and placed in the correct place\n\t// public void testTraceId() throws IOException {\n\t// String saveClassDir = classDir;\n\t// try {\n\t// classDir = \"testdata/dummyAspect.jar\";\n\t//\n\t//\n\t//\n\t// final List l = new ArrayList();\n\t// BcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\n\t// public void implementOn(Shadow shadow) {\n\t// l.add(shadow);\n\t// }\n\t// };\n\t// boolean tempRunTests = runTests;\n\t// runTests = false;\n\t// weaveTest(new String[] {\"DummyAspect\"}, \"Id\", p);\n\t// runTests = tempRunTests;\n\t//\n\t// checkShadowSet(l, new String[] {\n\t// \"constructor-execution(void DummyAspect.<init>())\",\n\t// // XXX waiting on parser stuff\n\t// //\"advice-execution(void DummyAspect.ajc_before_1(java.lang.Object))\",\n\t// });\n\t// } finally {\n\t// classDir = saveClassDir;\n\t// }\n\t// }\n\n}\n",
    "size": 3553
  },
  {
    "file_id": "F140",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/JImageTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2017 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n * ******************************************************************/\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.aspectj.bridge.AbortException;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.IMessage.Kind;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.bcel.ClassPathManager.ClassFile;\nimport org.aspectj.weaver.bcel.ClassPathManager.Entry;\nimport org.aspectj.weaver.bcel.ClassPathManager.JImageEntry;\n\nimport junit.framework.TestCase;\n\n/**\n * Exercise the JImage handling in @link {@link org.aspectj.weaver.bcel.ClassPathManager}.\n *\n * @author Andy Clement\n */\npublic class JImageTestCase extends TestCase {\n\n\tClassPathManager cpm;\n\n\tpublic void setUp() throws Exception {\n\t\tList<String> paths = new ArrayList<>();\n\t\tpaths.add(LangUtil.getJrtFsFilePath());\n\t\tcpm = new ClassPathManager(paths,new TestMessageHandler());\n\t}\n\n\tpublic void testOnJava9() {\n\t\tif (!LangUtil.isVMGreaterOrEqual(9)) {\n\t\t\tSystem.out.println(\"SKIPPING JIMAGE TESTS AS NOT ON 1.9 OR LATER\");\n\t\t}\n\t}\n\n\tpublic void testBasicStructureAndCapabilities() {\n\t\tif (!LangUtil.isVMGreaterOrEqual(9)) return;\n\t\t// Should be one entry for finding JRT contents\n\t\tList<Entry> entries = cpm.getEntries();\n\t\tassertEquals(1,entries.size());\n\t\tassertEquals(JImageEntry.class,entries.get(0).getClass());\n\n\t\tClassFile stringClassFile = cpm.find(UnresolvedType.JL_STRING);\n\t\tassertNotNull(stringClassFile);\n\t\tassertEquals(\"java/lang/String.class\",stringClassFile.getPath());\n\t}\n\n\tpublic void testBehaviour() throws Exception {\n\t\tif (!LangUtil.isVMGreaterOrEqual(9)) return;\n\t\tJImageEntry jie = getJImageEntry();\n\n\t\tMap<String, Path> packageCache = jie.getPackageCache();\n\t\tassertTrue(packageCache.size()>0);\n\t\t// Note: seems to be about 1625 entries in it for Java9\n\t\tPath path = packageCache.get(\"java/lang\");\n\t\tassertEquals(\"modules/java.base/java/lang\", path.toString());\n\t\tpath = packageCache.get(\"java/io\");\n\t\tassertEquals(\"modules/java.base/java/io\", path.toString());\n\n\t\tassertNotNull(jie.find(\"java/lang/String\"));\n\t\tassertNotNull(jie.find(\"java/io/File\"));\n\t\t// TODO test the filecache, hard because difficult to simulate collection of SoftReferences\n\t}\n\n\n\tstatic class TestMessageHandler implements IMessageHandler {\n\n\t\t@Override\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isIgnoring(Kind kind) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void dontIgnore(Kind kind) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void ignore(Kind kind) {\n\t\t}\n\n\t}\n\n\t// ---\n\n\tprivate JImageEntry getJImageEntry() {\n\t\treturn (JImageEntry) cpm.getEntries().get(0);\n\t}\n\n\tpublic List<String> getAllTheClasses() {\n\t\tfinal List<String> result = new ArrayList<>();\n\t\tURI JRT_URI = URI.create(\"jrt:/\"); //$NON-NLS-1$\n\t\tFileSystem fs = FileSystems.getFileSystem(JRT_URI);\n\t\tIterable<java.nio.file.Path> roots = fs.getRootDirectories();\n\t\ttry {\n\t\t\tfor (java.nio.file.Path path : roots) {\n\t\t\t\tFiles.walkFileTree(path, new SimpleFileVisitor<Path>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n\t\t\t\t\t\tif (file.getNameCount()>3 && file.toString().endsWith(\".class\")) {\n\t\t\t\t\t\t\tString withClassSuffix = file.subpath(2, file.getNameCount()).toString();\n\t\t\t\t\t\t\tresult.add(withClassSuffix.substring(0,withClassSuffix.length()-\".class\".length()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn result;\n\t}\n\n}\n",
    "size": 4323
  },
  {
    "file_id": "F141",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/MegaZipTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.MemberImpl;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeaverTestCase;\n\npublic class MegaZipTestCase extends WeaveTestCase {\n\n\tprivate File outDir;\n\n\tpublic MegaZipTestCase(String arg0) {\n\t\tsuper(arg0);\n\t}\n\n\tpublic void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\toutDir = WeaverTestCase.getOutdir();\n\t}\n\n\tpublic void tearDown() throws Exception {\n\t\tsuper.tearDown();\n\t\tWeaverTestCase.removeOutDir();\n\t\toutDir = null;\n\t}\n\n\tprivate BcelAdvice makeAroundMunger(final boolean matchOnlyPrintln) {\n\t\t// BcelWorld world = new BcelWorld();\n\t\tfinal Member sig = MemberImpl.method(UnresolvedType.forName(\"fluffy.Aspect\"), Modifier.STATIC, \"aroundFun\",\n\t\t\t\t\"(Lorg/aspectj/runtime/internal/AroundClosure;)Ljava/lang/Object;\");\n\n\t\treturn new BcelAdvice(AdviceKind.stringToKind(\"around\"), matchOnlyPrintln ? makePointcutPrintln() : makePointcutAll(), sig,\n\t\t\t\t0, -1, -1, null, null) {\n\t\t\tpublic void specializeOn(Shadow s) {\n\t\t\t\tsuper.specializeOn(s);\n\t\t\t\t((BcelShadow) s).initializeForAroundClosure();\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic List<ShadowMunger> getShadowMungers() {\n\t\tList<ShadowMunger> ret = new ArrayList<>();\n\t\tret.add(makeConcreteAdvice(\"before\" + \"(): call(* *.println(..)) -> static void fluffy.Aspect.before_method_call()\"));\n\t\tret.add(makeConcreteAdvice(\"afterReturning\"\n\t\t\t\t+ \"(): call(* *.println(..)) -> static void fluffy.Aspect.afterReturning_method_call()\"));\n\n\t\tret.add(makeConcreteAdvice(\"before\" + \"(): execution(* *.*(..)) -> static void fluffy.Aspect.ignoreMe()\"));\n\n\t\tret.add(makeConcreteAdvice(\"afterReturning\" + \"(): execution(* *.*(..)) -> static void fluffy.Aspect.ignoreMe()\"));\n\n\t\tret.add(makeConcreteAdvice(\"afterThrowing\"\n\t\t\t\t+ \"(): execution(* *.*(..)) -> static void fluffy.Aspect.afterThrowing_method_execution(java.lang.Throwable)\", 1));\n\t\tret.add(makeConcreteAdvice(\"after\" + \"(): execution(* *.*(..)) -> static void fluffy.Aspect.ignoreMe()\"));\n\n\t\tret.add(makeAroundMunger(true));\n\t\treturn ret;\n\t}\n\n\tpublic void zipTest(String fileName) throws IOException {\n\t\tlong startTime = System.currentTimeMillis();\n\t\tFile inFile = new File(WeaverTestCase.TESTDATA_PATH, fileName);\n\t\tFile outFile = new File(outDir, fileName);\n\t\toutFile.delete();\n\n\t\tworld = new BcelWorld(\"c:/apps/java-1.3.1_04/lib/tools.jar\");\n\t\tBcelWeaver weaver1 = new BcelWeaver(world);\n\n\t\tZipFileWeaver weaver = new ZipFileWeaver(inFile);\n\n\t\tweaver1.setShadowMungers(getShadowMungers());\n\n\t\tweaver.weave(weaver1, outFile);\n\t\tassertTrue(outFile.lastModified() > startTime);\n\t}\n\n\tpublic void testEmptyForAntJUnit() {\n\t}\n\n\t// this is something we test every now and again.\n\t// to try, rename as testBig and put aspectjtools.jar in testdata\n\tpublic void trytestBig() throws IOException {\n\t\tSystem.out.println(\"could take 80 seconds...\");\n\t\tzipTest(\"aspectjtools.jar\");\n\t}\n\n}\n",
    "size": 3658
  },
  {
    "file_id": "F142",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/MoveInstructionsWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\n\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.weaver.NameMangler;\nimport org.aspectj.weaver.Shadow;\n\npublic class MoveInstructionsWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic MoveInstructionsWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\tpublic void testHello() throws IOException {\n\t\tBcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\n\t\t\tpublic void specializeOn(Shadow s) {\n\t\t\t\tsuper.specializeOn(s);\n\t\t\t\t((BcelShadow) s).initializeForAroundClosure();\n\t\t\t}\n\n\t\t\tpublic boolean implementOn(Shadow s) {\n\t\t\t\tBcelShadow shadow = (BcelShadow) s;\n\t\t\t\tLazyMethodGen newMethod = shadow.extractShadowInstructionsIntoNewMethod(NameMangler.getExtractableName(shadow\n\t\t\t\t\t\t.getSignature())\n\t\t\t\t\t\t+ \"_extracted\", 0, this.getSourceLocation(), new ArrayList(),shadow.getEnclosingClass().isInterface());\n\t\t\t\tshadow.getRange().append(shadow.makeCallToCallback(newMethod));\n\n\t\t\t\tif (!shadow.isFallsThrough()) {\n\t\t\t\t\tshadow.getRange().append(InstructionFactory.createReturn(newMethod.getReturnType()));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\n\t\tweaveTest(\"HelloWorld\", \"ExtractedHelloWorld\", p);\n\t}\n\n\tstatic int counter = 0;\n\n\tpublic void testFancyHello() throws IOException {\n\t\t// Reset counter, just in case this test runs multiple times in one JVM. This can happen e.g. due to \"run all tests\"\n\t\t// in IntelliJ IDEA, which directly runs this test class and als WeaverModuleTests, both of which implement\n\t\t// junit.framework.TestCase. In that case, during the second run the counter would start at a higher base count,\n\t\t// making the 2nd test run fail.\n\t\tcounter = 0;\n\t\tBcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\n\t\t\tpublic void specializeOn(Shadow s) {\n\t\t\t\tsuper.specializeOn(s);\n\t\t\t\t((BcelShadow) s).initializeForAroundClosure();\n\t\t\t}\n\n\t\t\tpublic boolean implementOn(Shadow s) {\n\t\t\t\tBcelShadow shadow = (BcelShadow) s;\n\t\t\t\tLazyMethodGen newMethod =\n\t\t\t\t\t\tshadow.extractShadowInstructionsIntoNewMethod(NameMangler.getExtractableName(shadow\n\t\t\t\t\t\t.getSignature())\n\t\t\t\t\t\t+ \"_extracted\" + counter++, 0, this.getSourceLocation(), new ArrayList(),shadow.getEnclosingClass().isInterface());\n\t\t\t\tshadow.getRange().append(shadow.makeCallToCallback(newMethod));\n\n\t\t\t\tif (!shadow.isFallsThrough()) {\n\t\t\t\t\tshadow.getRange().append(InstructionFactory.createReturn(newMethod.getReturnType()));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\n\t\tweaveTest(\"FancyHelloWorld\", \"ExtractedFancyHelloWorld\", p);\n\t}\n}\n",
    "size": 3131
  },
  {
    "file_id": "F143",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\n\nimport org.aspectj.weaver.CrosscuttingMembers;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.patterns.PatternParser;\nimport org.aspectj.weaver.patterns.PerClause;\nimport org.aspectj.weaver.patterns.PerSingleton;\nimport org.aspectj.weaver.patterns.TestScope;\n\npublic class NonstaticWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic NonstaticWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\n\tpublic void testBefore() throws IOException {\n\t\tString s = \"before(): get(* *.*) -> void Aspect.ajc_before()\";\n\t\tPerClause per = new PerSingleton();\n\t\tper = per.concretize(world.resolve(\"Aspect\"));\n\n        ShadowMunger myMunger = this.makeConcreteAdvice(s, 0, per);\n\n\t\tweaveTest(getStandardTargets(), \"NonStaticBefore\", myMunger);\n\t}\n\n\tpublic void testBeforeCflow() throws IOException {\n\t\tString s = \"before(): get(* *.*) -> void Aspect.ajc_before()\";\n\t\tPerClause per = new PatternParser(\"percflow(execution(void main(..)))\").maybeParsePerClause();\n\t\tper.resolve(new TestScope(new String[0], new String[0], world));\n\n\t\tResolvedType onAspect = world.resolve(\"Aspect\");\n\t\tCrosscuttingMembers xcut = new CrosscuttingMembers(onAspect,true);\n\t\tonAspect.crosscuttingMembers = xcut;\n\n\t\tper = per.concretize(onAspect);\n\n        ShadowMunger myMunger = this.makeConcreteAdvice(s, 0, per);\n\n\t\txcut.addConcreteShadowMunger(myMunger);\n\n\n\t\tweaveTest(getStandardTargets(), \"CflowNonStaticBefore\", xcut.getShadowMungers());\n\t}\n\n\tpublic void testBeforePerThis() throws IOException {\n\t\tString s = \"before(): call(* println(..)) -> void Aspect.ajc_before()\";\n\t\tPerClause per = new PatternParser(\"pertarget(call(* println(..)))\").maybeParsePerClause();\n\t\tper.resolve(new TestScope(new String[0], new String[0], world));\n\n\t\tResolvedType onAspect = world.resolve(\"Aspect\");\n\t\tCrosscuttingMembers xcut = new CrosscuttingMembers(onAspect,true);\n\t\tonAspect.crosscuttingMembers = xcut;\n\t\tper = per.concretize(onAspect);\n\n        ShadowMunger myMunger = this.makeConcreteAdvice(s, 0, per);\n\t\txcut.addConcreteShadowMunger(myMunger);\n\n//\t\tList mungers = new ArrayList();\n//\t\tmungers.add(myMunger);\n//\t\tmungers.addAll(onAspect.getExtraConcreteShadowMungers());\n\n\n\t\tweaveTest(getStandardTargets(), \"PerThisNonStaticBefore\", xcut.getShadowMungers());\n\t}\n\n\n\n}\n",
    "size": 2905
  },
  {
    "file_id": "F144",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/PatternWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.aspectj.weaver.CompressingDataOutputStream;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.VersionedDataInputStream;\nimport org.aspectj.weaver.patterns.ConstantPoolSimulator;\nimport org.aspectj.weaver.patterns.FormalBinding;\nimport org.aspectj.weaver.patterns.Pointcut;\nimport org.aspectj.weaver.patterns.SimpleScope;\n\npublic class PatternWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic PatternWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\tString[] none = new String[0];\n\n\t// XXX this test is incompatible with optimizations made to weaver\n\n\tpublic void testPublic() throws IOException {\n\t\tString[] publicHello = new String[] { \"method-execution(void HelloWorld.main(java.lang.String[]))\", };\n\t\tString[] publicFancyHello = new String[] { \"method-execution(void FancyHelloWorld.main(java.lang.String[]))\",\n\t\t\t\t\"method-execution(java.lang.String FancyHelloWorld.getName())\", };\n\t\tcheckPointcut(\"execution(public * *(..))\", publicHello, publicFancyHello);\n\t}\n\n\t//\n\t// public void testPrintln() throws IOException {\n\t// String[] callPrintlnHello = new String[] {\n\t// \"method-call(void java.io.PrintStream.println(java.lang.String))\",\n\t// };\n\t// String[] callPrintlnFancyHello = new String[] {\n\t// \"method-call(void java.io.PrintStream.println(java.lang.String))\",\n\t// \"method-call(void java.io.PrintStream.println(java.lang.String))\",\n\t// \"method-call(void java.io.PrintStream.println(java.lang.Object))\",\n\t// };\n\t// checkPointcut(\"call(* println(*))\", callPrintlnHello, callPrintlnFancyHello);\n\t// }\n\t//\n\t// public void testMumble() throws IOException {\n\t// checkPointcut(\"call(* mumble(*))\", none, none);\n\t// }\n\t//\n\t// public void testFooBar() throws IOException {\n\t// checkPointcut(\"call(FooBar *(..))\", none, none);\n\t// }\n\t//\n\t// public void testGetOut() throws IOException {\n\t// String[] getOutHello = new String[] {\n\t// \"field-get(java.io.PrintStream java.lang.System.out)\",\n\t// };\n\t//\n\t// checkPointcut(\"get(* java.lang.System.out)\", getOutHello, getOutHello);\n\t// }\n\t//\n\t// // private Pointcut makePointcut(String s) {\n\t// // return new PatternParser(s).parsePointcut();\n\t// // }\n\t//\n\tprivate void checkPointcut(String pointcutSource, String[] expectedHelloShadows, String[] expectedFancyShadows)\n\t\t\tthrows IOException {\n\t\tPointcut sp = Pointcut.fromString(pointcutSource);\n\t\tPointcut rp = sp.resolve(new SimpleScope(world, FormalBinding.NONE));\n\t\tPointcut cp = rp.concretize(ResolvedType.MISSING, ResolvedType.MISSING, 0);\n\n\t\tfinal List l = new ArrayList();\n\t\tBcelAdvice p = new BcelAdvice(null, cp, null, 0, -1, -1, null, null) {\n\t\t\tpublic boolean implementOn(Shadow shadow) {\n\t\t\t\tl.add(shadow);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tweaveTest(new String[] { \"HelloWorld\" }, \"PatternWeave\", p);\n\n\t\tcheckShadowSet(l, expectedHelloShadows);\n\n\t\tl.clear();\n\t\tweaveTest(new String[] { \"FancyHelloWorld\" }, \"PatternWeave\", p);\n\n\t\tcheckShadowSet(l, expectedFancyShadows);\n\n\t\tcheckSerialize(rp);\n\t}\n\n\tpublic void checkSerialize(Pointcut p) throws IOException {\n\t\tByteArrayOutputStream bo = new ByteArrayOutputStream();\n\t\tConstantPoolSimulator cps = new ConstantPoolSimulator();\n\t\tCompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);\n\t\tp.write(out);\n\t\tout.close();\n\n\t\tByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());\n\t\tVersionedDataInputStream in = new VersionedDataInputStream(bi, cps);\n\t\tPointcut newP = Pointcut.read(in, null);\n\n\t\tassertEquals(\"write/read\", p, newP);\n\t}\n\n}\n",
    "size": 4229
  },
  {
    "file_id": "F145",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/PointcutResidueTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.lang.reflect.Modifier;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.CompressingDataOutputStream;\nimport org.aspectj.weaver.CrosscuttingMembers;\nimport org.aspectj.weaver.MemberImpl;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.VersionedDataInputStream;\nimport org.aspectj.weaver.patterns.ConstantPoolSimulator;\nimport org.aspectj.weaver.patterns.Pointcut;\nimport org.aspectj.weaver.patterns.SimpleScope;\n\npublic class PointcutResidueTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic PointcutResidueTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\tString[] none = new String[0];\n\n\t// -----\n\n\t// ----\n\n\tpublic void testArgResidue1() throws IOException {\n\t\tcheckMultiArgWeave(\"StringResidue1\",\n\t\t\t\t\"call(* *(java.lang.Object, java.lang.Object)) && args(java.lang.String, java.lang.String)\");\n\t}\n\n\tpublic void testArgResidue2() throws IOException {\n\t\tcheckMultiArgWeave(\"StringResidue2\", \"call(* *(java.lang.Object, java.lang.Object)) && args(.., java.lang.String)\");\n\t}\n\n\tpublic void testArgResidue3() throws IOException {\n\t\tcheckMultiArgWeave(\"StringResidue3\", \"call(* *(java.lang.Object, java.lang.Object)) && args(java.lang.String, ..)\");\n\t}\n\n\t// BETAX this is a beta feature.\n\t// public void testArgResidue4() throws IOException {\n\t// checkMultiArgWeave(\n\t// \"StringResidue4\",\n\t// \"call(* *(java.lang.Object, java.lang.Object)) && args(.., java.lang.String, ..)\");\n\t// }\n\n\tpublic void testMultiArgState() throws IOException {\n\t\tcheckWeave(\"StateResidue\", \"MultiArgHelloWorld\", \"call(* *(java.lang.Object, java.lang.Object)) && args(s, ..)\",\n\t\t\t\tnew String[] { \"java.lang.String\" }, new String[] { \"s\" });\n\t\tcheckWeave(\"StateResidue\", \"MultiArgHelloWorld\", \"call(* *(java.lang.Object, java.lang.Object)) && args(s, *)\",\n\t\t\t\tnew String[] { \"java.lang.String\" }, new String[] { \"s\" });\n\t}\n\n\tpublic void testAdd() throws IOException {\n\t\tcheckDynamicWeave(\"AddResidue\", \"call(public * add(..)) && target(java.util.ArrayList)\");\n\t\tcheckDynamicWeave(\"AddResidue\", \"call(public * add(..)) && (target(java.util.ArrayList) || target(java.lang.String))\");\n\t\tcheckDynamicWeave(\"AddResidue\",\n\t\t\t\t\"call(public * add(..)) && this(java.io.Serializable) && target(java.util.ArrayList) && !this(java.lang.Integer)\");\n\t}\n\n\tpublic void testNot() throws IOException {\n\t\tcheckDynamicWeave(\"AddNotResidue\", \"call(public * add(..)) && !target(java.util.ArrayList)\");\n\t\tcheckDynamicWeave(\"AddNotResidue\", \"call(public * add(..)) && !(target(java.util.ArrayList) || target(java.lang.String)) \");\n\t\tcheckDynamicWeave(\"AddNotResidue\", \"call(public * add(..)) && target(java.lang.Object) && !target(java.util.ArrayList)\");\n\t}\n\n\tpublic void testState() throws IOException {\n\t\tcheckWeave(\"AddStateResidue\", \"DynamicHelloWorld\", \"call(public * add(..)) && target(list)\",\n\t\t\t\tnew String[] { \"java.util.ArrayList\" }, new String[] { \"list\" });\n\t\tcheckWeave(\"AddStateResidue\", \"DynamicHelloWorld\", \"target(foo) && !target(java.lang.Integer) && call(public * add(..))\",\n\t\t\t\tnew String[] { \"java.util.ArrayList\" }, new String[] { \"foo\" });\n\t\tcheckDynamicWeave(\"AddResidue\", \"call(public * add(..)) && (target(java.util.ArrayList) || target(java.lang.String))\");\n\t\tcheckDynamicWeave(\"AddResidue\",\n\t\t\t\t\"call(public * add(..)) && this(java.io.Serializable) && target(java.util.ArrayList) && !this(java.lang.Integer)\");\n\t}\n\n\tpublic void testNoResidueArgs() throws IOException {\n\t\tcheckDynamicWeave(\"NoResidue\", \"call(public * add(..)) && args(java.lang.Object)\");\n\t\tcheckDynamicWeave(\"NoResidue\", \"call(public * add(..)) && args(*)\");\n\t\tcheckDynamicWeave(\"NoResidue\", \"call(public * add(..))\");\n\t}\n\n\t// ---- cflow tests\n\n\tpublic void testCflowState() throws IOException {\n\t\tcheckWeave(\"CflowStateResidue\", \"DynamicHelloWorld\",\n\t\t\t\t\"cflow(call(public * add(..)) && target(list)) && execution(public void main(..))\",\n\t\t\t\tnew String[] { \"java.util.ArrayList\" }, new String[] { \"list\" });\n\t\t// checkWeave(\n\t\t// \"CflowStateResidue\",\n\t\t// \"DynamicHelloWorld\",\n\t\t// \"cflow(call(public * add(..)) && target(list)) && this(obj) && execution(public void doit(..))\",\n\t\t// new String[] { \"java.lang.Object\", \"java.util.ArrayList\" },\n\t\t// new String[] { \"obj\", \"list\" });\n\t\t// checkWeave(\n\t\t// \"AddStateResidue\",\n\t\t// \"DynamicHelloWorld\",\n\t\t// \"target(foo) && !target(java.lang.Integer) && call(public * add(..))\",\n\t\t// new String[] { \"java.util.ArrayList\" },\n\t\t// new String[] { \"foo\" });\n\t\t// checkDynamicWeave(\n\t\t// \"AddResidue\",\n\t\t// \"call(public * add(..)) && (target(java.util.ArrayList) || target(java.lang.String))\");\n\t\t// checkDynamicWeave(\n\t\t// \"AddResidue\",\n\t\t// \"call(public * add(..)) && this(java.io.Serializable) && target(java.util.ArrayList) && !this(java.lang.Integer)\");\n\t}\n\n\t// ----\n\n\tprivate void checkDynamicWeave(String label, String pointcutSource) throws IOException {\n\t\tcheckWeave(label, \"DynamicHelloWorld\", pointcutSource, new String[0], new String[0]);\n\t}\n\n\tprivate void checkMultiArgWeave(String label, String pointcutSource) throws IOException {\n\t\tcheckWeave(label, \"MultiArgHelloWorld\", pointcutSource, new String[0], new String[0]);\n\t}\n\n\tprivate void checkWeave(String label, String filename, String pointcutSource, String[] formalTypes, String[] formalNames)\n\t\t\tthrows IOException {\n\t\tfinal Pointcut sp = Pointcut.fromString(pointcutSource);\n\t\tfinal Pointcut rp = sp.resolve(new SimpleScope(world, SimpleScope.makeFormalBindings(UnresolvedType.forNames(formalTypes),\n\t\t\t\tformalNames)));\n\n\t\tShadowMunger pp = new BcelAdvice(AdviceKind.Before, rp, MemberImpl.method(UnresolvedType.forName(\"Aspect\"),\n\t\t\t\tModifier.STATIC, \"ajc_before_0\",\n\t\t\t\tMemberImpl.typesToSignature(UnresolvedType.VOID, UnresolvedType.forNames(formalTypes), false)), 0, -1, -1, null,\n\t\t\t\tnull);\n\n\t\tResolvedType inAspect = world.resolve(\"Aspect\");\n\t\tCrosscuttingMembers xcut = new CrosscuttingMembers(inAspect, true);\n\t\tinAspect.crosscuttingMembers = xcut;\n\n\t\tShadowMunger cp = pp.concretize(inAspect, world, null);\n\n\t\txcut.addConcreteShadowMunger(cp);\n\n\t\t// System.out.println(\"extras: \" + inAspect.getExtraConcreteShadowMungers());\n\t\t// List advice = new ArrayList();\n\t\t// advice.add(cp);\n\t\t// advice.addAll(inAspect.getExtraConcreteShadowMungers());\n\t\tweaveTest(new String[] { filename }, label, xcut.getShadowMungers());\n\n\t\tcheckSerialize(rp);\n\t}\n\n\tpublic void weaveTest(String name, String outName, ShadowMunger planner) throws IOException {\n\t\tList<ShadowMunger> l = Collections.singletonList(planner);\n\t\tweaveTest(name, outName, l);\n\t}\n\n\tpublic void checkSerialize(Pointcut p) throws IOException {\n\t\tByteArrayOutputStream bo = new ByteArrayOutputStream();\n\t\tConstantPoolSimulator cps = new ConstantPoolSimulator();\n\t\tCompressingDataOutputStream out = new CompressingDataOutputStream(bo, cps);\n\t\tp.write(out);\n\t\tout.close();\n\n\t\tByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());\n\t\tVersionedDataInputStream in = new VersionedDataInputStream(bi, cps);\n\t\tPointcut newP = Pointcut.read(in, null);\n\n\t\tassertEquals(\"write/read\", p, newP);\n\t}\n\n}\n",
    "size": 7787
  },
  {
    "file_id": "F146",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/TjpWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\nimport java.util.Arrays;\n\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.TestUtils;\nimport org.aspectj.weaver.UnresolvedType;\n\npublic class TjpWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic TjpWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\tpublic void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tbehave15 = true;\n\t}\n\n\tpublic void tearDown() throws Exception {\n\t\tsuper.tearDown();\n\t\tbehave15 = false;\n\t}\n\n\tpublic void testStaticTjp() throws IOException {\n\t\tBcelAdvice munger = new BcelAdvice(AdviceKind.stringToKind(\"before\"), makePointcutAll(),\n\t\t\t\tTestUtils.methodFromString(\"static void Aspect.ajc_before(org.aspectj.lang.JoinPoint$StaticPart)\"),\n\t\t\t\tAdvice.ThisJoinPointStaticPart, -1, -1, null, null);\n\n\t\tweaveTest(\"HelloWorld\", \"StaticTjpBeforeHelloWorld\", munger);\n\t}\n\n\tpublic void testEnclosingStaticTjp() throws IOException {\n\t\tBcelAdvice munger = new BcelAdvice(AdviceKind.stringToKind(\"before\"), makePointcutAll(),\n\t\t\t\tTestUtils.methodFromString(\"static void Aspect.ajc_before(org.aspectj.lang.JoinPoint$StaticPart)\"),\n\t\t\t\tAdvice.ThisEnclosingJoinPointStaticPart, -1, -1, null, null);\n\n\t\tweaveTest(\"HelloWorld\", \"StaticEnclosingTjpBeforeHelloWorld\", munger);\n\t}\n\n\tpublic void testTjp() throws IOException {\n\t\tBcelAdvice munger = new BcelAdvice(AdviceKind.stringToKind(\"before\"), makePointcutAll(),\n\t\t\t\tTestUtils.methodFromString(\"static void Aspect.ajc_before(org.aspectj.lang.JoinPoint)\"), Advice.ThisJoinPoint, -1,\n\t\t\t\t-1, null, null);\n\n\t\tweaveTest(\"HelloWorld\", \"TjpBeforeHelloWorld\", munger);\n\t}\n\n\tpublic void testAroundTjp() throws IOException {\n\t\tBcelAdvice munger = new BcelAdvice(\n\t\t\t\tAdviceKind.stringToKind(\"around\"),\n\t\t\t\tmakePointcutAll(),\n\t\t\t\tTestUtils\n\t\t\t\t\t\t.methodFromString(\"static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)\"),\n\t\t\t\tAdvice.ThisJoinPoint | Advice.ExtraArgument, -1, -1, null, null);\n\n\t\tweaveTest(\"HelloWorld\", \"TjpAroundHelloWorld\", munger);\n\t}\n\n\tpublic void testAround2Tjp() throws IOException {\n\t\tResolvedType rtx = world.resolve(UnresolvedType.forName(\"Aspect\"), true);\n\t\tassertTrue(\"Couldnt find type Aspect\", !rtx.isMissing());\n\t\tBcelAdvice munger1 = new BcelAdvice(\n\t\t\t\tAdviceKind.stringToKind(\"around\"),\n\t\t\t\tmakePointcutAll(),\n\t\t\t\tTestUtils\n\t\t\t\t\t\t.methodFromString(\"static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)\"),\n\t\t\t\tAdvice.ThisJoinPoint | Advice.ExtraArgument, -1, -1, null, rtx);\n\n\t\tBcelAdvice munger2 = new BcelAdvice(\n\t\t\t\tAdviceKind.stringToKind(\"around\"),\n\t\t\t\tmakePointcutAll(),\n\t\t\t\tTestUtils\n\t\t\t\t\t\t.methodFromString(\"static java.lang.Object Aspect.ajc_around(org.aspectj.runtime.internal.AroundClosure, org.aspectj.lang.JoinPoint)\"),\n\t\t\t\tAdvice.ThisJoinPoint | Advice.ExtraArgument, -1, -1, null, rtx);\n\n\t\tweaveTest(\"HelloWorld\", \"TjpAround2HelloWorld\", Arrays.asList(new ShadowMunger[] { munger1, munger2 }));\n\t}\n\n}\n",
    "size": 3666
  },
  {
    "file_id": "F147",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/TraceJarWeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.IOException;\n\npublic class TraceJarWeaveTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic TraceJarWeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\n\tpublic void testTraceJar() throws IOException {\n\t\tworld = new BcelWorld(getTraceJar());\n\t\tBcelWeaver weaver = new BcelWeaver(world);\n\t\tweaver.addLibraryAspect(\"MyTrace\");\n\t\tUnwovenClassFile classFile\n            = makeUnwovenClassFile(classDir, \"DynamicHelloWorld\", outDirPath);\n\n        weaver.addClassFile(classFile,false);\n        weaver.prepareForWeave();\n\n\t\tweaveTestInner(weaver, classFile, \"DynamicHelloWorld\", \"TraceJarHello\");\n\t}\n}\n",
    "size": 1196
  },
  {
    "file_id": "F148",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/UtilityTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\nimport java.io.IOException;\n\nimport junit.framework.TestCase;\n\npublic class UtilityTestCase extends TestCase {\n\n    public UtilityTestCase(String name) {\n        super(name);\n    }\n\n    public void disassembleTest(String name) throws IOException {\n        BcelWorld world = new BcelWorld(\"../weaver/bin\");\n//        world.setFastDelegateSupport(false);\n        world.addPath(WeaveTestCase.classDir);\n\n        LazyClassGen clazz = new LazyClassGen(BcelWorld.getBcelObjectType(world.resolve(name)));\n        clazz.print();\n        System.out.println();\n    }\n\n\n    public void testHelloWorld() throws IOException {\n        disassembleTest(\"Test\");\n    }\n    public void testFancyHelloWorld() throws IOException {\n        disassembleTest(\"FancyHelloWorld\");\n    }\n//    public void testSwitchy() throws IOException {\n//        disassembleTest(\"TestSwitchy\");\n//    }\n\n    public static void main(String[] args) throws IOException {\n    \tBcelWorld world = new BcelWorld();\n        LazyClassGen clazz = new LazyClassGen(BcelWorld.getBcelObjectType(world.resolve(args[0])));\n        clazz.print();\n    }\n}\n\n",
    "size": 1672
  },
  {
    "file_id": "F149",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/WeaveOrderTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.AdviceKind;\nimport org.aspectj.weaver.CrosscuttingMembers;\nimport org.aspectj.weaver.MemberImpl;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.patterns.Declare;\nimport org.aspectj.weaver.patterns.PatternParser;\n\n/**.\n */\npublic class WeaveOrderTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic WeaveOrderTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\n\tpublic void testLexicalOrder() {\n\t\tAdvice a1 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);\n\t\tAdvice a2 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.THROWABLE, 2);\n\n\t\tassertEquals(-1, a2.compareTo(a1));\n\t\tassertEquals(+1, a1.compareTo(a2));\n\t}\n\n\tpublic void testLexicalOrderWithAfter() {\n\t\tAdvice a1 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);\n\t\tAdvice a2 =\n\t\t\tmakeConcreteAdvice(AdviceKind.After, UnresolvedType.OBJECT, UnresolvedType.THROWABLE, 2);\n\n\t\tassertEquals(+1, a2.compareTo(a1));\n\t\tassertEquals(-1, a1.compareTo(a2));\n\n\t\ta1 =\n\t\t\tmakeConcreteAdvice(AdviceKind.After, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);\n\t\ta2 =\n\t\t\tmakeConcreteAdvice(AdviceKind.After, UnresolvedType.OBJECT, UnresolvedType.THROWABLE, 2);\n\n\t\tassertEquals(+1, a2.compareTo(a1));\n\t\tassertEquals(-1, a1.compareTo(a2));\n\t}\n\n\tpublic void testSubtypes() {\n\t\tAdvice a1 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);\n\t\tAdvice a2 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.THROWABLE, UnresolvedType.OBJECT, 1);\n\t\tAdvice a3 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.forName(\"java.lang.String\"), UnresolvedType.OBJECT, 1);\n\n\t\tassertEquals(+1, a2.compareTo(a1));\n\t\tassertEquals(-1, a1.compareTo(a2));\n\n\t\tassertEquals(+1, a3.compareTo(a1));\n\t\tassertEquals(-1, a1.compareTo(a3));\n\n\t\tassertEquals(0, a3.compareTo(a2));\n\t\tassertEquals(0, a2.compareTo(a3));\n\t}\n\n\n\tpublic void testDominates() {\n\t\tDeclare dom =\n\t\t\tnew PatternParser(\"declare precedence: java.lang.String, java.lang.Throwable\").parseDeclare();\n\t\t//??? concretize dom\n\t\tResolvedType aType =  world.resolve(\"Aspect\");\n\t\tCrosscuttingMembers xcut = new CrosscuttingMembers(aType,true);\n\t\taType.crosscuttingMembers = xcut;\n\t\txcut.addDeclare(dom);\n\t\tworld.getCrosscuttingMembersSet().addFixedCrosscuttingMembers(aType);\n\n\t\tAdvice a1 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);\n\t\tAdvice a2 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.THROWABLE, 2);\n\t\tAdvice a3 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.forName(\"java.lang.String\"), 2);\n\n\t\tassertEquals(-1, a2.compareTo(a1));\n\t\tassertEquals(+1, a1.compareTo(a2));\n\n\t\tassertEquals(-1, a3.compareTo(a1));\n\t\tassertEquals(+1, a1.compareTo(a3));\n\n\n\t\tassertEquals(+1, a3.compareTo(a2));\n\t\tassertEquals(-1, a2.compareTo(a3));\n\t}\n\n\tpublic void testDominatesHarder() {\n\t\tDeclare dom =\n\t\t\tnew PatternParser(\"declare precedence: *, java.lang.String, java.lang.Throwable\").parseDeclare();\n\t\t//??? concretize dom\n\t\tResolvedType aType =  world.resolve(\"Aspect\");\n\t\tCrosscuttingMembers xcut = new CrosscuttingMembers(aType,true);\n\t\taType.crosscuttingMembers = xcut;\n\t\txcut.addDeclare(dom);\n\t\tworld.getCrosscuttingMembersSet().addFixedCrosscuttingMembers(aType);\n\n\t\tAdvice a1 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 2);\n\t\tAdvice a2 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.THROWABLE, 1);\n\t\tAdvice a3 =\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.forName(\"java.lang.String\"), 1);\n\n\t\tassertEquals(-1, a2.compareTo(a1));\n\t\tassertEquals(+1, a1.compareTo(a2));\n\n\t\tassertEquals(-1, a3.compareTo(a1));\n\t\tassertEquals(+1, a1.compareTo(a3));\n\n\n\t\tassertEquals(+1, a3.compareTo(a2));\n\t\tassertEquals(-1, a2.compareTo(a3));\n\t}\n\n\n\n\n\tprivate Advice makeConcreteAdvice(AdviceKind kind, UnresolvedType declaringAspect,\n\t\t\t\tUnresolvedType concreteAspect, int lexicalPosition)\n\t{\n\t\tAdvice a1 = new BcelAdvice(kind, makeResolvedPointcut(\"this(*)\"),\n\t\t\t\tMemberImpl.method(declaringAspect, 0, \"foo\", \"()V\"),\n\t\t\t\t0, lexicalPosition, lexicalPosition, null, null);\n\t\ta1 = (Advice)a1.concretize(concreteAspect.resolve(world), world, null);\n\t\treturn a1;\n\t}\n\n\n\n}\n",
    "size": 5015
  },
  {
    "file_id": "F150",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/WeaveTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.aspectj.apache.bcel.Constants;\nimport org.aspectj.apache.bcel.generic.InstructionFactory;\nimport org.aspectj.apache.bcel.generic.InstructionList;\nimport org.aspectj.apache.bcel.generic.InvokeInstruction;\nimport org.aspectj.apache.bcel.generic.Type;\nimport org.aspectj.testing.util.TestUtil;\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.WeaverTestCase;\nimport org.aspectj.weaver.patterns.FormalBinding;\nimport org.aspectj.weaver.patterns.PerClause;\nimport org.aspectj.weaver.patterns.Pointcut;\nimport org.aspectj.weaver.patterns.SimpleScope;\n\nimport junit.framework.TestCase;\n\npublic abstract class WeaveTestCase extends TestCase {\n\n\tpublic boolean regenerate = false;\n\tpublic boolean runTests = true;\n\tpublic boolean behave15 = false;\n\n\tFile outDir;\n\tString outDirPath;\n\n\tpublic BcelWorld world = new BcelWorld();\n\t{\n\t\tworld.addPath(classDir);\n\t\t// Some of the tests in here rely on comparing output from dumping the delegates - if\n\t\t// we are using ASM delegates we don't know the names of parameters (they are irrelevant...)\n\t\t// and are missing from the dumping of asm delegates. This switch ensures we\n\t\t// continue to use BCEL for these tests.\n\t\t// world.setFastDelegateSupport(false);\n\t}\n\n\tpublic WeaveTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\t@Override\n\tpublic void setUp() throws Exception {\n\t\toutDir = WeaverTestCase.getOutdir();\n\t\toutDirPath = outDir.getAbsolutePath();\n\t}\n\n\t@Override\n\tpublic void tearDown() throws Exception {\n\t\tsuper.tearDown();\n\t\tWeaverTestCase.removeOutDir();\n\t\toutDir = null;\n\t\toutDirPath = null;\n\t}\n\n\tpublic static InstructionList getAdviceTag(BcelShadow shadow, String where) {\n\t\tString methodName = \"ajc_\" + where + \"_\" + shadow.getKind().toLegalJavaIdentifier();\n\n\t\tInstructionFactory fact = shadow.getFactory();\n\t\tInvokeInstruction il = fact.createInvoke(\"Aspect\", methodName, Type.VOID, new Type[] {}, Constants.INVOKESTATIC);\n\t\treturn new InstructionList(il);\n\t}\n\n\tpublic void weaveTest(String name, String outName, ShadowMunger planner) throws IOException {\n\t\tList<ShadowMunger> l = new ArrayList<>(1);\n\t\tl.add(planner);\n\t\tweaveTest(name, outName, l);\n\t}\n\n\t// static String classDir = \"../weaver/bin\";\n\tstatic String classDir = WeaverTestCase.TESTDATA_PATH + File.separator + \"bin\";\n\n\tpublic void weaveTest(String name, String outName, List<ShadowMunger> planners) throws IOException {\n\t\tBcelWeaver weaver = new BcelWeaver(world);\n\t\ttry {\n\t\t\tif (behave15)\n\t\t\t\tworld.setBehaveInJava5Way(true);\n\n\t\t\tUnwovenClassFile classFile = makeUnwovenClassFile(classDir, name, outDirPath);\n\n\t\t\tweaver.addClassFile(classFile, false);\n\t\t\tweaver.setShadowMungers(planners);\n\t\t\tweaveTestInner(weaver, classFile, name, outName);\n\t\t} finally {\n\t\t\tif (behave15)\n\t\t\t\tworld.setBehaveInJava5Way(false);\n\t\t}\n\t}\n\n\tprotected void weaveTestInner(BcelWeaver weaver, UnwovenClassFile classFile, String name, String outName) throws IOException {\n\t\t// int preErrors = currentResult.errorCount();\n\t\tBcelObjectType classType = BcelWorld.getBcelObjectType(world.resolve(classFile.getClassName()));\n\t\tLazyClassGen gen = weaver.weave(classFile, classType);\n\t\tif (gen == null) {\n\t\t\t// we didn't do any weaving, but let's make a gen anyway\n\t\t\tgen = classType.getLazyClassGen(); // new LazyClassGen(classType);\n\t\t}\n\t\ttry {\n\t\t\tString filenameToUse = findMostRelevantFile(outName);\n\t\t\tcheckClass(gen, outDirPath, filenameToUse);\n\t\t\tif (runTests) {\n\t\t\t\tSystem.out.println(\"*******RUNNING: \" + outName + \"  \" + name + \" *******\");\n\t\t\t\tTestUtil.runMain(makeClassPath(outDirPath), name);\n\t\t\t}\n\t\t} catch (Error e) {\n\t\t\tSystem.err.println(\"Comparing to \" + outName + \".txt\");\n\t\t\tgen.print(System.err);\n\t\t\tthrow e;\n\t\t} catch (RuntimeException e) {\n\t\t\tgen.print(System.err);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tpublic String findMostRelevantFile(String name) {\n\t\tdouble version = LangUtil.getVmVersion();\n\t\twhile (version > 0) {\n\t\t\tString possibleFileName = name+\".\"+Double.toString(version)+\".txt\";\n\t\t\tif (new File(TESTDATA_DIR, possibleFileName).exists()) {\n\t\t\t\treturn possibleFileName;\n\t\t\t}\n\t\t\tversion--;\n\t\t}\n\t\t// Use the standard file\n\t\treturn name+\".txt\";\n\t}\n\n\tpublic String makeClassPath(String outDir) {\n\t\treturn outDir + File.pathSeparator + getTraceJar() + File.pathSeparator + classDir + File.pathSeparator\n\t\t\t\t+ System.getProperty(\"java.class.path\");\n\t}\n\n\t/**\n\t * '/' in the name indicates the location of the class\n\t */\n\tpublic static UnwovenClassFile makeUnwovenClassFile(String classDir, String name, String outDir) throws IOException {\n\t\tFile outFile = new File(outDir, name + \".class\");\n\t\tif (classDir.endsWith(\".jar\")) {\n\t\t\tString fname = name + \".class\";\n\t\t\tUnwovenClassFile ret = new UnwovenClassFile(outFile.getAbsolutePath(), FileUtil.readAsByteArray(FileUtil\n\t\t\t\t\t.getStreamFromZip(classDir, fname)));\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tFile inFile = new File(classDir, name + \".class\");\n\t\t\treturn new UnwovenClassFile(outFile.getAbsolutePath(), FileUtil.readAsByteArray(inFile));\n\t\t}\n\t}\n\n\tpublic void checkClass(LazyClassGen gen, String outDir, String expectedFile) throws IOException {\n\t\tif (regenerate)\n\t\t\tgenClass(gen, outDir, expectedFile);\n\t\telse\n\t\t\trealCheckClass(gen, outDir, expectedFile);\n\t}\n\n\tstatic final File TESTDATA_DIR = new File(WeaverTestCase.TESTDATA_PATH);\n\n\tvoid genClass(LazyClassGen gen, String outDir, String expectedFile) throws IOException {\n\t\t// ClassGen b = getJavaClass(outDir, className);\n\t\tFileOutputStream out = new FileOutputStream(new File(TESTDATA_DIR, expectedFile));\n\t\tPrintStream ps = new PrintStream(out);\n\t\tgen.print(ps);\n\t\tps.flush();\n\n\t}\n\n\tvoid realCheckClass(LazyClassGen gen, String outDir, String expectedFile) throws IOException {\n\t\tTestUtil.assertMultiLineStringEquals(expectedFile/* \"classes\" */,\n\t\t\t\tFileUtil.readAsString(new File(TESTDATA_DIR, expectedFile)), gen.toLongString());\n\t}\n\n\t// ----\n\tpublic ShadowMunger makeConcreteAdvice(String mungerString) {\n\t\treturn makeConcreteAdvice(mungerString, 0, null);\n\t}\n\n\tpublic ShadowMunger makeConcreteAdvice(String mungerString, int extraArgFlag) {\n\t\treturn makeConcreteAdvice(mungerString, extraArgFlag, null);\n\t}\n\n\tprotected ShadowMunger makeConcreteAdvice(String mungerString, int extraArgFlag, PerClause perClause) {\n\t\tAdvice myMunger = BcelTestUtils.shadowMunger(world, mungerString, extraArgFlag);\n\n\t\t// PerSingleton s = new PerSingleton();\n\t\t// s.concretize(world.resolve(\"Aspect\"));\n\t\t// System.err.println(((KindedPointcut)myMunger.getPointcut().getPointcut()).getKind());\n\t\tAdvice cm = (Advice) myMunger.concretize(myMunger.getDeclaringAspect().resolve(world), world, perClause);\n\t\treturn cm;\n\t}\n\n\tpublic ShadowMunger makeAdviceField(String kind, String extraArgType) {\n\t\treturn makeConcreteAdvice(kind + \"(): get(* *.*) -> static void Aspect.ajc_\" + kind + \"_field_get(\" + extraArgType + \")\", 1);\n\t}\n\n\tpublic List<ShadowMunger> makeAdviceAll(String kind, boolean matchOnlyPrintln) {\n\t\tList<ShadowMunger> ret = new ArrayList<>();\n\t\tif (matchOnlyPrintln) {\n\t\t\tret.add(makeConcreteAdvice(kind + \"(): call(* *.println(..)) -> static void Aspect.ajc_\" + kind + \"_method_execution()\"));\n\t\t} else {\n\t\t\tret.add(makeConcreteAdvice(kind + \"(): call(* *.*(..)) -> static void Aspect.ajc_\" + kind + \"_method_call()\"));\n\t\t\tret.add(makeConcreteAdvice(kind + \"(): call(*.new(..)) -> static void Aspect.ajc_\" + kind + \"_constructor_call()\"));\n\t\t\tret.add(makeConcreteAdvice(kind + \"(): execution(* *.*(..)) -> static void Aspect.ajc_\" + kind + \"_method_execution()\"));\n\t\t\tret.add(makeConcreteAdvice(kind + \"(): execution(*.new(..)) -> static void Aspect.ajc_\" + kind\n\t\t\t\t\t+ \"_constructor_execution()\"));\n\t\t\t// ret.add(\n\t\t\t// makeConcreteMunger(\n\t\t\t// kind\n\t\t\t// + \"(): staticinitialization(*) -> static void Aspect.ajc_\"\n\t\t\t// + kind\n\t\t\t// + \"_staticinitialization()\"));\n\t\t\tret.add(makeConcreteAdvice(kind + \"(): get(* *.*) -> static void Aspect.ajc_\" + kind + \"_field_get()\"));\n\t\t\t// ret.add(\n\t\t\t// makeConcreteMunger(\n\t\t\t// kind + \"(): set(* *.*) -> static void Aspect.ajc_\" + kind + \"_field_set()\"));\n\t\t\t// XXX no test for advice execution, staticInitialization or (god help us) preInitialization\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic List<ShadowMunger> makeAdviceAll(final String kind) {\n\t\treturn makeAdviceAll(kind, false);\n\t}\n\n\tpublic Pointcut makePointcutAll() {\n\t\treturn makeConcretePointcut(\"get(* *.*) || call(* *.*(..)) || execution(* *.*(..)) || call(*.new(..)) || execution(*.new(..))\");\n\t}\n\n\tpublic Pointcut makePointcutNoZeroArg() {\n\t\treturn makeConcretePointcut(\"call(* *.*(*, ..)) || execution(* *.*(*, ..)) || call(*.new(*, ..)) || execution(*.new(*, ..))\");\n\t}\n\n\tpublic Pointcut makePointcutPrintln() {\n\t\treturn makeConcretePointcut(\"call(* *.println(..))\");\n\t}\n\n\tpublic Pointcut makeConcretePointcut(String s) {\n\t\treturn makeResolvedPointcut(s).concretize(null, null, 0);\n\t}\n\n\tpublic Pointcut makeResolvedPointcut(String s) {\n\t\tPointcut pointcut0 = Pointcut.fromString(s);\n\t\treturn pointcut0.resolve(new SimpleScope(world, FormalBinding.NONE));\n\t}\n\n\t// ----\n\n\tpublic String[] getStandardTargets() {\n\t\treturn new String[] { \"HelloWorld\", \"FancyHelloWorld\" };\n\t}\n\n\tpublic String getTraceJar() {\n\t\treturn WeaverTestCase.TESTDATA_PATH + \"/tracing.jar\";\n\t}\n\n\t// ----\n\n\tprotected void weaveTest(String[] inClassNames, String outKind, ShadowMunger patternMunger) throws IOException {\n\t\tfor (String inFileName : inClassNames) {\n\t\t\tweaveTest(inFileName, outKind + inFileName, patternMunger);\n\t\t}\n\t}\n\n\tprotected void weaveTest(String[] inClassNames, String outKind, List<ShadowMunger> patternMungers) throws IOException {\n\t\tfor (String inFileName : inClassNames) {\n\t\t\tweaveTest(inFileName, outKind + inFileName, patternMungers);\n\t\t}\n\t}\n\n\tprotected List<ShadowMunger> addLexicalOrder(List<ShadowMunger> l) {\n\t\tint i = 10;\n\t\tfor (ShadowMunger element: l) {\n\t\t\t((Advice)element).setLexicalPosition(i += 10);\n\t\t}\n\t\treturn l;\n\t}\n\n\t// XXX cut-and-paster from IdWeaveTestCase\n\tpublic void checkShadowSet(List l, String[] ss) {\n\t\touter:\n\t\tfor (String s : ss) {\n\t\t\t// inner:\n\t\t\tfor (Iterator j = l.iterator(); j.hasNext(); ) {\n\t\t\t\tBcelShadow shadow = (BcelShadow) j.next();\n\t\t\t\tString shadowString = shadow.toString();\n\t\t\t\tif (shadowString.equals(s)) {\n\t\t\t\t\tj.remove();\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassertTrue(\"didn't find \" + s + \" in \" + l, false);\n\t\t}\n\t\tassertTrue(\"too many things in \" + l, l.size() == 0);\n\t}\n\n}\n",
    "size": 11092
  },
  {
    "file_id": "F151",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/WorldTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.lang.reflect.Modifier;\n\nimport org.aspectj.weaver.Advice;\nimport org.aspectj.weaver.CommonWorldTests;\nimport org.aspectj.weaver.Member;\nimport org.aspectj.weaver.MemberImpl;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.ShadowMunger;\nimport org.aspectj.weaver.TestUtils;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeaverTestCase;\nimport org.aspectj.weaver.World;\n\n/**\n * This is a test case for the nameType parts of worlds.\n */\npublic class WorldTestCase extends CommonWorldTests {\n\n\tprivate final BcelWorld world = new BcelWorld(WeaverTestCase.TESTDATA_PATH + \"/tracing.jar\");\n\n\tprotected World getWorld() {\n\t\treturn world;\n\t}\n\n\tprotected boolean getSupportsAutoboxing() {\n\t\treturn true;\n\t}\n\n\t// XXX fix the various XXXs before expecting this test to work\n\tpublic void xtestTraceJar() {\n\t\tResolvedType trace = world.resolve(UnresolvedType.forName(\"Trace\"), true);\n\t\tassertTrue(\"Couldnt find type Trace\", !trace.isMissing());\n\t\tfieldsTest(trace, Member.NONE);\n\t\t/* Member constr = */TestUtils.methodFromString(\"void Trace.<init>()\");\n\t\t// XXX need attribute fix -\n\t\t// methodsTest(trace, new Member[] { constr });\n\n\t\tinterfacesTest(trace, ResolvedType.NONE);\n\t\tsuperclassTest(trace, UnresolvedType.OBJECT);\n\t\tisInterfaceTest(trace, false);\n\t\tisClassTest(trace, false);\n\t\tisAspectTest(trace, true);\n\n\t\tpointcutsTest(trace, new Member[] { MemberImpl.pointcut(trace, \"traced\", \"(Ljava/lang/Object;)V\"), });\n\n\t\tmodifiersTest(trace.findPointcut(\"traced\"), Modifier.PUBLIC | Modifier.ABSTRACT);\n\n\t\tmungersTest(\n\t\t\t\ttrace,\n\t\t\t\tnew ShadowMunger[] {\n\t\t\t\t\t\tBcelTestUtils.shadowMunger(world, \"before(foo): traced(foo) -> void Trace.ajc_before_4(java.lang.Object))\",\n\t\t\t\t\t\t\t\t0),\n\t\t\t\t\t\tBcelTestUtils\n\t\t\t\t\t\t\t\t.shadowMunger(\n\t\t\t\t\t\t\t\t\t\tworld,\n\t\t\t\t\t\t\t\t\t\t\"afterReturning(foo): traced(foo) -> void Trace.ajc_afterreturning_3(java.lang.Object, java.lang.Object))\",\n\t\t\t\t\t\t\t\t\t\tAdvice.ExtraArgument),\n\t\t\t\t\t\tBcelTestUtils\n\t\t\t\t\t\t\t\t.shadowMunger(\n\t\t\t\t\t\t\t\t\t\tworld,\n\t\t\t\t\t\t\t\t\t\t\"around(): execution(* doit(..)) -> java.lang.Object Trace.ajc_around_2(org.aspectj.runtime.internal.AroundClosure))\",\n\t\t\t\t\t\t\t\t\t\tAdvice.ExtraArgument),\n\t\t\t\t\t\tBcelTestUtils\n\t\t\t\t\t\t\t\t.shadowMunger(\n\t\t\t\t\t\t\t\t\t\tworld,\n\t\t\t\t\t\t\t\t\t\t\"around(foo): traced(foo) -> java.lang.Object Trace.ajc_around_1(java.lang.Object, org.aspectj.runtime.internal.AroundClosure))\",\n\t\t\t\t\t\t\t\t\t\tAdvice.ExtraArgument), });\n\n\t\tResolvedType myTrace = world.resolve(UnresolvedType.forName(\"MyTrace\"), true);\n\t\tassertTrue(\"Couldnt find type MyTrace\", !myTrace.isMissing());\n\n\t\tinterfacesTest(myTrace, ResolvedType.NONE);\n\t\tsuperclassTest(myTrace, trace);\n\t\tisInterfaceTest(myTrace, false);\n\t\tisClassTest(myTrace, false);\n\t\tisAspectTest(myTrace, true);\n\n\t\t// XXX need attribute fix -\n\t\t// fieldsTest(myTrace, Member.NONE);\n\n\t\tpointcutsTest(trace, new Member[] { MemberImpl.pointcut(trace, \"traced\", \"(Ljava/lang/Object;)V\"), });\n\n\t\tmodifiersTest(myTrace.findPointcut(\"traced\"), Modifier.PUBLIC);\n\n\t\t// this tests for declared mungers\n\t\tmungersTest(myTrace, ShadowMunger.NONE);\n\n\t}\n\n\tpublic void testIterator() {\n\t\tint abstractPublic = Modifier.ABSTRACT | Modifier.PUBLIC;\n\t\tResolvedType iter = world.getCoreType(UnresolvedType.forRawTypeName(\"java.util.Iterator\"));\n\n\t\tmodifiersTest(iter, abstractPublic | Modifier.INTERFACE);\n\t\tfieldsTest(iter, ResolvedMember.NONE);\n\t\tmethodsTest(iter, new Member[] {\n\t\t\t\tMemberImpl.method(iter, 0, \"hasNext\", \"()Z\"),\n\t\t\t\tMemberImpl.method(iter, 0, \"remove\", \"()V\"),\n\t\t\t\tMemberImpl.method(iter, 0, \"next\", \"()Ljava/lang/Object;\"),\n\t\t\t\tMemberImpl.method(iter, 0, \"forEachRemaining\", \"(Ljava/util/function/Consumer;)V\")\n//\t\t\t\tdefault void forEachRemaining(Consumer<? super E> action) {\n//\t\t\t        Objects.requireNonNull(action);\n//\t\t\t        while (hasNext())\n//\t\t\t            action.accept(next());\n//\t\t\t    }\n\t\t\t\t});\n\t\tResolvedMember remove = iter.lookupMethod(MemberImpl.method(iter, 0, \"remove\", \"()V\"));\n\t\tassertNotNull(\"iterator doesn't have remove\", remove);\n\t\tmodifiersTest(remove, Modifier.PUBLIC); // no longer abstract in Java8 (default instead)\n\t\texceptionsTest(remove, UnresolvedType.NONE);\n\n\t\tResolvedMember clone = iter.lookupMethod(MemberImpl.method(UnresolvedType.OBJECT, 0, \"clone\", \"()Ljava/lang/Object;\"));\n\t\tassertNotNull(\"iterator doesn't have clone\", clone);\n\t\t// AV: JRockit Object.clone() is not native.. corrupted test here:\n\t\t// modifiersTest(clone, Modifier.PROTECTED | Modifier.NATIVE);\n\t\tassertTrue(\"should be protected\" + clone.toString(), Modifier.isProtected(clone.getModifiers()));\n\t\texceptionsTest(clone, UnresolvedType.forNames(new String[] { \"java.lang.CloneNotSupportedException\" }));\n\n\t\tinterfacesTest(iter, ResolvedType.NONE);\n\t\tsuperclassTest(iter, UnresolvedType.OBJECT);\n\t\tpointcutsTest(iter, ResolvedMember.NONE);\n\t\tmungersTest(iter, ShadowMunger.NONE);\n\t\tisInterfaceTest(iter, true);\n\t\tisClassTest(iter, false);\n\t\tisAspectTest(iter, false);\n\t}\n\n\tpublic void testObjectCoersion() {\n\t\tassertCouldBeCoercibleFrom(\"java.lang.Object\", \"java.lang.String\");\n\t\tassertCouldBeCoercibleFrom(\"java.lang.Integer\", \"java.lang.Object\");\n\t\tassertCouldBeCoercibleFrom(\"java.io.Serializable\", \"java.lang.Runnable\");\n\t\tassertCouldBeCoercibleFrom(\"java.util.Stack\", \"java.lang.Runnable\");\n\t\tassertCouldNotBeCoercibleFrom(\"java.lang.Runnable\", \"java.lang.Integer\");\n\t\tassertCouldNotBeCoercibleFrom(\"java.lang.Integer\", \"java.lang.String\");\n\t\tassertCouldNotBeCoercibleFrom(\"java.lang.Integer\", \"java.lang.Runnable\");\n\t}\n\n\t// ----\n\n\tprivate void assertCouldBeCoercibleFrom(String a, String b) {\n\t\tisCoerceableFromTest(world.resolve(a), world.resolve(b), true);\n\t}\n\n\tprivate void assertCouldNotBeCoercibleFrom(String a, String b) {\n\t\tisCoerceableFromTest(world.resolve(a), world.resolve(b), false);\n\t}\n\n}\n",
    "size": 6341
  },
  {
    "file_id": "F152",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/ZipFileWeaver.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.File;\nimport java.io.IOException;\n\n\n//XXX delete very soon\npublic class ZipFileWeaver {\n\tFile inFile;\n\tpublic ZipFileWeaver(File inFile) {\n\t\tsuper();\n\t\tthis.inFile = inFile;\n\t}\n\n\tpublic void weave(BcelWeaver weaver, File outFile) throws IOException {\n\t\tint count = 0;\n\t\tlong startTime = System.currentTimeMillis();\n\t\tweaver.addJarFile(inFile, new File(\".\"),false);\n\t\tweaver.weave(outFile);\n\t\tlong stopTime = System.currentTimeMillis();\n\n\n\t\tSystem.out.println(\"handled \" + count + \" entries, in \" +\n\t\t\t\t(stopTime-startTime)/1000. + \" seconds\");\n\t}\n}\n",
    "size": 1136
  },
  {
    "file_id": "F153",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/bcel/ZipTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.bcel;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collection;\n\nimport org.aspectj.weaver.WeaverTestCase;\n\nimport junit.framework.TestCase;\n\npublic class ZipTestCase extends TestCase {\n\n\tFile outDir;\n\n\t/**\n\t * Constructor for ZipTestCase.\n\t *\n\t * @param arg0\n\t */\n\tpublic ZipTestCase(String arg0) {\n\t\tsuper(arg0);\n\t}\n\n\tpublic void setUp() {\n\t\toutDir = WeaverTestCase.getOutdir();\n\t}\n\n\tpublic void tearDown() {\n\t\tWeaverTestCase.removeOutDir();\n\t\toutDir = null;\n\t}\n\n\tpublic void zipTest(String fileName, String aspectjar) throws IOException {\n\t\tzipTest(fileName, aspectjar, false);\n\t}\n\n\tpublic void zipTest(String fileName, String aspectjar, boolean isInJar) throws IOException {\n\t\tFile inFile = new File(fileName);\n\t\tFile outFile = new File(outDir, inFile.getName());\n\t\tBcelWorld world = new BcelWorld();\n\t\tBcelWeaver weaver = new BcelWeaver(world);\n\n\t\tlong startTime = System.currentTimeMillis();\n\t\t// ensure that a fast cpu doesn't complete file write within 1000ms of start\n\t\ttry {\n\t\t\tThread.sleep(2000);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tweaver.addJarFile(inFile, new File(\".\"), false);\n\n\t\tif (aspectjar != null) {\n\t\t\tif (isInJar) {\n\t\t\t\tweaver.addJarFile(new File(aspectjar), new File(\".\"), false);\n\t\t\t} else {\n\t\t\t\tweaver.addLibraryJarFile(new File(aspectjar));\n\t\t\t\tworld.addPath(new File(aspectjar).toString());\n\t\t\t}\n\t\t}\n\t\tweaver.addLibraryJarFile(new File(WeaverTestCase.TESTDATA_PATH + \"/Regex.jar\")); // ???\n\t\tworld.addPath(new File(WeaverTestCase.TESTDATA_PATH + \"/Regex.jar\").getPath());\n\n\t\tCollection<String> woven = weaver.weave(outFile);\n\t\tlong stopTime = System.currentTimeMillis();\n\n\t\tSystem.out.println(\"handled \" + woven.size() + \" entries, in \" + (stopTime - startTime) / 1000. + \" seconds\");\n\t\t// last mod times on linux (at least) are only accurate to the second.\n\t\t// with fast disks and a fast cpu the following test can fail if the write completes less than\n\t\t// 1000 milliseconds after the start of the test, hence the 1000ms delay added above.\n\t\tassertTrue(outFile.lastModified() > startTime);\n\t}\n\n\tpublic void testSmall() throws IOException {\n\t\tzipTest(WeaverTestCase.TESTDATA_PATH + \"/Regex.jar\", null);\n\t}\n\n\tpublic void testSmallWithAspects() throws IOException {\n\t\tSystem.out.println(\"could take 4 seconds...\");\n\t\tzipTest(WeaverTestCase.TESTDATA_PATH + \"/Regex.jar\", WeaverTestCase.TESTDATA_PATH + \"/megatrace.jar\");\n\t}\n\n\tpublic void testSmallWithAspectsNoWeave() throws IOException {\n\t\tSystem.out.println(\"could take 4 seconds...\");\n\t\tzipTest(WeaverTestCase.TESTDATA_PATH + \"/Regex.jar\", WeaverTestCase.TESTDATA_PATH + \"/megatraceNoweave.jar\", true);\n\t}\n\n\tpublic void testBig() throws IOException {\n\t\tSystem.out.println(\"could take 4 seconds...\");\n\t\t// Weave a big JAR file. This is unrelated to Ant, i.e. the JAR can be replaced by another one for this test.\n\t\tzipTest(\"../lib/ant/lib/ant.jar\", null);\n\t}\n\n\tpublic void testBigWithEasyNoTrace() throws IOException {\n\t\tSystem.out.println(\"could take 4 seconds...\");\n\t\t// Weave a big JAR file. This is unrelated to Ant, i.e. the JAR can be replaced by another one for this test.\n\t\tzipTest(\"../lib/ant/lib/ant.jar\", WeaverTestCase.TESTDATA_PATH + \"/megatrace0easy.jar\");\n\t}\n\n\t// this is something we test every now and again.\n\tpublic void xtestBigWithHardNoTrace() throws IOException {\n\t\tSystem.out.println(\"could take 24 seconds...\");\n\t\t// Weave a big JAR file. This is unrelated to Ant, i.e. the JAR can be replaced by another one for this test.\n\t\tzipTest(\"../lib/ant/lib/ant.jar\", WeaverTestCase.TESTDATA_PATH + \"/megatrace0hard.jar\");\n\t}\n\n\tpublic void xtestBigWithAspects() throws IOException {\n\t\tSystem.out.println(\"could take 40 seconds...\");\n\t\t// Weave a big JAR file. This is unrelated to Ant, i.e. the JAR can be replaced by another one for this test.\n\t\tzipTest(\"../lib/ant/lib/ant.jar\", WeaverTestCase.TESTDATA_PATH + \"/megatrace.jar\");\n\t}\n\n}\n",
    "size": 4449
  },
  {
    "file_id": "F154",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/AnnotationPatternMatchingTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2004 IBM Corporation.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement     initial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.patterns;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.aspectj.bridge.AbortException;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.IMessage.Kind;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.WeaverTestCase;\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\n/*\n * Sample types that this program uses are:\n\n import p.SimpleAnnotation;\n\n @SimpleAnnotation(id=2)\n public class AnnotatedClass {\n\n @SimpleAnnotation(id=3)\n public void m1() { }\n\n @SimpleAnnotation(id=4)\n int i;\n }\n\n * with SimpleAnnotation defined as:\n\n package p;\n import java.lang.annotation.*;\n\n @Retention(RetentionPolicy.RUNTIME)\n public @interface SimpleAnnotation {\n int id();\n String fruit() default \"bananas\";\n }\n\n *NOTE NOTE NOTE NOTE NOTE NOTE NOTE*\n If you need to rebuild the test data code, run 'ant -f build-15.xml' in the\n testdata directory.\n\n */\npublic class AnnotationPatternMatchingTestCase extends TestCase {\n\n\tprivate BcelWorld world;\n\tprivate AnnotationTypePattern fooTP, simpleAnnotationTP;\n\n\tprivate ResolvedType loadType(String name) {\n\t\tif (world == null) {\n\t\t\tworld = new BcelWorld(WeaverTestCase.TESTDATA_PATH + \"/testcode.jar\");\n\t\t\tworld.setBehaveInJava5Way(true);\n\t\t}\n\t\treturn world.resolve(name);\n\t}\n\n\tprivate void initAnnotationTypePatterns() {\n\t\tPatternParser p = new PatternParser(\"@Foo\");\n\t\tfooTP = p.maybeParseAnnotationPattern();\n\t\tfooTP = fooTP.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\n\t\tp = new PatternParser(\"@p.SimpleAnnotation\");\n\t\tsimpleAnnotationTP = p.maybeParseAnnotationPattern();\n\t\tsimpleAnnotationTP = simpleAnnotationTP.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t}\n\n\tpublic void testAnnotationPatternMatchingOnTypes() {\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\n\t\tinitAnnotationTypePatterns();\n\n\t\t// One should match\n\t\tassertTrue(\"@Foo should not match on the AnnotatedClass\", fooTP.matches(rtx).alwaysFalse());\n\t\tassertTrue(\"@SimpleAnnotation should match on the AnnotatedClass\", simpleAnnotationTP.matches(rtx).alwaysTrue());\n\n\t}\n\n\tstatic class MyMessageHandler implements IMessageHandler {\n\t\tpublic List<IMessage> messages = new ArrayList<>();\n\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\n\t\t\tmessages.add(message);\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic boolean isIgnoring(Kind kind) {\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\n\t\t}\n\n\t\tpublic void ignore(Kind kind) {\n\t\t}\n\t}\n\n\tpublic void testReferenceToNonAnnotationType() {\n\t\t// ResolvedType rtx =\n\t\tloadType(\"AnnotatedClass\"); // inits the world\n\t\tPatternParser p = new PatternParser(\"@java.lang.String\");\n\n\t\tMyMessageHandler mh = new MyMessageHandler();\n\t\tworld.setMessageHandler(mh);\n\t\tAnnotationTypePattern atp = p.maybeParseAnnotationPattern();\n\t\tatp = atp.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\n\t\tassertTrue(\"Expected 1 error message but got \" + mh.messages.size(), mh.messages.size() == 1);\n\n\t\tString expected = \"Type referred to is not an annotation type\";\n\t\tString msg = ((IMessage) mh.messages.get(0)).toString();\n\t\tassertTrue(\"Expected: \" + expected + \" but got \" + msg, msg.contains(expected));\n\t}\n\n\tpublic void testReferenceViaFormalToNonAnnotationType() {\n\t\t// ResolvedType rtx =\n\t\tloadType(\"AnnotatedClass\"); // inits the world\n\t\tPatternParser p = new PatternParser(\"a\");\n\n\t\tMyMessageHandler mh = new MyMessageHandler();\n\t\tworld.setMessageHandler(mh);\n\t\tAnnotationTypePattern atp = p.parseAnnotationNameOrVarTypePattern();\n\t\tatp = atp.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\n\t\tassertTrue(\"Expected 3 error messages but got \" + mh.messages.size(), mh.messages.size() == 3);\n\n\t\tString expected = \"Type referred to is not an annotation type\";\n\t\tString msg = ((IMessage) mh.messages.get(0)).toString();\n\t\tassertTrue(\"Expected: \" + expected + \" but got \" + msg, msg.contains(expected));\n\n\t\t// expected = \"Binding not supported in @pcds (1.5.0 M1 limitation): null\";\n\t\t// msg = ((IMessage)mh.messages.get(1)).toString();\n\t\t// assertTrue(\"Expected: \"+expected+\" but got \"+msg,msg.indexOf(expected)!=-1);\n\t}\n\n\tpublic TestScope makeSimpleScope() {\n\t\treturn new TestScope(new String[] { \"int\", \"java.lang.String\" }, new String[] { \"a\", \"b\" }, world);\n\t}\n\n\tpublic void testUnresolvedAnnotationTypes() {\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\n\n\t\tPatternParser p = new PatternParser(\"@Foo\");\n\t\tAnnotationTypePattern fooTP = p.maybeParseAnnotationPattern();\n\t\ttry {\n\t\t\tfooTP.matches(rtx);\n\t\t\tfail(\"Should have failed with illegal state exception, fooTP is not resolved\");\n\t\t} catch (IllegalStateException ise) {\n\t\t\t// Correct!\n\t\t}\n\t}\n\n\tpublic void testAnnotationPatternMatchingOnMethods() {\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\n\t\tResolvedMember aMethod = rtx.getDeclaredMethods()[1];\n\n\t\tassertTrue(\"Haven't got the right method, I'm looking for 'm1()': \" + aMethod.getName(), aMethod.getName().equals(\"m1\"));\n\n\t\tinitAnnotationTypePatterns();\n\n\t\t// One should match\n\t\tassertTrue(\"@Foo should not match on the AnnotatedClass.m1() method\", fooTP.matches(aMethod).alwaysFalse());\n\t\tassertTrue(\"@SimpleAnnotation should match on the AnnotatedClass.m1() method\", simpleAnnotationTP.matches(aMethod)\n\t\t\t\t.alwaysTrue());\n\t}\n\n\tpublic void testAnnotationPatternMatchingOnFields() {\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\n\t\tResolvedMember aField = rtx.getDeclaredFields()[0];\n\n\t\tassertTrue(\"Haven't got the right field, I'm looking for 'i'\" + aField.getName(), aField.getName().equals(\"i\"));\n\n\t\tinitAnnotationTypePatterns();\n\n\t\t// One should match\n\t\tassertTrue(\"@Foo should not match on the AnnotatedClass.i field\", fooTP.matches(aField).alwaysFalse());\n\t\tassertTrue(\"@SimpleAnnotation should match on the AnnotatedClass.i field\", simpleAnnotationTP.matches(aField)\n\t\t\t\t.alwaysTrue());\n\n\t}\n\n\tpublic void testAnnotationTypeResolutionOnTypes() {\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\n\t\tResolvedType[] types = rtx.getAnnotationTypes();\n\t\tassertTrue(\"Did not expect null\", types != null);\n\t\tassertTrue(\"Expected 1 entry but got \" + types.length, types.length == 1);\n\t\tassertTrue(\"Should be 'p.SimpleAnnotation' but is \" + types[0], types[0].equals(world.resolve(\"p.SimpleAnnotation\")));\n\t}\n\n\tpublic void testAnnotationTypeResolutionOnMethods() {\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\n\n\t\tResolvedMember aMethod = rtx.getDeclaredMethods()[1];\n\t\tassertTrue(\"Haven't got the right method, I'm looking for 'm1()': \" + aMethod.getName(), aMethod.getName().equals(\"m1\"));\n\n\t\tResolvedType[] types = aMethod.getAnnotationTypes();\n\t\tassertTrue(\"Did not expect null\", types != null);\n\t\tassertTrue(\"Expected 1 entry but got \" + types.length, types.length == 1);\n\t\tassertTrue(\"Should be 'p.SimpleAnnotation' but is \" + types[0], types[0].equals(world.resolve(\"p.SimpleAnnotation\")));\n\t}\n\n\tpublic void testAnnotationTypeResolutionOnFields() {\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\n\n\t\tResolvedMember aField = rtx.getDeclaredFields()[0];\n\n\t\tassertTrue(\"Haven't got the right field, I'm looking for 'i'\" + aField.getName(), aField.getName().equals(\"i\"));\n\n\t\tResolvedType[] types = aField.getAnnotationTypes();\n\t\tassertTrue(\"Did not expect null\", types != null);\n\t\tassertTrue(\"Expected 1 entry but got \" + types.length, types.length == 1);\n\t\tassertTrue(\"Should be 'p.SimpleAnnotation' but is \" + types[0], types[0].equals(world.resolve(\"p.SimpleAnnotation\")));\n\t}\n\n\tpublic void testWildPatternMatchingOnTypes() {\n\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\n\t\tinitAnnotationTypePatterns();\n\n\t\t// Let's create something wild\n\t\tPatternParser p = new PatternParser(\"@(Foo || Boo)\");\n\t\tAnnotationTypePattern ap = p.maybeParseAnnotationPattern();\n\t\tap = ap.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t\tassertTrue(\"shouldnt match the type AnnotatedClass\", ap.matches(rtx).alwaysFalse());\n\n\t\tp = new PatternParser(\"@(p.SimpleAnnotation || Boo)\");\n\t\tap = p.maybeParseAnnotationPattern();\n\t\tap = ap.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t\tassertTrue(\"should match the type AnnotatedClass\", ap.matches(rtx).alwaysTrue());\n\t}\n\n}\n",
    "size": 8699
  },
  {
    "file_id": "F155",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/AnnotationPatternTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2004 IBM Corporation.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * ******************************************************************/\npackage org.aspectj.weaver.patterns;\n\nimport org.aspectj.bridge.AbortException;\nimport org.aspectj.weaver.AnnotatedElement;\nimport org.aspectj.weaver.AnnotationAJ;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeaverTestCase;\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\npublic class AnnotationPatternTestCase extends TestCase {\n\n\tpublic void testParseSimpleAnnotationPattern() {\n\t\tPatternParser p = new PatternParser(\"@Foo\");\n\t\tAnnotationTypePattern foo = p.maybeParseAnnotationPattern();\n\t\tfoo = foo.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t\tassertTrue(\"ExactAnnotationTypePattern\", foo instanceof ExactAnnotationTypePattern);\n\t\tassertEquals(\"Foo\", UnresolvedType.forSignature(\"LFoo;\"), ((ExactAnnotationTypePattern) foo).annotationType);\n\t}\n\n\tpublic void testParseAndAnnotationPattern() {\n\t\tPatternParser p = new PatternParser(\"@Foo @Goo\");\n\t\tAnnotationTypePattern fooAndGoo = p.maybeParseAnnotationPattern();\n\t\tassertTrue(\"AndAnnotationTypePattern\", fooAndGoo instanceof AndAnnotationTypePattern);\n\t\tassertEquals(\"@(Foo) @(Goo)\", fooAndGoo.toString());\n\t\tfooAndGoo = fooAndGoo.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t\tassertEquals(\"@Foo @Goo\", fooAndGoo.toString());\n\t\tAnnotationTypePattern left = ((AndAnnotationTypePattern) fooAndGoo).getLeft();\n\t\tAnnotationTypePattern right = ((AndAnnotationTypePattern) fooAndGoo).getRight();\n\t\tassertEquals(\"Foo\", UnresolvedType.forSignature(\"LFoo;\"), ((ExactAnnotationTypePattern) left).annotationType);\n\t\tassertEquals(\"Goo\", UnresolvedType.forSignature(\"LGoo;\"), ((ExactAnnotationTypePattern) right).annotationType);\n\t}\n\n\t//\n\t// public void testParseOrAnnotationPattern() {\n\t// PatternParser p = new PatternParser(\"@Foo || @Goo\");\n\t// AnnotationTypePattern fooOrGoo = p.parseAnnotationTypePattern();\n\t// assertTrue(\"OrAnnotationTypePattern\",fooOrGoo instanceof\n\t// OrAnnotationTypePattern);\n\t// assertEquals(\"(@Foo || @Goo)\",fooOrGoo.toString());\n\t// AnnotationTypePattern left =\n\t// ((OrAnnotationTypePattern)fooOrGoo).getLeft();\n\t// AnnotationTypePattern right =\n\t// ((OrAnnotationTypePattern)fooOrGoo).getRight();\n\t// assertEquals(\"Foo\",UnresolvedType.forName(\"Foo\"),((\n\t// ExactAnnotationTypePattern)left).annotationType);\n\t// assertEquals(\"Goo\",UnresolvedType.forName(\"Goo\"),((\n\t// ExactAnnotationTypePattern)right).annotationType);\n\t// }\n\t//\n\tpublic void testParseNotAnnotationPattern() {\n\t\tPatternParser p = new PatternParser(\"!@Foo\");\n\t\tAnnotationTypePattern notFoo = p.maybeParseAnnotationPattern();\n\t\tassertTrue(\"NotAnnotationTypePattern\", notFoo instanceof NotAnnotationTypePattern);\n\t\tnotFoo = notFoo.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t\tassertEquals(\"!@Foo\", notFoo.toString());\n\t\tAnnotationTypePattern body = ((NotAnnotationTypePattern) notFoo).getNegatedPattern();\n\t\tassertEquals(\"Foo\", UnresolvedType.forName(\"Foo\"), ((ExactAnnotationTypePattern) body).annotationType);\n\t}\n\n\tpublic void testParseBracketedAnnotationPattern() {\n\t\tPatternParser p = new PatternParser(\"(@Foo)\");\n\t\tAnnotationTypePattern foo = p.maybeParseAnnotationPattern();\n\t\t// cannot start with ( so, we get ANY\n\t\tassertEquals(\"ANY\", AnnotationTypePattern.ANY, foo);\n\t}\n\n\tpublic void testParseFQAnnPattern() {\n\t\tPatternParser p = new PatternParser(\"@org.aspectj.Foo\");\n\t\tAnnotationTypePattern foo = p.maybeParseAnnotationPattern();\n\t\tassertEquals(\"@(org.aspectj.Foo)\", foo.toString());\n\t}\n\n\tpublic void testParseComboPattern() {\n\t\t// PatternParser p = new PatternParser(\"!((@Foo || @Goo) && !@Boo)\");\n\t\tPatternParser p = new PatternParser(\"@(Foo || Goo)!@Boo\");\n\t\tAnnotationTypePattern ap = p.maybeParseAnnotationPattern();\n\t\tap = ap.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t\tAndAnnotationTypePattern atp = (AndAnnotationTypePattern) ap;\n\t\tNotAnnotationTypePattern notBoo = (NotAnnotationTypePattern) atp.getRight();\n\t\t// ExactAnnotationTypePattern boo = (ExactAnnotationTypePattern)\n\t\tnotBoo.getNegatedPattern();\n\t\t// AnnotationTypePattern fooOrGoo = (AnnotationTypePattern)\n\t\tatp.getLeft();\n\t\tassertEquals(\"@((Foo || Goo)) !@Boo\", ap.toString());\n\t}\n\n\t// public void testParseAndOrPattern() {\n\t// PatternParser p = new PatternParser(\"@Foo && @Boo || @Goo\");\n\t// AnnotationTypePattern andOr = p.parseAnnotationTypePattern();\n\t// assertTrue(\"Should be or pattern\",andOr instanceof\n\t// OrAnnotationTypePattern);\n\t// }\n\t//\n\tpublic void testParseBadPattern() {\n\t\tPatternParser p = new PatternParser(\"@@Foo\");\n\t\ttry {\n\t\t\tp.maybeParseAnnotationPattern();\n\t\t\tfail(\"ParserException expected\");\n\t\t} catch (ParserException pEx) {\n\t\t\tassertEquals(\"name pattern\", pEx.getMessage());\n\t\t}\n\t}\n\n\tpublic void testParseBadPattern2() {\n\t\tPatternParser p = new PatternParser(\"Foo\");\n\t\tAnnotationTypePattern bad = p.maybeParseAnnotationPattern();\n\t\tassertEquals(\"ANY\", AnnotationTypePattern.ANY, bad);\n\t}\n\n\tpublic void testParseNameOrVarAnnotationPattern() {\n\t\tPatternParser p = new PatternParser(\"Foo\");\n\t\tAnnotationTypePattern foo = p.parseAnnotationNameOrVarTypePattern();\n\t\tassertTrue(\"ExactAnnotationTypePattern expected\", foo != null);\n\t\tassertEquals(\"Foo\", UnresolvedType.forName(\"Foo\"), ((ExactAnnotationTypePattern) foo).annotationType);\n\t}\n\n\tpublic void testParseNameOrVarAnnotationPatternWithNot() {\n\t\tPatternParser p = new PatternParser(\"!@Foo\");\n\t\ttry {\n\t\t\t// AnnotationTypePattern bad =\n\t\t\tp.parseAnnotationNameOrVarTypePattern();\n\t\t\tfail(\"ParserException expected\");\n\t\t} catch (ParserException pEx) {\n\t\t\tassertEquals(\"identifier\", pEx.getMessage());\n\t\t}\n\t}\n\n\tpublic void testParseNameOrVarAnnotationPatternWithOr() {\n\t\tPatternParser p = new PatternParser(\"Foo || Boo\");\n\t\tAnnotationTypePattern foo = p.parseAnnotationNameOrVarTypePattern();\n\t\t// rest of pattern not consumed...\n\t\tassertTrue(\"ExactAnnotationTypePattern\", foo instanceof ExactAnnotationTypePattern);\n\t\tassertEquals(\"Foo\", UnresolvedType.forName(\"Foo\"), ((ExactAnnotationTypePattern) foo).annotationType);\n\t}\n\n\tpublic void testParseNameOrVarAnnotationWithBinding() {\n\t\tPatternParser p = new PatternParser(\"foo\");\n\t\tAnnotationTypePattern foo = p.parseAnnotationNameOrVarTypePattern();\n\t\tassertTrue(\"ExactAnnotationTypePattern\", foo instanceof ExactAnnotationTypePattern);\n\t\tassertEquals(\"@foo\", ((ExactAnnotationTypePattern) foo).toString());\n\t}\n\n\tpublic void testParseNameOrVarAnnotationPatternWithAnd() {\n\t\tPatternParser p = new PatternParser(\"Foo Boo\");\n\t\tAnnotationTypePattern foo = p.parseAnnotationNameOrVarTypePattern();\n\t\t// rest of pattern not consumed...\n\t\tassertEquals(\"@Foo\", foo.toString());\n\t}\n\n\tpublic void testMaybeParseAnnotationPattern() {\n\t\tPatternParser p = new PatternParser(\"@Foo\");\n\t\tAnnotationTypePattern a = p.maybeParseAnnotationPattern();\n\t\tassertNotNull(\"Should find annotation pattern\", a);\n\t\tp = new PatternParser(\"Foo && Boo\");\n\t\ta = p.maybeParseAnnotationPattern();\n\t\tassertEquals(\"Should be ANY pattern for a non-match\", AnnotationTypePattern.ANY, a);\n\t}\n\n\tpublic void testParseTypePatternsWithAnnotations() {\n\t\tPatternParser p = new PatternParser(\"@Foo *\");\n\t\tTypePattern t = p.parseTypePattern();\n\t\tassertTrue(\"AnyWithAnnotationTypePattern\", t instanceof AnyWithAnnotationTypePattern);\n\t\tAnnotationTypePattern atp = t.annotationPattern;\n\t\tassertEquals(\"@(Foo)\", atp.toString());\n\t\tassertEquals(\"(@(Foo) *)\", t.toString());\n\t}\n\n\tpublic void testParseTypePatternsWithAnnotationsComplex() {\n\t\tPatternParser p = new PatternParser(\"(@(Foo || Boo) (Foo || Boo))\");\n\t\tTypePattern t = p.parseTypePattern();\n\t\tassertTrue(\"OrTypePattern\", t instanceof OrTypePattern);\n\t\tassertEquals(\"((@((Foo || Boo)) Foo) || (@((Foo || Boo)) Boo))\", t.toString());\n\t}\n\n\tpublic void testNotSyntax() {\n\t\tPatternParser p = new PatternParser(\"!@Foo (Foo || Boo))\");\n\t\tTypePattern t = p.parseTypePattern();\n\t\tassertTrue(\"OrTypePattern\", t instanceof OrTypePattern);\n\t\tassertEquals(\"((!@(Foo) Foo) || (!@(Foo) Boo))\", t.toString());\n\t}\n\n\tpublic void testParseMethodOrConstructorSigNoAP() {\n\t\tPatternParser p = new PatternParser(\"* *.*(..)\");\n\t\tSignaturePattern s = p.parseMethodOrConstructorSignaturePattern();\n\t\tassertEquals(\"Any annotation\", AnnotationTypePattern.ANY, s.getAnnotationPattern());\n\t\tassertEquals(\"Any return\", \"*\", s.getReturnType().toString());\n\t\tassertEquals(\"Any dec type\", \"*\", s.getDeclaringType().toString());\n\t\tassertEquals(\"Any name\", \"*\", s.getName().toString());\n\t\tassertEquals(\"* *.*(..)\", s.toString());\n\t}\n\n\tpublic void testParseMethodOrConstructorSigSimpleAP() {\n\t\tPatternParser p = new PatternParser(\"@Foo * *.*(..)\");\n\t\tSignaturePattern s = p.parseMethodOrConstructorSignaturePattern();\n\t\tassertEquals(\"@(Foo) annotation\", \"@(Foo)\", s.getAnnotationPattern().toString());\n\t\tassertEquals(\"Any return\", \"*\", s.getReturnType().toString());\n\t\tassertEquals(\"Any dec type\", \"*\", s.getDeclaringType().toString());\n\t\tassertEquals(\"Any name\", \"*\", s.getName().toString());\n\t\tassertEquals(\"@(Foo) * *.*(..)\", s.toString());\n\t}\n\n\tpublic void testParseMethodOrConstructorSigComplexAP() {\n\t\tPatternParser p = new PatternParser(\"!@(Foo || Goo) * *.*(..)\");\n\t\tSignaturePattern s = p.parseMethodOrConstructorSignaturePattern();\n\t\tassertEquals(\"complex annotation\", \"!@((Foo || Goo))\", s.getAnnotationPattern().toString());\n\t\tassertEquals(\"Any return\", \"*\", s.getReturnType().toString());\n\t\tassertEquals(\"Any dec type\", \"*\", s.getDeclaringType().toString());\n\t\tassertEquals(\"Any name\", \"*\", s.getName().toString());\n\t\tassertEquals(\"!@((Foo || Goo)) * *.*(..)\", s.toString());\n\t}\n\n\tpublic void testParseMethodFieldSigNoAP() {\n\t\tPatternParser p = new PatternParser(\"* *.*\");\n\t\tSignaturePattern s = p.parseFieldSignaturePattern();\n\t\tassertEquals(\"Any annotation\", AnnotationTypePattern.ANY, s.getAnnotationPattern());\n\t\tassertEquals(\"Any field type\", \"*\", s.getReturnType().toString());\n\t\tassertEquals(\"Any dec type\", \"*\", s.getDeclaringType().toString());\n\t\tassertEquals(\"Any name\", \"*\", s.getName().toString());\n\t\tassertEquals(\"* *.*\", s.toString());\n\t}\n\n\tpublic void testParseFieldSigSimpleAP() {\n\t\tPatternParser p = new PatternParser(\"@Foo * *.*\");\n\t\tSignaturePattern s = p.parseFieldSignaturePattern();\n\t\tassertEquals(\"@Foo annotation\", \"@(Foo)\", s.getAnnotationPattern().toString());\n\t\tassertEquals(\"Any field type\", \"*\", s.getReturnType().toString());\n\t\tassertEquals(\"Any dec type\", \"*\", s.getDeclaringType().toString());\n\t\tassertEquals(\"Any name\", \"*\", s.getName().toString());\n\t\tassertEquals(\"@(Foo) * *.*\", s.toString());\n\t}\n\n\tpublic void testParseFieldSigComplexAP() {\n\t\tPatternParser p = new PatternParser(\"!@(Foo || Goo) * *.*\");\n\t\tSignaturePattern s = p.parseFieldSignaturePattern();\n\t\tassertEquals(\"complex annotation\", \"!@((Foo || Goo))\", s.getAnnotationPattern().toString());\n\t\tassertEquals(\"Any field type\", \"*\", s.getReturnType().toString());\n\t\tassertEquals(\"Any dec type\", \"*\", s.getDeclaringType().toString());\n\t\tassertEquals(\"Any name\", \"*\", s.getName().toString());\n\t\tassertEquals(\"!@((Foo || Goo)) * *.*\", s.toString());\n\t}\n\n\tpublic void testExactAnnotationPatternMatching() {\n\t\tPatternParser p = new PatternParser(\"@Foo\");\n\t\tAnnotationTypePattern ap = p.maybeParseAnnotationPattern();\n\t\tap = ap.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t\tAnnotatedElementImpl ae = new AnnotatedElementImpl(new String[] { \"Foo\" });\n\t\tassertTrue(\"matches element with Foo\", ap.matches(ae).alwaysTrue());\n\t\tAnnotatedElementImpl ae2 = new AnnotatedElementImpl(new String[] { \"Boo\" });\n\t\tassertTrue(\"does not match element with Boo\", ap.matches(ae2).alwaysFalse());\n\t}\n\n\tpublic void testBindingAnnotationPatternMatching() {\n\t\tPatternParser p = new PatternParser(\"foo\");\n\t\tAnnotationTypePattern ap = p.parseAnnotationNameOrVarTypePattern();\n\t\ttry {\n\t\t\tap = ap.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t\t} catch (AbortException abEx) {\n\t\t\tassertEquals(\"Binding not supported in @pcds (1.5.0 M1 limitation): null\", abEx.getMessage());\n\t\t}\n\t\t// uncomment these next lines once binding is supported\n\t\t// AnnotatedElementImpl ae = new AnnotatedElementImpl(new\n\t\t// String[]{\"Foo\"});\n\t\t// assertTrue(\"matches element with Foo\",ap.matches(ae).alwaysTrue())\n\t\t// ;\n\t\t// AnnotatedElementImpl ae2 = new AnnotatedElementImpl(new\n\t\t// String[]{\"Boo\"});\n\t\t// assertTrue(\"does not match element with Boo\",ap.matches(ae2).\n\t\t// alwaysFalse());\n\t}\n\n\tpublic void testAndAnnotationPatternMatching() {\n\t\tPatternParser p = new PatternParser(\"@Foo @Boo\");\n\t\tAnnotationTypePattern ap = p.maybeParseAnnotationPattern();\n\t\tap = ap.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t\tAnnotatedElementImpl ae = new AnnotatedElementImpl(new String[] { \"Foo\", \"Boo\" });\n\t\tassertTrue(\"matches foo and boo\", ap.matches(ae).alwaysTrue());\n\t\tae = new AnnotatedElementImpl(new String[] { \"Foo\" });\n\t\tassertTrue(\"does not match foo\", ap.matches(ae).alwaysFalse());\n\t\tae = new AnnotatedElementImpl(new String[] { \"Boo\" });\n\t\tassertTrue(\"does not match boo\", ap.matches(ae).alwaysFalse());\n\t\tae = new AnnotatedElementImpl(new String[] { \"Goo\" });\n\t\tassertTrue(\"does not match goo\", ap.matches(ae).alwaysFalse());\n\t}\n\n\t//\n\t// public void testOrAnnotationPatternMatching() {\n\t// PatternParser p = new PatternParser(\"@Foo || @Boo\");\n\t// AnnotationTypePattern ap = p.parseAnnotationTypePattern();\n\t// ap = ap.resolveBindings(makeSimpleScope(),new Bindings(3),true);\n\t// AnnotatedElementImpl ae = new AnnotatedElementImpl(new String[]\n\t// {\"Foo\",\"Boo\"});\n\t// assertTrue(\"matches foo and boo\",ap.matches(ae).alwaysTrue());\n\t// ae = new AnnotatedElementImpl(new String[] {\"Foo\"});\n\t// assertTrue(\"matches foo\",ap.matches(ae).alwaysTrue());\n\t// ae = new AnnotatedElementImpl(new String[] {\"Boo\"});\n\t// assertTrue(\"matches boo\",ap.matches(ae).alwaysTrue());\n\t// ae = new AnnotatedElementImpl(new String[] {\"Goo\"});\n\t// assertTrue(\"does not match goo\",ap.matches(ae).alwaysFalse());\n\t// }\n\t//\n\tpublic void testNotAnnotationPatternMatching() {\n\t\tPatternParser p = new PatternParser(\"!@Foo\");\n\t\tAnnotationTypePattern ap = p.maybeParseAnnotationPattern();\n\t\tap = ap.resolveBindings(makeSimpleScope(), new Bindings(3), true);\n\t\tAnnotatedElementImpl ae = new AnnotatedElementImpl(new String[] { \"Foo\", \"Boo\" });\n\t\tassertTrue(\"does not match foo and boo\", ap.matches(ae).alwaysFalse());\n\t\tae = new AnnotatedElementImpl(new String[] { \"Boo\" });\n\t\tassertTrue(\"matches boo\", ap.matches(ae).alwaysTrue());\n\t}\n\n\tpublic void testAnyAnnotationPatternMatching() {\n\t\tAnnotatedElementImpl ae = new AnnotatedElementImpl(new String[] { \"Foo\", \"Boo\" });\n\t\tassertTrue(\"always matches\", AnnotationTypePattern.ANY.matches(ae).alwaysTrue());\n\t\tae = new AnnotatedElementImpl(new String[] {});\n\t\tassertTrue(\"always matches\", AnnotationTypePattern.ANY.matches(ae).alwaysTrue());\n\t}\n\n\tpublic TestScope makeSimpleScope() {\n\t\tBcelWorld bWorld = new BcelWorld(WeaverTestCase.TESTDATA_PATH + \"/testcode.jar\"); // testcode contains Foo/Boo/Goo/etc\n\t\tbWorld.setBehaveInJava5Way(true);\n\t\treturn new TestScope(new String[] { \"int\", \"java.lang.String\", \"Foo\", \"Boo\", \"Goo\" }, new String[] { \"a\", \"b\", \"foo\",\n\t\t\t\t\"boo\", \"goo\" }, bWorld);\n\t}\n\n\t// put test cases for AnnotationPatternList matching in separate test\n\t// class...\n\n\tstatic class AnnotatedElementImpl implements AnnotatedElement {\n\n\t\tprivate String[] annotationTypes;\n\n\t\tpublic AnnotatedElementImpl(String[] annotationTypes) {\n\t\t\tthis.annotationTypes = annotationTypes;\n\t\t}\n\n\t\tpublic boolean hasAnnotation(UnresolvedType ofType) {\n\t\t\tfor (String annotationType : annotationTypes) {\n\t\t\t\tif (annotationType.equals(ofType.getName())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * (non-Javadoc)\n\t\t *\n\t\t * @see org.aspectj.weaver.AnnotatedElement#getAnnotationTypes()\n\t\t */\n\t\tpublic ResolvedType[] getAnnotationTypes() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t}\n}\n",
    "size": 16275
  },
  {
    "file_id": "F156",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/ConcretizationTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n * ******************************************************************/\n\npackage org.aspectj.weaver.patterns;\n\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.bcel.WeaveTestCase;\n\npublic class ConcretizationTestCase extends WeaveTestCase {\n\t{\n\t\tregenerate = false;\n\t}\n\n\tpublic ConcretizationTestCase(String name) {\n\t\tsuper(name);\n\t}\n\n\tpublic void testNothingForAntJUnit() {\n\t}\n\n\t// String[] none = new String[0];\n\n\t/*\n\t * XXX temporarily skipping public void testCflowResidual() throws IOException {\n\t *\n\t * BcelAdvice a = (BcelAdvice) makeConcreteTestAdviceEntryPart();\n\t *\n\t * TestShadow shadow = new TestShadow(Shadow.MethodCall, Member.methodFromString(\"int Aspect.i(int x)\"), UnresolvedType.OBJECT,\n\t * world);\n\t *\n\t * ExposedState state = new ExposedState(1);\n\t *\n\t * a.specializeOn(shadow);\n\t *\n\t * //System.err.println(shadow); //System.err.println(a);\n\t *\n\t * //System.err.println(a.exposedState);\n\t *\n\t *\n\t * }\n\t *\n\t *\n\t *\n\t * public Advice makeConcreteTestAdviceEntryPart() throws IOException { // XXX copied from below, refactor later\n\t *\n\t *\n\t * // returns the advice for the entry part of cflow(foo(a)) Pointcut in = createResolvedPointcut(\n\t * \"cflow(foo(a)) && (args(b) && !cflow(foo(int)))\", new String[] { \"b\", \"a\" }, new String[] { \"float\", \"int\" });\n\t *\n\t * ResolvedPointcutDefinition ref = new ResolvedPointcutDefinition( UnresolvedType.forName(\"Aspect\"), 0, \"foo\", new\n\t * UnresolvedType[] { UnresolvedType.INT }, createResolvedPointcut( \"args(refA)\", new String[] { \"refA\" }, new String[] { \"int\"\n\t * })); BcelObjectType target = (BcelObjectType) world.resolve(\"Aspect\");\n\t *\n\t * // now munge this to get the pointcut in it\n\t *\n\t * target.addPointcutDefinition(ref); CrosscuttingMembers xcut = new CrosscuttingMembers(target); target.crosscuttingMembers =\n\t * xcut;\n\t *\n\t * Advice adviceMember = new BcelAdvice( AdviceKind.Before, in, Member.method(UnresolvedType.forName(\"FOO\"), 0, \"garadf\",\n\t * \"(FI)V\"), 0, 0, 0, null, null); // The pointcut to concretize\n\t *\n\t * // this returns the actual advice, but we don't care about it now. in.concretize(target, 2, adviceMember);\n\t *\n\t * List c = (List)xcut.getCflowEntries(); //target.getExtraConcreteShadowMungers();\n\t *\n\t * return (Advice) c.get(0); }\n\t *\n\t * public void XtestCflow() throws IOException { Pointcut in =\n\t * createResolvedPointcut(\"cflow(foo(a)) && (args(b) && !cflow(foo(int)))\", new String[] {\"b\", \"a\"}, new String[] {\"float\",\n\t * \"int\"} );\n\t *\n\t * ResolvedPointcutDefinition ref = new ResolvedPointcutDefinition(UnresolvedType.forName(\"Aspect\"), 0, \"foo\", new\n\t * UnresolvedType[] { UnresolvedType.INT }, createResolvedPointcut(\"args(refA)\", new String[] {\"refA\"}, new String[] {\"int\"}));\n\t *\n\t * List expectedSlots = new ArrayList(); expectedSlots.add(new ConcreteCflowPointcut.Slot(1, UnresolvedType.INT, 0));\n\t *\n\t * checkConcr(in, ref, expectedSlots); }\n\t *\n\t * public void checkConcr( Pointcut in, ResolvedPointcutDefinition referredTo, List expectedSlots) throws IOException {\n\t *\n\t * BcelObjectType target = (BcelObjectType)world.resolve(\"Aspect\");\n\t *\n\t * // now munge this to get the pointcut in it\n\t *\n\t * target.addPointcutDefinition(referredTo);\n\t *\n\t *\n\t * Advice adviceMember = new BcelAdvice(AdviceKind.Before, in, Member.method(UnresolvedType.forName(\"FOO\"), 0, \"garadf\",\n\t * \"(FI)V\"), 0, 0, 0, null, null);\n\t *\n\t * // The pointcut to concretize AndPointcut ap = (AndPointcut)in.concretize(target, 2, adviceMember);\n\t *\n\t *\n\t * ConcreteCflowPointcut conc = (ConcreteCflowPointcut)ap.left;\n\t *\n\t * List slots = conc.slots; TestUtil.assertSetEquals(expectedSlots, slots);\n\t *\n\t * }\n\t */\n\n\tpublic Pointcut createResolvedPointcut(String pointcutSource, String[] formalNames, String[] formalTypes) {\n\t\tfinal Pointcut sp = Pointcut.fromString(pointcutSource);\n\t\tfinal Pointcut rp = sp.resolve(new SimpleScope(world, SimpleScope.makeFormalBindings(UnresolvedType.forNames(formalTypes),\n\t\t\t\tformalNames)));\n\t\treturn rp;\n\t}\n}\n",
    "size": 4406
  },
  {
    "file_id": "F157",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/WildTypePatternResolutionTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Adrian Colyer     initial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.patterns;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\nimport org.aspectj.weaver.AjAttribute.WeaverVersionInfo;\nimport org.aspectj.weaver.BoundedReferenceType;\nimport org.aspectj.weaver.CompressingDataOutputStream;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.TypeFactory;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.VersionedDataInputStream;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\n// TODO write test cases for instanceof matching\n\npublic class WildTypePatternResolutionTestCase extends TestCase {\n\n\tprivate World world;\n\tprivate Bindings bindings;\n\tprivate SimpleScope scope;\n\tprivate ResolvedType javaUtilList;\n\tprivate ResolvedType javaLangString;\n\tprivate ResolvedType javaUtilListOfString;\n\tprivate ResolvedType javaUtilListOfDouble;\n\tprivate ResolvedType javaUtilListOfSomething;\n\n\t/**\n\t * Foo where Foo exists and is generic Parser creates WildTypePattern namePatterns={Foo} resolveBindings resolves Foo to RT(Foo\n\t * - raw) return ExactTypePattern(LFoo;)\n\t */\n\tpublic void testSimpleFoo() {\n\t\tTypePattern rtp = resolveWildTypePattern(\"List\", false);\n\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\n\t\tUnresolvedType exactType = rtp.getExactType();\n\t\tassertTrue(exactType.isRawType());\n\t\tassertEquals(\"Ljava/util/List;\", exactType.getSignature());\n\n\t\tResolvedType rt = exactType.resolve(world);\n\t\tassertEquals(\"Ljava/util/List;\", rt.getSignature());\n\t\tassertTrue(rt.isRawType());\n\n\t\tExactTypePattern etp = (ExactTypePattern) writeAndRead(rtp);\n\t\texactType = etp.getExactType();\n\n\t\tassertEquals(\"Ljava/util/List;\", exactType.getSignature());\n\n\t\trt = exactType.resolve(world);\n\t\tassertEquals(\"Ljava/util/List;\", rt.getSignature());\n\t\tassertTrue(rt.isRawType());\n\n\t\tassertTrue(\"matches List\", etp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());\n\t\tassertTrue(\"matches generic List\", etp.matches(javaUtilList.getGenericType(), TypePattern.STATIC).alwaysTrue());\n\t\tassertTrue(\"matches parameterized list\", etp.matches(javaUtilListOfString, TypePattern.STATIC).alwaysTrue());\n\t\tassertTrue(\"does not match String\", etp.matches(javaLangString, TypePattern.STATIC).alwaysFalse());\n\t}\n\n\t/**\n\t * Foo<String> where Foo exists and String meets the bounds Parser creates WildTypePattern namePatterns = {Foo},\n\t * typeParameters=WTP{String} resolveBindings resolves typeParameters to ExactTypePattern(String) resolves Foo to RT(Foo)\n\t * returns ExactTypePattern(PFoo<String>; - parameterized)\n\t */\n\tpublic void testParameterized() {\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<String>\", false);\n\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\n\t\tUnresolvedType exactType = rtp.getExactType();\n\t\tassertTrue(exactType.isParameterizedType());\n\t\tassertEquals(\"Pjava/util/List<Ljava/lang/String;>;\", exactType.getSignature());\n\n\t\tResolvedType rt = exactType.resolve(world);\n\t\tassertEquals(\"Pjava/util/List<Ljava/lang/String;>;\", rt.getSignature());\n\t\tassertTrue(rt.isParameterizedType());\n\n\t\tExactTypePattern etp = (ExactTypePattern) writeAndRead(rtp);\n\t\texactType = etp.getExactType();\n\n\t\tassertEquals(\"Pjava/util/List<Ljava/lang/String;>;\", rt.getSignature());\n\t\tassertTrue(rt.isParameterizedType());\n\n\t\trt = exactType.resolve(world);\n\t\tassertEquals(\"Pjava/util/List<Ljava/lang/String;>;\", rt.getSignature());\n\t\tassertTrue(rt.isParameterizedType());\n\n\t\tassertFalse(\"does not match List\", etp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match generic List\", etp.matches(javaUtilList.getGenericType(), TypePattern.STATIC).alwaysTrue());\n\t\tassertTrue(\"matches parameterized list\", etp.matches(javaUtilListOfString, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list of double\", etp.matches(javaUtilListOfDouble, TypePattern.STATIC)\n\t\t\t\t.alwaysTrue());\n\t\tassertTrue(\"does not match String\", etp.matches(javaLangString, TypePattern.STATIC).alwaysFalse());\n\n\t}\n\n\t/**\n\t * Foo<Str*> where Foo exists and takes one bound Parser creates WildTypePattern namePatterns = {Foo}, typeParameters=WTP{Str*}\n\t * resolveBindings resolves typeParameters to WTP{Str*} resolves Foo to RT(Foo) returns WildTypePattern(name = Foo,\n\t * typeParameters = WTP{Str*} isGeneric=false)\n\t */\n\tpublic void testParameterizedWildCard() {\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<Str*>\", false);\n\n\t\tassertTrue(\"resolves to WildTypePattern\", rtp instanceof WildTypePattern);\n\t\tassertTrue(\"one type parameter\", rtp.typeParameters.size() == 1);\n\t\tassertTrue(\"missing\", ResolvedType.isMissing(rtp.getExactType()));\n\n\t\tWildTypePattern wtp = (WildTypePattern) writeAndRead(rtp);\n\t\tassertTrue(\"one type parameter\", wtp.typeParameters.size() == 1);\n\t\tassertTrue(\"missing\", ResolvedType.isMissing(wtp.getExactType()));\n\t\tassertEquals(\"Str*\", wtp.getTypeParameters().getTypePatterns()[0].toString());\n\n\t\tassertFalse(\"does not match List\", wtp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match generic List\", wtp.matches(javaUtilList.getGenericType(), TypePattern.STATIC).alwaysTrue());\n\t\tassertTrue(\"matches parameterized list\", wtp.matches(javaUtilListOfString, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list of double\", wtp.matches(javaUtilListOfDouble, TypePattern.STATIC)\n\t\t\t\t.alwaysTrue());\n\t\tassertTrue(\"does not match String\", wtp.matches(javaLangString, TypePattern.STATIC).alwaysFalse());\n\t}\n\n\t/**\n\t * Fo*<String> Parser creates WildTypePattern namePatterns = {Fo*}, typeParameters=WTP{String} resolveBindings resolves\n\t * typeParameters to ETP{String} returns WildTypePattern(name = Fo*, typeParameters = ETP{String} isGeneric=false)\n\t */\n\tpublic void testWildcardParameterized() {\n\t\tTypePattern rtp = resolveWildTypePattern(\"Li*<String>\", false);\n\n\t\tassertTrue(\"resolves to WildTypePattern\", rtp instanceof WildTypePattern);\n\t\tassertTrue(\"one type parameter\", rtp.typeParameters.size() == 1);\n\t\tassertEquals(\"Ljava/lang/String;\", rtp.typeParameters.getTypePatterns()[0].getExactType().getSignature());\n\n\t\tWildTypePattern wtp = (WildTypePattern) writeAndRead(rtp);\n\t\tassertTrue(\"one type parameter\", wtp.typeParameters.size() == 1);\n\t\tassertEquals(\"Ljava/lang/String;\", wtp.typeParameters.getTypePatterns()[0].getExactType().getSignature());\n\n\t\tassertFalse(\"does not match List\", wtp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match generic List\", wtp.matches(javaUtilList.getGenericType(), TypePattern.STATIC).alwaysTrue());\n\t\tassertTrue(\"matches parameterized list\", wtp.matches(javaUtilListOfString, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list of double\", wtp.matches(javaUtilListOfDouble, TypePattern.STATIC)\n\t\t\t\t.alwaysTrue());\n\t\tassertTrue(\"does not match String\", wtp.matches(javaLangString, TypePattern.STATIC).alwaysFalse());\n\t}\n\n\t/**\n\t * Foo<?>\n\t */\n\tpublic void testSomething() {\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<?>\", false);\n\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\n\t\tUnresolvedType exactType = rtp.getExactType();\n\t\tassertTrue(exactType.isParameterizedType());\n\t\tassertEquals(\"Pjava/util/List<*>;\", exactType.getSignature());\n\n\t\tExactTypePattern etp = (ExactTypePattern) writeAndRead(rtp);\n\t\texactType = etp.getExactType();\n\t\tassertTrue(exactType.isParameterizedType());\n\t\tassertEquals(\"Pjava/util/List<*>;\", exactType.getSignature());\n\n\t\tassertFalse(\"does not match List\", etp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match generic List\", etp.matches(javaUtilList.getGenericType(), TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list\", etp.matches(javaUtilListOfString, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list of double\", etp.matches(javaUtilListOfDouble, TypePattern.STATIC)\n\t\t\t\t.alwaysTrue());\n\t\tassertTrue(\"does not match String\", etp.matches(javaLangString, TypePattern.STATIC).alwaysFalse());\n\n\t\tassertTrue(\"matches list of something\", etp.matches(javaUtilListOfSomething, TypePattern.STATIC).alwaysTrue());\n\t}\n\n\t/**\n\t * Foo<? extends Number>\n\t */\n\tpublic void testSomethingExtends() {\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<? extends Number>\", false);\n\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\n\t\tUnresolvedType exactType = rtp.getExactType();\n\t\tassertTrue(exactType.isParameterizedType());\n\t\tassertEquals(\"Pjava/util/List<+Ljava/lang/Number;>;\", exactType.getSignature());\n\t\tassertTrue(\"got a bounded reference type\", exactType.getTypeParameters()[0] instanceof BoundedReferenceType);\n\n\t\tExactTypePattern etp = (ExactTypePattern) writeAndRead(rtp);\n\t\texactType = etp.getExactType();\n\t\texactType = exactType.resolve(world);\n\t\tassertTrue(exactType.isParameterizedType());\n\t\tassertEquals(\"Pjava/util/List<+Ljava/lang/Number;>;\", exactType.getSignature());\n\t\tassertTrue(\"got a bounded reference type\", exactType.getTypeParameters()[0] instanceof BoundedReferenceType);\n\n\t\tassertFalse(\"does not match List\", etp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match generic List\", etp.matches(javaUtilList.getGenericType(), TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list\", etp.matches(javaUtilListOfString, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list of double\", etp.matches(javaUtilListOfDouble, TypePattern.STATIC)\n\t\t\t\t.alwaysTrue());\n\t\tassertTrue(\"does not match String\", etp.matches(javaLangString, TypePattern.STATIC).alwaysFalse());\n\t\tassertFalse(\"does not match list of something\", etp.matches(javaUtilListOfSomething, TypePattern.STATIC).alwaysTrue());\n\n\t\tResolvedType listOfNumber = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { UnresolvedType\n\t\t\t\t.forName(\"java.lang.Number\").resolve(world) }, world);\n\n\t\tResolvedType listOfDouble = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { UnresolvedType\n\t\t\t\t.forName(\"java.lang.Double\").resolve(world) }, world);\n\n\t\tassertFalse(\"does not match list of number\", etp.matches(listOfNumber, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match list of double\", etp.matches(listOfDouble, TypePattern.STATIC).alwaysTrue());\n\n\t\tResolvedType extendsNumber = TypeFactory.createTypeFromSignature(\"+Ljava/lang/Number;\").resolve(world);\n\t\tResolvedType listOfExtendsNumber = TypeFactory.createParameterizedType(javaUtilList,\n\t\t\t\tnew UnresolvedType[] { extendsNumber }, world);\n\n\t\tassertTrue(\"matches list of ? extends number\", etp.matches(listOfExtendsNumber, TypePattern.STATIC).alwaysTrue());\n\n\t}\n\n\t/**\n\t * Foo<? extends Number+>\n\t */\n\tpublic void testSomethingExtendsPattern() {\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<? extends Number+>\", false);\n\n\t\tassertTrue(\"resolves to wild type pattern\", rtp instanceof WildTypePattern);\n\t\tassertEquals(\"one type parameter\", 1, rtp.getTypeParameters().size());\n\t\tTypePattern tp = rtp.getTypeParameters().getTypePatterns()[0];\n\t\tassertTrue(\"parameter is wild\", tp instanceof WildTypePattern);\n\t\tWildTypePattern tpwtp = (WildTypePattern) tp;\n\t\tassertEquals(\"?\", tpwtp.getNamePatterns()[0].maybeGetSimpleName());\n\t\tassertEquals(\"java.lang.Number+\", tpwtp.upperBound.toString());\n\n\t\tWildTypePattern wtp = (WildTypePattern) writeAndRead(rtp);\n\t\tassertEquals(\"one type parameter\", 1, wtp.getTypeParameters().size());\n\t\ttp = rtp.getTypeParameters().getTypePatterns()[0];\n\t\tassertTrue(\"parameter is wild\", tp instanceof WildTypePattern);\n\t\ttpwtp = (WildTypePattern) tp;\n\t\tassertEquals(\"?\", tpwtp.getNamePatterns()[0].maybeGetSimpleName());\n\t\tassertEquals(\"java.lang.Number+\", tpwtp.upperBound.toString());\n\n\t\tassertFalse(\"does not match List\", wtp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match generic List\", wtp.matches(javaUtilList.getGenericType(), TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list\", wtp.matches(javaUtilListOfString, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list of double\", wtp.matches(javaUtilListOfDouble, TypePattern.STATIC)\n\t\t\t\t.alwaysTrue());\n\t\tassertTrue(\"does not match String\", wtp.matches(javaLangString, TypePattern.STATIC).alwaysFalse());\n\t\tassertFalse(\"does not match list of something\", wtp.matches(javaUtilListOfSomething, TypePattern.STATIC).alwaysTrue());\n\n\t\tResolvedType listOfNumber = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { UnresolvedType\n\t\t\t\t.forName(\"java.lang.Number\").resolve(world) }, world);\n\n\t\tResolvedType listOfDouble = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { UnresolvedType\n\t\t\t\t.forName(\"java.lang.Double\").resolve(world) }, world);\n\n\t\tassertFalse(\"does not match list of number\", wtp.matches(listOfNumber, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match list of double\", wtp.matches(listOfDouble, TypePattern.STATIC).alwaysTrue());\n\n\t\tResolvedType extendsNumber = TypeFactory.createTypeFromSignature(\"+Ljava/lang/Number;\").resolve(world);\n\t\tResolvedType listOfExtendsNumber = TypeFactory.createParameterizedType(javaUtilList,\n\t\t\t\tnew UnresolvedType[] { extendsNumber }, world);\n\n\t\tassertTrue(\"matches list of ? extends number\", wtp.matches(listOfExtendsNumber, TypePattern.STATIC).alwaysTrue());\n\n\t\tResolvedType extendsDouble = TypeFactory.createTypeFromSignature(\"+Ljava/lang/Double;\").resolve(world);\n\t\tResolvedType listOfExtendsDouble = TypeFactory.createParameterizedType(javaUtilList,\n\t\t\t\tnew UnresolvedType[] { extendsDouble }, world);\n\n\t\tassertTrue(\"matches list of ? extends double\", wtp.matches(listOfExtendsDouble, TypePattern.STATIC).alwaysTrue());\n\n\t}\n\n\t/**\n\t * Foo<? extends Num*>\n\t */\n\tpublic void testSomethingExtendsPatternv2() {\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<? extends Num*>\", false);\n\n\t\tassertTrue(\"resolves to wild type pattern\", rtp instanceof WildTypePattern);\n\t\tassertEquals(\"one type parameter\", 1, rtp.getTypeParameters().size());\n\t\tTypePattern tp = rtp.getTypeParameters().getTypePatterns()[0];\n\t\tassertTrue(\"parameter is wild\", tp instanceof WildTypePattern);\n\t\tWildTypePattern tpwtp = (WildTypePattern) tp;\n\t\tassertEquals(\"?\", tpwtp.getNamePatterns()[0].maybeGetSimpleName());\n\t\tassertEquals(\"Num*\", tpwtp.upperBound.toString());\n\n\t\tWildTypePattern wtp = (WildTypePattern) writeAndRead(rtp);\n\t\tassertEquals(\"one type parameter\", 1, wtp.getTypeParameters().size());\n\t\ttp = rtp.getTypeParameters().getTypePatterns()[0];\n\t\tassertTrue(\"parameter is wild\", tp instanceof WildTypePattern);\n\t\ttpwtp = (WildTypePattern) tp;\n\t\tassertEquals(\"?\", tpwtp.getNamePatterns()[0].maybeGetSimpleName());\n\t\tassertEquals(\"Num*\", tpwtp.upperBound.toString());\n\n\t\tassertFalse(\"does not match List\", wtp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match generic List\", wtp.matches(javaUtilList.getGenericType(), TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list\", wtp.matches(javaUtilListOfString, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list of double\", wtp.matches(javaUtilListOfDouble, TypePattern.STATIC)\n\t\t\t\t.alwaysTrue());\n\t\tassertTrue(\"does not match String\", wtp.matches(javaLangString, TypePattern.STATIC).alwaysFalse());\n\t\tassertFalse(\"does not match list of something\", wtp.matches(javaUtilListOfSomething, TypePattern.STATIC).alwaysTrue());\n\n\t\tResolvedType listOfNumber = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { UnresolvedType\n\t\t\t\t.forName(\"java.lang.Number\").resolve(world) }, world);\n\n\t\tResolvedType listOfDouble = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { UnresolvedType\n\t\t\t\t.forName(\"java.lang.Double\").resolve(world) }, world);\n\n\t\tassertFalse(\"does not match list of number\", wtp.matches(listOfNumber, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match list of double\", wtp.matches(listOfDouble, TypePattern.STATIC).alwaysTrue());\n\n\t\tResolvedType extendsNumber = TypeFactory.createTypeFromSignature(\"+Ljava/lang/Number;\").resolve(world);\n\t\tResolvedType listOfExtendsNumber = TypeFactory.createParameterizedType(javaUtilList,\n\t\t\t\tnew UnresolvedType[] { extendsNumber }, world);\n\n\t\tassertTrue(\"matches list of ? extends number\", wtp.matches(listOfExtendsNumber, TypePattern.STATIC).alwaysTrue());\n\n\t\tResolvedType extendsDouble = TypeFactory.createTypeFromSignature(\"+Ljava/lang/Double;\").resolve(world);\n\t\tResolvedType listOfExtendsDouble = TypeFactory.createParameterizedType(javaUtilList,\n\t\t\t\tnew UnresolvedType[] { extendsDouble }, world);\n\n\t\tassertFalse(\"does not match list of ? extends double\", wtp.matches(listOfExtendsDouble, TypePattern.STATIC).alwaysTrue());\n\t}\n\n\t/**\n\t * Foo<? super Number>\n\t *\n\t */\n\tpublic void testSomethingSuper() {\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<? super Double>\", false);\n\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\n\t\tUnresolvedType exactType = rtp.getExactType();\n\t\tassertTrue(exactType.isParameterizedType());\n\t\tassertEquals(\"Pjava/util/List<-Ljava/lang/Double;>;\", exactType.getSignature());\n\t\tassertTrue(\"got a bounded reference type\", exactType.getTypeParameters()[0] instanceof BoundedReferenceType);\n\n\t\tExactTypePattern etp = (ExactTypePattern) writeAndRead(rtp);\n\t\texactType = etp.getExactType();\n\t\texactType = exactType.resolve(world);\n\t\tassertTrue(exactType.isParameterizedType());\n\t\tassertEquals(\"Pjava/util/List<-Ljava/lang/Double;>;\", exactType.getSignature());\n\t\tassertTrue(\"got a bounded reference type\", exactType.getTypeParameters()[0] instanceof BoundedReferenceType);\n\n\t\tassertFalse(\"does not match List\", etp.matches(javaUtilList, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match generic List\", etp.matches(javaUtilList.getGenericType(), TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list\", etp.matches(javaUtilListOfString, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match parameterized list of double\", etp.matches(javaUtilListOfDouble, TypePattern.STATIC)\n\t\t\t\t.alwaysTrue());\n\t\tassertTrue(\"does not match String\", etp.matches(javaLangString, TypePattern.STATIC).alwaysFalse());\n\t\tassertFalse(\"does not match list of something\", etp.matches(javaUtilListOfSomething, TypePattern.STATIC).alwaysTrue());\n\n\t\tResolvedType listOfNumber = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { UnresolvedType\n\t\t\t\t.forName(\"java.lang.Number\").resolve(world) }, world);\n\n\t\tResolvedType listOfDouble = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { UnresolvedType\n\t\t\t\t.forName(\"java.lang.Double\").resolve(world) }, world);\n\n\t\tassertFalse(\"does not match list of number\", etp.matches(listOfNumber, TypePattern.STATIC).alwaysTrue());\n\t\tassertFalse(\"does not match list of double\", etp.matches(listOfDouble, TypePattern.STATIC).alwaysTrue());\n\n\t\tResolvedType superDouble = TypeFactory.createTypeFromSignature(\"-Ljava/lang/Double;\").resolve(world);\n\t\tResolvedType listOfSuperDouble = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { superDouble },\n\t\t\t\tworld);\n\n\t\tassertTrue(\"matches list of ? super double\", etp.matches(listOfSuperDouble, TypePattern.STATIC).alwaysTrue());\n\t}\n\n\tprivate TypePattern resolveWildTypePattern(String source, boolean requireExact) {\n\t\tWildTypePattern wtp = makeWildTypePattern(source);\n\t\treturn wtp.resolveBindings(scope, bindings, false, requireExact);\n\t}\n\n\tprivate WildTypePattern makeWildTypePattern(String source) {\n\t\tPatternParser parser = new PatternParser(source);\n\t\treturn (WildTypePattern) parser.parseTypePattern();\n\t}\n\n\tprivate TypePattern writeAndRead(TypePattern etp) {\n\t\ttry {\n\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\t\tConstantPoolSimulator cps = new ConstantPoolSimulator();\n\t\t\tCompressingDataOutputStream dos = new CompressingDataOutputStream(baos, cps);\n\t\t\tetp.write(dos);\n\t\t\tdos.flush();\n\t\t\tdos.close();\n\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n\t\t\tVersionedDataInputStream in = new VersionedDataInputStream(bais, cps);\n\t\t\tin.setVersion(new WeaverVersionInfo());\n\t\t\tTypePattern ret = TypePattern.read(in, null);\n\t\t\treturn ret;\n\t\t} catch (IOException ioEx) {\n\t\t\tfail(ioEx + \" thrown during serialization\");\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tthis.world = new BcelWorld();\n\t\tthis.world.setBehaveInJava5Way(true);\n\t\tthis.bindings = new Bindings(0);\n\t\tthis.scope = new SimpleScope(world, new FormalBinding[] {});\n\t\tthis.scope.setImportedPrefixes(new String[] { \"java.io.\", \"java.util.\", \"java.lang.\" });\n\t\tthis.javaLangString = UnresolvedType.forName(\"java.lang.String\").resolve(world);\n\t\tthis.javaUtilList = UnresolvedType.forName(\"java.util.List\").resolve(world);\n\t\tthis.javaUtilListOfString = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { javaLangString },\n\t\t\t\tworld);\n\t\tthis.javaUtilListOfDouble = TypeFactory.createParameterizedType(javaUtilList, new UnresolvedType[] { UnresolvedType\n\t\t\t\t.forName(\"java.lang.Double\").resolve(world) }, world);\n\t\tthis.javaUtilListOfSomething = TypeFactory.createParameterizedType(javaUtilList,\n\t\t\t\tnew UnresolvedType[] { UnresolvedType.SOMETHING.resolve(world) }, world);\n\t}\n}\n",
    "size": 21924
  },
  {
    "file_id": "F158",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/bcel/BcelAndOrNotTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.patterns.bcel;\n\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelWorld;\nimport org.aspectj.weaver.patterns.AndOrNotTestCase;\n\npublic class BcelAndOrNotTestCase extends AndOrNotTestCase {\n\n\tpublic World getWorld() {\n\t\treturn new BcelWorld();\n\t}\n\n}\n",
    "size": 774
  },
  {
    "file_id": "F159",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/bcel/BcelBindingTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.patterns.bcel;\n\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelWorld;\nimport org.aspectj.weaver.patterns.BindingTestCase;\n\npublic class BcelBindingTestCase extends BindingTestCase {\n\n\tpublic World getWorld() {\n\t\treturn new BcelWorld();\n\t}\n\n}\n",
    "size": 771
  },
  {
    "file_id": "F160",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/bcel/BcelModifiersPatternTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.patterns.bcel;\n\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelWorld;\nimport org.aspectj.weaver.patterns.ModifiersPatternTestCase;\n\npublic class BcelModifiersPatternTestCase extends ModifiersPatternTestCase {\n\n\tpublic World getWorld() {\n\t\treturn new BcelWorld();\n\t}\n\n}\n",
    "size": 798
  },
  {
    "file_id": "F161",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/bcel/BcelParserTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.patterns.bcel;\n\nimport org.aspectj.weaver.WeaverTestCase;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelWorld;\nimport org.aspectj.weaver.patterns.ParserTestCase;\n\npublic class BcelParserTestCase extends ParserTestCase {\n\n\tpublic World getWorld() {\n\t\treturn new BcelWorld(WeaverTestCase.TESTDATA_PATH + \"/testcode.jar\");\n\t}\n\n}\n",
    "size": 856
  },
  {
    "file_id": "F162",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/bcel/BcelSignaturePatternTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.patterns.bcel;\n\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelWorld;\nimport org.aspectj.weaver.patterns.SignaturePatternTestCase;\n\npublic class BcelSignaturePatternTestCase extends SignaturePatternTestCase {\n\n\tpublic World getWorld() {\n\t\treturn new BcelWorld();\n\t}\n\n}\n",
    "size": 798
  },
  {
    "file_id": "F163",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/bcel/BcelTypePatternListTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.patterns.bcel;\n\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelWorld;\nimport org.aspectj.weaver.patterns.TypePatternListTestCase;\n\npublic class BcelTypePatternListTestCase extends TypePatternListTestCase {\n\n\tpublic World getWorld() {\n\t\treturn new BcelWorld();\n\t}\n}\n",
    "size": 794
  },
  {
    "file_id": "F164",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/bcel/BcelTypePatternTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.patterns.bcel;\n\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelWorld;\nimport org.aspectj.weaver.patterns.TypePatternTestCase;\n\npublic class BcelTypePatternTestCase extends TypePatternTestCase {\n\n\tpublic World getWorld() {\n\t\treturn new BcelWorld();\n\t}\n\n}\n",
    "size": 783
  },
  {
    "file_id": "F165",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/patterns/bcel/BcelWithinTestCase.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *    Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.patterns.bcel;\n\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelWorld;\nimport org.aspectj.weaver.patterns.WithinTestCase;\n\npublic class BcelWithinTestCase extends WithinTestCase {\n\n\tpublic World getWorld() {\n\t\treturn new BcelWorld();\n\t}\n}\n",
    "size": 767
  },
  {
    "file_id": "F166",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.reflect;\n\nimport java.lang.reflect.Method;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\npublic abstract class ReflectionBasedReferenceTypeDelegateTest extends TestCase {\n\n\tprotected ReflectionWorld world;\n\tprivate ResolvedType objectType;\n\tprivate ResolvedType classType;\n\n\tpublic void testIsAspect() {\n\t\tassertFalse(objectType.isAspect());\n\t}\n\n\tpublic void testIsAnnotationStyleAspect() {\n\t\tassertFalse(objectType.isAnnotationStyleAspect());\n\t}\n\n\tpublic void testIsInterface() {\n\t\tassertFalse(objectType.isInterface());\n\t\tassertTrue(world.resolve(\"java.io.Serializable\").isInterface());\n\t}\n\n\tpublic void testIsEnum() {\n\t\tassertFalse(objectType.isEnum());\n\t}\n\n\tpublic void testIsAnnotation() {\n\t\tassertFalse(objectType.isAnnotation());\n\t}\n\n\tpublic void testIsAnnotationWithRuntimeRetention() {\n\t\tassertFalse(objectType.isAnnotationWithRuntimeRetention());\n\t}\n\n\tpublic void testIsClass() {\n\t\tassertTrue(objectType.isClass());\n\t\tassertFalse(world.resolve(\"java.io.Serializable\").isClass());\n\t}\n\n\tpublic void testIsGeneric() {\n\t\tassertFalse(objectType.isGenericType());\n\t}\n\n\tpublic void testIsExposedToWeaver() {\n\t\tassertFalse(objectType.isExposedToWeaver());\n\t}\n\n\tpublic void testHasAnnotation() {\n\t\tassertFalse(objectType.hasAnnotation(UnresolvedType.forName(\"Foo\")));\n\t}\n\n\tpublic void testGetAnnotations() {\n\t\tassertEquals(\"no entries\", 0, objectType.getAnnotations().length);\n\t}\n\n\tpublic void testGetAnnotationTypes() {\n\t\tassertEquals(\"no entries\", 0, objectType.getAnnotationTypes().length);\n\t}\n\n\tpublic void testGetTypeVariables() {\n\t\tassertEquals(\"no entries\", 0, objectType.getTypeVariables().length);\n\t}\n\n\tpublic void testGetPerClause() {\n\t\tassertNull(objectType.getPerClause());\n\t}\n\n\tpublic void testGetModifiers() {\n\t\tassertEquals(Object.class.getModifiers(), objectType.getModifiers());\n\t}\n\n\tpublic void testGetSuperclass() {\n\t\tassertTrue(\"Superclass of object should be null, but it is: \" + objectType.getSuperclass(),\n\t\t\t\tobjectType.getSuperclass() == null);\n\t\tassertEquals(objectType, world.resolve(\"java.lang.Class\").getSuperclass());\n\t\tResolvedType d = world.resolve(\"reflect.tests.D\");\n\t\tassertEquals(world.resolve(\"reflect.tests.C\"), d.getSuperclass());\n\t}\n\n\tprotected int findMethod(String name, ResolvedMember[] methods) {\n\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\tif (name.equals(methods[i].getName())) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprotected int findMethod(String name, int numArgs, ResolvedMember[] methods) {\n\t\tfor (int i = 0; i < methods.length; i++) {\n\t\t\tif (name.equals(methods[i].getName()) && (methods[i].getParameterTypes().length == numArgs)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic void testGetDeclaredMethods() {\n\t\tResolvedMember[] methods = objectType.getDeclaredMethods();\n\t\tassertEquals(Object.class.getDeclaredMethods().length + Object.class.getDeclaredConstructors().length, methods.length);\n\n\t\tResolvedType c = world.resolve(\"reflect.tests.C\");\n\t\tmethods = c.getDeclaredMethods();\n\t\tassertEquals(3, methods.length);\n\t\tint idx = findMethod(\"foo\", methods);\n\t\tassertTrue(idx > -1);\n\n\t\tassertEquals(world.resolve(\"java.lang.String\"), methods[idx].getReturnType());\n\t\tassertEquals(1, methods[idx].getParameterTypes().length);\n\t\tassertEquals(objectType, methods[idx].getParameterTypes()[0]);\n\t\tassertEquals(1, methods[idx].getExceptions().length);\n\t\tassertEquals(world.resolve(\"java.lang.Exception\"), methods[idx].getExceptions()[0]);\n\t\tint baridx = findMethod(\"bar\", methods);\n\t\tint initidx = findMethod(\"<init>\", methods);\n\t\tassertTrue(baridx > -1);\n\t\tassertTrue(initidx > -1);\n\t\tassertTrue(baridx != initidx && baridx != idx && idx <= 2 && initidx <= 2 && baridx <= 2);\n\n\t\tResolvedType d = world.resolve(\"reflect.tests.D\");\n\t\tmethods = d.getDeclaredMethods();\n\t\tassertEquals(2, methods.length);\n\n\t\tclassType = world.resolve(\"java.lang.Class\");\n\t\tmethods = classType.getDeclaredMethods();\n\t\tassertEquals(Class.class.getDeclaredMethods().length + Class.class.getDeclaredConstructors().length, methods.length);\n\t}\n\n\tpublic void testGetDeclaredFields() {\n\t\tResolvedMember[] fields = objectType.getDeclaredFields();\n\t\tassertEquals(0, fields.length);\n\n\t\tResolvedType c = world.resolve(\"reflect.tests.C\");\n\t\tfields = c.getDeclaredFields();\n\n\t\tassertEquals(2, fields.length);\n\t\tassertEquals(\"f\", fields[0].getName());\n\t\tassertEquals(\"s\", fields[1].getName());\n\t\tassertEquals(UnresolvedType.INT, fields[0].getReturnType());\n\t\tassertEquals(world.resolve(\"java.lang.String\"), fields[1].getReturnType());\n\t}\n\n\tpublic void testGetDeclaredInterfaces() {\n\t\tResolvedType[] interfaces = objectType.getDeclaredInterfaces();\n\t\tassertEquals(0, interfaces.length);\n\n\t\tResolvedType d = world.resolve(\"reflect.tests.D\");\n\t\tinterfaces = d.getDeclaredInterfaces();\n\t\tassertEquals(1, interfaces.length);\n\t\tassertEquals(world.resolve(\"java.io.Serializable\"), interfaces[0]);\n\t}\n\n\tpublic void testGetDeclaredPointcuts() {\n\t\tResolvedMember[] pointcuts = objectType.getDeclaredPointcuts();\n\t\tassertEquals(0, pointcuts.length);\n\t}\n\n\tpublic void testSerializableSuperclass() {\n\t\tResolvedType serializableType = world.resolve(\"java.io.Serializable\");\n\t\tResolvedType superType = serializableType.getSuperclass();\n\t\tassertTrue(\"Superclass of serializable should be Object but was \" + superType, superType.equals(UnresolvedType.OBJECT));\n\n\t\tBcelWorld bcelworld = new BcelWorld();\n\t\tbcelworld.setBehaveInJava5Way(true);\n\t\tResolvedType bcelSupertype = bcelworld.resolve(UnresolvedType.SERIALIZABLE).getSuperclass();\n\t\tassertTrue(\"Should be null but is \" + bcelSupertype, bcelSupertype.equals(UnresolvedType.OBJECT));\n\t}\n\n\tpublic void testSubinterfaceSuperclass() {\n\t\tResolvedType ifaceType = world.resolve(\"java.security.Key\");\n\t\tResolvedType superType = ifaceType.getSuperclass();\n\t\tassertTrue(\"Superclass should be Object but was \" + superType, superType.equals(UnresolvedType.OBJECT));\n\n\t\tBcelWorld bcelworld = new BcelWorld();\n\t\tbcelworld.setBehaveInJava5Way(true);\n\t\tResolvedType bcelSupertype = bcelworld.resolve(\"java.security.Key\").getSuperclass();\n\t\tassertTrue(\"Should be null but is \" + bcelSupertype, bcelSupertype.equals(UnresolvedType.OBJECT));\n\t}\n\n\tpublic void testVoidSuperclass() {\n\t\tResolvedType voidType = world.resolve(Void.TYPE);\n\t\tResolvedType superType = voidType.getSuperclass();\n\t\tassertNull(superType);\n\n\t\tBcelWorld bcelworld = new BcelWorld();\n\t\tbcelworld.setBehaveInJava5Way(true);\n\t\tResolvedType bcelSupertype = bcelworld.resolve(\"void\").getSuperclass();\n\t\tassertTrue(\"Should be null but is \" + bcelSupertype, bcelSupertype == null);\n\t}\n\n\tpublic void testIntSuperclass() {\n\t\tResolvedType voidType = world.resolve(Integer.TYPE);\n\t\tResolvedType superType = voidType.getSuperclass();\n\t\tassertNull(superType);\n\n\t\tBcelWorld bcelworld = new BcelWorld();\n\t\tbcelworld.setBehaveInJava5Way(true);\n\t\tResolvedType bcelSupertype = bcelworld.resolve(\"int\").getSuperclass();\n\t\tassertTrue(\"Should be null but is \" + bcelSupertype, bcelSupertype == null);\n\t}\n\n\tpublic void testGenericInterfaceSuperclass_BcelWorldResolution() {\n\t\tBcelWorld bcelworld = new BcelWorld();\n\t\tbcelworld.setBehaveInJava5Way(true);\n\n\t\tUnresolvedType javaUtilMap = UnresolvedType.forName(\"java.util.Map\");\n\n\t\tReferenceType rawType = (ReferenceType) bcelworld.resolve(javaUtilMap);\n\t\tassertTrue(\"Should be the raw type ?!? \" + rawType.getTypekind(), rawType.isRawType());\n\n\t\tReferenceType genericType = (ReferenceType) rawType.getGenericType();\n\t\tassertTrue(\"Should be the generic type ?!? \" + genericType.getTypekind(), genericType.isGenericType());\n\n\t\tResolvedType rt = rawType.getSuperclass();\n\t\tassertTrue(\"Superclass for Map raw type should be Object but was \" + rt, rt.equals(UnresolvedType.OBJECT));\n\n\t\tResolvedType rt2 = genericType.getSuperclass();\n\t\tassertTrue(\"Superclass for Map generic type should be Object but was \" + rt2, rt2.equals(UnresolvedType.OBJECT));\n\t}\n\n\t// FIXME asc maybe. The reflection list of methods returned doesn't include <clinit> (the static initializer) ... is that really\n\t// a problem.\n\tpublic void testCompareSubclassDelegates() {\n\n\t\tboolean barfIfClinitMissing = false;\n\t\tworld.setBehaveInJava5Way(true);\n\n\t\tBcelWorld bcelWorld = new BcelWorld(getClass().getClassLoader(), IMessageHandler.THROW, null);\n\t\tbcelWorld.setBehaveInJava5Way(true);\n\t\tUnresolvedType javaUtilHashMap = UnresolvedType.forName(\"java.util.HashMap\");\n\t\tReferenceType rawType = (ReferenceType) bcelWorld.resolve(javaUtilHashMap);\n\n\t\tReferenceType rawReflectType = (ReferenceType) world.resolve(javaUtilHashMap);\n\t\tResolvedMember[] rms1 = rawType.getDelegate().getDeclaredMethods();\n\t\tResolvedMember[] rms2 = rawReflectType.getDelegate().getDeclaredMethods();\n\t\tStringBuilder errors = new StringBuilder();\n\t\tSet one = new HashSet();\n\t\tfor (ResolvedMember item : rms1) {\n\t\t\tone.add(item.toString());\n\t\t}\n\t\tSet two = new HashSet();\n\t\tfor (ResolvedMember value : rms2) {\n\t\t\ttwo.add(value.toString());\n\t\t}\n\t\tfor (ResolvedMember member : rms2) {\n\t\t\tif (!one.contains(member.toString())) {\n\t\t\t\terrors.append(\"Couldn't find \" + member.toString() + \" in the bcel set\\n\");\n\t\t\t}\n\t\t}\n\t\tfor (ResolvedMember resolvedMember : rms1) {\n\t\t\tif (!two.contains(resolvedMember.toString())) {\n\t\t\t\tif (!barfIfClinitMissing && resolvedMember.getName().equals(\"<clinit>\"))\n\t\t\t\t\tcontinue;\n\t\t\t\terrors.append(\"Couldn't find \" + resolvedMember.toString() + \" in the reflection set\\n\");\n\t\t\t}\n\t\t}\n\t\tassertTrue(\"Errors:\" + errors.toString(), errors.length() == 0);\n\n\t\t// the good old ibm vm seems to offer clinit through its reflection support (see pr145322)\n\t\tif (rms1.length == rms2.length)\n\t\t\treturn;\n\t\tif (barfIfClinitMissing) {\n\t\t\t// the numbers must be exact\n\t\t\tassertEquals(rms1.length, rms2.length);\n\t\t} else {\n\t\t\t// the numbers can be out by one in favour of bcel\n\t\t\tif (rms1.length != (rms2.length + 1)) {\n\t\t\t\tfor (int i = 0; i < rms1.length; i++) {\n\t\t\t\t\tSystem.err.println(\"bcel\" + i + \" is \" + rms1[i]);\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < rms2.length; i++) {\n\t\t\t\t\tSystem.err.println(\"refl\" + i + \" is \" + rms2[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassertTrue(\"Should be one extra (clinit) in BCEL case, but bcel=\" + rms1.length + \" reflect=\" + rms2.length,\n\t\t\t\t\trms1.length == rms2.length + 1);\n\t\t}\n\t}\n\n\tpublic void testArrayArgsSig() throws Exception {\n\t\tMethod invokeMethod = Method.class.getMethod(\"invoke\", new Class[] { Object.class, Object[].class });\n\t\tResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);\n\t\tString exp = \"(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\";\n\t\tassertTrue(\"Expected: \\n\" + exp + \"\\n but got:\\n\" + reflectionMethod.getSignature(), reflectionMethod.getSignature()\n\t\t\t\t.equals(exp));\n\t}\n\n\t// todo: array of int\n\n\tprotected void setUp() throws Exception {\n\t\tworld = new ReflectionWorld(getClass().getClassLoader());\n\t\tobjectType = world.resolve(\"java.lang.Object\");\n\t}\n}\n",
    "size": 11579
  },
  {
    "file_id": "F167",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/reflect/ReflectionWorldReferenceTypeTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2002-2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     Andy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.reflect;\n\nimport org.aspectj.weaver.CommonReferenceTypeTests;\nimport org.aspectj.weaver.World;\n\npublic class ReflectionWorldReferenceTypeTest extends CommonReferenceTypeTests {\n\n\tprotected boolean getSupportsAutoboxing() {\n\t\treturn true;\n\t}\n\n\tpublic World getWorld() {\n\t\treturn new ReflectionWorld(false, getClass().getClassLoader());\n\t}\n\n}\n",
    "size": 855
  },
  {
    "file_id": "F168",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/reflect/ReflectionWorldTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005,2017 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n * ******************************************************************/\npackage org.aspectj.weaver.reflect;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.weaver.ReferenceType;\nimport org.aspectj.weaver.ResolvedMember;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.WeakClassLoaderReference;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.bcel.BcelWorld;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Andy Clement\n * @author Adrian Colyer\n */\npublic class ReflectionWorldTest extends TestCase {\n\n\tpublic void testDelegateCreation() {\n\t\tWorld world = new ReflectionWorld(getClass().getClassLoader());\n\t\tResolvedType rt = world.resolve(\"java.lang.Object\");\n\t\tassertNotNull(rt);\n\t\tassertEquals(\"Ljava/lang/Object;\", rt.getSignature());\n\t}\n\n\t// Removed for now. In Spring the reflection worlds are customized by introducing new\n\t// PCD handlers. It means more thought needs to be put into reusing worlds.\n\tpublic void xtestReflectionWorldFactory() throws Exception {\n\t\tClassLoader parent = getClass().getClassLoader();\n\t\tClassLoader cl1 = new URLClassLoader(new URL[] {}, parent);\n\t\tClassLoader cl2 = new URLClassLoader(new URL[] {}, parent);\n\n\t\tWeakClassLoaderReference wcl1 = new WeakClassLoaderReference(cl1);\n\t\tWeakClassLoaderReference wcl2 = new WeakClassLoaderReference(cl2);\n\t\tReflectionWorld a = ReflectionWorld.getReflectionWorldFor(wcl1);\n\n\t\tResolvedType stringClass1 = a.resolve(String.class);\n\t\tassertNotNull(stringClass1);\n\n\t\tReflectionWorld b = ReflectionWorld.getReflectionWorldFor(wcl1);\n\n\t\t// They should be the same because the classloader has not gone away\n\t\tassertTrue(a==b);\n\n\t\tcl1 = null;\n\t\tfor (int i=0;i<100;i++) {\n\t\t\tSystem.gc(); // How robust is it that this should be causing the reference to be collected?\n\t\t}\n\t\tb = ReflectionWorld.getReflectionWorldFor(wcl1);\n\n\t\tassertFalse(a==b);\n\n\t\tcl1 = new URLClassLoader(new URL[] {}, parent);\n\t\twcl1 = new WeakClassLoaderReference(cl1);\n\t\ta = ReflectionWorld.getReflectionWorldFor(wcl1);\n\t\tb = ReflectionWorld.getReflectionWorldFor(wcl2);\n\t\tassertFalse(a==b);\n\n\t\tField declaredField = ReflectionWorld.class.getDeclaredField(\"rworlds\");\n\t\tdeclaredField.setAccessible(true);\n\t\tMap worlds = (Map)declaredField.get(null);\n\t\tassertEquals(2, worlds.size());\n\n\t\tcl2 = null;\n\t\tfor (int i=0;i<100;i++) {\n\t\t\tSystem.gc(); // How robust is it that this should be causing the reference to be collected?\n\t\t}\n\t\tReflectionWorld.getReflectionWorldFor(wcl1); // need to call this to trigger tidyup\n\t\tassertEquals(1, worlds.size());\n\n\t\tcl1 = null;\n\t\tfor (int i=0;i<100;i++) {\n\t\t\tSystem.gc(); // How robust is it that this should be causing the reference to be collected?\n\t\t}\n\t\tReflectionWorld.getReflectionWorldFor(wcl1); // need to call this to trigger tidyup\n\t\tassertEquals(0, worlds.size());\n\n\t\tcl1 = new URLClassLoader(new URL[] {}, parent);\n\t\twcl1 = new WeakClassLoaderReference(cl1);\n\t\tReflectionWorld reflectionWorldFor = ReflectionWorld.getReflectionWorldFor(wcl1);\n\t\tassertEquals(1, worlds.size());\n\t\tReflectionWorld.cleanUpWorlds();\n\t\tassertEquals(0, worlds.size());\n\t}\n\n\tpublic void testArrayTypes() {\n\t\tIReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\n\t\tString[] strArray = new String[1];\n\t\tResolvedType rt = world.resolve(strArray.getClass());\n\t\tassertTrue(rt.isArray());\n\t}\n\n\tpublic void testPrimitiveTypes() {\n\t\tIReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\n\t\tassertEquals(\"int\", UnresolvedType.INT, world.resolve(int.class));\n\t\tassertEquals(\"void\", UnresolvedType.VOID, world.resolve(void.class));\n\t}\n\n\tstatic class AbstractSuperClass<A,B> {}\n\tinterface InterfaceOne {}\n\tinterface InterfaceTwo<A> {}\n\tstatic class ID {}\n\tstatic abstract class AbstractTestClass<T> extends AbstractSuperClass<T,ID> implements InterfaceOne, InterfaceTwo<T> {\n\n\t}\n\tstatic class TestType {}\n//\tstatic class ConcreteClass extends AbstractTestClass<TestType> {\n\tstatic class ConcreteClass extends AbstractTestClass<List<TestType>> {\n\t}\n\n\tstatic class Bar extends ConcreteClass {}\n\n\tpublic void testGenerics() {\n\t\tReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\n//\t\tworld.lookupOrCreateName(UnresolvedType.forName(AbstractTestClass.class.getName()));\n//\t\tResolvedType resolvedType = world.resolve(AbstractTestClass.class);\n\t\tJavaLangTypeToResolvedTypeConverter converter = new JavaLangTypeToResolvedTypeConverter(world);\n\t\tResolvedType resolvedType2 = converter.fromType(ConcreteClass.class);\n\t}\n\n\tpublic void xtestTypeConversions_509327() throws Exception {\n\t\tReflectionWorld rWorld = new ReflectionWorld(getClass().getClassLoader());\n\t\tJavaLangTypeToResolvedTypeConverter converter = new JavaLangTypeToResolvedTypeConverter(rWorld);\n\n\t\t// Check basic conversion of String to String\n\t\tMethod method = TestClass.class.getDeclaredMethod(\"m\");\n\t\tType stringType = method.getGenericReturnType();\n\t\tassertEquals(\"java.lang.String\",stringType.getTypeName());\n\t\tResolvedType stringResolvedType = converter.fromType(stringType);\n\t\tassertEquals(\"java.lang.String\",stringResolvedType.getName());\n\n\t\t// public String m() { return \"\"; }\n\t\tmethod = TestClass2.class.getDeclaredMethod(\"m\");\n\t\tstringType = method.getGenericReturnType();\n\t\tassertEquals(\"java.lang.String\",stringType.getTypeName());\n\t\tstringResolvedType = converter.fromType(stringType);\n\t\tassertEquals(\"java.lang.String\",stringResolvedType.getName());\n\n\t\t// Verify that the conversion process creates the same thing as the bcel unpacking\n\n\t\t// Here the return type is a non-static inner of a generic class\n\t\t// public Inner m2() { return null; }\n\t\tmethod = TestClass2.class.getDeclaredMethod(\"m2\");\n\t\tType innerType = method.getGenericReturnType();\n\t\tassertEquals(\"org.aspectj.weaver.reflect.ReflectionWorldTest.org.aspectj.weaver.reflect.ReflectionWorldTest$TestClass2<T>.Inner\",innerType.getTypeName());\n\t\tResolvedType rType_Inner = converter.fromType(innerType);\n\t\tassertEquals(\"Lorg/aspectj/weaver/reflect/ReflectionWorldTest$TestClass2$Inner;\",rType_Inner.getSignature());\n\t\tassertEquals(UnresolvedType.TypeKind.SIMPLE,rType_Inner.getTypekind());\n\t\tResolvedType rType_Outer = rType_Inner.getOuterClass();\n\t\tassertEquals(\"Lorg/aspectj/weaver/reflect/ReflectionWorldTest$TestClass2;\",rType_Outer.getSignature());\n\n\t\tBcelWorld bWorld = new BcelWorld(getClass().getClassLoader(), IMessageHandler.THROW, null);\n\t\tbWorld.setBehaveInJava5Way(true);\n\t\tUnresolvedType javaUtilHashMap = UnresolvedType.forName(\"java.util.HashMap\");\n\t\tReferenceType rawType = (ReferenceType) bWorld.resolve(javaUtilHashMap);\n\t\tassertNotNull(rawType);\n\n\t\t// Now use bcel to resolve the same m2 method, and compare the signatures of the return types\n\t\tResolvedType bResolved_TestClass2 = bWorld.resolve(UnresolvedType.forName(TestClass2.class.getName()));\n\t\tassertNotNull(bResolved_TestClass2);\n\t\tResolvedMember bMethod_m2 = findMethod(bResolved_TestClass2,\"m2\");\n\t\tResolvedType bType_Inner = (ResolvedType) bMethod_m2.getReturnType();\n\t\tassertEquals(\"Lorg/aspectj/weaver/reflect/ReflectionWorldTest$TestClass2$Inner;\",bType_Inner.getSignature());\n\t\tassertEquals(UnresolvedType.TypeKind.SIMPLE,bType_Inner.getTypekind());\n\t\tResolvedType bType_Outer = bType_Inner.getOuterClass();\n\t\tassertEquals(\"Lorg/aspectj/weaver/reflect/ReflectionWorldTest$TestClass2;\",bType_Outer.getSignature());\n\n\t\tassertEquals(bType_Inner.getSignature(),rType_Inner.getSignature());\n\t\tassertEquals(bType_Outer.getSignature(),rType_Outer.getSignature());\n\t}\n\n\n\tpublic void xtestTypeConversions_509327_2() throws Exception {\n\t\tReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\n\t\tJavaLangTypeToResolvedTypeConverter converter = new JavaLangTypeToResolvedTypeConverter(world);\n\t\tBcelWorld bWorld = new BcelWorld(getClass().getClassLoader(), IMessageHandler.THROW, null);\n\t\tbWorld.setBehaveInJava5Way(true);\n\n\t\t// Slightly more advanced, now the method is returning a parameterized form of the outer\n\t\t// generic class\n\n\t\t// public TestClass2<String>.Inner m3() { return new TestClass2<String>.Inner(\"Foo\"); }\n\t\tMethod method = TestClass2.class.getDeclaredMethod(\"m3\");\n\t\tType type_ParameterizedInner = method.getGenericReturnType();\n\t\tassertEquals(\"org.aspectj.weaver.reflect.ReflectionWorldTest.org.aspectj.weaver.reflect.ReflectionWorldTest$TestClass2<java.lang.String>.Inner\",type_ParameterizedInner.getTypeName());\n\t\tResolvedType rType_ParameterizedInner = converter.fromType(type_ParameterizedInner);\n\t\t// NOTE: DECLARED PARAMETERIZATION OF OUTER IS LOST\n\t\tassertEquals(\"Lorg/aspectj/weaver/reflect/ReflectionWorldTest$TestClass2$Inner;\",rType_ParameterizedInner.getSignature());\n\n\t\tResolvedType bResolved_TestClass2 = bWorld.resolve(UnresolvedType.forName(TestClass2.class.getName()));\n\t\tassertNotNull(bResolved_TestClass2);\n\t\tResolvedMember bMethod_m3 = findMethod(bResolved_TestClass2,\"m3\");\n\t\tResolvedType bType_Inner = (ResolvedType) bMethod_m3.getReturnType();\n\t\t// NOTE: DECLARED PARAMETERIZATION OF OUTER IS LOST\n\t\tassertEquals(\"Lorg/aspectj/weaver/reflect/ReflectionWorldTest$TestClass2$Inner;\",bType_Inner.getSignature());\n\n\t\tassertEquals(UnresolvedType.TypeKind.SIMPLE,bType_Inner.getTypekind());\n\t\tResolvedType bType_Outer = bType_Inner.getOuterClass();\n\n\t\t// Fields seem to lose it too, although the backinggenericmember has the info\n//\t\tResolvedMember bField_f = findField(bResolved_TestClass2,\"f\");\n//\t\tResolvedMember backingGenericMember = bField_f.getBackingGenericMember();\n//\t\tSystem.out.println(backingGenericMember);\n//\t\tSystem.out.println(backingGenericMember.getGenericReturnType());\n//\t\tSystem.out.println(bField_f);\n//\t\tSystem.out.println(bField_f.getSignature());\n//\t\tSystem.out.println(bField_f.getGenericReturnType());\n\t}\n\n//\tpublic void testbar() throws Exception {\n//\t\tReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\n//\t\tJavaLangTypeToResolvedTypeConverter converter = new JavaLangTypeToResolvedTypeConverter(world);\n//\n//\t\t// public TestClass2<String>.Inner m3() { return new TestClass2<String>.Inner(\"Foo\"); }\n//\t\tMethod method = TestClass2.class.getDeclaredMethod(\"m3\");\n//\t\tType type_ParameterizedInner = method.getGenericReturnType();\n//\t\tassertEquals(\"org.aspectj.weaver.reflect.ReflectionWorldTest.org.aspectj.weaver.reflect.ReflectionWorldTest$TestClass2<java.lang.String>.Inner\",type_ParameterizedInner.getTypeName());\n//\t\tResolvedType rType_ParameterizedInner = converter.fromType(type_ParameterizedInner);\n//\t\tSystem.out.println(rType_ParameterizedInner);\n//\t\tSystem.out.println(type_ParameterizedInner.getTypeName());\n//\t}\n//\n//\tpublic void testfoo() {\n//\t\tReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\n//\t\tJavaLangTypeToResolvedTypeConverter converter = new JavaLangTypeToResolvedTypeConverter(world);\n//\t\tBcelWorld bWorld = new BcelWorld(getClass().getClassLoader(), IMessageHandler.THROW, null);\n//\t\tbWorld.setBehaveInJava5Way(true);\n//\n//\n//\t\tResolvedType bResolved_TestClass2 = bWorld.resolve(UnresolvedType.forName(TestClass2.class.getName()));\n//\t\tResolvedMember bField_f = findField(bResolved_TestClass2,\"f\");\n//\t\tSystem.out.println(bField_f);\n//\t\tSystem.out.println(bField_f.getGenericReturnType());\n//\t\tSystem.out.println(bField_f.getReturnType());\n//\t\tSystem.out.println(bField_f.getBackingGenericMember().getGenericReturnType());\n//\t}\n\n\tstatic class TestClass {\n\t\tpublic String m() { return \"\"; }\n\t}\n\n\tstatic class TestClass2<T> {\n\t\tclass Inner {\n\t\t\tT t;\n\t\t\tInner(T t) {\n\t\t\t\tthis.t = t;\n\t\t\t}\n\t\t}\n\t\tpublic String m() { return \"\"; }\n\t\tpublic Inner m2() { return null; }\n\t\tpublic TestClass2<String> f;\n\t\tpublic TestClass2<String>.Inner m3() { return new TestClass2<String>.Inner(\"Foo\"); }\n\t}\n\n\tprivate ResolvedMember findMethod(ResolvedType resolvedType, String methodName) {\n\t\tfor (ResolvedMember method: resolvedType.getDeclaredMethods()) {\n\t\t\tif (method.getName().equals(methodName)) {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate ResolvedMember findField(ResolvedType resolvedType, String fieldName) {\n\t\tfor (ResolvedMember field: resolvedType.getDeclaredFields()) {\n\t\t\tif (field.getName().equals(fieldName)) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n}\n",
    "size": 12690
  },
  {
    "file_id": "F169",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.tools;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.internal.tools.PointcutExpressionImpl;\nimport org.aspectj.weaver.patterns.AbstractPatternNodeVisitor;\nimport org.aspectj.weaver.patterns.AndAnnotationTypePattern;\nimport org.aspectj.weaver.patterns.AnnotationPatternList;\nimport org.aspectj.weaver.patterns.AnyAnnotationTypePattern;\nimport org.aspectj.weaver.patterns.BindingAnnotationTypePattern;\nimport org.aspectj.weaver.patterns.ExactAnnotationTypePattern;\nimport org.aspectj.weaver.patterns.KindedPointcut;\nimport org.aspectj.weaver.patterns.NotAnnotationTypePattern;\nimport org.aspectj.weaver.patterns.OrAnnotationTypePattern;\nimport org.aspectj.weaver.patterns.SignaturePattern;\nimport org.aspectj.weaver.patterns.TypePattern;\nimport org.aspectj.weaver.patterns.TypePatternList;\nimport org.aspectj.weaver.patterns.WildAnnotationTypePattern;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\nimport test.A1AnnotatedType;\nimport test.A2AnnotatedType;\n\n/**\n * Test parameter pointcut parsing.  Extended by Andy Clement to cover parameter annotation matching.\n *\n */\npublic class Java15PointcutExpressionTest extends TestCase {\n\n\tpublic static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"Java15PointcutExpressionTest\");\n\t\tsuite.addTestSuite(Java15PointcutExpressionTest.class);\n\t\treturn suite;\n\t}\n\n\tprivate PointcutParser parser;\n\tprivate Method a;\n\tprivate Method b;\n\tprivate Method c;\n\tprivate Method d;\n\n\t/**\n\t * Parse some expressions and ensure we capture the parameter annotations and parameter type annotations correctly.\n\t * Buckle up, this will get complicated ;)\n\t */\n\tpublic void testParseParameterAnnotationExpressions() {\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());\n\t\tPointcutExpression pexpr = null;\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA *))\");\n\t\tcheckParameterAnnotations(pexpr,0,null,\"@MA\",\"exact[@MA:t]\");\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA (*)))\");\n\t\tcheckParameterAnnotations(pexpr,0,\"@MA\",null,\"exact[@MA:p]\");\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA @MB *))\");\n\t\tcheckParameterAnnotations(pexpr,0,null,\"@MA @MB\",\"(exact[@MA:t] and exact[@MB:t])\");\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA (@MB *)))\");\n\t\tcheckParameterAnnotations(pexpr,0,\"@MA\",\"@MB\",\"(exact[@MA:p] and exact[@MB:t])\");\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA @MB (@MC *)))\");\n\t\tcheckParameterAnnotations(pexpr,0,\"@MA @MB\",\"@MC\",\"((exact[@MA:p] and exact[@MB:p]) and exact[@MC:t])\");\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA (@MB @MC @MD *)))\");\n\t\tcheckParameterAnnotations(pexpr,0,\"@MA\",\"@MB @MC @MD\",\"(exact[@MA:p] and ((exact[@MB:t] and exact[@MC:t]) and exact[@MD:t]))\");\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@(MA || MB) (@MC @MD *)))\");\n\t\tcheckParameterAnnotations(pexpr,0,null/*Should be MA MB */,\"@MC @MD\",\"(wild[(MA || MB)] and (exact[@MC:t] and exact[@MD:t]))\"); // I dont think WildAnnotationTypePatterns work properly...\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA (@MB *),(@MC *),@MD (*)))\");\n\t\tcheckParameterAnnotations(pexpr,0,\"@MA\",\"@MB\",\"(exact[@MA:p] and exact[@MB:t])\");\n\t\tcheckParameterAnnotations(pexpr,1,null,\"@MC\",\"exact[@MC:t]\");\n\t\tcheckParameterAnnotations(pexpr,2,\"@MD\",null,\"exact[@MD:p]\");\n\n\t}\n\n\tpublic void testMatchingAnnotationValueExpressions() throws SecurityException, NoSuchMethodException {\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());\n\t\tPointcutExpression pexpr = null;\n\t\tShadowMatch match = null;\n\n\t\tMethod n = test.AnnoValues.class.getMethod(\"none\");\n\t\tMethod r = test.AnnoValues.class.getMethod(\"redMethod\");\n\t\tMethod g = test.AnnoValues.class.getMethod(\"greenMethod\");\n\t\tMethod b = test.AnnoValues.class.getMethod(\"blueMethod\");\n\t\tMethod d = test.AnnoValues.class.getMethod(\"defaultMethod\");\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(@test.A3(test.Color.RED) public void *(..))\");\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(n).neverMatches()); // default value RED\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(r).alwaysMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(g).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(b).neverMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(d).alwaysMatches());\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(@test.A3(test.Color.GREEN) public void *(..))\");\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(n).neverMatches()); // default value RED\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(r).neverMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(g).alwaysMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(b).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(d).neverMatches());\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(@test.A3(test.Color.BLUE) public void *(..))\");\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(n).neverMatches()); // default value RED\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(r).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(g).neverMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(b).alwaysMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(d).neverMatches());\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(@test.A3 public void *(..))\");\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(n).neverMatches()); // default value RED\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(r).alwaysMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(g).alwaysMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(b).alwaysMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(d).alwaysMatches());\n\n\t}\n\n\tprivate static final Set<PointcutPrimitive> DEFAULT_SUPPORTED_PRIMITIVES = new HashSet<>();\n\n\t static {\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.EXECUTION);\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.ARGS);\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.REFERENCE);\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.THIS);\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.TARGET);\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.WITHIN);\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_ANNOTATION);\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_WITHIN);\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_ARGS);\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_TARGET);\n\t }\n\n\tpublic void testPerformanceOfPointcutParsing() {\n\t\tString expression = \"execution(public * rewards.internal.*.*Repository+.*(..))\";\n\t\tlong stime1 = System.currentTimeMillis();\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingContextClassloaderForResolution(DEFAULT_SUPPORTED_PRIMITIVES);\n\t\tlong stime2 = System.currentTimeMillis();\n\t\tPointcutExpression pointcutExpression = parser.parsePointcutExpression(expression, null, new PointcutParameter[0]);\n\t\tlong etime = System.currentTimeMillis();\n\t\tSystem.out.println(\"Time to get a parser \"+(stime2-stime1)+\"ms\");\n\t\tSystem.out.println(\"Time taken to parse expression is \"+(etime-stime2)+\"ms\");\n\t}\n\n\n\tpublic void testPerformanceOfPointcutParsingWithBean() {\n\t\tString expression = \"execution(public * rewards.internal.*.*Repository+.*(..))\";\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());\n\t\tBeanDesignatorHandler beanHandler = new BeanDesignatorHandler();\n\t\tparser.registerPointcutDesignatorHandler(beanHandler);\n\t\tlong stime = System.currentTimeMillis();\n\t\tPointcutExpression pointcutExpression = parser.parsePointcutExpression(expression, null, new PointcutParameter[0]);\n\t\tlong etime = System.currentTimeMillis();\n\t\tSystem.out.println(\"Time taken to parse expression is \"+(etime-stime)+\"ms\");\n\t}\n\n\tprivate class BeanDesignatorHandler implements PointcutDesignatorHandler {\n\n\t\tprivate String askedToParse;\n\t\tpublic boolean simulateDynamicTest = false;\n\n\t\tpublic String getDesignatorName() {\n\t\t\treturn \"bean\";\n\t\t}\n\n\t\t/* (non-Javadoc)\n\t\t * @see org.aspectj.weaver.tools.PointcutDesignatorHandler#parse(java.lang.String)\n\t\t */\n\t\tpublic ContextBasedMatcher parse(String expression) {\n\t\t\tthis.askedToParse = expression;\n\t\t\treturn null;\n//\t\t\treturn new BeanPointcutExpression(expression,this.simulateDynamicTest);\n\t\t}\n\n\t\tpublic String getExpressionLastAskedToParse() {\n\t\t\treturn this.askedToParse;\n\t\t}\n\t}\n\n\n\t/**\n\t * Test matching of pointcuts against expressions.  A reflection world is being used on the backend here (not a Bcel one).\n\t */\n\tpublic void testMatchingParameterAnnotationExpressions() throws SecurityException, NoSuchMethodException {\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());\n\t\tPointcutExpression pexpr = null;\n\t\tShadowMatch match = null;\n\n\t\tMethod a = test.A.class.getMethod(\"a\",new Class[] {String.class});             // public void a(String s) {}\n\t\tMethod b = test.A.class.getMethod(\"b\",new Class[] {String.class});             // public void b(@A1 String s) {}\n\t\tMethod c = test.A.class.getMethod(\"c\",new Class[] {String.class});             // public void c(@A1 @A2 String s) {}\n//\t\tMethod d = test.A.class.getMethod(\"d\",new Class[] {String.class,String.class});// public void d(@A1 String s,@A2 String t) {}\n\n\t\tMethod e = test.A.class.getMethod(\"e\",new Class[] {A1AnnotatedType.class});    // public void e(A1AnnotatedType s) {}\n\t\tMethod f = test.A.class.getMethod(\"f\",new Class[] {A2AnnotatedType.class});    // public void f(A2AnnotatedType s) {}\n\t\tMethod g = test.A.class.getMethod(\"g\",new Class[] {A1AnnotatedType.class});    // public void g(@A2 A1AnnotatedType s) {}\n\t\tMethod h = test.A.class.getMethod(\"h\",new Class[] {A1AnnotatedType.class});    // public void h(@A1 A1AnnotatedType s) {}\n//\t\tMethod i = test.A.class.getMethod(\"i\",new Class[] {A1AnnotatedType.class,String.class});    // public void i(A1AnnotatedType s,@A2 String t) {}\n//\t\tMethod j = test.A.class.getMethod(\"j\",new Class[] {String.class});             // public void j(@A1 @A2 String s) {}\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void *(@test.A1 *))\");\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(a).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(b).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(c).neverMatches());\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void *(@test.A1 (*)))\");\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(a).neverMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(b).alwaysMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(c).alwaysMatches());\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void *(@test.A1 *))\");\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(e).alwaysMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(f).neverMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(g).alwaysMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(h).alwaysMatches());\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void *(@test.A1 (*)))\");\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(e).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(f).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(g).neverMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(h).alwaysMatches());\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void *(@(test.A1 || test.A2) (*)))\");\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(a).neverMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(b).alwaysMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(c).alwaysMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(g).alwaysMatches());\n\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(h).alwaysMatches());\n\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void *(@(test.A1 && test.A2) (*),..))\");\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(a).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(b).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(c).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(g).neverMatches());\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(h).neverMatches());\n//\t\tassertTrue(\"Should match\", pexpr.matchesMethodExecution(j).alwaysMatches()); // should match but does not, broken implementation, old bug - see WildAnnotationTypePattern.match\n\n\n\n\t}\n\n\tprivate void checkParameterAnnotations(PointcutExpression pe,int parameterNumber,String expectedParameterAnnotations,String expectedParameterTypeAnnotations,String expectedNodeStructure) {\n\t  org.aspectj.weaver.patterns.Pointcut p = ((PointcutExpressionImpl)pe).getUnderlyingPointcut();\n\t  KindedPointcut kindedP = (KindedPointcut)p;\n\t  SignaturePattern sp = kindedP.getSignature();\n\t  TypePatternList tpl = sp.getParameterTypes();\n\t  TypePattern[] tps = tpl.getTypePatterns();\n\n\t  // A visitor over the annotation pattern for the parameter will break it down into parameter vs parameter type annotations\n\t  MyPatternNodeVisitor mpnv = new MyPatternNodeVisitor();\n\t  tps[parameterNumber].getAnnotationPattern().accept(mpnv,null);\n\n\t  if (expectedNodeStructure==null) {\n\t\t  // The caller hasn't worked it out yet!!\n\t\t  System.out.println(mpnv.getStringRepresentation());\n\t  } else if (!mpnv.getStringRepresentation().equals(expectedNodeStructure)) {\n\t\t  System.out.println(mpnv.getStringRepresentation());\n\t\t  fail(\"Expected annotation pattern node structure for expression \"+pe.getPointcutExpression()+\n\t\t\t   \" was '\"+expectedNodeStructure+\"' but it turned out to be '\"+mpnv.getStringRepresentation()+\"'\");\n\t  }\n\n\t  tps[parameterNumber].getAnnotationPattern().toString();\n\n\t  // parameter type annotation checking\n\t\tSet<String> expected = new HashSet<>(mpnv.getParameterTypeAnnotations());\n\n\t  StringTokenizer st = new StringTokenizer(expectedParameterTypeAnnotations==null?\"\":expectedParameterTypeAnnotations);\n\t  while (st.hasMoreTokens()) {\n\t\t  String nextToken = st.nextToken();\n\t\t  if (!expected.contains(nextToken))\n\t\t\t  fail(\"In pointcut expression \"+pe.getPointcutExpression()+\" parameter \"+parameterNumber+\". The annotation type pattern did not include parameter type annotation \"+nextToken+\".  It's full set was \"+mpnv.getParameterTypeAnnotations());\n\t\t  expected.remove(nextToken);\n\t  }\n\t  if (expected.size()>0) { // we have excess ones!\n\t\t  StringBuilder excessTokens = new StringBuilder();\n\t\t  for (String string : expected) {\n\t\t\t  excessTokens.append(string).append(\" \");\n\t\t  }\n\t    fail(\"In pointcut expression \"+pe.getPointcutExpression()+\" parameter \"+parameterNumber+\". The annotation type pattern has these unexpected parameter type annotations \"+excessTokens.toString());\n\t  }\n\n\t  // parameter annotation checking\n\t\texpected = new HashSet<>(mpnv.getParameterAnnotations());\n\n\t  st = new StringTokenizer(expectedParameterAnnotations==null?\"\":expectedParameterAnnotations);\n\t  while (st.hasMoreTokens()) {\n\t\t  String nextToken = st.nextToken();\n\t\t  if (!expected.contains(nextToken))\n\t\t\t  fail(\"In pointcut expression \"+pe.getPointcutExpression()+\" parameter \"+parameterNumber+\". The annotation type pattern did not include parameter annotation \"+nextToken+\".  It's full set was \"+mpnv.getParameterAnnotations());\n\t\t  expected.remove(nextToken);\n\t  }\n\t  if (expected.size()>0) { // we have excess ones!\n\t\t  StringBuilder excessTokens = new StringBuilder();\n\t\t  for (String string : expected) {\n\t\t\t  excessTokens.append(string).append(\" \");\n\t\t  }\n\t    fail(\"In pointcut expression \"+pe.getPointcutExpression()+\" parameter \"+parameterNumber+\". The annotation type pattern has these unexpected parameter annotations \"+excessTokens.toString());\n\t  }\n\n\t}\n\n\tstatic class MyPatternNodeVisitor extends AbstractPatternNodeVisitor {\n\t\tprivate StringBuffer stringRep = new StringBuffer();\n\t\tprivate List<String> parameterAnnotations = new ArrayList<>();\n\t\tprivate List<String> parameterTypeAnnotations = new ArrayList<>();\n\n\t\tpublic String getStringRepresentation() { return stringRep.toString(); }\n\t\tpublic List<String> getParameterAnnotations() { return parameterAnnotations; }\n\t\tpublic List<String> getParameterTypeAnnotations() { return parameterTypeAnnotations; }\n\n\t\tpublic Object visit(AndAnnotationTypePattern node, Object data) {\n\t\t\tstringRep.append(\"(\");\n\t\t\tnode.getLeft().accept(this, data);\n\t\t\tstringRep.append(\" and \");\n\t\t\tnode.getRight().accept(this, data);\n\t\t\tstringRep.append(\")\");\n\t\t\treturn node;\n\t\t}\n\t    public Object visit(AnyAnnotationTypePattern node, Object data) {\n\t    \tstringRep.append(\"any\");\n\t\t\treturn node;\n\t    }\n\t    public Object visit(ExactAnnotationTypePattern node, Object data) {\n\t    \tstringRep.append(\"exact[\"+stringify(node.getResolvedAnnotationType())+\":\"+(node.isForParameterAnnotationMatch()?\"p\":\"t\")+\"]\");\n\t    \tif (node.isForParameterAnnotationMatch()) {\n\t    \t\tparameterAnnotations.add(stringify(node.getResolvedAnnotationType()));\n\t    \t} else {\n\t    \t\tparameterTypeAnnotations.add(stringify(node.getResolvedAnnotationType()));\n\t    \t}\n\t\t\treturn node;\n\t    }\n\t    private String stringify(ResolvedType resolvedAnnotationType) {\n\t    \treturn \"@\"+resolvedAnnotationType.getSimpleName();\n\t\t}\n\n\t\tpublic Object visit(BindingAnnotationTypePattern node, Object data) {\n\t\t\tstringRep.append(\"binding\");\n\n\t\t\treturn node;\n\t    }\n\t    public Object visit(NotAnnotationTypePattern node, Object data) {\n\t\t\tstringRep.append(\"not\");\n\t\t\treturn node;\n\t    }\n\t    public Object visit(OrAnnotationTypePattern node, Object data) {\n\t\t\tstringRep.append(\"(\");\n\t\t\tnode.getLeft().accept(this, data);\n\t\t\tstringRep.append(\" or \");\n\t\t\tnode.getRight().accept(this, data);\n\t\t\tstringRep.append(\")\");\n\t\t\treturn node;\n\t    }\n\t    public Object visit(WildAnnotationTypePattern node, Object data) {\n\t\t\tstringRep.append(\"wild[\");\n\t\t\tstringRep.append(node.getTypePattern().toString());\n\t\t\tstringRep.append(\"]\");\n\t\t\treturn node;\n\t    }\n\t    public Object visit(AnnotationPatternList node, Object data) {\n\t\t\tstringRep.append(\"list\");\n\n\t\t\treturn node;\n\t    }\n\n\n\t}\n\n\n\n\tpublic void testAtThis() {\n\t\tPointcutExpression atThis = parser.parsePointcutExpression(\"@this(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\n\t\tShadowMatch sMatch1 = atThis.matchesMethodExecution(a);\n\t\tShadowMatch sMatch2 = atThis.matchesMethodExecution(b);\n\t\tassertTrue(\"maybe matches A\",sMatch1.maybeMatches());\n\t\tassertTrue(\"maybe matches B\",sMatch2.maybeMatches());\n\t\tJoinPointMatch jp1 = sMatch1.matchesJoinPoint(new A(), new A(), new Object[0]);\n\t\tassertFalse(\"does not match\",jp1.matches());\n\t\tJoinPointMatch jp2 = sMatch2.matchesJoinPoint(new B(), new B(), new Object[0]);\n\t\tassertTrue(\"matches\",jp2.matches());\n\t}\n\n\tpublic void testAtTarget() {\n\t\tPointcutExpression atTarget = parser.parsePointcutExpression(\"@target(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\n\t\tShadowMatch sMatch1 = atTarget.matchesMethodExecution(a);\n\t\tShadowMatch sMatch2 = atTarget.matchesMethodExecution(b);\n\t\tassertTrue(\"maybe matches A\",sMatch1.maybeMatches());\n\t\tassertTrue(\"maybe matches B\",sMatch2.maybeMatches());\n\t\tJoinPointMatch jp1 = sMatch1.matchesJoinPoint(new A(), new A(), new Object[0]);\n\t\tassertFalse(\"does not match\",jp1.matches());\n\t\tJoinPointMatch jp2 = sMatch2.matchesJoinPoint(new B(), new B(), new Object[0]);\n\t\tassertTrue(\"matches\",jp2.matches());\n\t}\n\n\tpublic void testAtThisWithBinding() {\n\t\tPointcutParameter param = parser.createPointcutParameter(\"a\",MyAnnotation.class);\n\t\tB myB = new B();\n\t\tMyAnnotation bAnnotation = B.class.getAnnotation(MyAnnotation.class);\n\t\tPointcutExpression atThis = parser.parsePointcutExpression(\"@this(a)\",A.class,new PointcutParameter[] {param});\n\t\tShadowMatch sMatch1 = atThis.matchesMethodExecution(a);\n\t\tShadowMatch sMatch2 = atThis.matchesMethodExecution(b);\n\t\tassertTrue(\"maybe matches A\",sMatch1.maybeMatches());\n\t\tassertTrue(\"maybe matches B\",sMatch2.maybeMatches());\n\t\tJoinPointMatch jp1 = sMatch1.matchesJoinPoint(new A(), new A(), new Object[0]);\n\t\tassertFalse(\"does not match\",jp1.matches());\n\t\tJoinPointMatch jp2 = sMatch2.matchesJoinPoint(myB, myB, new Object[0]);\n\t\tassertTrue(\"matches\",jp2.matches());\n\t\tassertEquals(1,jp2.getParameterBindings().length);\n\t\tassertEquals(\"should be myB's annotation\",bAnnotation,jp2.getParameterBindings()[0].getBinding());\n\t}\n\n\tpublic void testAtTargetWithBinding() {\n\t\tPointcutParameter param = parser.createPointcutParameter(\"a\",MyAnnotation.class);\n\t\tB myB = new B();\n\t\tMyAnnotation bAnnotation = B.class.getAnnotation(MyAnnotation.class);\n\t\tPointcutExpression atThis = parser.parsePointcutExpression(\"@target(a)\",A.class,new PointcutParameter[] {param});\n\t\tShadowMatch sMatch1 = atThis.matchesMethodExecution(a);\n\t\tShadowMatch sMatch2 = atThis.matchesMethodExecution(b);\n\t\tassertTrue(\"maybe matches A\",sMatch1.maybeMatches());\n\t\tassertTrue(\"maybe matches B\",sMatch2.maybeMatches());\n\t\tJoinPointMatch jp1 = sMatch1.matchesJoinPoint(new A(), new A(), new Object[0]);\n\t\tassertFalse(\"does not match\",jp1.matches());\n\t\tJoinPointMatch jp2 = sMatch2.matchesJoinPoint(myB, myB, new Object[0]);\n\t\tassertTrue(\"matches\",jp2.matches());\n\t\tassertEquals(1,jp2.getParameterBindings().length);\n\t\tassertEquals(\"should be myB's annotation\",bAnnotation,jp2.getParameterBindings()[0].getBinding());\n\t}\n\n\tpublic void testAtArgs() {\n\t\tPointcutExpression atArgs = parser.parsePointcutExpression(\"@args(..,org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\n\t\tShadowMatch sMatch1 = atArgs.matchesMethodExecution(a);\n\t\tShadowMatch sMatch2 = atArgs.matchesMethodExecution(c);\n\t\tassertTrue(\"never matches A\",sMatch1.neverMatches());\n\t\tassertTrue(\"maybe matches C\",sMatch2.maybeMatches());\n\t\tJoinPointMatch jp2 = sMatch2.matchesJoinPoint(new B(), new B(), new Object[]{new A(),new B()});\n\t\tassertTrue(\"matches\",jp2.matches());\n\n\t\tatArgs = parser.parsePointcutExpression(\"@args(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation,org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\n\t\tsMatch1 = atArgs.matchesMethodExecution(a);\n\t\tsMatch2 = atArgs.matchesMethodExecution(c);\n\t\tassertTrue(\"never matches A\",sMatch1.neverMatches());\n\t\tassertTrue(\"maybe matches C\",sMatch2.maybeMatches());\n\t\tJoinPointMatch jp1 = sMatch2.matchesJoinPoint(new A(), new A(), new Object[] {new A(), new B()});\n\t\tassertFalse(\"does not match\",jp1.matches());\n\t\tjp2 = sMatch2.matchesJoinPoint(new B(), new B(), new Object[] {new B(),new B()});\n\t\tassertTrue(\"matches\",jp2.matches());\n\t}\n\n\tpublic void testAtArgs2() {\n\t\tPointcutExpression atArgs = parser.parsePointcutExpression(\"@args(*, org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\n\t\tShadowMatch sMatch1 = atArgs.matchesMethodExecution(c);\n\t\tShadowMatch sMatch2 = atArgs.matchesMethodExecution(d);\n\t\tassertTrue(\"maybe matches c\",sMatch1.maybeMatches());\n\t\tassertTrue(\"maybe matches d\",sMatch2.maybeMatches());\n\t\tJoinPointMatch jp1 = sMatch1.matchesJoinPoint(new B(), new B(), new Object[] {new A(), new B()});\n\t\tassertTrue(\"matches\",jp1.matches());\n\t\tJoinPointMatch jp2 = sMatch2.matchesJoinPoint(new B(), new B(), new Object[] {new A(),new A()});\n\t\tassertFalse(\"does not match\",jp2.matches());\n\t}\n\n\tpublic void testAtArgsWithBinding() {\n\t\tPointcutParameter p1 = parser.createPointcutParameter(\"a\",MyAnnotation.class);\n\t\tPointcutParameter p2 = parser.createPointcutParameter(\"b\", MyAnnotation.class);\n\t\tPointcutExpression atArgs = parser.parsePointcutExpression(\"@args(..,a)\",A.class,new PointcutParameter[] {p1});\n\t\tShadowMatch sMatch2 = atArgs.matchesMethodExecution(c);\n\t\tassertTrue(\"maybe matches C\",sMatch2.maybeMatches());\n\t\tJoinPointMatch jp2 = sMatch2.matchesJoinPoint(new B(), new B(), new Object[]{new A(),new B()});\n\t\tassertTrue(\"matches\",jp2.matches());\n\t\tassertEquals(1,jp2.getParameterBindings().length);\n\t\tMyAnnotation bAnnotation = B.class.getAnnotation(MyAnnotation.class);\n\t\tassertEquals(\"annotation on B\",bAnnotation,jp2.getParameterBindings()[0].getBinding());\n\n\t\tatArgs = parser.parsePointcutExpression(\"@args(a,b)\",A.class,new PointcutParameter[] {p1,p2});\n\t\tsMatch2 = atArgs.matchesMethodExecution(c);\n\t\tassertTrue(\"maybe matches C\",sMatch2.maybeMatches());\n\t\tjp2 = sMatch2.matchesJoinPoint(new B(), new B(), new Object[] {new B(),new B()});\n\t\tassertTrue(\"matches\",jp2.matches());\n\t\tassertEquals(2,jp2.getParameterBindings().length);\n\t\tassertEquals(\"annotation on B\",bAnnotation,jp2.getParameterBindings()[0].getBinding());\n\t\tassertEquals(\"annotation on B\",bAnnotation,jp2.getParameterBindings()[1].getBinding());\n\t}\n\n\tpublic void testAtWithin() {\n\t\tPointcutExpression atWithin = parser.parsePointcutExpression(\"@within(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\n\t\tShadowMatch sMatch1 = atWithin.matchesMethodExecution(a);\n\t\tShadowMatch sMatch2 = atWithin.matchesMethodExecution(b);\n\t\tassertTrue(\"does not match a\",sMatch1.neverMatches());\n\t\tassertTrue(\"matches b\",sMatch2.alwaysMatches());\n\t}\n\n\tpublic void testAtWithinWithBinding() {\n\t\tPointcutParameter p1 = parser.createPointcutParameter(\"x\",MyAnnotation.class);\n\t\tPointcutExpression atWithin = parser.parsePointcutExpression(\"@within(x)\",B.class,new PointcutParameter[] {p1});\n\t\tShadowMatch sMatch1 = atWithin.matchesMethodExecution(a);\n\t\tShadowMatch sMatch2 = atWithin.matchesMethodExecution(b);\n\t\tassertTrue(\"does not match a\",sMatch1.neverMatches());\n\t\tassertTrue(\"matches b\",sMatch2.alwaysMatches());\n\t\tJoinPointMatch jpm = sMatch2.matchesJoinPoint(new B(), new B(), new Object[0]);\n\t\tassertTrue(jpm.matches());\n\t\tassertEquals(1,jpm.getParameterBindings().length);\n\t\tMyAnnotation bAnnotation = B.class.getAnnotation(MyAnnotation.class);\n\t\tassertEquals(\"annotation on B\",bAnnotation,jpm.getParameterBindings()[0].getBinding());\n\t}\n\n\tpublic void testAtWithinCode() {\n\t\tPointcutExpression atWithinCode = parser.parsePointcutExpression(\"@withincode(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\n\t\tShadowMatch sMatch1 = atWithinCode.matchesMethodCall(a,b);\n\t\tShadowMatch sMatch2 = atWithinCode.matchesMethodCall(a,a);\n\t\tassertTrue(\"does not match from b\",sMatch1.neverMatches());\n\t\tassertTrue(\"matches from a\",sMatch2.alwaysMatches());\n\t}\n\n\tpublic void testAtWithinCodeWithBinding() {\n\t\tPointcutParameter p1 = parser.createPointcutParameter(\"x\",MyAnnotation.class);\n\t\tPointcutExpression atWithinCode = parser.parsePointcutExpression(\"@withincode(x)\",A.class,new PointcutParameter[] {p1});\n\t\tShadowMatch sMatch2 = atWithinCode.matchesMethodCall(a,a);\n\t\tassertTrue(\"matches from a\",sMatch2.alwaysMatches());\n\t\tJoinPointMatch jpm = sMatch2.matchesJoinPoint(new A(), new A(), new Object[0]);\n\t\tassertEquals(1,jpm.getParameterBindings().length);\n\t\tMyAnnotation annOna = a.getAnnotation(MyAnnotation.class);\n\t\tassertEquals(\"MyAnnotation on a\",annOna,jpm.getParameterBindings()[0].getBinding());\n\t}\n\n\tpublic void testAtAnnotation() {\n\t\tPointcutExpression atAnnotation = parser.parsePointcutExpression(\"@annotation(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\n\t\tShadowMatch sMatch1 = atAnnotation.matchesMethodCall(b,a);\n\t\tShadowMatch sMatch2 = atAnnotation.matchesMethodCall(a,a);\n\t\tassertTrue(\"does not match call to b\",sMatch1.neverMatches());\n\t\tassertTrue(\"matches call to a\",sMatch2.alwaysMatches());\n\t}\n\n\tpublic void testAtAnnotationWithBinding() {\n\t\tPointcutParameter p1 = parser.createPointcutParameter(\"x\",MyAnnotation.class);\n\t\tPointcutExpression atAnnotation = parser.parsePointcutExpression(\"@annotation(x)\",A.class,new PointcutParameter[] {p1});\n\t\tShadowMatch sMatch2 = atAnnotation.matchesMethodCall(a,a);\n\t\tassertTrue(\"matches call to a\",sMatch2.alwaysMatches());\n\t\tJoinPointMatch jpm = sMatch2.matchesJoinPoint(new A(), new A(), new Object[0]);\n\t\tassertTrue(jpm.matches());\n\t\tassertEquals(1,jpm.getParameterBindings().length);\n\t\tMyAnnotation annOna = a.getAnnotation(MyAnnotation.class);\n\t\tassertEquals(\"MyAnnotation on a\",annOna,jpm.getParameterBindings()[0].getBinding());\n\t}\n\n\tpublic void testReferencePointcutNoParams() {\n\t\tPointcutExpression pc = parser.parsePointcutExpression(\"foo()\",C.class,new PointcutParameter[0]);\n\t\tShadowMatch sMatch1 = pc.matchesMethodCall(a,b);\n\t\tShadowMatch sMatch2 = pc.matchesMethodExecution(a);\n\t\tassertTrue(\"no match on call\",sMatch1.neverMatches());\n\t\tassertTrue(\"match on execution\",sMatch2.alwaysMatches());\n\n\t\tpc = parser.parsePointcutExpression(\"org.aspectj.weaver.tools.Java15PointcutExpressionTest.C.foo()\");\n\t\tsMatch1 = pc.matchesMethodCall(a,b);\n\t\tsMatch2 = pc.matchesMethodExecution(a);\n\t\tassertTrue(\"no match on call\",sMatch1.neverMatches());\n\t\tassertTrue(\"match on execution\",sMatch2.alwaysMatches());\n\t}\n\n\tpublic void testReferencePointcutParams() {\n\t\tPointcutParameter p1 = parser.createPointcutParameter(\"x\",A.class);\n\t\tPointcutExpression pc = parser.parsePointcutExpression(\"goo(x)\",C.class,new PointcutParameter[] {p1});\n\n\t\tShadowMatch sMatch1 = pc.matchesMethodCall(a,b);\n\t\tShadowMatch sMatch2 = pc.matchesMethodExecution(a);\n\t\tassertTrue(\"no match on call\",sMatch1.neverMatches());\n\t\tassertTrue(\"match on execution\",sMatch2.maybeMatches());\n\t\tA anA = new A();\n\t\tJoinPointMatch jpm = sMatch2.matchesJoinPoint(anA, new A(), new Object[0]);\n\t\tassertTrue(jpm.matches());\n\t\tassertEquals(\"should be bound to anA\",anA,jpm.getParameterBindings()[0].getBinding());\n\n\t}\n\n\tpublic void testExecutionWithClassFileRetentionAnnotation() {\n\t\tPointcutExpression pc1 = parser.parsePointcutExpression(\"execution(@org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation * *(..))\");\n\t\tPointcutExpression pc2 = parser.parsePointcutExpression(\"execution(@org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyClassFileRetentionAnnotation * *(..))\");\n\t\tShadowMatch sMatch = pc1.matchesMethodExecution(a);\n\t\tassertTrue(\"matches\",sMatch.alwaysMatches());\n\t\tsMatch = pc2.matchesMethodExecution(a);\n\t\tassertTrue(\"no match\",sMatch.neverMatches());\n\t\tsMatch = pc1.matchesMethodExecution(b);\n\t\tassertTrue(\"no match\",sMatch.neverMatches());\n\t\tsMatch = pc2.matchesMethodExecution(b);\n\t\tassertTrue(\"matches\",sMatch.alwaysMatches());\n\t}\n\n\tpublic void testGenericMethodSignatures() throws Exception{\n\t\tPointcutExpression ex = parser.parsePointcutExpression(\"execution(* set*(java.util.List<org.aspectj.weaver.tools.Java15PointcutExpressionTest.C>))\");\n\t\tMethod m = TestBean.class.getMethod(\"setFriends\",List.class);\n\t\tShadowMatch sm = ex.matchesMethodExecution(m);\n\t\tassertTrue(\"should match\",sm.alwaysMatches());\n\t}\n\n\tpublic void testAnnotationInExecution() throws Exception {\n\t\tparser.parsePointcutExpression(\"execution(@(org.springframework..*) * *(..))\");\n\t}\n\n\tpublic void testVarArgsMatching() throws Exception {\n\t\tPointcutExpression ex = parser.parsePointcutExpression(\"execution(* *(String...))\");\n\t\tMethod usesVarArgs = D.class.getMethod(\"varArgs\",String[].class);\n\t\tMethod noVarArgs = D.class.getMethod(\"nonVarArgs\", String[].class);\n\t\tShadowMatch sm1 = ex.matchesMethodExecution(usesVarArgs);\n\t\tassertTrue(\"should match\",sm1.alwaysMatches());\n\t\tShadowMatch sm2 = ex.matchesMethodExecution(noVarArgs);\n\t\tassertFalse(\"should not match\",sm2.alwaysMatches());\n\t}\n\n\tpublic void testJavaLangMatching() throws Exception {\n\t\tPointcutExpression ex = parser.parsePointcutExpression(\"@within(java.lang.Deprecated)\");\n\t\tMethod foo = GoldenOldie.class.getMethod(\"foo\");\n\t\tShadowMatch sm1 = ex.matchesMethodExecution(foo);\n\t\tassertTrue(\"should match\",sm1.alwaysMatches());\n\t}\n\n\tpublic void testReferencePCsInSameType() throws Exception {\n\t\tPointcutExpression ex = parser.parsePointcutExpression(\"org.aspectj.weaver.tools.Java15PointcutExpressionTest.NamedPointcutResolution.c()\",NamedPointcutResolution.class,new PointcutParameter[0]);\n\t\tShadowMatch sm = ex.matchesMethodExecution(a);\n\t\tassertTrue(\"should match\",sm.alwaysMatches());\n\t\tsm = ex.matchesMethodExecution(b);\n\t\tassertTrue(\"does not match\",sm.neverMatches());\n\t}\n\n\tpublic void testReferencePCsInOtherType() throws Exception {\n\t\tPointcutExpression ex = parser.parsePointcutExpression(\"org.aspectj.weaver.tools.Java15PointcutExpressionTest.ExternalReferrer.d()\",ExternalReferrer.class,new PointcutParameter[0]);\n\t\tShadowMatch sm = ex.matchesMethodExecution(a);\n\t\tassertTrue(\"should match\",sm.alwaysMatches());\n\t\tsm = ex.matchesMethodExecution(b);\n\t\tassertTrue(\"does not match\",sm.neverMatches());\n\t}\n\n\tpublic void testArrayTypeInArgs() throws Exception {\n\t\tPointcutParameter[] params = new PointcutParameter[3];\n\t\tparams[0] = parser.createPointcutParameter(\"d\", Date.class);\n\t\tparams[1] = parser.createPointcutParameter(\"s\", String.class);\n\t\tparams[2] = parser.createPointcutParameter(\"ss\", String[].class);\n\t\tparser.parsePointcutExpression(\"org.aspectj.weaver.tools.Java15PointcutExpressionTest.UsesArrays.pc(d,s,ss)\",UsesArrays.class,params);\n\t}\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tparser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());\n\t\ta = A.class.getMethod(\"a\");\n\t\tb = B.class.getMethod(\"b\");\n\t\tc = B.class.getMethod(\"c\",new Class[] {A.class,B.class});\n\t\td = B.class.getMethod(\"d\",new Class[] {A.class,A.class});\n\t}\n\n\t@Retention(RetentionPolicy.RUNTIME)\n\tprivate @interface MyAnnotation {}\n\n\tprivate @interface MyClassFileRetentionAnnotation {}\n\n\tprivate static class A {\n\t\t@MyAnnotation public void a() {}\n\t}\n\n\t@MyAnnotation\n\tprivate static class B {\n\t\t@MyClassFileRetentionAnnotation public void b() {}\n\t\tpublic void c(A anA, B aB) {}\n\n\t\tpublic void d(A anA, A anotherA) {}\n\t}\n\n\tprivate static class C {\n\n\t\t@Pointcut(\"execution(* *(..))\")\n\t\tpublic void foo() {}\n\n\t\t@Pointcut(value=\"execution(* *(..)) && this(x)\", argNames=\"x\")\n\t\tpublic void goo(A x) {}\n\t}\n\n\tprivate static class D {\n\n\t\tpublic void nonVarArgs(String[] strings) {};\n\n\t\tpublic void varArgs(String... strings) {};\n\n\t}\n\n\tstatic class TestBean {\n\t\tpublic void setFriends(List<C> friends) {}\n\t}\n\n\t@Deprecated\n\tstatic class GoldenOldie {\n\t\tpublic void foo() {}\n\t}\n\n\tprivate static class NamedPointcutResolution {\n\n\t\t@Pointcut(\"execution(* *(..))\")\n\t\tpublic void a() {}\n\n\t\t@Pointcut(\"this(org.aspectj.weaver.tools.Java15PointcutExpressionTest.A)\")\n\t\tpublic void b() {}\n\n\t\t@Pointcut(\"a() && b()\")\n\t\tpublic void c() {}\n\t}\n\n\tprivate static class ExternalReferrer {\n\n\t  @Pointcut(\"org.aspectj.weaver.tools.Java15PointcutExpressionTest.NamedPointcutResolution.a() && \" +\n\t\t\t    \"org.aspectj.weaver.tools.Java15PointcutExpressionTest.NamedPointcutResolution.b())\")\n\t  public void d() {}\n\n\t}\n\n\tprivate static class UsesArrays {\n\n\t\t@Pointcut(\"execution(* *(..)) && args(d,s,ss)\")\n\t\tpublic void pc(Date d, String s, String[] ss) {}\n\n\t}\n}\n\n\n",
    "size": 36197
  },
  {
    "file_id": "F170",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/PointcutDesignatorHandlerTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage org.aspectj.weaver.tools;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Adrian Colyer\n *\n */\npublic class PointcutDesignatorHandlerTest extends TestCase {\n\n\tboolean needToSkip = false;\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tneedToSkip = needToSkipPointcutParserTests();\n\t}\n\n\t/** this condition can occur on the build machine only, and is way too complex to fix right now... */\n\tprivate boolean needToSkipPointcutParserTests() {\n\t\ttry {\n\t\t\tClass.forName(\"org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate\",false,this.getClass().getClassLoader());//ReflectionBasedReferenceTypeDelegate.class.getClassLoader());\n\t\t} catch (ClassNotFoundException cnfEx) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void testParseWithoutHandler() {\n\t\tif (needToSkip) return;\n\t\ttry {\n\t\t\tPointcutParser\n\t\t\t  .getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution()\n\t\t\t  .parsePointcutExpression(\"bean(service.*\");\n\t\t\tfail(\"should not be able to parse bean(service.*)\");\n\t\t} catch(IllegalArgumentException ex) {\n\t\t\tassertTrue(\"contains bean\", ex.getMessage().contains(\"bean\"));\n\t\t}\n\t}\n\n\tpublic void testParseWithHandler() {\n\t\tif (needToSkip) return;\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\n\t\tBeanDesignatorHandler beanHandler = new BeanDesignatorHandler();\n\t\tparser.registerPointcutDesignatorHandler(beanHandler);\n\t\tparser.parsePointcutExpression(\"bean(service.*)\");\n\t\tassertEquals(\"service.*\",beanHandler.getExpressionLastAskedToParse());\n\t}\n\n\n\t/*\n     * Bug 205907 - the registered pointcut designator does not also get registered with the\n     * InternalUseOnlyPointcutParser inside the Java15ReflectionBasedReferenceTypeDelegate code. First test checks\n     * parsing is OK\n     */\n    public void testParsingBeanInReferencePointcut01() throws Exception {\n        if (needToSkip) return;\n        PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\n        BeanDesignatorHandler beanHandler = new BeanDesignatorHandler();\n        parser.registerPointcutDesignatorHandler(beanHandler);\n        // The pointcut in CounterAspect look as follows:\n        //\n        // @Pointcut(\"execution(* setAge(..)) && bean(testBean1)\")\n        // public void testBean1SetAge() { }\n\n        // This should be found and resolved\n//        PointcutExpression pc =\n        \tparser.parsePointcutExpression(\"CounterAspect.testBean1SetAge()\");\n\n    }\n\n    /*\n     * Bug 205907 - the registered pointcut designator does not also get registered with the\n     * InternalUseOnlyPointcutParser inside the Java15ReflectionBasedReferenceTypeDelegate code. This test checks the\n     * actual matching.\n     */\n    public void testParsingBeanInReferencePointcut02() throws Exception {\n        if (needToSkip) return;\n        PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\n        BeanDesignatorHandler beanHandler = new BeanDesignatorHandler();\n        parser.registerPointcutDesignatorHandler(beanHandler);\n        // The pointcut in CounterAspect look as follows:\n        //\n        // @Pointcut(\"execution(* toString(..)) && bean(testBean1)\")\n        // public void testBean1toString() { }\n\n        // This should be found and resolved\n        PointcutExpression pc = parser.parsePointcutExpression(\"CounterAspect.testBean1toString()\");\n\n        DefaultMatchingContext context = new DefaultMatchingContext();\n        context.addContextBinding(\"beanName\", \"testBean1\");\n        pc.setMatchingContext(context);\n        ShadowMatch sm = pc.matchesMethodExecution(Object.class.getMethod(\"toString\", new Class[0]));\n        assertTrue(sm.alwaysMatches());\n\n        sm = pc.matchesMethodExecution(Object.class.getMethod(\"hashCode\", new Class[0]));\n        assertTrue(sm.neverMatches());\n\n        context = new DefaultMatchingContext();\n        context.addContextBinding(\"beanName\", \"testBean2\");\n        pc.setMatchingContext(context);\n        sm = pc.matchesMethodExecution(Object.class.getMethod(\"toString\", new Class[0]));\n        assertTrue(sm.neverMatches());\n    }\n\n    public void testParseWithHandlerAndMultipleSegments() {\n        if (needToSkip) return;\n        PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\n\t\tBeanDesignatorHandler beanHandler = new BeanDesignatorHandler();\n\t\tparser.registerPointcutDesignatorHandler(beanHandler);\n\t\tparser.parsePointcutExpression(\"bean(org.xyz.someapp..*)\");\n\t\tassertEquals(\"org.xyz.someapp..*\",beanHandler.getExpressionLastAskedToParse());\n\t}\n\n\tpublic void testStaticMatch() throws Exception {\n\t\tif (needToSkip) return;\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\n\t\tBeanDesignatorHandler beanHandler = new BeanDesignatorHandler();\n\t\tparser.registerPointcutDesignatorHandler(beanHandler);\n\t\tPointcutExpression pc = parser.parsePointcutExpression(\"bean(myBean)\");\n\t\tDefaultMatchingContext context = new DefaultMatchingContext();\n\t\tcontext.addContextBinding(\"beanName\",\"myBean\");\n\t\tpc.setMatchingContext(context);\n\t\tShadowMatch sm = pc.matchesMethodExecution(Object.class.getMethod(\"toString\",new Class[0]));\n\t\tassertTrue(sm.alwaysMatches());\n\t\tcontext.addContextBinding(\"beanName\", \"notMyBean\");\n\t\tsm = pc.matchesMethodExecution(Object.class.getMethod(\"toString\",new Class[0]));\n\t\tassertTrue(sm.neverMatches());\n\t}\n\n\tpublic void testDynamicMatch() throws Exception {\n\t\tif (needToSkip) return;\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\n\t\tBeanDesignatorHandler beanHandler = new BeanDesignatorHandler();\n\t\tbeanHandler.simulateDynamicTest = true;\n\t\tparser.registerPointcutDesignatorHandler(beanHandler);\n\t\tPointcutExpression pc = parser.parsePointcutExpression(\"bean(myBean)\");\n\t\tShadowMatch sm = pc.matchesMethodExecution(Object.class.getMethod(\"toString\",new Class[0]));\n\t\tDefaultMatchingContext context = new DefaultMatchingContext();\n\t\tassertTrue(sm.maybeMatches());\n\t\tassertFalse(sm.alwaysMatches());\n\t\tassertFalse(sm.neverMatches());\n\t\tcontext.addContextBinding(\"beanName\",\"myBean\");\n\t\tsm.setMatchingContext(context);\n\t\tassertTrue(sm.matchesJoinPoint(null, null, null).matches());\n\t\tcontext.addContextBinding(\"beanName\", \"notMyBean\");\n\t\tassertFalse(sm.matchesJoinPoint(null, null, null).matches());\n\t}\n\n\tpublic void testFastMatch() {\n\t\tif (needToSkip) return;\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\n\t\tBeanDesignatorHandler beanHandler = new BeanDesignatorHandler();\n\t\tparser.registerPointcutDesignatorHandler(beanHandler);\n\t\tPointcutExpression pc = parser.parsePointcutExpression(\"bean(myBean)\");\n\t\tDefaultMatchingContext context = new DefaultMatchingContext();\n\t\tcontext.addContextBinding(\"beanName\",\"myBean\");\n\t\tpc.setMatchingContext(context);\n\t\tassertTrue(pc.couldMatchJoinPointsInType(String.class));\n\t\tcontext.addContextBinding(\"beanName\",\"yourBean\");\n\t\tassertFalse(pc.couldMatchJoinPointsInType(String.class));\n\t}\n\n\tprivate class BeanDesignatorHandler implements PointcutDesignatorHandler {\n\n\t\tprivate String askedToParse;\n\t\tpublic boolean simulateDynamicTest = false;\n\n\t\tpublic String getDesignatorName() {\n\t\t\treturn \"bean\";\n\t\t}\n\n\t\t/* (non-Javadoc)\n\t\t * @see org.aspectj.weaver.tools.PointcutDesignatorHandler#parse(java.lang.String)\n\t\t */\n\t\tpublic ContextBasedMatcher parse(String expression) {\n\t\t\tthis.askedToParse = expression;\n\t\t\treturn new BeanPointcutExpression(expression,this.simulateDynamicTest);\n\t\t}\n\n\t\tpublic String getExpressionLastAskedToParse() {\n\t\t\treturn this.askedToParse;\n\t\t}\n\t}\n\n\tprivate class BeanPointcutExpression implements ContextBasedMatcher {\n\n\t\tprivate final String beanNamePattern;\n\t\tprivate final boolean simulateDynamicTest;\n\n\t\tpublic BeanPointcutExpression(String beanNamePattern, boolean simulateDynamicTest) {\n\t\t\tthis.beanNamePattern = beanNamePattern;\n\t\t\tthis.simulateDynamicTest = simulateDynamicTest;\n\t\t}\n\n\n\t\tpublic boolean couldMatchJoinPointsInType(Class aClass) {\n\t\t\treturn true;\n\t\t}\n\n\t\t/* (non-Javadoc)\n\t\t * @see org.aspectj.weaver.tools.ContextBasedMatcher#couldMatchJoinPointsInType(java.lang.Class)\n\t\t */\n\t\tpublic boolean couldMatchJoinPointsInType(Class aClass, MatchingContext context) {\n\t\t\tif (this.beanNamePattern.equals(context.getBinding(\"beanName\"))) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\n\t\t/* (non-Javadoc)\n\t\t * @see org.aspectj.weaver.tools.ContextBasedMatcher#mayNeedDynamicTest()\n\t\t */\n\t\tpublic boolean mayNeedDynamicTest() {\n\t\t\treturn this.simulateDynamicTest;\n\t\t}\n\n\n\t\tpublic FuzzyBoolean matchesStatically(MatchingContext matchContext) {\n\t\t\tif (this.simulateDynamicTest) return FuzzyBoolean.MAYBE;\n\t\t\tif (this.beanNamePattern.equals(matchContext.getBinding(\"beanName\"))) {\n\t\t\t\treturn FuzzyBoolean.YES;\n\t\t\t} else {\n\t\t\t\treturn FuzzyBoolean.NO;\n\t\t\t}\n\t\t}\n\n\n\t\t/* (non-Javadoc)\n\t\t * @see org.aspectj.weaver.tools.ContextBasedMatcher#matchesDynamically(org.aspectj.weaver.tools.MatchingContext)\n\t\t */\n\t\tpublic boolean matchesDynamically(MatchingContext matchContext) {\n\t\t\treturn this.beanNamePattern.equals(matchContext.getBinding(\"beanName\"));\n\t\t}\n\t}\n}\n",
    "size": 9870
  },
  {
    "file_id": "F171",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/PointcutExpressionTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2004 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.aspectj.weaver.tools;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\nimport junit.framework.TestCase;\n\npublic class PointcutExpressionTest extends TestCase {\n\n\tPointcutParser p;\n\tConstructor asCons;\n\tConstructor bsCons;\n\tConstructor bsStringCons;\n\tConstructor clientCons;\n\tMethod a;\n\tMethod aa;\n\tMethod aaa;\n\tField x;\n\tField y;\n\tMethod b;\n\tMethod bsaa;\n\tField n;\n\tMethod foo;\n\tMethod bar;\n\n\tpublic void testMatchesMethodCall() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"call(* *..A.a*(..))\");\n\t\tassertTrue(\"Should match call to A.a()\", ex.matchesMethodCall(a, a).alwaysMatches());\n\t\tassertTrue(\"Should match call to A.aaa()\", ex.matchesMethodCall(aaa, a).alwaysMatches());\n\t\tassertTrue(\"Should match call to B.aa()\", ex.matchesMethodCall(bsaa, a).alwaysMatches());\n\t\tassertTrue(\"Should not match call to B.b()\", ex.matchesMethodCall(b, a).neverMatches());\n\t\tex = p.parsePointcutExpression(\"call(* *..A.a*(int))\");\n\t\tassertTrue(\"Should match call to A.aa()\", ex.matchesMethodCall(aa, a).alwaysMatches());\n\t\tassertTrue(\"Should not match call to A.a()\", ex.matchesMethodCall(a, a).neverMatches());\n\t\tex = p.parsePointcutExpression(\"call(void aaa(..)) && this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"Should match call to A.aaa() from Client\", ex.matchesMethodCall(aaa, foo).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"call(void aaa(..)) && this(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Should match call to A.aaa() from B\", ex.matchesMethodCall(aaa, b).alwaysMatches());\n\t\tassertTrue(\"May match call to A.aaa() from A\", ex.matchesMethodCall(aaa, a).maybeMatches());\n\t\tassertFalse(\"May match call to A.aaa() from A\", ex.matchesMethodCall(aaa, a).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"execution(* *.*(..))\");\n\t\tassertTrue(\"Should not match call to A.aa\", ex.matchesMethodCall(aa, a).neverMatches());\n\t\t// this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"Should match Client\", ex.matchesMethodCall(a, foo).alwaysMatches());\n\t\tassertTrue(\"Should not match A\", ex.matchesMethodCall(a, a).neverMatches());\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Should maybe match B\", ex.matchesMethodCall(bsaa, a).maybeMatches());\n\t\tassertFalse(\"Should maybe match B\", ex.matchesMethodCall(bsaa, a).alwaysMatches());\n\t\t// target\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"Should not match Client\", ex.matchesMethodCall(a, a).neverMatches());\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"Should match A\", ex.matchesMethodCall(a, a).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Should maybe match A\", ex.matchesMethodCall(aa, a).maybeMatches());\n\t\tassertFalse(\"Should maybe match A\", ex.matchesMethodCall(aa, a).alwaysMatches());\n\t\t// test args\n\t\tex = p.parsePointcutExpression(\"args(..,int)\");\n\t\tassertTrue(\"Should match A.aa\", ex.matchesMethodCall(aa, a).alwaysMatches());\n\t\tassertTrue(\"Should match A.aaa\", ex.matchesMethodCall(aaa, a).alwaysMatches());\n\t\tassertTrue(\"Should not match A.a\", ex.matchesMethodCall(a, a).neverMatches());\n\t\t// within\n\t\tex = p.parsePointcutExpression(\"within(*..A)\");\n\t\tassertTrue(\"Matches in class A\", ex.matchesMethodCall(a, a).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesMethodCall(a, b).neverMatches());\n\t\tassertTrue(\"Matches in class A\", ex.matchesMethodCall(a, A.class).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesMethodCall(a, B.class).neverMatches());\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Should match\", ex.matchesMethodCall(b, bsaa).alwaysMatches());\n\t\tassertTrue(\"Should not match\", ex.matchesMethodCall(b, b).neverMatches());\n\t}\n\n\tpublic void testMatchesMethodExecution() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"execution(* *..A.aa(..))\");\n\t\tassertTrue(\"Should match execution of A.aa\", ex.matchesMethodExecution(aa).alwaysMatches());\n\t\tassertTrue(\"Should match execution of B.aa\", ex.matchesMethodExecution(bsaa).alwaysMatches());\n\t\tassertTrue(\"Should not match execution of A.a\", ex.matchesMethodExecution(a).neverMatches());\n\t\tex = p.parsePointcutExpression(\"call(* *..A.a*(int))\");\n\t\tassertTrue(\"Should not match execution of A.a\", ex.matchesMethodExecution(a).neverMatches());\n\n\t\t// test this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"Should match A\", ex.matchesMethodExecution(a).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Maybe matches B\", ex.matchesMethodExecution(a).maybeMatches());\n\t\tassertFalse(\"Maybe matches B\", ex.matchesMethodExecution(a).alwaysMatches());\n\n\t\t// test target\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"Should match A\", ex.matchesMethodExecution(a).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Maybe matches B\", ex.matchesMethodExecution(a).maybeMatches());\n\t\tassertFalse(\"Maybe matches B\", ex.matchesMethodExecution(a).alwaysMatches());\n\n\t\t// test args\n\t\tex = p.parsePointcutExpression(\"args(..,int)\");\n\t\tassertTrue(\"Should match A.aa\", ex.matchesMethodExecution(aa).alwaysMatches());\n\t\tassertTrue(\"Should match A.aaa\", ex.matchesMethodExecution(aaa).alwaysMatches());\n\t\tassertTrue(\"Should not match A.a\", ex.matchesMethodExecution(a).neverMatches());\n\n\t\t// within\n\t\tex = p.parsePointcutExpression(\"within(*..A)\");\n\t\tassertTrue(\"Matches in class A\", ex.matchesMethodExecution(a).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesMethodExecution(bsaa).neverMatches());\n\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Should not match\", ex.matchesMethodExecution(a).neverMatches());\n\t}\n\n\tpublic void testMatchesConstructorCall() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"call(new(String))\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesConstructorCall(asCons, b).alwaysMatches());\n\t\tassertTrue(\"Should match B(String)\", ex.matchesConstructorCall(bsStringCons, b).alwaysMatches());\n\t\tassertTrue(\"Should not match B()\", ex.matchesConstructorCall(bsCons, foo).neverMatches());\n\t\tex = p.parsePointcutExpression(\"call(*..A.new(String))\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesConstructorCall(asCons, b).alwaysMatches());\n\t\tassertTrue(\"Should not match B(String)\", ex.matchesConstructorCall(bsStringCons, foo).neverMatches());\n\t\t// this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"Should match Client\", ex.matchesConstructorCall(asCons, foo).alwaysMatches());\n\t\tassertTrue(\"Should not match A\", ex.matchesConstructorCall(asCons, a).neverMatches());\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Should maybe match B\", ex.matchesConstructorCall(asCons, a).maybeMatches());\n\t\tassertFalse(\"Should maybe match B\", ex.matchesConstructorCall(asCons, a).alwaysMatches());\n\t\t// target\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"Should not match Client\", ex.matchesConstructorCall(asCons, foo).neverMatches());\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"Should not match A (no target)\", ex.matchesConstructorCall(asCons, a).neverMatches());\n\t\t// args\n\t\tex = p.parsePointcutExpression(\"args(String)\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesConstructorCall(asCons, b).alwaysMatches());\n\t\tassertTrue(\"Should match B(String)\", ex.matchesConstructorCall(bsStringCons, foo).alwaysMatches());\n\t\tassertTrue(\"Should not match B()\", ex.matchesConstructorCall(bsCons, foo).neverMatches());\n\t\t// within\n\t\tex = p.parsePointcutExpression(\"within(*..A)\");\n\t\tassertTrue(\"Matches in class A\", ex.matchesConstructorCall(asCons, a).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesConstructorCall(asCons, b).neverMatches());\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Should match\", ex.matchesConstructorCall(bsCons, aa).alwaysMatches());\n\t\tassertTrue(\"Should not match\", ex.matchesConstructorCall(bsCons, b).neverMatches());\n\t}\n\n\tpublic void testMatchesConstructorExecution() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"execution(new(String))\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesConstructorExecution(asCons).alwaysMatches());\n\t\tassertTrue(\"Should match B(String)\", ex.matchesConstructorExecution(bsStringCons).alwaysMatches());\n\t\tassertTrue(\"Should not match B()\", ex.matchesConstructorExecution(bsCons).neverMatches());\n\t\tex = p.parsePointcutExpression(\"execution(*..A.new(String))\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesConstructorExecution(asCons).alwaysMatches());\n\t\tassertTrue(\"Should not match B(String)\", ex.matchesConstructorExecution(bsStringCons).neverMatches());\n\n\t\t// test this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"Should match A\", ex.matchesConstructorExecution(asCons).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Maybe matches B\", ex.matchesConstructorExecution(asCons).maybeMatches());\n\t\tassertFalse(\"Maybe matches B\", ex.matchesConstructorExecution(asCons).alwaysMatches());\n\t\tassertTrue(\"Should match B\", ex.matchesConstructorExecution(bsCons).alwaysMatches());\n\t\tassertTrue(\"Does not match client\", ex.matchesConstructorExecution(clientCons).neverMatches());\n\n\t\t// test target\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"Should match A\", ex.matchesConstructorExecution(asCons).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Maybe matches B\", ex.matchesConstructorExecution(asCons).maybeMatches());\n\t\tassertFalse(\"Maybe matches B\", ex.matchesConstructorExecution(asCons).alwaysMatches());\n\t\tassertTrue(\"Should match B\", ex.matchesConstructorExecution(bsCons).alwaysMatches());\n\t\tassertTrue(\"Does not match client\", ex.matchesConstructorExecution(clientCons).neverMatches());\n\n\t\t// within\n\t\tex = p.parsePointcutExpression(\"within(*..A)\");\n\t\tassertTrue(\"Matches in class A\", ex.matchesConstructorExecution(asCons).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesConstructorExecution(bsCons).neverMatches());\n\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Does not match\", ex.matchesConstructorExecution(bsCons).neverMatches());\n\n\t\t// args\n\t\tex = p.parsePointcutExpression(\"args(String)\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesConstructorExecution(asCons).alwaysMatches());\n\t\tassertTrue(\"Should match B(String)\", ex.matchesConstructorExecution(bsStringCons).alwaysMatches());\n\t\tassertTrue(\"Should not match B()\", ex.matchesConstructorExecution(bsCons).neverMatches());\n\t}\n\n\tpublic void testMatchesAdviceExecution() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"adviceexecution()\");\n\t\tassertTrue(\"Should match (advice) A.a\", ex.matchesAdviceExecution(a).alwaysMatches());\n\t\t// test this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"Should match Client\", ex.matchesAdviceExecution(foo).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Maybe matches B\", ex.matchesAdviceExecution(a).maybeMatches());\n\t\tassertFalse(\"Maybe matches B\", ex.matchesAdviceExecution(a).alwaysMatches());\n\t\tassertTrue(\"Does not match client\", ex.matchesAdviceExecution(foo).neverMatches());\n\n\t\t// test target\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"Should match Client\", ex.matchesAdviceExecution(foo).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Maybe matches B\", ex.matchesAdviceExecution(a).maybeMatches());\n\t\tassertFalse(\"Maybe matches B\", ex.matchesAdviceExecution(a).alwaysMatches());\n\t\tassertTrue(\"Does not match client\", ex.matchesAdviceExecution(foo).neverMatches());\n\n\t\t// test within\n\t\tex = p.parsePointcutExpression(\"within(*..A)\");\n\t\tassertTrue(\"Matches in class A\", ex.matchesAdviceExecution(a).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesAdviceExecution(b).neverMatches());\n\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Does not match\", ex.matchesAdviceExecution(a).neverMatches());\n\n\t\t// test args\n\t\tex = p.parsePointcutExpression(\"args(..,int)\");\n\t\tassertTrue(\"Should match A.aa\", ex.matchesAdviceExecution(aa).alwaysMatches());\n\t\tassertTrue(\"Should match A.aaa\", ex.matchesAdviceExecution(aaa).alwaysMatches());\n\t\tassertTrue(\"Should not match A.a\", ex.matchesAdviceExecution(a).neverMatches());\n\t}\n\n\tpublic void testMatchesHandler() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"handler(Exception)\");\n\t\tassertTrue(\"Should match catch(Exception)\", ex.matchesHandler(Exception.class, Client.class).alwaysMatches());\n\t\tassertTrue(\"Should not match catch(Throwable)\", ex.matchesHandler(Throwable.class, Client.class).neverMatches());\n\t\t// test this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"Should match Client\", ex.matchesHandler(Exception.class, foo).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Maybe matches B\", ex.matchesHandler(Exception.class, a).maybeMatches());\n\t\tassertFalse(\"Maybe matches B\", ex.matchesHandler(Exception.class, a).alwaysMatches());\n\t\tassertTrue(\"Does not match client\", ex.matchesHandler(Exception.class, foo).neverMatches());\n\t\t// target - no target for exception handlers\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"Should match Client\", ex.matchesHandler(Exception.class, foo).neverMatches());\n\t\t// args\n\t\tex = p.parsePointcutExpression(\"args(Exception)\");\n\t\tassertTrue(\"Should match Exception\", ex.matchesHandler(Exception.class, foo).alwaysMatches());\n\t\tassertTrue(\"Should match RuntimeException\", ex.matchesHandler(RuntimeException.class, foo).alwaysMatches());\n\t\tassertTrue(\"Should not match String\", ex.matchesHandler(String.class, foo).neverMatches());\n\t\tassertTrue(\"Maybe matches Throwable\", ex.matchesHandler(Throwable.class, foo).maybeMatches());\n\t\tassertFalse(\"Maybe matches Throwable\", ex.matchesHandler(Throwable.class, foo).alwaysMatches());\n\t\t// within\n\t\tex = p.parsePointcutExpression(\"within(*..Client)\");\n\t\tassertTrue(\"Matches in class Client\", ex.matchesHandler(Exception.class, foo).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesHandler(Exception.class, b).neverMatches());\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Matches within aa\", ex.matchesHandler(Exception.class, aa).alwaysMatches());\n\t\tassertTrue(\"Does not match within b\", ex.matchesHandler(Exception.class, b).neverMatches());\n\t}\n\n\tpublic void testMatchesInitialization() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"initialization(new(String))\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesInitialization(asCons).alwaysMatches());\n\t\tassertTrue(\"Should match B(String)\", ex.matchesInitialization(bsStringCons).alwaysMatches());\n\t\tassertTrue(\"Should not match B()\", ex.matchesInitialization(bsCons).neverMatches());\n\t\tex = p.parsePointcutExpression(\"initialization(*..A.new(String))\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesInitialization(asCons).alwaysMatches());\n\t\tassertTrue(\"Should not match B(String)\", ex.matchesInitialization(bsStringCons).neverMatches());\n\t\t// test this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"Should match A\", ex.matchesInitialization(asCons).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Maybe matches B\", ex.matchesInitialization(asCons).maybeMatches());\n\t\tassertFalse(\"Maybe matches B\", ex.matchesInitialization(asCons).alwaysMatches());\n\n\t\t// test target\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"Should match A\", ex.matchesInitialization(asCons).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"Maybe matches B\", ex.matchesInitialization(asCons).maybeMatches());\n\t\tassertFalse(\"Maybe matches B\", ex.matchesInitialization(asCons).alwaysMatches());\n\t\t// within\n\t\tex = p.parsePointcutExpression(\"within(*..A)\");\n\t\tassertTrue(\"Matches in class A\", ex.matchesInitialization(asCons).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesInitialization(bsCons).neverMatches());\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Does not match\", ex.matchesInitialization(bsCons).neverMatches());\n\t\t// args\n\t\tex = p.parsePointcutExpression(\"args(String)\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesInitialization(asCons).alwaysMatches());\n\t\tassertTrue(\"Should match B(String)\", ex.matchesInitialization(bsStringCons).alwaysMatches());\n\t\tassertTrue(\"Should not match B()\", ex.matchesInitialization(bsCons).neverMatches());\n\t}\n\n\tpublic void testMatchesPreInitialization() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"preinitialization(new(String))\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesPreInitialization(asCons).alwaysMatches());\n\t\tassertTrue(\"Should match B(String)\", ex.matchesPreInitialization(bsStringCons).alwaysMatches());\n\t\tassertTrue(\"Should not match B()\", ex.matchesPreInitialization(bsCons).neverMatches());\n\t\tex = p.parsePointcutExpression(\"preinitialization(*..A.new(String))\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesPreInitialization(asCons).alwaysMatches());\n\t\tassertTrue(\"Should not match B(String)\", ex.matchesPreInitialization(bsStringCons).neverMatches());\n\t\t// test this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"No match, no this at preinit\", ex.matchesPreInitialization(asCons).neverMatches());\n\n\t\t// test target\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"No match, no target at preinit\", ex.matchesPreInitialization(asCons).neverMatches());\n\n\t\t// within\n\t\tex = p.parsePointcutExpression(\"within(*..A)\");\n\t\tassertTrue(\"Matches in class A\", ex.matchesPreInitialization(asCons).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesPreInitialization(bsCons).neverMatches());\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Does not match\", ex.matchesPreInitialization(bsCons).neverMatches());\n\t\t// args\n\t\tex = p.parsePointcutExpression(\"args(String)\");\n\t\tassertTrue(\"Should match A(String)\", ex.matchesPreInitialization(asCons).alwaysMatches());\n\t\tassertTrue(\"Should match B(String)\", ex.matchesPreInitialization(bsStringCons).alwaysMatches());\n\t\tassertTrue(\"Should not match B()\", ex.matchesPreInitialization(bsCons).neverMatches());\n\t}\n\n\tpublic void testMatchesStaticInitialization() {\n\t\t// staticinit\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"staticinitialization(*..A+)\");\n\t\tassertTrue(\"Matches A\", ex.matchesStaticInitialization(A.class).alwaysMatches());\n\t\tassertTrue(\"Matches B\", ex.matchesStaticInitialization(B.class).alwaysMatches());\n\t\tassertTrue(\"Doesn't match Client\", ex.matchesStaticInitialization(Client.class).neverMatches());\n\t\t// this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"No this\", ex.matchesStaticInitialization(A.class).neverMatches());\n\t\t// target\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t\tassertTrue(\"No target\", ex.matchesStaticInitialization(A.class).neverMatches());\n\n\t\t// args\n\t\tex = p.parsePointcutExpression(\"args()\");\n\t\tassertTrue(\"No args\", ex.matchesStaticInitialization(A.class).alwaysMatches());\n\t\tex = p.parsePointcutExpression(\"args(String)\");\n\t\tassertTrue(\"No args\", ex.matchesStaticInitialization(A.class).neverMatches());\n\n\t\t// within\n\t\tex = p.parsePointcutExpression(\"within(*..A)\");\n\t\tassertTrue(\"Matches in class A\", ex.matchesStaticInitialization(A.class).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesStaticInitialization(B.class).neverMatches());\n\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Does not match\", ex.matchesStaticInitialization(A.class).neverMatches());\n\t}\n\n\tpublic void testMatchesFieldSet() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"set(* *..A+.*)\");\n\t\tassertTrue(\"matches x\", ex.matchesFieldSet(x, a).alwaysMatches());\n\t\tassertTrue(\"matches y\", ex.matchesFieldSet(y, foo).alwaysMatches());\n\t\tassertTrue(\"does not match n\", ex.matchesFieldSet(n, foo).neverMatches());\n\t\t// this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"matches Client\", ex.matchesFieldSet(x, foo).alwaysMatches());\n\t\tassertTrue(\"does not match A\", ex.matchesFieldSet(n, a).neverMatches());\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"maybe matches A\", ex.matchesFieldSet(x, a).maybeMatches());\n\t\tassertFalse(\"maybe matches A\", ex.matchesFieldSet(x, a).alwaysMatches());\n\t\t// target\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"matches B\", ex.matchesFieldSet(y, foo).alwaysMatches());\n\t\tassertTrue(\"maybe matches A\", ex.matchesFieldSet(x, foo).maybeMatches());\n\t\tassertFalse(\"maybe matches A\", ex.matchesFieldSet(x, foo).alwaysMatches());\n\t\t// args\n\t\tex = p.parsePointcutExpression(\"args(int)\");\n\t\tassertTrue(\"matches x\", ex.matchesFieldSet(x, a).alwaysMatches());\n\t\tassertTrue(\"matches y\", ex.matchesFieldSet(y, a).alwaysMatches());\n\t\tassertTrue(\"does not match n\", ex.matchesFieldSet(n, a).neverMatches());\n\t\t// within\n\t\tex = p.parsePointcutExpression(\"within(*..A)\");\n\t\tassertTrue(\"Matches in class A\", ex.matchesFieldSet(x, a).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesFieldSet(x, b).neverMatches());\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Should match\", ex.matchesFieldSet(x, aa).alwaysMatches());\n\t\tassertTrue(\"Should not match\", ex.matchesFieldSet(x, b).neverMatches());\n\t}\n\n\tpublic void testMatchesFieldGet() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"get(* *..A+.*)\");\n\t\tassertTrue(\"matches x\", ex.matchesFieldGet(x, a).alwaysMatches());\n\t\tassertTrue(\"matches y\", ex.matchesFieldGet(y, foo).alwaysMatches());\n\t\tassertTrue(\"does not match n\", ex.matchesFieldGet(n, foo).neverMatches());\n\t\t// this\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)\");\n\t\tassertTrue(\"matches Client\", ex.matchesFieldGet(x, foo).alwaysMatches());\n\t\tassertTrue(\"does not match A\", ex.matchesFieldGet(n, a).neverMatches());\n\t\tex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"maybe matches A\", ex.matchesFieldGet(x, a).maybeMatches());\n\t\tassertFalse(\"maybe matches A\", ex.matchesFieldGet(x, a).alwaysMatches());\n\t\t// target\n\t\tex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertTrue(\"matches B\", ex.matchesFieldGet(y, foo).alwaysMatches());\n\t\tassertTrue(\"maybe matches A\", ex.matchesFieldGet(x, foo).maybeMatches());\n\t\tassertFalse(\"maybe matches A\", ex.matchesFieldGet(x, foo).alwaysMatches());\n\t\t// args - no args at get join point\n\t\tex = p.parsePointcutExpression(\"args(int)\");\n\t\tassertTrue(\"matches x\", ex.matchesFieldGet(x, a).neverMatches());\n\t\t// within\n\t\tex = p.parsePointcutExpression(\"within(*..A)\");\n\t\tassertTrue(\"Matches in class A\", ex.matchesFieldGet(x, a).alwaysMatches());\n\t\tassertTrue(\"Does not match in class B\", ex.matchesFieldGet(x, b).neverMatches());\n\t\t// withincode\n\t\tex = p.parsePointcutExpression(\"withincode(* a*(..))\");\n\t\tassertTrue(\"Should match\", ex.matchesFieldGet(x, aa).alwaysMatches());\n\t\tassertTrue(\"Should not match\", ex.matchesFieldGet(x, b).neverMatches());\n\t}\n\n\tpublic void testArgsMatching() {\n\t\t// too few args\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"args(*,*,*,*)\");\n\t\tassertTrue(\"Too few args\", ex.matchesMethodExecution(foo).neverMatches());\n\t\tassertTrue(\"Matching #args\", ex.matchesMethodExecution(bar).alwaysMatches());\n\t\t// one too few + ellipsis\n\t\tex = p.parsePointcutExpression(\"args(*,*,*,..)\");\n\t\tassertTrue(\"Matches with ellipsis\", ex.matchesMethodExecution(foo).alwaysMatches());\n\t\t// exact number + ellipsis\n\t\tassertTrue(\"Matches with ellipsis\", ex.matchesMethodExecution(bar).alwaysMatches());\n\t\tassertTrue(\"Does not match with ellipsis\", ex.matchesMethodExecution(a).neverMatches());\n\t\t// too many + ellipsis\n\t\tex = p.parsePointcutExpression(\"args(*,..,*)\");\n\t\tassertTrue(\"Matches with ellipsis\", ex.matchesMethodExecution(bar).alwaysMatches());\n\t\tassertTrue(\"Does not match with ellipsis\", ex.matchesMethodExecution(a).neverMatches());\n\t\tassertTrue(\"Matches with ellipsis\", ex.matchesMethodExecution(aaa).alwaysMatches());\n\t\t// exact match\n\t\tex = p.parsePointcutExpression(\"args(String,int,Number)\");\n\t\tassertTrue(\"Matches exactly\", ex.matchesMethodExecution(foo).alwaysMatches());\n\t\t// maybe match\n\t\tex = p.parsePointcutExpression(\"args(String,int,Double)\");\n\t\tassertTrue(\"Matches maybe\", ex.matchesMethodExecution(foo).maybeMatches());\n\t\tassertFalse(\"Matches maybe\", ex.matchesMethodExecution(foo).alwaysMatches());\n\t\t// never match\n\t\tex = p.parsePointcutExpression(\"args(String,Integer,Number)\");\n\t\tassertTrue(\"matches\", ex.matchesMethodExecution(foo).alwaysMatches());\n\t}\n\n\t// public void testMatchesDynamically() {\n\t// // everything other than this,target,args should just return true\n\t// PointcutExpression ex = p.parsePointcutExpression(\"call(* *.*(..)) && execution(* *.*(..)) &&\" +\n\t// \"get(* *) && set(* *) && initialization(new(..)) && preinitialization(new(..)) &&\" +\n\t// \"staticinitialization(X) && adviceexecution() && within(Y) && withincode(* *.*(..)))\");\n\t// assertTrue(\"Matches dynamically\",ex.matchesDynamically(a,b,new Object[0]));\n\t// // this\n\t// ex = p.parsePointcutExpression(\"this(String)\");\n\t// assertTrue(\"String matches\",ex.matchesDynamically(\"\",this,new Object[0]));\n\t// assertFalse(\"Object doesn't match\",ex.matchesDynamically(new Object(),this,new Object[0]));\n\t// ex = p.parsePointcutExpression(\"this(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t// assertTrue(\"A matches\",ex.matchesDynamically(new A(\"\"),this,new Object[0]));\n\t// assertTrue(\"B matches\",ex.matchesDynamically(new B(\"\"),this,new Object[0]));\n\t// // target\n\t// ex = p.parsePointcutExpression(\"target(String)\");\n\t// assertTrue(\"String matches\",ex.matchesDynamically(this,\"\",new Object[0]));\n\t// assertFalse(\"Object doesn't match\",ex.matchesDynamically(this,new Object(),new Object[0]));\n\t// ex = p.parsePointcutExpression(\"target(org.aspectj.weaver.tools.PointcutExpressionTest.A)\");\n\t// assertTrue(\"A matches\",ex.matchesDynamically(this,new A(\"\"),new Object[0]));\n\t// assertTrue(\"B matches\",ex.matchesDynamically(this,new B(\"\"),new Object[0]));\n\t// // args\n\t// ex = p.parsePointcutExpression(\"args(*,*,*,*)\");\n\t// assertFalse(\"Too few args\",ex.matchesDynamically(null,null,new Object[]{a,b}));\n\t// assertTrue(\"Matching #args\",ex.matchesDynamically(null,null,new Object[]{a,b,aa,aaa}));\n\t// // one too few + ellipsis\n\t// ex = p.parsePointcutExpression(\"args(*,*,*,..)\");\n\t// assertTrue(\"Matches with ellipsis\",ex.matchesDynamically(null,null,new Object[]{a,b,aa,aaa}));\n\t// // exact number + ellipsis\n\t// assertTrue(\"Matches with ellipsis\",ex.matchesDynamically(null,null,new Object[]{a,b,aa}));\n\t// assertFalse(\"Does not match with ellipsis\",ex.matchesDynamically(null,null,new Object[]{a,b}));\n\t// // too many + ellipsis\n\t// ex = p.parsePointcutExpression(\"args(*,..,*)\");\n\t// assertTrue(\"Matches with ellipsis\",ex.matchesDynamically(null,null,new Object[]{a,b,aa,aaa}));\n\t// assertFalse(\"Does not match with ellipsis\",ex.matchesDynamically(null,null,new Object[]{a}));\n\t// assertTrue(\"Matches with ellipsis\",ex.matchesDynamically(null,null,new Object[]{a,b}));\n\t// // exact match\n\t// ex = p.parsePointcutExpression(\"args(String,int,Number)\");\n\t// assertTrue(\"Matches exactly\",ex.matchesDynamically(null,null,new Object[]{\"\",new Integer(5),new Double(5.0)}));\n\t// ex = p.parsePointcutExpression(\"args(String,Integer,Number)\");\n\t// assertTrue(\"Matches exactly\",ex.matchesDynamically(null,null,new Object[]{\"\",new Integer(5),new Double(5.0)}));\n\t// // never match\n\t// ex = p.parsePointcutExpression(\"args(String,Integer,Number)\");\n\t// assertFalse(\"Does not match\",ex.matchesDynamically(null,null,new Object[]{a,b,aa}));\n\t// }\n\n\tpublic void testGetPointcutExpression() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"staticinitialization(*..A+)\");\n\t\tassertEquals(\"staticinitialization(*..A+)\", ex.getPointcutExpression());\n\t}\n\n\tpublic void testCouldMatchJoinPointsInType() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"execution(* org.aspectj.weaver.tools.PointcutExpressionTest.B.*(..))\");\n\t\tassertFalse(\"Could maybe match String (as best we know at this point)\", ex.couldMatchJoinPointsInType(String.class));\n\t\tassertTrue(\"Will always match B\", ex.couldMatchJoinPointsInType(B.class));\n\t\tex = p.parsePointcutExpression(\"within(org.aspectj.weaver.tools.PointcutExpressionTest.B)\");\n\t\tassertFalse(\"Will never match String\", ex.couldMatchJoinPointsInType(String.class));\n\t\tassertTrue(\"Will always match B\", ex.couldMatchJoinPointsInType(B.class));\n\t}\n\n\tpublic void testMayNeedDynamicTest() {\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"execution(* org.aspectj.weaver.tools.PointcutExpressionTest.B.*(..))\");\n\t\tassertFalse(\"No dynamic test needed\", ex.mayNeedDynamicTest());\n\t\tex = p\n\t\t\t\t.parsePointcutExpression(\"execution(* org.aspectj.weaver.tools.PointcutExpressionTest.B.*(..)) && args(org.aspectj.weaver.tools.PointcutExpressionTest.X)\");\n\t\tassertTrue(\"Dynamic test needed\", ex.mayNeedDynamicTest());\n\t}\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tp = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass()\n\t\t\t\t.getClassLoader());\n\t\tasCons = A.class.getConstructor(new Class[] { String.class });\n\t\tbsCons = B.class.getConstructor(new Class[0]);\n\t\tbsStringCons = B.class.getConstructor(new Class[] { String.class });\n\t\ta = A.class.getMethod(\"a\", new Class[0]);\n\t\taa = A.class.getMethod(\"aa\", new Class[] { int.class });\n\t\taaa = A.class.getMethod(\"aaa\", new Class[] { String.class, int.class });\n\t\tx = A.class.getDeclaredField(\"x\");\n\t\ty = B.class.getDeclaredField(\"y\");\n\t\tb = B.class.getMethod(\"b\", new Class[0]);\n\t\tbsaa = B.class.getMethod(\"aa\", new Class[] { int.class });\n\t\tclientCons = Client.class.getConstructor(new Class[0]);\n\t\tn = Client.class.getDeclaredField(\"n\");\n\t\tfoo = Client.class.getDeclaredMethod(\"foo\", new Class[] { String.class, int.class, Number.class });\n\t\tbar = Client.class.getDeclaredMethod(\"bar\", new Class[] { String.class, int.class, Integer.class, Number.class });\n\t}\n\n\tstatic class A {\n\t\tpublic A(String s) {\n\t\t}\n\n\t\tpublic void a() {\n\t\t}\n\n\t\tpublic void aa(int i) {\n\t\t}\n\n\t\tpublic void aaa(String s, int i) {\n\t\t}\n\n\t\tint x;\n\t}\n\n\tstatic class B extends A {\n\t\tpublic B() {\n\t\t\tsuper(\"\");\n\t\t}\n\n\t\tpublic B(String s) {\n\t\t\tsuper(s);\n\t\t}\n\n\t\tpublic String b() {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void aa(int i) {\n\t\t}\n\n\t\tint y;\n\t}\n\n\tstatic class Client {\n\t\tpublic Client() {\n\t\t}\n\n\t\tNumber n;\n\n\t\tpublic void foo(String s, int i, Number n) {\n\t\t}\n\n\t\tpublic void bar(String s, int i, Integer i2, Number n) {\n\t\t}\n\t}\n\n\tstatic class X {\n\t}\n\n}\n",
    "size": 33054
  },
  {
    "file_id": "F172",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/PointcutParserTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2004 IBM Corporation.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * ******************************************************************/\npackage org.aspectj.weaver.tools;\n\nimport java.util.HashSet;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.aspectj.bridge.AbortException;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.IMessage.Kind;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.weaver.patterns.PatternParser;\nimport org.aspectj.weaver.patterns.Pointcut;\nimport org.aspectj.weaver.patterns.PointcutRewriter;\n\nimport org.junit.Assert;\nimport junit.framework.TestCase;\n\n/**\n * Test cases for the PointcutParser class\n */\npublic class PointcutParserTest extends TestCase {\n\n\tprivate boolean needToSkip = false;\n\n\t/** this condition can occur on the build machine only, and is way too complex to fix right now... */\n\tprivate boolean needToSkipPointcutParserTests() {\n\t\ttry {\n\t\t\tClass.forName(\"org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate\", false, this.getClass()\n\t\t\t\t\t.getClassLoader());// ReflectionBasedReferenceTypeDelegate.class.getClassLoader());\n\t\t} catch (ClassNotFoundException cnfEx) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tneedToSkip = needToSkipPointcutParserTests();\n\t}\n\n\tpublic void testGetAllSupportedPointcutPrimitives() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tSet<PointcutPrimitive> s = PointcutParser.getAllSupportedPointcutPrimitives();\n\t\tassertEquals(\"Should be 21 elements in the set\", 21, s.size());\n\t\tassertFalse(\"Should not contain if pcd\", s.contains(PointcutPrimitive.IF));\n\t\tassertFalse(\"Should not contain cflow pcd\", s.contains(PointcutPrimitive.CFLOW));\n\t\tassertFalse(\"Should not contain cflowbelow pcd\", s.contains(PointcutPrimitive.CFLOW_BELOW));\n\t}\n\n\tpublic void testEmptyConstructor() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tPointcutParser parser = PointcutParser\n\t\t\t\t.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());\n\t\tSet<PointcutPrimitive> s = parser.getSupportedPrimitives();\n\t\tassertEquals(\"Should be 21 elements in the set\", 21, s.size());\n\t\tassertFalse(\"Should not contain if pcd\", s.contains(PointcutPrimitive.IF));\n\t\tassertFalse(\"Should not contain cflow pcd\", s.contains(PointcutPrimitive.CFLOW));\n\t\tassertFalse(\"Should not contain cflowbelow pcd\", s.contains(PointcutPrimitive.CFLOW_BELOW));\n\t}\n\n\tpublic void testSetConstructor() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tSet<PointcutPrimitive> p = PointcutParser.getAllSupportedPointcutPrimitives();\n\t\tPointcutParser parser = PointcutParser\n\t\t\t\t.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(p, this.getClass()\n\t\t\t\t\t\t.getClassLoader());\n\t\tassertEquals(\"Should use the set we pass in\", p, parser.getSupportedPrimitives());\n\t\tSet<PointcutPrimitive> q = new HashSet<>();\n\t\tq.add(PointcutPrimitive.ARGS);\n\t\tparser = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(q, this\n\t\t\t\t.getClass().getClassLoader());\n\t\tassertEquals(\"Should have only one element in set\", 1, parser.getSupportedPrimitives().size());\n\t\tassertEquals(\"Should only have ARGS pcd\", PointcutPrimitive.ARGS, parser.getSupportedPrimitives().iterator().next());\n\t}\n\n\tpublic void testParsePointcutExpression() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this\n\t\t\t\t.getClass().getClassLoader());\n\t\tIMessageHandler current = p.setCustomMessageHandler(new IgnoreWarningsMessageHandler());\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"(adviceexecution() || execution(* *.*(..)) || handler(Exception) || \"\n\t\t\t\t\t+ \"call(Foo Bar+.*(Goo)) || get(* foo) || set(Foo+ (Goo||Moo).s*) || \"\n\t\t\t\t\t+ \"initialization(Foo.new(..)) || preinitialization(*.new(Foo,..)) || \"\n\t\t\t\t\t+ \"staticinitialization(org.xzy.abc..*)) && (this(Foo) || target(Boo) ||\" + \"args(A,B,C)) && !handler(X)\");\n\t\t} finally {\n\t\t\tp.setCustomMessageHandler(current);\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"gobble-de-gook()\");\n\t\t\tfail(\"Expected IllegalArgumentException\");\n\t\t} catch (IllegalArgumentException ex) {\n\t\t}\n\t}\n\n\tpublic void testParseExceptionErrorMessages() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this\n\t\t\t\t.getClass().getClassLoader());\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"execution(int Foo.*(..) && args(Double)\");\n\t\t\tfail(\"Expected IllegalArgumentException\");\n\t\t} catch (IllegalArgumentException ex) {\n\t\t\tassertTrue(\"Pointcut is not well-formed message\",\n\t\t\t\t\tex.getMessage().startsWith(\"Pointcut is not well-formed: expecting ')' at character position 24\"));\n\t\t}\n\t}\n\n\tpublic void testOperatorPrecedence_319190() throws Exception {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tString s = null;\n\t\tPointcut p = null;\n\n\t\ts = \"(execution(* A.credit(float)) || execution(* A.debit(float))) && this(acc) && args(am)  || execution(* C.*(Account, float)) && args(acc, am)\";\n\t\tp = new PatternParser(s).parsePointcut();\n\t\tAssert.assertEquals(\n\t\t\t\t\"(((execution(* A.credit(float)) || execution(* A.debit(float))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\n\t\t\t\tp.toString());\n\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\n\t\tp = new PatternParser(s).parsePointcut();\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if(true) && args(acc, am)))))\n\t\tAssert.assertEquals(\"(((if(true) || if(false)) && (this(acc) && args(am))) || (if(true) && args(acc, am)))\", p.toString());\n\t\tp = new PointcutRewriter().rewrite(p);\n\t\tAssert.assertEquals(\"(((this(acc) && args(am)) && if(true)) || (args(acc, am) && if(true)))\", p.toString());\n\n\t\ts = \"if(true) && if(false) || if(true)\";\n\t\tp = new PatternParser(s).parsePointcut();\n\t\tassertEquals(\"((if(true) && if(false)) || if(true))\", p.toString());\n\t\tp = new PointcutRewriter().rewrite(p);\n\t\tAssert.assertEquals(\"if(true)\", p.toString());\n\t}\n\n\tpublic void testParseIfPCD() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this\n\t\t\t\t.getClass().getClassLoader());\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"if(true)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Should not support IF\", PointcutPrimitive.IF, ex.getUnsupportedPrimitive());\n\t\t}\n\t}\n\n\tpublic void testParseCflowPCDs() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this\n\t\t\t\t.getClass().getClassLoader());\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"cflow(this(t))\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Should not support CFLOW\", PointcutPrimitive.CFLOW, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"cflowbelow(this(t))\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Should not support CFLOW_BELOW\", PointcutPrimitive.CFLOW_BELOW, ex.getUnsupportedPrimitive());\n\t\t}\n\t}\n\n\tpublic void testParseReferencePCDs() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tSet<PointcutPrimitive> pcKinds = PointcutParser.getAllSupportedPointcutPrimitives();\n\t\tpcKinds.remove(PointcutPrimitive.REFERENCE);\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(\n\t\t\t\tpcKinds, this.getClass().getClassLoader());\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"bananas(String)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertTrue(ex.getUnsupportedPrimitive() == PointcutPrimitive.REFERENCE);\n\t\t}\n\t}\n\n\tpublic void testParseUnsupportedPCDs() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tSet s = new HashSet();\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(\n\t\t\t\ts, this.getClass().getClassLoader());\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"args(x)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Args\", PointcutPrimitive.ARGS, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"within(x)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Within\", PointcutPrimitive.WITHIN, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"withincode(new(..))\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Withincode\", PointcutPrimitive.WITHIN_CODE, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"handler(Exception)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"handler\", PointcutPrimitive.HANDLER, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"this(X)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"this\", PointcutPrimitive.THIS, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"target(X)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"target\", PointcutPrimitive.TARGET, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"this(X) && target(Y)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"This\", PointcutPrimitive.THIS, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"this(X) || target(Y)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"This\", PointcutPrimitive.THIS, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"!this(X)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"This\", PointcutPrimitive.THIS, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"call(* *.*(..))\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Call\", PointcutPrimitive.CALL, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"execution(* *.*(..))\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Execution\", PointcutPrimitive.EXECUTION, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"get(* *)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Get\", PointcutPrimitive.GET, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"set(* *)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Set\", PointcutPrimitive.SET, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"initialization(new(..))\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Initialization\", PointcutPrimitive.INITIALIZATION, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"preinitialization(new(..))\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Prc-init\", PointcutPrimitive.PRE_INITIALIZATION, ex.getUnsupportedPrimitive());\n\t\t}\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"staticinitialization(T)\");\n\t\t\tfail(\"Expected UnsupportedPointcutPrimitiveException\");\n\t\t} catch (UnsupportedPointcutPrimitiveException ex) {\n\t\t\tassertEquals(\"Staticinit\", PointcutPrimitive.STATIC_INITIALIZATION, ex.getUnsupportedPrimitive());\n\t\t}\n\t}\n\n\tpublic void testFormals() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tPointcutParser parser = PointcutParser\n\t\t\t\t.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());\n\t\tPointcutParameter param = parser.createPointcutParameter(\"x\", String.class);\n\t\tPointcutExpression pc = parser.parsePointcutExpression(\"args(x)\", null, new PointcutParameter[] { param });\n\t\tassertEquals(\"args(x)\", pc.getPointcutExpression());\n\n\t\ttry {\n\t\t\tpc = parser.parsePointcutExpression(\"args(String)\", null, new PointcutParameter[] { param });\n\t\t\tfail(\"Expecting IllegalArgumentException\");\n\t\t} catch (IllegalArgumentException ex) {\n\t\t\tassertTrue(\"formal unbound\", ex.getMessage().contains(\"formal unbound\"));\n\t\t}\n\n\t\ttry {\n\t\t\tpc = parser.parsePointcutExpression(\"args(y)\");\n\t\t\tfail(\"Expecting IllegalArgumentException\");\n\t\t} catch (IllegalArgumentException ex) {\n\t\t\tassertTrue(\"no match for type name\", ex.getMessage().contains(\"warning no match for this type name: y\"));\n\t\t}\n\t}\n\n\tpublic void testXLintConfiguration() {\n\t\tif (needToSkip) {\n\t\t\treturn;\n\t\t}\n\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this\n\t\t\t\t.getClass().getClassLoader());\n\t\ttry {\n\t\t\tp.parsePointcutExpression(\"this(FooBar)\");\n\t\t} catch (IllegalArgumentException ex) {\n\t\t\tassertTrue(\"should have xlint:invalidAbsoluteTypeName\", ex.getMessage().contains(\"Xlint:invalidAbsoluteTypeName\"));\n\t\t}\n\t\tProperties props = new Properties();\n\t\tprops.put(\"invalidAbsoluteTypeName\", \"ignore\");\n\t\tp.setLintProperties(props);\n\t\tp.parsePointcutExpression(\"this(FooBar)\");\n\t}\n\n\tprivate static class IgnoreWarningsMessageHandler implements IMessageHandler {\n\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\n\t\t\tif (message.getKind() != IMessage.WARNING) {\n\t\t\t\tthrow new RuntimeException(\"unexpected message: \" + message.toString());\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic boolean isIgnoring(Kind kind) {\n\t\t\tif (kind != IMessage.ERROR) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic void dontIgnore(Kind kind) {\n\t\t}\n\n\t\tpublic void ignore(Kind kind) {\n\t\t}\n\n\t}\n}\n",
    "size": 14930
  },
  {
    "file_id": "F173",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/ReadingAttributesTest.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2009 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *\tAndy Clement\n * ******************************************************************/\npackage org.aspectj.weaver.tools;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.aspectj.apache.bcel.classfile.Attribute;\nimport org.aspectj.apache.bcel.classfile.JavaClass;\nimport org.aspectj.apache.bcel.classfile.Unknown;\nimport org.aspectj.apache.bcel.util.ClassPath;\nimport org.aspectj.apache.bcel.util.SyntheticRepository;\nimport org.aspectj.weaver.VersionedDataInputStream;\nimport org.aspectj.weaver.WeaverStateInfo;\n\nimport junit.framework.TestCase;\n\npublic class ReadingAttributesTest extends TestCase {\n\n\tpublic void testSkip() {} // Review what to do about these tests\n\n\tpublic void xtestWeaverStateInfo() throws ClassNotFoundException, IOException {\n\n\t\tJavaClass jc = getClassFrom(new File(\"n:/temp\"), \"com.springsource.petclinic.domain.Visit\");\n\t\tassertNotNull(jc);\n\t\tAttribute[] attrs = jc.getAttributes();\n\t\tfor (Attribute attr : attrs) {\n\t\t\tSystem.out.println(attr.getName());\n\t\t\tif (attr.getName().endsWith(\"WeaverState\")) {\n\t\t\t\tUnknown u = (Unknown) attr;\n\t\t\t\tVersionedDataInputStream vdis = new VersionedDataInputStream(new ByteArrayInputStream(u.getBytes()), null);\n\t\t\t\t// WeaverStateInfo wsi =\n\t\t\t\tWeaverStateInfo.read(vdis, null);\n\t\t\t\t// System.out.println(wsi);\n\t\t\t}\n\t\t}\n\t\t// Method[] meths = jc.getMethods();\n\t\t// Method oneWeWant = null;\n\t\t// for (int i = 0; i < meths.length && oneWeWant == null; i++) {\n\t\t// Method method = meths[i];\n\t\t// if (method.getName().equals(\"main\")) {\n\t\t// oneWeWant = meths[i];\n\t\t// }\n\t\t// }\n\t}\n\n\tpublic SyntheticRepository createRepos(File cpentry) {\n\t\tClassPath cp = new ClassPath(cpentry + File.pathSeparator + System.getProperty(\"java.class.path\"));\n\t\treturn SyntheticRepository.getInstance(cp);\n\t}\n\n\tprotected JavaClass getClassFrom(File where, String clazzname) throws ClassNotFoundException {\n\t\tSyntheticRepository repos = createRepos(where);\n\t\treturn repos.loadClass(clazzname);\n\t}\n}\n",
    "size": 2375
  },
  {
    "file_id": "F174",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/TypePatternMatcherTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2004 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.aspectj.weaver.tools;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport junit.framework.TestCase;\n\npublic class TypePatternMatcherTest extends TestCase {\n\n\tTypePatternMatcher tpm;\n\n\tprivate boolean needToSkip = false;\n\n\t/** this condition can occur on the build machine only, and is way too complex to fix right now... */\n\tprivate boolean needToSkipPointcutParserTests() {\n\t\ttry {\n\t\t\tClass.forName(\"org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate\",false,this.getClass().getClassLoader());//ReflectionBasedReferenceTypeDelegate.class.getClassLoader());\n\t\t} catch (ClassNotFoundException cnfEx) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void testMatching() {\n\t\tif (needToSkip) return;\n\n\t\tassertTrue(\"Map+ matches Map\",tpm.matches(Map.class));\n\t\tassertTrue(\"Map+ matches HashMap\",tpm.matches(HashMap.class));\n\t\tassertFalse(\"Map+ does not match String\",tpm.matches(String.class));\n\t}\n\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tneedToSkip = needToSkipPointcutParserTests();\n\t\tif (needToSkip) return;\n\t\tPointcutParser pp = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());\n\t\ttpm = pp.parseTypePattern(\"java.util.Map+\");\n\t}\n\n\n\n}\n",
    "size": 1825
  },
  {
    "file_id": "F175",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/cache/AbstractCacheBackingTestSupport.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.io.StreamCorruptedException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.security.CodeSource;\nimport java.security.ProtectionDomain;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\n\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.tools.cache.AbstractIndexedFileCacheBacking.IndexEntry;\n\nimport junit.framework.TestCase;\n\n/**\n */\npublic abstract class AbstractCacheBackingTestSupport extends TestCase {\n\tpublic static final String\tJAR_FILE_SUFFIX=\".jar\";\n    /**\n     * Prefix used in URL(s) that reference a resource inside a JAR\n     */\n    public static final String\tJAR_URL_PREFIX=\"jar:\";\n    /**\n     * Separator used in URL(s) that reference a resource inside a JAR\n     * to denote the sub-path inside the JAR\n     */\n    public static final char\tRESOURCE_SUBPATH_SEPARATOR='!';\n\n\tprivate File\ttargetFolder;\n\tprivate File\ttestTempFolder;\n\tprotected File root;\n\n\tpublic static final String TEMP_SUBFOLDER_NAME=\"temp\";\n\n\tprotected AbstractCacheBackingTestSupport() {\n\t\tsuper();\n\t}\n\n\tprotected AbstractCacheBackingTestSupport(String name) {\n\t\tsuper(name);\n\t}\n\n\t@Override\n\tpublic void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tif (root == null) {\n\t\t\troot = createTempFile(\"aspectj\", \"testdir\");\n\t\t\tFileUtil.deleteContents(root);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void tearDown() throws Exception {\n\t\tif (root != null) {\n\t\t\tFileUtil.deleteContents(root);\n\t\t\troot = null;\n\t\t}\n\n\t\tif (targetFolder != null) {\n\t\t\tFileUtil.deleteContents(targetFolder);\n\t\t}\n\n\t\tsuper.tearDown();\n\t}\n\n    protected File ensureTempFolderExists () throws IllegalStateException {\n    \tsynchronized(TEMP_SUBFOLDER_NAME) {\n    \t\tif (testTempFolder == null) {\n    \t\t\tFile\tparent=detectTargetFolder();\n    \t\t\ttestTempFolder = new File(parent, TEMP_SUBFOLDER_NAME);\n    \t\t}\n    \t}\n\n    \treturn ensureFolderExists(testTempFolder);\n    }\n\n    protected File detectTargetFolder () throws IllegalStateException {\n    \tsynchronized(TEMP_SUBFOLDER_NAME) {\n    \t\tif (targetFolder == null) {\n\t\t\ttry {\n\t\t\t\tFile targetFolder = File.createTempFile(\"ajc\", \"TmpCacheDir\");\n\t\t\t\ttargetFolder.delete();\n\t\t\t\ttargetFolder.mkdirs();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new IllegalStateException(\"Unable to create cache dir\",e);\n\t\t\t}\n\n\n//    \t\t\tif ((targetFolder=detectTargetFolder(getClass())) == null) {\n//\n////    \t\t\t\tthrow new IllegalStateException(\"Failed to detect target folder\");\n//    \t\t\t}\n    \t\t}\n    \t}\n\n    \treturn targetFolder;\n    }\n\n    protected File createTempFile (String prefix, String suffix) throws IOException {\n    \tFile\tdestFolder=ensureTempFolderExists();\n    \treturn File.createTempFile(prefix, suffix, destFolder);\n    }\n\n    public static final File ensureFolderExists (File folder) throws IllegalStateException {\n    \tif (folder == null) {\n    \t\tthrow new IllegalArgumentException(\"No folder to ensure existence\");\n    \t}\n\n    \tif ((!folder.exists()) && (!folder.mkdirs())) {\n    \t\tthrow new IllegalStateException(\"Failed to create \" + folder.getAbsolutePath());\n    \t}\n\n    \treturn folder;\n    }\n    /**\n     * @param anchor An anchor {@link Class} whose container we want to use\n     * as the starting point for the &quot;target&quot; folder lookup up the\n     * hierarchy\n     * @return The &quot;target&quot; <U>folder</U> - <code>null</code> if not found\n     * @see #detectTargetFolder(File)\n     */\n    public static final File detectTargetFolder (Class<?> anchor) {\n    \treturn detectTargetFolder(getClassContainerLocationFile(anchor));\n    }\n\n    /**\n     * @param anchorFile An anchor {@link File) we want to use\n     * as the starting point for the &quot;target&quot; folder lookup up the\n     * hierarchy\n     * @return The &quot;target&quot; <U>folder</U> - <code>null</code> if not found\n     */\n    public static final File detectTargetFolder (File anchorFile) {\n    \tfor (File\tfile=anchorFile; file != null; file=file.getParentFile()) {\n    \t\tif (!file.isDirectory()) {\n    \t\t\tcontinue;\n    \t\t}\n\n    \t\tString\tname=file.getName();\n    \t\tif (\"target\".equals(name) || \"bin\".equals(name) || \"src\".equals(name)) {\n    \t\t\tFile\tparent=file.getParentFile();\n    \t\t\treturn new File(parent, \"target2\");\n    \t\t}\n    \t}\n\n    \treturn null;\n    }\n\n    /**\n     * @param clazz A {@link Class} object\n     * @return A {@link File} of the location of the class bytes container\n     * - e.g., the root folder, the containing JAR, etc.. Returns\n     * <code>null</code> if location could not be resolved\n     * @throws IllegalArgumentException If location is not a valid\n     * {@link File} location\n     * @see #getClassContainerLocationURI(Class)\n     * @see File#File(URI)\n     */\n    public static File getClassContainerLocationFile (Class<?> clazz)\n            throws IllegalArgumentException {\n        try {\n            URI uri=getClassContainerLocationURI(clazz);\n            return (uri == null) ? null : new File(uri);\n        } catch(URISyntaxException e) {\n            throw new IllegalArgumentException(e.getClass().getSimpleName() + \": \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * @param clazz A {@link Class} object\n     * @return A {@link URI} to the location of the class bytes container\n     * - e.g., the root folder, the containing JAR, etc.. Returns\n     * <code>null</code> if location could not be resolved\n     * @throws URISyntaxException if location is not a valid URI\n     * @see #getClassContainerLocationURL(Class)\n     */\n    public static URI getClassContainerLocationURI (Class<?> clazz) throws URISyntaxException {\n        URL url=getClassContainerLocationURL(clazz);\n        return (url == null) ? null : url.toURI();\n    }\n\n    /**\n     * @param clazz A {@link Class} object\n     * @return A {@link URL} to the location of the class bytes container\n     * - e.g., the root folder, the containing JAR, etc.. Returns\n     * <code>null</code> if location could not be resolved\n     */\n    public static URL getClassContainerLocationURL (Class<?> clazz) {\n        ProtectionDomain    pd=clazz.getProtectionDomain();\n        CodeSource          cs=(pd == null) ? null : pd.getCodeSource();\n        URL\t\t\t\t\turl=(cs == null) ? null : cs.getLocation();\n        if (url == null) {\n        \tClassLoader\tcl=getDefaultClassLoader(clazz);\n        \tString\t\tclassName=clazz.getName().replace('.', '/') + \".class\";\n        \tif ((url=cl.getResource(className)) == null) {\n        \t\treturn null;\n        \t}\n\n        \tString\tsrcForm=getURLSource(url);\n        \tif (LangUtil.isEmpty(srcForm)) {\n        \t\treturn null;\n        \t}\n\n        \ttry {\n        \t\turl = new URL(srcForm);\n        \t} catch(MalformedURLException e) {\n        \t\tthrow new IllegalArgumentException(\"getClassContainerLocationURL(\" + clazz.getName() + \")\"\n        \t\t\t\t\t\t\t\t\t\t  + \"Failed to create URL=\" + srcForm + \" from \" + url.toExternalForm()\n        \t\t\t\t\t\t\t\t\t\t  + \": \" + e.getMessage());\n        \t}\n        }\n\n        return url;\n    }\n    /**\n     * @param anchor An &quot;anchor&quot; {@link Class} to be used in case\n     * no thread context loader is available\n     * @return A {@link ClassLoader} to be used by the caller. The loader is\n     * resolved in the following manner:</P></BR>\n     * <UL>\n     *      <LI>\n     *      If a non-<code>null</code> loader is returned from the\n     *      {@link Thread#getContextClassLoader()} call then use it.\n     *      </LI>\n     *\n     *      <LI>\n     *      Otherwise, use the same loader that was used to load the anchor class.\n     *      </LI>\n     * </UL>\n     * @throws IllegalArgumentException if no anchor class provided (regardless of\n     * whether it is used or not)\n     */\n    public static ClassLoader getDefaultClassLoader(Class<?> anchor) {\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"No anchor class provided\");\n        }\n\n        Thread      t=Thread.currentThread();\n        ClassLoader cl=t.getContextClassLoader();\n        if (cl == null) {\n            // No thread context class loader -> use class loader of this class.\n            cl = anchor.getClassLoader();\n        }\n\n        if (cl == null) {\t// no class loader - assume system\n        \tcl = ClassLoader.getSystemClassLoader();\n        }\n\n        return cl;\n\n    }\n    public static final String getURLSource (File file) {\n    \treturn getURLSource((file == null) ? null : file.toURI());\n    }\n\n    public static final String getURLSource (URI uri) {\n    \treturn getURLSource((uri == null) ? null : uri.toString());\n    }\n\n    /**\n     * @param url The {@link URL} value - ignored if <code>null</code>\n     * @return The URL(s) source path where {@link #JAR_URL_PREFIX} and\n     * any sub-resource are stripped\n     * @see #getURLSource(String)\n     */\n    public static final String getURLSource (URL url) {\n    \treturn getURLSource((url == null) ? null : url.toExternalForm());\n    }\n\n    /**\n     * @param externalForm The {@link URL#toExternalForm()} string - ignored if\n     * <code>null</code>/empty\n     * @return The URL(s) source path where {@link #JAR_URL_PREFIX} and\n     * any sub-resource are stripped\n     */\n    public static final String getURLSource (String externalForm) {\n\t\tString\turl=externalForm;\n    \tif (LangUtil.isEmpty(url)) {\n    \t\treturn url;\n    \t}\n\n    \turl = stripJarURLPrefix(externalForm);\n    \tif (LangUtil.isEmpty(url)){\n    \t\treturn url;\n    \t}\n\n    \tint\tsepPos=url.indexOf(RESOURCE_SUBPATH_SEPARATOR);\n    \tif (sepPos < 0) {\n    \t\treturn adjustURLPathValue(url);\n    \t} else {\n    \t\treturn adjustURLPathValue(url.substring(0, sepPos));\n    \t}\n    }\n\n    /**\n     * @param path A URL path value\n     * @return The path after stripping any trailing '/' provided the path\n     * is not '/' itself\n     */\n    public static final String adjustURLPathValue(final String path) {\n        final int   pathLen=LangUtil.isEmpty(path) ? 0 : path.length();\n        if ((pathLen <= 1) || (path.charAt(pathLen - 1) != '/')) {\n            return path;\n        }\n\n        return path.substring(0, pathLen - 1);\n    }\n\n    public static final String adjustURLPathValue(URL url) {\n        return adjustURLPathValue((url == null) ? null : url.getPath());\n    }\n\n\tpublic static String stripJarURLPrefix(String externalForm) {\n\t\tString\turl=externalForm;\n    \tif (LangUtil.isEmpty(url)) {\n    \t\treturn url;\n    \t}\n\n    \tif (url.startsWith(JAR_URL_PREFIX)) {\n    \t\treturn url.substring(JAR_URL_PREFIX.length());\n    \t}\n\n    \treturn url;\n\t}\n\n    protected static final void writeIndex (File indexFile, IndexEntry ... entries) throws IOException {\n        writeIndex(indexFile, LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));\n    }\n\n    protected static final void writeIndex (File indexFile, Collection<? extends IndexEntry> entries) throws IOException {\n        File    indexDir=indexFile.getParentFile();\n        if ((!indexDir.exists()) && (!indexDir.mkdirs())) {\n            throw new IOException(\"Failed to create path to \" + indexFile.getAbsolutePath());\n        }\n\n        int             numEntries=LangUtil.isEmpty(entries) ? 0 : entries.size();\n        IndexEntry[]    entryValues=(numEntries <= 0) ? null : entries.toArray(new IndexEntry[numEntries]);\n        // if no entries, simply delete the index file\n        if (LangUtil.isEmpty(entryValues)) {\n            if (indexFile.exists() && (!indexFile.delete())) {\n                throw new StreamCorruptedException(\"Failed to clean up index file at \" + indexFile.getAbsolutePath());\n            }\n\n            return;\n        }\n\n        ObjectOutputStream oos=new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(indexFile), 4096));\n        try {\n            oos.writeObject(entryValues);\n        } finally {\n            oos.close();\n        }\n    }\n\n    public static final void assertArrayEquals (String msg, byte[] expected, byte[] actual) {\n    \tint\teLen=LangUtil.isEmpty(expected) ? 0 : expected.length;\n    \tint\taLen=LangUtil.isEmpty(actual) ? 0 : expected.length;\n    \tassertEquals(msg + \"[mismatched length]\", eLen, aLen);\n\n    \tfor (int\tindex=0; index < eLen; index++) {\n    \t\tbyte\teb=expected[index], ab=actual[index];\n    \t\tif (eb != ab) {\n    \t\t\tfail(msg + \": Mismatched value at index=\" + index\n    \t\t\t   + \" - \" + ab + \" instead of \" + eb\n    \t\t\t   + \": expected=\" + Arrays.toString(expected) + \", actual=\" + Arrays.toString(actual));\n    \t\t}\n    \t}\n    }\n}\n",
    "size": 13174
  },
  {
    "file_id": "F176",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/cache/AsynchronousFileCacheBackingTestSupport.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.TreeMap;\n\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.tools.cache.AbstractIndexedFileCacheBacking.IndexEntry;\n\n/**\n */\npublic abstract class AsynchronousFileCacheBackingTestSupport\n\t\textends AbstractCacheBackingTestSupport {\n    private File  cacheDir, indexFile;\n    protected final byte[]    bytes=new byte[Byte.MAX_VALUE];\n    protected final Random    random=new Random(System.nanoTime());\n\n\tprotected AsynchronousFileCacheBackingTestSupport() {\n\t\tsuper();\n\t}\n\n\tprotected AsynchronousFileCacheBackingTestSupport(String name) {\n\t\tsuper(name);\n\t}\n\n    @Override\n    public void setUp () throws Exception {\n    \tsuper.setUp();\n    \tcleanupCache();\n\n        random.nextBytes(bytes);\n    }\n\n    @Override\n    public void tearDown () throws Exception {\n    \tcleanupCache();\n    \tsuper.tearDown();\n    }\n\n    protected void cleanupCache() {\n    \tif (indexFile != null) {\n    \t\tif (FileUtil.deleteContents(indexFile) > 0) {\n    \t\t\tSystem.out.println(\"Deleted index file: \" + indexFile);\n    \t\t}\n    \t\tindexFile = null;\n    \t}\n\n    \tif (cacheDir != null) {\n    \t\tif (FileUtil.deleteContents(cacheDir) > 0) {\n    \t\t\tSystem.out.println(\"Deleted cache directory content: \" + cacheDir);\n    \t\t}\n        if (cacheDir.delete()) {\n    \t\t\tSystem.out.println(\"Deleted cache directory: \" + cacheDir);\n    \t\t}\n    \t\tcacheDir = null;\n    \t}\n    }\n\n    protected File getIndexFile () {\n    \tif (indexFile == null) {\n    \t\tFile\tparent=getCacheDir();\n    \t\tindexFile=new File(parent, AbstractIndexedFileCacheBacking.INDEX_FILE);\n    \t}\n\n    \treturn indexFile;\n    }\n\n    protected File getCacheDir () {\n    \tif (cacheDir == null) {\n    \t\tFile\ttargetDir=detectTargetFolder();\n    \t\tcacheDir = new File(targetDir, \"dir-\" + String.valueOf(Math.random()));\n    \t}\n\n    \treturn ensureFolderExists(cacheDir);\n    }\n\n    protected abstract AsynchronousFileCacheBacking createFileBacking (File dir);\n\n    public void testDeleteIndexFileOnEmptyIndex () throws Exception {\n        IndexEntry[]    entries={\n                createIndexEntry(\"weaved-empty\", false, false, bytes, bytes),\n                createIndexEntry(\"generated-empty\", true, false, bytes, bytes)\n            };\n        File\tcacheIndex=getIndexFile();\n        writeIndex(cacheIndex, entries);\n        assertTrue(\"No initial index file available: \" + cacheIndex, cacheIndex.canRead());\n\n        AsynchronousFileCacheBacking    cache=createFileBacking(getCacheDir());\n        // the call should read an empty index since no data files exist\n        Map<String, IndexEntry>         indexMap=cache.getIndexMap();\n        assertEquals(\"Mismatched index size\", 0, indexMap.size());\n\n        // no data files were created\n        Map<String, byte[]> bytesMap=cache.getBytesMap();\n        assertEquals(\"Mismatched bytes size\", 0, bytesMap.size());\n\n        writeIndex(cache.getIndexFile(), cache.getIndexEntries());\n\n        assertFalse(\"Index file still available: \" + cacheIndex, cacheIndex.canRead());\n    }\n\n    protected long generateNewBytes () {\n        final long          CRC=AbstractCacheBacking.crc(bytes);\n        long                crc=CRC;\n        // 8 tries should be enough to find a non-matching CRC...\n        for (int    index=0; (index < Byte.SIZE) && (CRC == crc) && (crc != -1L); index++) {\n            random.nextBytes(bytes);\n            crc = AbstractCacheBacking.crc(bytes);\n        }\n        assertTrue(\"Could not generate different CRC for \" + CRC, crc != CRC);\n\n        return crc;\n    }\n\n    protected Map<String, File> createDataFiles (IndexEntry ... entries) throws IOException {\n        return createDataFiles(LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));\n    }\n\n    protected Map<String, File> createDataFiles (Collection<? extends IndexEntry> entries) throws IOException {\n        if (LangUtil.isEmpty(entries)) {\n            return Collections.emptyMap();\n        }\n\n        Map<String, File>  files= new TreeMap<>();\n        for (IndexEntry entry : entries) {\n            File    file=createDataFile(entry);\n            if (file != null) {\n                files.put(entry.key, file);\n            }\n        }\n\n        return files;\n    }\n\n    protected File createDataFile (IndexEntry entry) throws IOException {\n        return createDataFile(entry, entry.ignored ? null : bytes);\n    }\n\n    protected File createDataFile (IndexEntry entry, byte[] dataBytes) throws IOException {\n        return createDataFile(entry.key, dataBytes);\n    }\n\n    protected File createDataFile (String key, byte[] dataBytes) throws IOException {\n        if (LangUtil.isEmpty(dataBytes)) {\n            return null;\n        }\n\n        File    \t\tparent=getCacheDir(), file=new File(parent, key);\n        OutputStream    out=new FileOutputStream(file);\n        try {\n            out.write(dataBytes);\n        } finally {\n            out.close();\n        }\n\n        return file;\n    }\n\n    protected static final IndexEntry createIgnoredEntry (String key) {\n        return createIndexEntry(key, false, true, null, null);\n    }\n\n    protected static final IndexEntry createIndexEntry (String key, boolean generated, boolean ignored, byte[] bytes, byte[] originalBytes) {\n        IndexEntry  entry=new IndexEntry();\n        entry.key = key;\n        entry.generated = generated;\n        entry.ignored = ignored;\n        if (ignored) {\n            assertFalse(key + \" ignored cannot be generated\", generated);\n        } else {\n        \tentry.crcClass = AbstractCacheBacking.crc(originalBytes);\n            entry.crcWeaved = AbstractCacheBacking.crc(bytes);\n        }\n\n        return entry;\n    }\n}\n",
    "size": 6489
  },
  {
    "file_id": "F177",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/cache/DefaultCacheKeyResolverTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         initial implementation\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.Arrays;\nimport java.util.Collections;\n\nimport junit.framework.TestCase;\n\n/**\n */\npublic class DefaultCacheKeyResolverTest extends TestCase {\n\tbyte[] FAKE_BYTES = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\tString FAKE_CLASS = \"com.example.foo.Bar\";\n\n\tDefaultCacheKeyResolver resolver = new DefaultCacheKeyResolver();\n\n\tclass BasicTestCL extends ClassLoader {\n\t\tpublic BasicTestCL () {\n\t\t\tsuper();\n\t\t}\n\t}\n\n\tclass URLTestCL extends URLClassLoader {\n\t\tpublic URLTestCL(URL... urls) {\n\t\t\tsuper(urls);\n\t\t}\n\t}\n\n\n\tpublic void testNonURLClassLoaderScope() throws Exception {\n\t\tString scope = resolver.createClassLoaderScope(new BasicTestCL(), Collections.<String>emptyList());\n\t\tassertTrue(scope.startsWith(BasicTestCL.class.getSimpleName()));\n\t}\n\n\tpublic void testCreateURLClassLoaderScope() throws Exception {\n\t\tURL testURLA = new URL(\"https://example.com\");\n\t\tURL testURLB = new URL(\"file:///tmp\");\n\t\tURL testURLC = new URL(\"ftp://ftp.example.com\");\n\t\tURLTestCL A = new URLTestCL(testURLA);\n\t\tURLTestCL AB = new URLTestCL(testURLA, testURLB);\n\t\tURLTestCL BC = new URLTestCL(testURLB, testURLC);\n\t\tURLTestCL BC2 = new URLTestCL(testURLC, testURLB);\n\t\tString[] a = {\"one\", \"two\", \"three\", \"four\"};\n\t\tString[] a2 = {\"one\", \"two\", \"three\"};\n\t\tString scopeAa = resolver.createClassLoaderScope(A, Arrays.asList(a));\n\t\tString scopeABa = resolver.createClassLoaderScope(AB, Arrays.asList(a));\n\t\tString scopeBCa = resolver.createClassLoaderScope(BC, Arrays.asList(a));\n\t\tString scopeBC2a = resolver.createClassLoaderScope(BC2, Arrays.asList(a));\n\t\tString scopeAa2 = resolver.createClassLoaderScope(A, Arrays.asList(a2));\n\t\tString scopeABa2 = resolver.createClassLoaderScope(AB, Arrays.asList(a2));\n\t\tString scopeBCa2 = resolver.createClassLoaderScope(BC, Arrays.asList(a2));\n\t\tString scopeBC2a2 = resolver.createClassLoaderScope(BC2, Arrays.asList(a2));\n\n\t\tassertFalse(scopeAa.equals(scopeABa));\n\t\tassertFalse(scopeAa.equals(scopeBCa));\n\t\tassertFalse(scopeABa.equals(scopeBCa));\n\t\tassertTrue(scopeBC2a.equals(scopeBCa));\n\t\tassertFalse(scopeAa.equals(scopeAa2));\n\t\tassertFalse(scopeABa.equals(scopeABa2));\n\t\tassertFalse(scopeBCa.equals(scopeBCa2));\n\t\tassertFalse(scopeBC2a.equals(scopeBC2a2));\n\n\n\t}\n\n\n\tpublic void testCreateGeneratedCacheKey() throws Exception {\n\t\tCachedClassReference ref = resolver.generatedKey(FAKE_CLASS);\n\t\tassertTrue(ref.getKey().startsWith(FAKE_CLASS));\n\t\tassertTrue(ref.getKey().matches(resolver.getGeneratedRegex()));\n\t\tassertEquals(FAKE_CLASS, resolver.keyToClass(ref.getKey()));\n\t}\n\n\tpublic void testCreateCacheKey() throws Exception {\n\t\t// crc hashing\n\t\tCachedClassReference ref = resolver.weavedKey(FAKE_CLASS, FAKE_BYTES);\n\t\tassertTrue(\"key \" + ref.getKey() + \" does not match \" + resolver.getWeavedRegex(), ref.getKey().matches(resolver.getWeavedRegex()));\n\t\tString className = resolver.keyToClass(ref.getKey());\n\t\tassertEquals(\"class \" + FAKE_CLASS + \" != \" + className, FAKE_CLASS, className);\n\t}\n\n}\n",
    "size": 3558
  },
  {
    "file_id": "F178",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         initial implementation\n *   Lyor Goldstein (vmware)\tadd support for weaved class being re-defined\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.File;\nimport java.util.zip.CRC32;\n\nimport org.aspectj.util.LangUtil;\nimport org.aspectj.weaver.tools.cache.AbstractIndexedFileCacheBacking.IndexEntry;\n\n/**\n */\npublic class DefaultFileCacheBackingTest extends AbstractCacheBackingTestSupport {\n\tprivate final byte[] FAKE_BYTES = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\tprivate final String FAKE_CLASS = \"com.example.foo.Bar\";\n\tprivate final CacheKeyResolver resolver = new DefaultCacheKeyResolver();\n\tprivate final CachedClassReference fakeRef = resolver.weavedKey(FAKE_CLASS, FAKE_BYTES);\n\tprivate final String\tfakeKey=fakeRef.getKey();\n\n\tpublic DefaultFileCacheBackingTest () {\n\t\tsuper();\n\t}\n\n\tpublic void testCreateBacking() throws Exception {\n\t\tCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\n\t\tassertNotNull(backing);\n\t\tassertTrue(\"Root folder not created: \" + root, root.exists());\n\t\tassertTrue(\"Root folder not a directory: \" + root, root.isDirectory());\n\t}\n\n\tpublic void testClear() {\n\t\tCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\n\t\tbacking.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED), FAKE_BYTES);\n\t\tassertNotNull(backing.get(fakeRef, FAKE_BYTES));\n\t\tbacking.clear();\n\t\tassertNull(backing.get(fakeRef, FAKE_BYTES));\n\t}\n\n\tprivate CachedClassEntry createTestEntry(String key) {\n\t\treturn new CachedClassEntry(new CachedClassReference(key, key), FAKE_BYTES, CachedClassEntry.EntryType.WEAVED);\n\t}\n\n\tpublic void testGetKeys() throws Exception {\n\t\tCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\n\t\tbacking.put(createTestEntry(\"apple\"), FAKE_BYTES);\n\t\tbacking.put(createTestEntry(\"apply\"), FAKE_BYTES);\n\t\tbacking.put(createTestEntry(\"orange\"), FAKE_BYTES);\n\t\tString[] matches = backing.getKeys(\"app.*\");\n\t\tassertEquals(2, matches.length);\n\t\tmatches = backing.getKeys(\"orange\");\n\t\tassertEquals(1, matches.length);\n\t\tassertEquals(\"orange\", matches[0]);\n\t}\n\n\tpublic void testPut() throws Exception {\n\t\tCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\n\t\tbacking.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED), FAKE_BYTES);\n\t\tFile cachedFile = new File(root, fakeKey);\n\t\tassertTrue(cachedFile.exists());\n\t\tassertTrue(cachedFile.isFile());\n\t\tassertEquals(FAKE_BYTES.length, cachedFile.length());\n\t}\n\n\tpublic void testGet() throws Exception {\n\t\tDefaultFileCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\n\t\tassertNull(backing.get(fakeRef, FAKE_BYTES));\n\t\tbacking.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED), FAKE_BYTES);\n\t\tFile cachedFile = new File(root, fakeKey);\n\t\tassertTrue(cachedFile.isFile());\n\t\tassertEquals(FAKE_BYTES.length, cachedFile.length());\n\t\tCRC32 expectedCRC = new CRC32();\n\t\texpectedCRC.update(FAKE_BYTES);\n\t\tassertTrue(indexEntryExists(backing, fakeKey, expectedCRC.getValue()));\n\t\tCachedClassEntry entry = backing.get(fakeRef, FAKE_BYTES);\n\t\tassertEquals(FAKE_BYTES.length, entry.getBytes().length);\n\t}\n\n\tpublic void testRemove() throws Exception {\n\t\tDefaultFileCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\n\t\tbacking.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED), FAKE_BYTES);\n\t\tFile cachedFile = new File(root, fakeKey);\n\t\tassertTrue(\"Cached file not found: \" + cachedFile, cachedFile.exists());\n\t\tassertTrue(\"Cached file not a file: \" + cachedFile, cachedFile.isFile());\n\t\tCRC32 expectedCRC = new CRC32();\n\t\texpectedCRC.update(FAKE_BYTES);\n\t\tassertTrue(\"Cached entry index not found\", indexEntryExists(backing, fakeKey, expectedCRC.getValue()));\n\t\tbacking.remove(fakeRef);\n\n\t\tassertFalse(\"CacheFile Still exists: \" + cachedFile, cachedFile.exists());\n\t\tassertFalse(\"Cached file is a file: \" + cachedFile, cachedFile.isFile());\n\t\tassertFalse(\"Cached entry index not removed\", indexEntryExists(backing, fakeKey, expectedCRC.getValue()));\n\t}\n\n\tpublic void testMultiFile() throws Exception {\n\t\tCachedClassEntry entry;\n\t\tFile cachedFile;\n\t\tCRC32 expectedCRC = new CRC32();\n\t\texpectedCRC.update(FAKE_BYTES);\n\t\tDefaultFileCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\n\t\t// add weaved\n\t\tCachedClassReference wref = resolver.weavedKey(FAKE_CLASS + \"WEAVED\", FAKE_BYTES);\n\t\tentry = new CachedClassEntry(wref, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED);\n\t\tbacking.put(entry, FAKE_BYTES);\n\t\tcachedFile = new File(root, wref.getKey());\n\t\tassertTrue(cachedFile.exists());\n\t\tassertTrue(cachedFile.isFile());\n\t\tassertTrue(indexEntryExists(backing, wref.getKey(), expectedCRC.getValue()));\n\n\t\t// add generated\n\t\tCachedClassReference gref = resolver.generatedKey(FAKE_CLASS + \"GENERATED\");\n\t\tentry = new CachedClassEntry(gref, FAKE_BYTES, CachedClassEntry.EntryType.GENERATED);\n\t\tbacking.put(entry, FAKE_BYTES);\n\t\tcachedFile = new File(root, gref.getKey());\n\t\tassertTrue(cachedFile.exists());\n\t\tassertTrue(cachedFile.isFile());\n\t\tassertTrue(indexEntryExists(backing, gref.getKey(), expectedCRC.getValue()));\n\n\t\t// add ignored\n\t\tCachedClassReference iref = resolver.generatedKey(FAKE_CLASS + \"IGNORED\");\n\t\tentry = new CachedClassEntry(iref, FAKE_BYTES, CachedClassEntry.EntryType.IGNORED);\n\t\tbacking.put(entry, FAKE_BYTES);\n\t\tcachedFile = new File(root, iref.getKey());\n\t\tassertFalse(cachedFile.exists());\n\t\tassertTrue(indexEntryExists(backing, iref.getKey(), expectedCRC.getValue()));\n\n\t\tbacking.remove(wref);\n\t\tbacking.remove(gref);\n\t\tbacking.remove(iref);\n\t}\n\n\tpublic void testOriginalClassBytesChanged () {\n\t\tDefaultFileCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\n\t\tbacking.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED), FAKE_BYTES);\n\n\t\tCachedClassEntry entry = backing.get(fakeRef, FAKE_BYTES);\n\t\tassertNotNull(\"No initial entry\", entry);\n\n\t\tbyte[]\tnewBytes=new byte[FAKE_BYTES.length];\n\t\tfor (int index=0; index < FAKE_BYTES.length; index++) {\n\t\t\tnewBytes[index] = (byte) (0 - FAKE_BYTES[index]);\n\t\t}\n\n\t\tentry = backing.get(fakeRef, newBytes);\n\t\tassertNull(\"Unexpected modified bytes entry: \" + entry, entry);\n\n\t\tFile cachedFile = new File(root, fakeKey);\n\t\tassertFalse(\"Cache file not removed\", cachedFile.exists());\n\t}\n\n\tprivate boolean indexEntryExists(AbstractIndexedFileCacheBacking cache, String key, long expectedCRC) throws Exception {\n\t\tlong storedCRC = 0L;\n\t\tIndexEntry[] index = cache.readIndex(new File(root, AbstractIndexedFileCacheBacking.INDEX_FILE));\n\t\tif (LangUtil.isEmpty(index)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (IndexEntry ie : index) {\n\t\t\tif (ie.key.equals(key)) {\n\t\t\t\tstoredCRC = ie.crcWeaved;\n\t\t\t\tif (!ie.ignored) {\n\t\t\t\t\tassertEquals(expectedCRC, storedCRC);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
    "size": 7302
  },
  {
    "file_id": "F179",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/cache/FlatFileCacheBackingTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 VMware, Inc.\n *\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *  Lyor Goldstein\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport org.aspectj.weaver.tools.cache.AbstractIndexedFileCacheBacking.IndexEntry;\n\n/**\n * @author Lyor Goldstein\n */\npublic class FlatFileCacheBackingTest extends AsynchronousFileCacheBackingTestSupport {\n\tpublic FlatFileCacheBackingTest() {\n\t\tsuper();\n\t}\n\n\t@Override\n\tprotected FlatFileCacheBacking createFileBacking(File dir) {\n\t\treturn new FlatFileCacheBacking(dir);\n\t}\n\n\tpublic void testReadIndex() throws IOException {\n\t\tIndexEntry[] entries = { createIgnoredEntry(\"ignored\"), createIndexEntry(\"weaved\", false, false, bytes, bytes),\n\t\t\t\tcreateIndexEntry(\"generated\", true, false, bytes, bytes) };\n\t\tFile indexFile = getIndexFile();\n\t\twriteIndex(indexFile, entries);\n\t\tMap<String, File> dataFiles = createDataFiles(entries);\n\n\t\tFile cacheDir = getCacheDir();\n\t\tAsynchronousFileCacheBacking cache = createFileBacking(cacheDir);\n\t\tMap<String, IndexEntry> indexMap = cache.getIndexMap();\n\t\tassertEquals(\"Mismatched index size\", entries.length, indexMap.size());\n\n\t\tMap<String, byte[]> bytesMap = cache.getBytesMap();\n\t\tassertEquals(\"Mismatched bytes size\", dataFiles.size() /* the ignored one has no file */, bytesMap.size());\n\n\t\tfor (IndexEntry entry : entries) {\n\t\t\tString key = entry.key;\n\t\t\tassertNotNull(\"Missing entry for key=\" + key, indexMap.get(key));\n\n\t\t\tif (entry.ignored) {\n\t\t\t\tassertNull(\"Unexpected bytes for ignored key=\" + key, bytesMap.get(key));\n\t\t\t} else {\n\t\t\t\tassertArrayEquals(\"Mismatched contents for key=\" + key, bytes, bytesMap.get(key));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testIgnoredBadCrcDataFiles() throws Exception {\n\t\tIndexEntry[] entries = { createIndexEntry(\"weaved-goodData\", false, false, bytes, bytes),\n\t\t\t\tcreateIndexEntry(\"badData-weaved\", false, false, bytes, bytes),\n\t\t\t\tcreateIndexEntry(\"generated-goodData\", true, false, bytes, bytes),\n\t\t\t\tcreateIndexEntry(\"badData-generated\", true, false, bytes, bytes) };\n\t\tFile indexFile = getIndexFile();\n\t\twriteIndex(indexFile, entries);\n\n\t\tMap<String, File> dataFiles = createDataFiles(entries);\n\t\tlong newCrc = generateNewBytes();\n\t\tassertTrue(\"Bad new CRC\", newCrc != (-1L));\n\n\t\tMap<String, File> badFiles = new TreeMap<>();\n\t\tfor (IndexEntry entry : entries) {\n\t\t\tString key = entry.key;\n\t\t\tif (key.startsWith(\"badData\")) {\n\t\t\t\tFile file = dataFiles.get(key);\n\t\t\t\tOutputStream out = new FileOutputStream(file);\n\t\t\t\ttry {\n\t\t\t\t\tout.write(bytes);\n\t\t\t\t} finally {\n\t\t\t\t\tout.close();\n\t\t\t\t}\n\t\t\t\tdataFiles.remove(key);\n\t\t\t\tbadFiles.put(key, file);\n\t\t\t}\n\t\t}\n\n\t\tFile cacheDir = getCacheDir();\n\t\tFlatFileCacheBacking cache = createFileBacking(cacheDir);\n\t\tMap<String, IndexEntry> indexMap = cache.getIndexMap();\n\t\tassertEquals(\"Mismatched index size\", dataFiles.size(), indexMap.size());\n\n\t\tMap<String, byte[]> bytesMap = cache.getBytesMap();\n\t\tassertEquals(\"Mismatched bytes size\", dataFiles.size(), bytesMap.size());\n\n\t\tfor (Map.Entry<String, File> badEntry : badFiles.entrySet()) {\n\t\t\tString key = badEntry.getKey();\n\t\t\tassertFalse(\"Unexpectedly indexed: \" + key, indexMap.containsKey(key));\n\t\t\tassertFalse(\"Unexpectedly loaded: \" + key, bytesMap.containsKey(key));\n\n\t\t\tFile file = badEntry.getValue();\n\t\t\tassertFalse(\"Unexpectedly still readable: \" + key, file.canRead());\n\t\t}\n\t}\n\n\tpublic void testSkipMissingDataFileOnReadIndex() throws IOException {\n\t\tIndexEntry[] entries = { createIndexEntry(\"weaved-noData\", false, false, null, null),\n\t\t\t\tcreateIndexEntry(\"withData-weaved\", false, false, bytes, bytes),\n\t\t\t\tcreateIndexEntry(\"generated-noData\", true, false, null, null),\n\t\t\t\tcreateIndexEntry(\"withData-generated\", true, false, bytes, bytes) };\n\t\tFile indexFile = getIndexFile();\n\t\twriteIndex(indexFile, entries);\n\n\t\tMap<String, File> dataFiles = new TreeMap<>();\n\t\tfor (IndexEntry entry : entries) {\n\t\t\tString key = entry.key;\n\t\t\tif (key.startsWith(\"withData\")) {\n\t\t\t\tdataFiles.put(key, createDataFile(entry, bytes));\n\t\t\t}\n\t\t}\n\n\t\tFile cacheDir = getCacheDir();\n\t\tFlatFileCacheBacking cache = createFileBacking(cacheDir);\n\t\tMap<String, IndexEntry> indexMap = cache.getIndexMap();\n\t\tassertEquals(\"Mismatched index size\", dataFiles.size(), indexMap.size());\n\n\t\tMap<String, byte[]> bytesMap = cache.getBytesMap();\n\t\tassertEquals(\"Mismatched bytes size\", dataFiles.size(), bytesMap.size());\n\n\t\tfor (IndexEntry entry : entries) {\n\t\t\tString key = entry.key;\n\t\t\tif (key.startsWith(\"withData\")) {\n\t\t\t\tassertTrue(\"Not indexed: \" + key, indexMap.containsKey(key));\n\t\t\t\tassertTrue(\"Not loaded: \" + key, bytesMap.containsKey(key));\n\t\t\t} else {\n\t\t\t\tassertFalse(\"Unexpectedly indexed: \" + key, indexMap.containsKey(key));\n\t\t\t\tassertFalse(\"Unexpectedly loaded: \" + key, bytesMap.containsKey(key));\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "size": 5278
  },
  {
    "file_id": "F180",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/cache/SimpleClassCacheTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Abraham Nevado (lucierna) initial implementation\n ********************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport junit.framework.TestCase;\n\nimport java.io.File;\n\npublic class SimpleClassCacheTest extends TestCase {\n\tbyte[] FAKE_BYTES_V1 = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\tbyte[] FAKE_BYTES_V2 = { 1, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n\tbyte[] FAKE_WOVEN_BYTES_V1 = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\tbyte[] FAKE_WOVEN_BYTES_V2 = { 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n\n\tprivate SimpleCache createCache() {\n\t\treturn new SimpleCache(System.getProperty(\"java.io.tmpdir\"), true);\n\t}\n\n\tpublic void testCache() {\n\t\tString classA = \"com.generated.A\";\n\t\tSimpleCache cache = createCache();\n\t\tcache.put(classA, FAKE_BYTES_V1, FAKE_WOVEN_BYTES_V1);\n\n\t\t// Returned woven bytes are the original ones\n\t\tbyte[] result = cache.getAndInitialize(classA, FAKE_BYTES_V1, null, null).orElse(null);\n\t\tassertNotNull(result);\n\t\tfor (int i = 0; i < result.length; i++)\n\t\t\tassertEquals(\n\t\t\t\t\"Cached version byte[\" + i + \"] should be equal to the original woven class\",\n\t\t\t\tresult[i], FAKE_WOVEN_BYTES_V1[i]\n\t\t\t);\n\n\t\t// Class is properly backed up\n\t\tFile f = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + \"com.generated.A-1164760902\");\n\t\tassertTrue(\n\t\t\t\"Class should be backed up with CRC 1164760902\",\n\t\t\tf.exists()\n\t\t);\n\t}\n\n\tpublic void testDifferentVersionCache() {\n\t\tString classA = \"com.generated.A\";\n\t\tSimpleCache cache = createCache();\n\t\tcache.put(classA, FAKE_BYTES_V1, FAKE_WOVEN_BYTES_V1);\n\t\tcache.put(classA, FAKE_BYTES_V2, FAKE_WOVEN_BYTES_V2);\n\n\t\t// Returned woven bytes are the original ones for v1\n\t\tbyte[] result = cache.getAndInitialize(classA, FAKE_BYTES_V1, null, null).orElse(null);\n\t\tassertNotNull(result);\n\t\tfor (int i = 0; i < result.length; i++)\n\t\t\tassertEquals(\n\t\t\t\t\"Cached version v1 byte[\" + i + \"] should be equal to the original woven class\",\n\t\t\t\tresult[i], FAKE_WOVEN_BYTES_V1[i]\n\t\t\t);\n\n\t\t// Returned woven bytes are the original ones for v2\n\t\tresult = cache.getAndInitialize(classA, FAKE_BYTES_V2, null, null).orElse(null);\n\t\tassertNotNull(result);\n\t\tfor (int i = 0; i < result.length; i++)\n\t\t\tassertEquals(\n\t\t\t\t\"Cached version v2 byte[\" + i + \"] should be equal to the original woven class\",\n\t\t\t\tresult[i], FAKE_WOVEN_BYTES_V2[i]\n\t\t\t);\n\t}\n\n\tpublic void testCacheMiss() {\n\t\tString classA = \"com.generated.A\";\n\t\tSimpleCache cache = createCache();\n\n\t\t// Woven bytes not found in cache\n\t\tassertNull(cache.getAndInitialize(classA, FAKE_BYTES_V1, null, null));\n\t}\n\n\tpublic void testCacheHitUnwoven() {\n\t\tString classA = \"com.generated.A\";\n\t\tSimpleCache cache = createCache();\n\t\tcache.put(classA, FAKE_BYTES_V1, SimpleCache.SAME_BYTES);\n\n\t\t// Returned woven bytes are null, indicating an unwoven class\n\t\tbyte[] result = cache.getAndInitialize(classA, FAKE_BYTES_V1, null, null).orElse(null);\n\t\tassertNull(result);\n\t}\n}\n",
    "size": 3310
  },
  {
    "file_id": "F181",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java",
    "text": "/*******************************************************************************\n * Copyright (c) 2012 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   John Kew (vmware)         initial implementation\n *******************************************************************************/\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.aspectj.bridge.AbortException;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.IMessageHandler;\nimport org.aspectj.weaver.tools.GeneratedClassHandler;\n\n/**\n */\npublic class WeavedClassCacheTest extends AbstractCacheBackingTestSupport {\n\tString FAKE_CLASS = \"com.example.foo.Bar\";\n\tbyte[] FAKE_BYTES = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n\tpublic WeavedClassCacheTest () {\n\t\tsuper();\n\t}\n\n\tpublic class MemoryCacheBacking implements CacheBacking {\n\t\tHashMap<String, CachedClassEntry> cache = new HashMap<>();\n\n\t\tpublic String[] getKeys(String regex) {\n\t\t\tSet<String> keys = cache.keySet();\n\t\t\tList<String> matches = new LinkedList<>();\n\t\t\tfor (String key : keys) {\n\t\t\t\tif (key.matches(regex)) {\n\t\t\t\t\tmatches.add(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matches.toArray(new String[0]);\n\t\t}\n\n\t\tpublic void remove(CachedClassReference ref) {\n\t\t\tcache.remove(ref.getKey());\n\t\t}\n\n\t\tpublic void clear() {\n\t\t\tcache.clear();\n\t\t}\n\n\t\tpublic CachedClassEntry get(CachedClassReference ref, byte[] originalBytes) {\n\t\t\treturn cache.get(ref.getKey());\n\t\t}\n\n\t\tpublic void put(CachedClassEntry entry, byte[] originalBytes) {\n\t\t\tassertNotNull(\"put(\" + entry + \") no original bytes\", originalBytes);\n\t\t\tcache.put(entry.getKey(), entry);\n\t\t}\n\t}\n\n\tMemoryCacheBacking memoryBacking = new MemoryCacheBacking();\n\n\tIMessageHandler messageHandler = new IMessageHandler() {\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic boolean isIgnoring(IMessage.Kind kind) {\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\n\t\t\t// do nothing\n\t\t}\n\n\t\tpublic void ignore(IMessage.Kind kind) {\n\t\t\t// do nothing\n\t\t}\n\t};\n\n\tpublic class TestGeneratedClassHandler implements GeneratedClassHandler {\n\t\tpublic int accepts = 0;\n\t\tpublic List<String> classesISaw = new LinkedList<>();\n\n\t\tpublic void acceptClass (String name, byte[] originalBytes, byte[] wovenBytes) {\n\t\t\taccepts++;\n\t\t\tclassesISaw.add(name);\n\t\t}\n\t}\n\n\tTestGeneratedClassHandler generatedClassHandler = new TestGeneratedClassHandler();\n\n\tCacheKeyResolver resolver = new DefaultCacheKeyResolver();\n\n\tprivate WeavedClassCache createCache() throws Exception {\n\t\treturn new WeavedClassCache(generatedClassHandler, messageHandler, \"test\", memoryBacking, resolver);\n\t}\n\n\tprivate void reset() throws Exception {\n\t\tmemoryBacking.cache.clear();\n\t\tgeneratedClassHandler.accepts = 0;\n\t\tgeneratedClassHandler.classesISaw.clear();\n\t}\n\n\tpublic void testGetCachingClassHandler() throws Exception {\n\t\tWeavedClassCache cache = createCache();\n\t\tGeneratedClassHandler newHandle = cache.getCachingClassHandler();\n\t\tassertTrue(generatedClassHandler != newHandle);\n\t\tassertTrue(newHandle instanceof GeneratedCachedClassHandler);\n\t}\n\n\tpublic void testCache() throws Exception {\n\t\treset();\n\t\tWeavedClassCache cache = createCache();\n\t\tCacheStatistics stats = cache.getStats();\n\t\tCachedClassReference ref = cache.createCacheKey(FAKE_CLASS, FAKE_BYTES);\n\t\tassertNull(cache.get(ref, FAKE_BYTES));\n\t\tcache.put(ref, FAKE_BYTES, FAKE_BYTES);\n\t\tassertNotNull(cache.get(ref, FAKE_BYTES));\n\n\t\tassertEquals(new String(FAKE_BYTES), new String(cache.get(ref, FAKE_BYTES).getBytes()));\n\n\t\tref = cache.createGeneratedCacheKey(FAKE_CLASS);\n\t\tassertNull(cache.get(ref, FAKE_BYTES));\n\t\tcache.put(ref, FAKE_BYTES, FAKE_BYTES);\n\t\tassertNotNull(cache.get(ref, FAKE_BYTES));\n\t\tassertEquals(new String(FAKE_BYTES), new String(cache.get(ref, FAKE_BYTES).getBytes()));\n\n\t\tassertEquals(4, stats.getHits());\n\t\tassertEquals(2, stats.getMisses());\n\n\n\t}\n\n\tpublic void testRemove() throws Exception {\n\t\treset();\n\t\tWeavedClassCache cache = createCache();\n\t\tCachedClassReference ref = cache.createCacheKey(FAKE_CLASS, FAKE_BYTES);\n\t\tassertNull(cache.get(ref, FAKE_BYTES));\n\t\tcache.put(ref, FAKE_BYTES, FAKE_BYTES);\n\t\tassertNotNull(cache.get(ref, FAKE_BYTES));\n\t\tcache.remove(ref);\n\t\tassertNull(cache.get(ref, FAKE_BYTES));\n\t}\n\n}\n",
    "size": 4545
  },
  {
    "file_id": "F182",
    "path": "aspectj-master/weaver/src/test/java/org/aspectj/weaver/tools/cache/ZippedFileCacheBackingTest.java",
    "text": "/**\n * Copyright (c) 2012 VMware, Inc.\n *\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n * Lyor Goldstein\n */\n\npackage org.aspectj.weaver.tools.cache;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.TreeMap;\n\nimport org.aspectj.util.FileUtil;\nimport org.aspectj.weaver.tools.cache.AbstractIndexedFileCacheBacking.IndexEntry;\n\n/**\n *\n */\npublic class ZippedFileCacheBackingTest extends AsynchronousFileCacheBackingTestSupport {\n\tprivate File\tzipTestFile;\n\n    public ZippedFileCacheBackingTest() {\n        super();\n    }\n\n    public void testReadIndex () throws Exception {\n        IndexEntry[]    entries={\n                createIgnoredEntry(\"ignored\"),\n                createIndexEntry(\"weaved\", false, false, bytes, bytes),\n                createIndexEntry(\"generated\", true, false, bytes, bytes)\n            };\n        File\tindexFile=getIndexFile();\n        writeIndex(indexFile, entries);\n\n        Map<String,byte[]>  entriesMap= new TreeMap<>();\n        for (IndexEntry ie : entries) {\n            if (ie.ignored) {\n                continue;\n            }\n\n            entriesMap.put(ie.key, bytes);\n        }\n\n        File\tzipFile=getZipFile();\n        ZippedFileCacheBacking.writeZipClassBytes(zipFile, entriesMap);\n\n        File\t\t\t\t\t\t\tcacheDir=getCacheDir();\n        AsynchronousFileCacheBacking    cache=createFileBacking(cacheDir);\n        Map<String, IndexEntry>\t\t\tindexMap=cache.getIndexMap();\n        assertEquals(\"Mismatched index size\", entries.length, indexMap.size());\n\n        Map<String, byte[]> bytesMap=cache.getBytesMap();\n        assertEquals(\"Mismatched bytes size\", entriesMap.size() /* the ignored one has no file */, bytesMap.size());\n\n        for (IndexEntry entry : entries) {\n            String  key=entry.key;\n            assertNotNull(\"Missing entry for key=\" + key, indexMap.get(key));\n\n            if (entry.ignored) {\n                assertNull(\"Unexpected bytes for ignored key=\" + key, bytesMap.get(key));\n            } else {\n                assertArrayEquals(\"Mismatched contents for key=\" + key, bytes, bytesMap.get(key));\n            }\n        }\n    }\n\n    public void testReadWriteZipClassBytes () throws IOException {\n        Map<String,byte[]>  entriesMap= new TreeMap<>();\n        for (int    index=0; index < Byte.SIZE; index++) {\n            String  name=\"classBytes#\" + index;\n            random.nextBytes(bytes);\n            entriesMap.put(name, bytes);\n        }\n\n        File\tzipFile=getZipFile();\n        ZippedFileCacheBacking.writeZipClassBytes(zipFile, entriesMap);\n\n        Map<String, byte[]> bytesMap=ZippedFileCacheBacking.readZipClassBytes(zipFile);\n        assertEquals(\"Mismatched recovered entries size\", entriesMap.size(), bytesMap.size());\n        for (Map.Entry<String,byte[]> bytesEntry : entriesMap.entrySet()) {\n            String  key=bytesEntry.getKey();\n            byte[]  expected=bytesEntry.getValue(), actual=bytesMap.get(key);\n            assertArrayEquals(\"Mismatched data for \" + key, expected, actual);\n        }\n    }\n\n    public void testReadClassBytes () throws IOException {\n        IndexEntry[]    entries={\n                createIgnoredEntry(\"ignoredReadClassBytes\"),\n                createIndexEntry(\"weavedReadClassBytes\", false, false, bytes, bytes),\n                createIndexEntry(\"generatedReadClassBytes\", true, false, bytes, bytes)\n            };\n        File\tindexFile=getIndexFile();\n        writeIndex(indexFile, entries);\n\n        long newCrc=generateNewBytes();\n        assertTrue(\"Bad new CRC\", newCrc != (-1L));\n\n        Map<String,byte[]>  entriesMap= new TreeMap<>();\n        for (IndexEntry ie : entries) {\n            if (ie.ignored) {\n                continue;\n            }\n\n            entriesMap.put(ie.key, bytes);\n        }\n\n        File\tzipFile=getZipFile();\n        ZippedFileCacheBacking.writeZipClassBytes(zipFile, entriesMap);\n\n        File\t\t\t\t\t\t\tcacheDir=getCacheDir();\n        AsynchronousFileCacheBacking    cache=createFileBacking(cacheDir);\n        Map<String, IndexEntry> \t\tindexMap=cache.getIndexMap();\n        assertEquals(\"Mismatched index size\", 1 /* only the ignored entry */, indexMap.size());\n\n        Map<String, byte[]> bytesMap=cache.getBytesMap();\n        assertEquals(\"Non empty data bytes\", 0, bytesMap.size());\n        assertFalse(\"Zip file not deleted: \" + zipFile, zipFile.canRead());\n    }\n\n    protected File getZipFile () {\n    \tif (zipTestFile == null) {\n    \t\tFile\tcacheDir=getCacheDir();\n    \t\tzipTestFile = new File(cacheDir, ZippedFileCacheBacking.ZIP_FILE);\n    \t}\n\n    \treturn zipTestFile;\n    }\n\n    @Override\n\tprotected void cleanupCache() {\n\t\tif (zipTestFile != null) {\n\t\t\tif (FileUtil.deleteContents(zipTestFile) > 0) {\n\t\t\t\tSystem.out.println(\"Deleted \" + zipTestFile);\n\t\t\t}\n\t\t\tzipTestFile = null;\n\t\t}\n\n\t\tsuper.cleanupCache();\n\t}\n\n    @Override\n    protected ZippedFileCacheBacking createFileBacking(File dir) {\n        return new ZippedFileCacheBacking(dir);\n    }\n}\n",
    "size": 5201
  },
  {
    "file_id": "F183",
    "path": "aspectj-master/weaver/src/test/java/reflect/tests/C.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2005 Contributors.\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *   Adrian Colyer\t\t\tInitial implementation\n * ******************************************************************/\npackage reflect.tests;\n\n/**\n * @author colyer\n * Part of the testdata for the org.aspectj.weaver.reflect tests\n */\npublic class C {\n\n\tpublic String foo(Object a) throws Exception {\n\t\treturn null;\n\t}\n\n\tprivate void bar() {}\n\n\tpublic int f;\n\tprivate String s;\n}\n\nclass D extends C implements java.io.Serializable {\n\tpublic int getNumberOfThingies() { return 0; }\n\tprivate Object o;\n}\n",
    "size": 889
  },
  {
    "file_id": "F184",
    "path": "aspectj-master/weaver/src/test/java/test/A.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\npackage test;\n\npublic class A {\n\tpublic void a(String s) {}\n\tpublic void b(@A1 String s) {}\n\tpublic void c(@A1 @A2 String s) {}\n\tpublic void d(@A1 String s,@A2 String t) {}\n\n\tpublic void e(A1AnnotatedType s) {}\n\tpublic void f(A2AnnotatedType s) {}\n\tpublic void g(@A2 A1AnnotatedType s) {}\n\tpublic void h(@A1 A1AnnotatedType s) {}\n\tpublic void i(A1AnnotatedType s,@A2 String t) {}\n\tpublic void j(@A1 @A2 String s) {}\n\n}\n",
    "size": 898
  },
  {
    "file_id": "F185",
    "path": "aspectj-master/weaver/src/test/java/test/A1.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\npackage test;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface A1 {\n\n}\n",
    "size": 641
  },
  {
    "file_id": "F186",
    "path": "aspectj-master/weaver/src/test/java/test/A1AnnotatedType.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\npackage test;\n\n@A1\npublic class A1AnnotatedType {\n\n}\n",
    "size": 532
  },
  {
    "file_id": "F187",
    "path": "aspectj-master/weaver/src/test/java/test/A2.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\npackage test;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface A2 {\n\n}\n",
    "size": 641
  },
  {
    "file_id": "F188",
    "path": "aspectj-master/weaver/src/test/java/test/A2AnnotatedType.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\npackage test;\n\n@A2\npublic class A2AnnotatedType {\n\n}\n",
    "size": 532
  },
  {
    "file_id": "F189",
    "path": "aspectj-master/weaver/src/test/java/test/A3.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\npackage test;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface A3 {\n\tColor value() default Color.RED;\n}\n",
    "size": 674
  },
  {
    "file_id": "F190",
    "path": "aspectj-master/weaver/src/test/java/test/AnnoValues.java",
    "text": "/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\npackage test;\n\npublic class AnnoValues {\n\tpublic void none() {}\n\t@A3 public void defaultMethod() {}\n\t@A3(Color.GREEN) public void greenMethod() {}\n\t@A3(Color.RED) public void redMethod() {}\n\t@A3(Color.BLUE) public void blueMethod() {}\n}\n",
    "size": 716
  },
  {
    "file_id": "F191",
    "path": "aspectj-master/weaver/src/test/java/test/Color.java",
    "text": "package test;\n/* *******************************************************************\n * Copyright (c) 2008 Contributors\n * All rights reserved.\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n *  Contributors\n *  Andy Clement\n * ******************************************************************/\n\npublic enum Color { RED, GREEN, BLUE }\n",
    "size": 533
  },
  {
    "file_id": "F192",
    "path": "aspectj-master/weaver/testdata/AnnotatedClass.java",
    "text": "import p.SimpleAnnotation;\n\n@SimpleAnnotation(id=2)\npublic class AnnotatedClass {\n\n  @SimpleAnnotation(id=3)\n  public void m1() { }\n\n  @SimpleAnnotation(id=4)\n  int i;\n}\n\n",
    "size": 171
  },
  {
    "file_id": "F193",
    "path": "aspectj-master/weaver/testdata/Boo.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Boo {\n  String landmark();\n}\n",
    "size": 115
  },
  {
    "file_id": "F194",
    "path": "aspectj-master/weaver/testdata/Foo.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Foo {\n  String color();\n}\n",
    "size": 112
  },
  {
    "file_id": "F195",
    "path": "aspectj-master/weaver/testdata/Goo.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Goo {\n  String weather();\n}\n",
    "size": 114
  },
  {
    "file_id": "F196",
    "path": "aspectj-master/weaver/testdata/SimpleAnnotation.java",
    "text": "package p;\nimport java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface SimpleAnnotation {\n  int id();\n  String fruit() default \"bananas\";\n}\n",
    "size": 166
  },
  {
    "file_id": "F197",
    "path": "aspectj-master/weaver/testdata/WeavingURLClassLoaderTest/packag/Aspect.aj",
    "text": "package packag;\n\npublic aspect Aspect {\n\tvoid around() : execution(public static void *.main(String[])) {\n\t\t// don't proceed, avoid exception\n\t}\n}\n",
    "size": 147
  },
  {
    "file_id": "F198",
    "path": "aspectj-master/weaver/testdata/WeavingURLClassLoaderTest/packag/Main.java",
    "text": "package packag;\n\npublic class Main {\n    public static void main(String[] args) {\n        throw new Error(\"around advice should have applied here\");\n    }\n}",
    "size": 156
  },
  {
    "file_id": "F199",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnnotatedClass.java",
    "text": "@AnnotationStringElement(stringval=\"hello\")\npublic class AnnotatedClass {\n}\n",
    "size": 76
  },
  {
    "file_id": "F200",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnnotatedFields.java",
    "text": "public class AnnotatedFields {\n  @SimpleAnnotation3(id=1) int i;\n\n  @SimpleAnnotation3(id=2) String s;\n}\n",
    "size": 105
  },
  {
    "file_id": "F201",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnnotatedMethods.java",
    "text": "public class AnnotatedMethods {\n\n  @SimpleAnnotation3(id=1)\n  public void method1() {\n  }\n\n  @SimpleAnnotation3(id=2) \n  public void method2() {\n  }\n}\n",
    "size": 151
  },
  {
    "file_id": "F202",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnnotatedParameters.java",
    "text": "public class AnnotatedParameters {\n\n\n  public static void main(@SimpleAnnotation(id=1) String args[]) {\n  }\n\n  public void foo(@SimpleAnnotation(id=2) int arg1, \n                  @SimpleAnnotation(id=3) @AnnotationEnumElement(enumval=SimpleEnum.Red) String arg2) {\n    try {\n      throw new RuntimeException(\"eee\");\n    } catch (@SimpleAnnotation(id=5) Exception ex) {\n    }\n  }\n\n}\n",
    "size": 383
  },
  {
    "file_id": "F203",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnnotatedWithClassClass.java",
    "text": "@AnnotationClassElement(clz=Integer.class)\npublic class AnnotatedWithClassClass {\n}\n",
    "size": 84
  },
  {
    "file_id": "F204",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnnotatedWithCombinedAnnotation.java",
    "text": "@CombinedAnnotation({@SimpleAnnotation(id=4)})\npublic class AnnotatedWithCombinedAnnotation {\n}\n",
    "size": 96
  },
  {
    "file_id": "F205",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnnotatedWithEnumClass.java",
    "text": "@AnnotationEnumElement(enumval=SimpleEnum.Red)\npublic class AnnotatedWithEnumClass {\n}\n",
    "size": 87
  },
  {
    "file_id": "F206",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnnotationClassElement.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AnnotationClassElement {\n  Class clz();\n}\n",
    "size": 128
  },
  {
    "file_id": "F207",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnnotationEnumElement.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AnnotationEnumElement {\n  SimpleEnum enumval();\n}\n",
    "size": 136
  },
  {
    "file_id": "F208",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnnotationStringElement.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AnnotationStringElement {\n  String stringval();\n}\n",
    "size": 136
  },
  {
    "file_id": "F209",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AnonymousClassTest.java",
    "text": "public class AnonymousClassTest {\n\t\n\tpublic void foo() {\n\t\t\n\t\tnew Runnable() {\n\t\t\tpublic void run() {};\n\t\t}.run();\n\t\t\n\t\t\n\t}\n\t\n\tclass X {}\n\t\n\tstatic class Y {}\n\t\n}",
    "size": 162
  },
  {
    "file_id": "F210",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AspectFromHell.java",
    "text": "import java.util.*;\n\npublic aspect AspectFromHell {\n\n  public void Foo.m1() {}\n  public int Foo.m2() {return 2;}\n  public void Foo.m3(String s) {}\n  public Foo.new(String s) {super();}\n  public int Foo.x;\n  public List Foo.y;\n\n\n  before(): execution(void Goo.m1()) {}\n  after(): execution(void Goo.m2(String)) { System.err.println(thisJoinPoint);}\n  void around(int i): execution(void Goo.m3(..)) && args(i) { }\n\n  class Goo {\n    void m1() {}\n    void m2(String s) {}\n    void m3(int i) {}\n  }\n}\n\n  class Foo { }\n",
    "size": 514
  },
  {
    "file_id": "F211",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AttributeTestClassEM01.java",
    "text": "public class AttributeTestClassEM01 {\n\n  public static void main(String[]argv) {\n    class S {\n      public void sayhello() { System.err.println(\"hello\");}\n    }\n  }\n}\n",
    "size": 168
  },
  {
    "file_id": "F212",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/AttributeTestClassEM02.java",
    "text": "public class AttributeTestClassEM02 {\n\n    Runnable r = new Runnable() {\n      public void run() { System.err.println(\"hello\");}\n    };\n  public static void main(String[]argv) {\n  }\n}\n",
    "size": 184
  },
  {
    "file_id": "F213",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/CombinedAnnotation.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CombinedAnnotation {\n public SimpleAnnotation[] value();\n}\n",
    "size": 145
  },
  {
    "file_id": "F214",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/Complex.java",
    "text": "// Class contains everything, for delegate comparing..\n\npublic class Complex {\n\n  int field1;\n  String field2;\n  Foo[] field3;\n\n\n\n  static class Foo {\n  }\n}\n",
    "size": 157
  },
  {
    "file_id": "F215",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/ComplexAnnotatedClass.java",
    "text": "@ComplexAnnotation(ival=4,bval=2,cval='5',fval=3.0f,dval=33.4,zval=false,jval=56,sval=99)\npublic class ComplexAnnotatedClass {\n}\n",
    "size": 129
  },
  {
    "file_id": "F216",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/ComplexAnnotation.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ComplexAnnotation {\n  int ival();\n  byte bval();\n  char cval();\n  long jval();\n  double dval();\n  boolean zval();\n  short sval();\n  float fval();\n}\n",
    "size": 234
  },
  {
    "file_id": "F217",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/ErasureTestData.java",
    "text": "import java.util.*;\n\npublic class ErasureTestData {\n\n  public Vector<String> getData() { return null; }\n\n}\n",
    "size": 107
  },
  {
    "file_id": "F218",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/HelloWorld.java",
    "text": "import java.io.*;\n\npublic class HelloWorld {\n      public static void main(String[] argv) {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String name = null;\n\n        try {\n\t      System.out.print(\"Please enter your name> \");\n\t      name = in.readLine();\n        } catch(IOException e) { return; }\n          System.out.println(\"Hello, \" + name);\n      }\n    }\n",
    "size": 404
  },
  {
    "file_id": "F219",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/MarkedType.java",
    "text": "@MarkerAnnotationInvisible\n@MarkerAnnotation\npublic class MarkedType {\n}\n",
    "size": 73
  },
  {
    "file_id": "F220",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/MarkerAnnotation.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MarkerAnnotation { }\n",
    "size": 107
  },
  {
    "file_id": "F221",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/MarkerAnnotationInvisible.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.CLASS)\npublic @interface MarkerAnnotationInvisible { }\n",
    "size": 114
  },
  {
    "file_id": "F222",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/PossibleGenericsSigs.java",
    "text": "import java.util.*;\n\npublic class PossibleGenericsSigs {\n\n  public void a(List<String> List_String) {}\n\n  public void b(List<Double> List_Double) {}\n\n  public void c(List<? extends Number> q_extends_Number) {}\n\n  public void d(List<? super Number> q_super_Number) {}\n\n  public void e(List<?> List_q) {}\n\n  public void f(Map<?,? super Number> Map_q_q_super_Number) {}\n\n\n\n  <T extends Object & Comparable<? super T>> void r(List<T> l) {}\n\n  <T extends Object & Comparable<? super T>> T s(Collection<T> col) {return null;}\n  \n  static <T extends Comparable<? super Number>> T t(Collection<T> col) {return null;}\n\n  static <T extends Comparable<T>> T u(Collection<T> col) {return null;}\n\n  <X> X v(Collection<X> x) {return null;}\n\n  public void w(List<List<List<List<List<? extends List>>>>> wtf) {}\n \n  static <T> void x(List <T> a,List<? extends T> b) {}\n\n  <T extends Number> void y(Map<T,? super Number> n) {}\n\n  static <T> void z(T[] ts,Collection<T> c) {}\n}\n",
    "size": 960
  },
  {
    "file_id": "F223",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleAnnotatedClass.java",
    "text": "@SimpleAnnotation(id=4)\npublic class SimpleAnnotatedClass {\n}\n",
    "size": 62
  },
  {
    "file_id": "F224",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleAnnotation.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.SOURCE)\npublic @interface SimpleAnnotation {\n  int id();\n  String fruit() default \"bananas\";\n}\n",
    "size": 154
  },
  {
    "file_id": "F225",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleAnnotation2.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.CLASS)\npublic @interface SimpleAnnotation2 {\n  int id();\n  String fruit() default \"bananas\";\n}\n\n",
    "size": 155
  },
  {
    "file_id": "F226",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleAnnotation3.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface SimpleAnnotation3 {\n  int id();\n  String fruit() default \"bananas\";\n}\n\n",
    "size": 157
  },
  {
    "file_id": "F227",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleAnnotation4.java",
    "text": "import java.lang.annotation.*;\n\npublic @interface SimpleAnnotation4 {\n  int id();\n  String fruit() default \"bananas\";\n}\n\n",
    "size": 121
  },
  {
    "file_id": "F228",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleAspect.java",
    "text": "public aspect SimpleAspect {\n  pointcut p(): call(* *(..));\n\n  before(): p() {\n    \n  }\n\n  int SimpleAspect.i;\n\n  public void SimpleAspect.m() { }\n\n}\n",
    "size": 150
  },
  {
    "file_id": "F229",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleClass.java",
    "text": "public class SimpleClass {\n  public static void main(String[] argv) {\n    // Nothing unusual in this class\n  }\n}\n",
    "size": 113
  },
  {
    "file_id": "F230",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleEnum.java",
    "text": "public enum SimpleEnum { Red,Orange,Yellow,Green,Blue,Indigo,Violet };\n",
    "size": 71
  },
  {
    "file_id": "F231",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleGenericsProgram.java",
    "text": "import java.util.*;\n\nclass TreasureChest<T> {\n\n  protected Set<T> contents;\n\n  public TreasureChest() {\n    contents = new HashSet<T>();\n  }\n\n  public void add(T o) {\n    contents.add(o);\n  }\n}\n\npublic class SimpleGenericsProgram {\n\n  public static void main(String []argv) {\n    TreasureChest<String> tc1 = new TreasureChest<String>();\n    TreasureChest<Integer> tc2 = new TreasureChest<Integer>();\n\n    tc1.add(\"dubloon\");\n    tc2.add(new Integer(\"777\"));\n\n  }\n}\n",
    "size": 465
  },
  {
    "file_id": "F232",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleGenericsUsage.java",
    "text": "import java.util.*;\n\npublic class SimpleGenericsUsage {\n\n  public static void main(String[]argv) {\n    ArrayList<String> fruits = new ArrayList<String>();\n    fruits.add(\"Oranges\");\n    fruits.add(\"Apples\");\n    fruits.add(\"Pears\");\n    System.err.println(fruits.size()+\" fruits defined\");\n  }\n}\n",
    "size": 296
  },
  {
    "file_id": "F233",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleStringAnnotation.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface SimpleStringAnnotation {\n  String fruit();\n}\n",
    "size": 131
  },
  {
    "file_id": "F234",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleType.java",
    "text": "class SimpleType {\n  public  Integer i;\n\n  public void setI(Integer i) { this.i=i;}\n  public Integer getI() { return i;}\n}\n",
    "size": 123
  },
  {
    "file_id": "F235",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/SimpleVarargs.java",
    "text": "\npublic class SimpleVarargs {\n  public static void main(String[] argv) {\n    callfoo(\"a\",\"b\",\"c\",\"d\",\"e\");\n  }\n\n  public static void callfoo(Object... args) {\n    for (int i = 0 ; i<args.length;i++) {\n      System.err.println(args[i]);\n    }\n  }\n}\n",
    "size": 248
  },
  {
    "file_id": "F236",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/VarargsClass.java",
    "text": "public class VarargsClass {\n\n  public void foo(String abc,String... args) { }\n\n  public void goo(String... args) { }\n\n  public void hoo() {}\n\n}\n",
    "size": 144
  },
  {
    "file_id": "F237",
    "path": "aspectj-master/weaver/testdata/forAsmDelegateTesting/VerySimpleAnnotation.java",
    "text": "import java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface VerySimpleAnnotation {\n  int id();\n}\n",
    "size": 123
  },
  {
    "file_id": "F238",
    "path": "aspectj-master/weaver/testinputdata/org/aspectj/weaver/test/Aspect.java",
    "text": "/* This file is part of the compiler and core tools for the AspectJ(tm)\n * programming language; see https://aspectj.org\n *\n * The contents of this file are subject to the Mozilla Public License\n * Version 1.1 (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n * either https://www.mozilla.org/MPL/ or https://aspectj.org/MPL/.\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is AspectJ.\n *\n * The Initial Developer of the Original Code is Palo Alto Research Center,\n * Incorporated (PARC). Portions created by PARC are are\n * Copyright (C) 2002 Palo Alto Research Center, Incorporated.\n * All Rights Reserved.\n *\n * Contributor(s):\n */\npackage org.aspectj.weaver.test;\nimport java.util.*;\n\nimport org.aspectj.runtime.internal.*;\nimport org.aspectj.runtime.internal.AroundClosure;\nimport org.aspectj.lang.JoinPoint;\n\npublic class Aspect {\n\n\tpublic static void ajc_before_0() {\n\t\tSystem.out.println(\"before_0\");\t\t\n\t}\n \tpublic static void ajc_before_0(String s) {\n\t\tSystem.out.println(\"before_0: \" + s);\t\t\n\t}\n    public static boolean ajc_around_0(ArrayList s, AroundClosure c) throws Throwable {\n        System.out.println(\"doing around, got \" + s);\n        Object ret = c.run(new Object[] {s}); // proceed(s)\n        return ((Boolean) ret).booleanValue();   \n    }\n\n\tpublic static void ajc_before_0(java.util.ArrayList list) {\n\t\tSystem.out.println(\"before_0: \" + list);\t\t\n\t}\n\n\tpublic static void ajc_before_method_execution() {\n\n\t}\t\n\tpublic static void ajc_before_method_execution(Object o) {\n\t\tSystem.out.println(\"before_method_execution: \" + o);\n\t}\n\n    public static void ajc_after_method_execution() {\n        System.out.println(\"after_method_execution\");\n    }    \n    public static void ajc_after_method_execution(Object o) {\n        System.out.println(\"after_method_execution: \" + o);\n    }\n    \n    public static void ajc_afterReturning_method_execution() {\n        System.out.println(\"ajc_afterReturning_method_execution\");\n    }           \t\n\tpublic static void ajc_afterReturning_method_execution(Object o) {\n\t\tSystem.out.println(\"afterReturning_method_execution: \" + o);\n\t}\n\n    public static void ajc_afterThrowing_method_execution() {\n        System.out.println(\"ajc_afterThrowing_method_execution\");\n    }               \n    public static void ajc_afterThrowing_method_execution(Object o) {\n        System.out.println(\"afterThrowing_method_execution: \" + o);\n    }    \n\n\n\n\n        \n    public static Object ajc_around(AroundClosure closure) throws Throwable {\n        Object ret = closure.run(new Object[] {});\n        return ret;\n    }   \n    \n    public static Object ajc_around(AroundClosure closure, JoinPoint tjp) throws Throwable {\n        System.out.println(\"thisJoinPoint: \" + tjp);\n        Object ret = closure.run(new Object[] {});\n        return ret;\n    }   \n    \n    // ---    \n    \n    \n    public static void ajc_before_method_call() {\n        System.out.println(\"before_method_call\");\n    }    \n    public static void ajc_before_method_call(Object o) {\n        System.out.println(\"before_method_call: \" + o);\n    }\n        \n    public static void ajc_after_method_call() {\n        System.out.println(\"after_method_call\");\n    }    \n    public static void ajc_after_method_call(Object o) {\n        System.out.println(\"after_method_call: \" + o);\n    }       \n\t\n    public static void ajc_afterReturning_method_call() {\n        System.out.println(\"ajc_afterReturning_method_call\");\n    }\n\tpublic static void ajc_afterReturning_method_call(Object o) {\n\t\tSystem.out.println(\"afterReturning_method_call: \" + o);\n\t}\n\t\n    public static void ajc_afterThrowing_method_call() {\n        System.out.println(\"ajc_afterThrowing_method_call\");\n    }\n    public static void ajc_afterThrowing_method_call(Object o) {\n        System.out.println(\"afterThrowing_method_call: \" + o);\n    }    \n    \n    public static Object ajc_around_method_call(AroundClosure closure) throws Throwable {\n        Object ret = null;\n        for (int i=0; i<3; i++) {\n            System.out.println(\"enter: \" + i);\n            ret = closure.run(new Object[] {});\n        }\n        return ret;\n    }\n    \n    // ----\n\n    public static void ajc_before_constructor_call() {\n        System.out.println(\"before_constructor_call\");\n    }    \n    public static void ajc_before_constructor_call(Object o) {\n        System.out.println(\"before_constructor_call: \" + o);\n    }\n        \n    public static void ajc_after_constructor_call() {\n        System.out.println(\"after_constructor_call\");\n    }    \n    public static void ajc_after_constructor_call(Object o) {\n        System.out.println(\"after_constructor_call: \" + o);\n    }       \n\t\n    public static void ajc_afterReturning_constructor_call() {\n        System.out.println(\"ajc_afterReturning_constructor_call\");\n    }\n\tpublic static void ajc_afterReturning_constructor_call(Object o) {\n\t\tSystem.out.println(\"afterReturning_constructor_call: \" + o);\n\t}\n\t\n    public static void ajc_afterThrowing_constructor_call() {\n        System.out.println(\"ajc_afterThrowing_constructor_call\");\n    }\n    public static void ajc_afterThrowing_constructor_call(Object o) {\n        System.out.println(\"afterThrowing_constructor_call: \" + o);\n    }    \n    \n    public static Object ajc_around_constructor_call(AroundClosure closure) throws Throwable {\n        Object ret = null;\n        for (int i=0; i<3; i++) {\n            System.out.println(\"enter: \" + i);\n            ret = closure.run(new Object[] {});\n        }\n        return ret;\n    }    \n    // ----\n\n    public static void ajc_before_constructor_execution() {\n        System.out.println(\"before_constructor_execution\");\n    }    \n    public static void ajc_before_constructor_execution(Object o) {\n        System.out.println(\"before_constructor_execution: \" + o);\n    }\n        \n    public static void ajc_after_constructor_execution() {\n        System.out.println(\"after_constructor_execution\");\n    }    \n    public static void ajc_after_constructor_execution(Object o) {\n        System.out.println(\"after_constructor_execution: \" + o);\n    }       \n\t\n    public static void ajc_afterReturning_constructor_execution() {\n        System.out.println(\"ajc_afterReturning_constructor_execution\");\n    }\n\tpublic static void ajc_afterReturning_constructor_execution(Object o) {\n\t\tSystem.out.println(\"afterReturning_constructor_execution: \" + o);\n\t}\n\t\n    public static void ajc_afterThrowing_constructor_execution() {\n        System.out.println(\"ajc_afterThrowing_constructor_execution\");\n    }\n    public static void ajc_afterThrowing_constructor_execution(Object o) {\n        System.out.println(\"afterThrowing_constructor_execution: \" + o);\n    }    \n    \n    public static Object ajc_around_constructor_execution(AroundClosure closure) throws Throwable {\n        Object ret = null;\n        for (int i=0; i<3; i++) {\n            System.out.println(\"enter: \" + i);\n            ret = closure.run(new Object[] {});\n        }\n        return ret;\n    }    \n    \n    \n    // ---\n\n\t\n\tpublic static void ajc_before_field_get() {\n\t\tSystem.out.println(\"before_field_get\");\n\t}   \n    public static void ajc_before_field_get(Object o) {\n        System.out.println(\"before_field_get: \" + o);\n    }\n    \n    public static void ajc_after_field_get() {\n        System.out.println(\"after_field_get\");\n    }    \n    public static void ajc_after_field_get(Object o) {\n        System.out.println(\"after_field_get: \" + o);\n    }\n    \n    public static void ajc_afterReturning_field_get() {\n        System.out.println(\"afterReturning_field_get\");\n    }    \n    public static void ajc_afterReturning_field_get(Object o) {\n        System.out.println(\"afterReturning_field_get: \" + o);\n    }\n\n    public static void ajc_afterThrowing_field_get() {\n        System.out.println(\"afterThrowing_field_get\");\n    }    \n    public static void ajc_afterThrowing_field_get(Object o) {\n        System.out.println(\"afterThrowing_field_get: \" + o);\n    }\n    public static void ajc_afterThrowing_field_get(Throwable t) {\n        System.out.println(\"afterThrowing_field_get: \" + t);\n    }\n\n\tpublic static Object ajc_around_field_get(AroundClosure closure) throws Throwable {\n\t\tObject ret = closure.run(new Object[] {});\n\t\treturn ret;\n\t}\n\t\n   \n    // ---\n\n\t\n\tpublic static void ajc_before_field_set() {\n\t\tSystem.out.println(\"before_field_set\");\n\t}   \n    public static void ajc_before_field_set(Object o) {\n        System.out.println(\"before_field_set: \" + o);\n    }\n    \n    public static void ajc_after_field_set() {\n        System.out.println(\"after_field_set\");\n    }    \n    public static void ajc_after_field_set(Object o) {\n        System.out.println(\"after_field_set: \" + o);\n    }\n    \n    public static void ajc_afterReturning_field_set() {\n        System.out.println(\"afterReturning_field_set\");\n    }    \n    public static void ajc_afterReturning_field_set(Object o) {\n        System.out.println(\"afterReturning_field_set: \" + o);\n    }\n\n    public static void ajc_afterThrowing_field_set() {\n        System.out.println(\"afterThrowing_field_set\");\n    }    \n    public static void ajc_afterThrowing_field_set(Object o) {\n        System.out.println(\"afterThrowing_field_set: \" + o);\n    }\n    public static void ajc_afterThrowing_field_set(Throwable t) {\n        System.out.println(\"afterThrowing_field_set: \" + t);\n    }\n\n\tpublic static Object ajc_around_field_set(AroundClosure closure) throws Throwable {\n\t\tObject ret = closure.run(new Object[] {});\n\t\treturn ret;\n\t}\t\n\t\n\t// don't call this method for callee-side call join points\n\tpublic static void ajc_before(JoinPoint.StaticPart tjp) {\n\t\tSystem.out.println(\"before: \" + tjp);\n\t\tif (tjp.getSourceLocation() == null) {\n\t\t\tthrow new RuntimeException(\"didn't want null\");\n\t\t}\n\t\tSystem.out.println(\"   loc: \" + tjp.getSourceLocation());\n\t}\n\t\n\tpublic static void ajc_before(JoinPoint tjp) {\n\t\tSystem.out.println(\"before: \" + tjp + \" this = \" + tjp.getThis() + \n\t\t\t\t\" target = \" + tjp.getTarget() +\n\t\t\t\t\" args = \" + Arrays.asList(tjp.getArgs()));\n\t}\n\t\n\t// per object stuff\n\t\n\tprivate static Map objects = new HashMap();\n\t\n\tpublic static void ajc$perObjectBind(Object o) {\n\t\tif (objects.containsKey(o)) return;\n\t\tobjects.put(o, new Aspect());\n\t}\n\t\n\tpublic static boolean hasAspect(Object o) {\n\t\treturn objects.containsKey(o);\n\t}\n\t\n\tpublic static Aspect aspectOf(Object o) {\n\t\treturn (Aspect) objects.get(o);\n\t}\t\n\t\n\t\n\t// per cflow stuff\n\t\n\tpublic static void ajc$perCflowPush() {\n\t\tajc$perCflowStack.pushInstance(new Aspect());\n\t}\n\t\n\tpublic static boolean hasAspect() {\n\t\treturn ajc$perCflowStack.isValid();\n\t}\n\t\n\tpublic static Aspect aspectOf() {\n\t\tif (ajc$perSingletonInstance != null) return ajc$perSingletonInstance;\n\t\t\n\t\treturn (Aspect) ajc$perCflowStack.peekInstance();\n\t}\n\t\n\tpublic static CFlowStack ajc$perCflowStack = new CFlowStack();\n\t\n\t// non-static methods\n\t\n\tpublic static Aspect ajc$perSingletonInstance = new Aspect();\n\tpublic void ajc_before() {\n\t\tSystem.out.println(\"before in: \" + this);\n\t}\n\t\n    public static CFlowStack ajc$cflowStack$0 = new CFlowStack();\n\t\n\t\n}\n",
    "size": 11277
  },
  {
    "file_id": "F239",
    "path": "aspectj-master/weaver/testinputdata/org/aspectj/weaver/test/DynamicHelloWorld.java",
    "text": "/* Copyright (c) 2002 Contributors.\n *\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n */\npackage org.aspectj.weaver.test;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * FIXME regen with an Eclipse 2.1 the testdata/bin with this new package\n * same for all classes in that package\n * and update tests then (pointcuts etc)\n *\n * @version \t1.0\n * @author\n */\npublic class DynamicHelloWorld implements Serializable {\n\n    public static void main(String[] args) {\n    \ttry {\n\t\t\tnew DynamicHelloWorld().doit(\"hello\", Collections.EMPTY_LIST);\n\t\t} catch (UnsupportedOperationException t) {\n\t\t\tSystem.out.println(\"expected and caught: \" + t);\n\t\t\treturn;\n\t\t}\n\t\tthrow new RuntimeException(\"should have caught exception\");\n    }\n\n    String doit(String s, List l) {\n    \tl.add(s);   // this will throw an exception\n    \treturn l.toString();\n    }\n}\n",
    "size": 1091
  },
  {
    "file_id": "F240",
    "path": "aspectj-master/weaver/testinputdata/org/aspectj/weaver/test/FancyHelloWorld.java",
    "text": "/* Copyright (c) 2002 Contributors.\n *\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n */\npackage org.aspectj.weaver.test;\n\nimport java.io.PrintStream;\n\n/**\n * @version \t1.0\n * @author\n */\npublic abstract class FancyHelloWorld {\n    public static void main(String[] args) {\n    \tPrintStream out = System.out;\n    \ttry {\n    \t\tout.println(\"bye\");\n    \t} catch (Exception e) {\n    \t\tout.println(e);\n    \t} finally {\n    \t\tout.println(\"finally\");\n    \t}\n    }\n\n    public static String getName() {\n    \tint x = 0;\n    \tx += \"name\".hashCode();\n    \treturn \"name\" + x;\n    }\n}\n",
    "size": 825
  },
  {
    "file_id": "F241",
    "path": "aspectj-master/weaver/testinputdata/org/aspectj/weaver/test/FieldyHelloWorld.java",
    "text": "/* Copyright (c) 2002 Contributors.\n *\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n */\npackage org.aspectj.weaver.test;\n\npublic class FieldyHelloWorld {\n\n\tpublic static String str = \"Hello\";\n\n    public static void main(String[] args) {\n        str += \" World\";\n\n        System.out.println(str);\n    }\n}\n",
    "size": 560
  },
  {
    "file_id": "F242",
    "path": "aspectj-master/weaver/testinputdata/org/aspectj/weaver/test/HelloWorld.java",
    "text": "/* Copyright (c) 2002 Contributors.\n *\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n */\npackage org.aspectj.weaver.test;\n\n/**\n * @version \t1.0\n * @author\n */\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n        System.out\n        .println(\"hello world\");\n        //System.out.println(\"hello world\");\n    }\n}\n",
    "size": 590
  },
  {
    "file_id": "F243",
    "path": "aspectj-master/weaver/testinputdata/org/aspectj/weaver/test/MultiArgHelloWorld.java",
    "text": "/* Copyright (c) 2002 Contributors.\n *\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n */\npackage org.aspectj.weaver.test;\n\npublic class MultiArgHelloWorld {\n\n    public static void main(String[] args) {\n    \tfoo(\"Hello\", \"World\");\n    }\n\n    static void foo(Object s, Object t) {\n    \tSystem.out.println(s + \" \" + t);\n    }\n}\n",
    "size": 580
  },
  {
    "file_id": "F244",
    "path": "aspectj-master/weaver/testinputdata/org/aspectj/weaver/test/Test.java",
    "text": "/* Copyright (c) 2002 Contributors.\n *\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n */\npackage org.aspectj.weaver.test;\n\nimport junit.framework.TestCase;\n\npublic class Test extends TestCase {\n    public static void main(String[] args) {\n        foo()\n        .\n        foo();\n    }\n    public static Test foo() {\n        new Exception().printStackTrace();\n        return new Test();\n    }\n    public void testNothingForAntJUnit() {}\n}\n",
    "size": 691
  },
  {
    "file_id": "F245",
    "path": "aspectj-master/weaver/testinputdata/org/aspectj/weaver/test/TestSwitchy.java",
    "text": "/* Copyright (c) 2002 Contributors.\n *\n * This program and the accompanying materials are made available\n * under the terms of the Eclipse Public License v 2.0\n * which accompanies this distribution and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.txt\n *\n * Contributors:\n *     PARC     initial implementation\n */\npackage org.aspectj.weaver.test;\n\n/**\n * @author hilsdale\n *\n * To change this generated comment edit the template variable \"typecomment\":\n * Window>Preferences>Java>Templates.\n * To enable and disable the creation of type comments go to\n * Window>Preferences>Java>Code Generation.\n */\npublic abstract class TestSwitchy {\n\n\n    public int i = 3;\n\n    public static final int j = 4;\n\n\n    public static void main(String[] args) {\n        switch (args.length) {\n            case 0: System.err.println(\"hi\");\n            case 1: System.err.println(\"bye\"); break;\n            case 2: System.err.println(\"two\");\n            default: System.err.println(\"ning\");\n        }\n        System.err.println(\"done\");\n    }\n\n\n    abstract int goo();\n\n    void nimbo() {}\n}\n",
    "size": 1100
  }
]