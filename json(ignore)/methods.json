[
  {
    "method_id": "M1",
    "name": "AnnotationAccessFieldVar",
    "return_type": "",
    "signature": "AnnotationAccessFieldVar(AnnotationAccessVar aav, ResolvedType annoFieldOfInterest, String name)",
    "file_id": "F3",
    "start_line": 44,
    "text_preview": " annoAccessor;\\n\tprivate ResolvedType annoFieldOfInterest;\\n\tprivate String name;\\n\tprivate int elementValueType;\\n\\n\tpublic AnnotationAccessFieldVar(AnnotationAccessVar aav, ResolvedType annoFieldOfInterest, String name) {\\n\t\tsuper(annoFieldOfInterest, 0);\\n\t\tthis.annoAccessor = aav;\\n\t\tthis.name = name;\\n\t\tString sig = annoFi"
  },
  {
    "method_id": "M2",
    "name": "appendLoadAndConvert",
    "return_type": "void",
    "signature": "appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType)",
    "file_id": "F3",
    "start_line": 68,
    "text_preview": "throw new IllegalStateException(sig);\\n\t\t}\\n\t\tthis.annoFieldOfInterest = annoFieldOfInterest;\\n\t}\\n\\n\t@Override\\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\\n\t\t// Only possible to do annotation field value extraction at MethodExecution\\n\t\tif (annoAccessor.getKind() != S"
  },
  {
    "method_id": "M3",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ anno : annos)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember annotationField : annotationFields)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M5",
    "name": "for",
    "return_type": "",
    "signature": "for(NameValuePair nvp : nvps)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M6",
    "name": "if",
    "return_type": "name",
    "signature": "if(countOfType > 1)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M7",
    "name": "if",
    "return_type": "",
    "signature": "if(o instanceof EnumElementValue)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M8",
    "name": "if",
    "return_type": "else",
    "signature": "if(o instanceof SimpleElementValue)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M9",
    "name": "if",
    "return_type": "",
    "signature": "if(foundValueInAnnotationUsage)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M10",
    "name": "if",
    "return_type": "values",
    "signature": "if(!foundValueInAnnotationUsage)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M11",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember annotationField : annotationFields)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M12",
    "name": "if",
    "return_type": "",
    "signature": "if(countOfType > 1)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M13",
    "name": "if",
    "return_type": "",
    "signature": "if(foundValueInAnnotationUsage)",
    "file_id": "F3",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M14",
    "name": "insertLoad",
    "return_type": "void",
    "signature": "insertLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F3",
    "start_line": 173,
    "text_preview": "\tbreak;\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tif (foundValueInAnnotationUsage) {\\n\t\t\t\tbreak;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\\n\t\t// Only possible to do annotation field value extraction at\\n\t\t// MethodExecution\\n\t\tif (annoAccessor.getKind() != Shadow.MethodExecution) {\\n\t"
  },
  {
    "method_id": "M15",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F3",
    "start_line": 183,
    "text_preview": ".MethodExecution) {\\n\t\t\treturn;\\n\t\t}\\n\t\tappendLoadAndConvert(il, fact, annoFieldOfInterest);\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn super.toString();\\n\t}\\n}\\n"
  },
  {
    "method_id": "M16",
    "name": "AnnotationAccessVar",
    "return_type": "",
    "signature": "AnnotationAccessVar(BcelShadow shadow, Kind kind, ResolvedType annotationType, UnresolvedType theTargetIsStoredHere,\n\t\t\tMember sig, boolean isWithin)",
    "file_id": "F4",
    "start_line": 44,
    "text_preview": "points)\\n\tprivate boolean isWithin; // implies @within() or @withincode(). If false, that implies @annotation()\\n\\n\tpublic AnnotationAccessVar(BcelShadow shadow, Kind kind, ResolvedType annotationType, UnresolvedType theTargetIsStoredHere,\\n\t\t\tMember sig, boolean isWithin) {\\n\t\tsuper(annotationType, 0);\\n\t\tthis.shadow = shad"
  },
  {
    "method_id": "M17",
    "name": "getKind",
    "return_type": "Kind",
    "signature": "getKind()",
    "file_id": "F4",
    "start_line": 54,
    "text_preview": " kind;\\n\t\tthis.containingType = theTargetIsStoredHere;\\n\t\tthis.member = sig;\\n\t\tthis.isWithin = isWithin;\\n\t}\\n\\n\tpublic Kind getKind() {\\n\t\treturn kind;\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn \"AnnotationAccessVar(\" + getType() + \")\";\\n\t}\\n\\n\t@Override\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\tthro"
  },
  {
    "method_id": "M18",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F4",
    "start_line": 59,
    "text_preview": "his.member = sig;\\n\t\tthis.isWithin = isWithin;\\n\t}\\n\\n\tpublic Kind getKind() {\\n\t\treturn kind;\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn \"AnnotationAccessVar(\" + getType() + \")\";\\n\t}\\n\\n\t@Override\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\tthrow new IllegalStateException(\"unimplemented\");\\n\t}\\n\\n\t@Overr"
  },
  {
    "method_id": "M19",
    "name": "createLoad",
    "return_type": "Instruction",
    "signature": "createLoad(InstructionFactory fact)",
    "file_id": "F4",
    "start_line": 64,
    "text_preview": "rride\\n\tpublic String toString() {\\n\t\treturn \"AnnotationAccessVar(\" + getType() + \")\";\\n\t}\\n\\n\t@Override\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\tthrow new IllegalStateException(\"unimplemented\");\\n\t}\\n\\n\t@Override\\n\tpublic Instruction createStore(InstructionFactory fact) {\\n\t\tthrow new IllegalStateException(\"u"
  },
  {
    "method_id": "M20",
    "name": "createStore",
    "return_type": "Instruction",
    "signature": "createStore(InstructionFactory fact)",
    "file_id": "F4",
    "start_line": 69,
    "text_preview": "eLoad(InstructionFactory fact) {\\n\t\tthrow new IllegalStateException(\"unimplemented\");\\n\t}\\n\\n\t@Override\\n\tpublic Instruction createStore(InstructionFactory fact) {\\n\t\tthrow new IllegalStateException(\"unimplemented\");\\n\t}\\n\\n\t@Override\\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tthrow new Ill"
  },
  {
    "method_id": "M21",
    "name": "createCopyFrom",
    "return_type": "InstructionList",
    "signature": "createCopyFrom(InstructionFactory fact, int oldSlot)",
    "file_id": "F4",
    "start_line": 74,
    "text_preview": "e(InstructionFactory fact) {\\n\t\tthrow new IllegalStateException(\"unimplemented\");\\n\t}\\n\\n\t@Override\\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tthrow new IllegalStateException(\"unimplemented\");\\n\t}\\n\\n\t@Override\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.ap"
  },
  {
    "method_id": "M22",
    "name": "appendLoad",
    "return_type": "void",
    "signature": "appendLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F4",
    "start_line": 79,
    "text_preview": "InstructionFactory fact, int oldSlot) {\\n\t\tthrow new IllegalStateException(\"unimplemented\");\\n\t}\\n\\n\t@Override\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createLoadInstructions(getType(), fact));\\n\t}\\n\\n\t@Override\\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory "
  },
  {
    "method_id": "M23",
    "name": "appendLoadAndConvert",
    "return_type": "void",
    "signature": "appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType)",
    "file_id": "F4",
    "start_line": 84,
    "text_preview": "onList il, InstructionFactory fact) {\\n\t\til.append(createLoadInstructions(getType(), fact));\\n\t}\\n\\n\t@Override\\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\\n\t\til.append(createLoadInstructions(toType, fact));\\n\t}\\n\\n\t@Override\\n\tpublic void insertLoad(InstructionList il, I"
  },
  {
    "method_id": "M24",
    "name": "insertLoad",
    "return_type": "void",
    "signature": "insertLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F4",
    "start_line": 89,
    "text_preview": "tionFactory fact, ResolvedType toType) {\\n\t\til.append(createLoadInstructions(toType, fact));\\n\t}\\n\\n\t@Override\\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.insert(createLoadInstructions(getType(), fact));\\n\t}\\n\\n\tprivate InstructionList createLoadInstructions(ResolvedType toType, InstructionFact"
  },
  {
    "method_id": "M25",
    "name": "createLoadInstructions",
    "return_type": "InstructionList",
    "signature": "createLoadInstructions(ResolvedType toType, InstructionFactory fact)",
    "file_id": "F4",
    "start_line": 80,
    "text_preview": "ion(\"unimplemented\");\\n\t}\\n\\n\t@Override\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createLoadInstructions(getType(), fact));\\n\t}\\n\\n\t@Override\\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\\n\t\til.append(createLoadInstructions(toType"
  },
  {
    "method_id": "M26",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == Shadow.FieldSet || kind == Shadow.FieldGet)",
    "file_id": "F4",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M27",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == Shadow.StaticInitialization || kind == Shadow.ExceptionHandler)",
    "file_id": "F4",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M28",
    "name": "generateBytecodeToAccessAnnotationAtFieldGetSetShadow",
    "return_type": "void",
    "signature": "generateBytecodeToAccessAnnotationAtFieldGetSetShadow(ResolvedType toType, InstructionFactory fact,\n\t\t\tInstructionList il, Instruction pushConstantAnnotationType)",
    "file_id": "F4",
    "start_line": 161,
    "text_preview": "pe[] { jlClass }, Constants.INVOKEVIRTUAL));\\n\t\t\t}\\n\t\t} else if (kind == Shadow.FieldSet || kind == Shadow.FieldGet) {\\n\t\t\tgenerateBytecodeToAccessAnnotationAtFieldGetSetShadow(toType, fact, il, pushConstant);\\n\t\t} else if (kind == Shadow.StaticInitialization || kind == Shadow.ExceptionHandler) {\\n\t\t\til.append(fact.createCo"
  },
  {
    "method_id": "M29",
    "name": "buildArray",
    "return_type": "void",
    "signature": "buildArray(InstructionList il, InstructionFactory fact, Type arrayElementType, Type[] arrayEntries, int dim)",
    "file_id": "F4",
    "start_line": 136,
    "text_preview": "act.createConstant(BcelWorld.makeBcelType(containingType)));\\n\\n\t\t\t\til.append(fact.createConstant(member.getName()));\\n\t\t\t\tbuildArray(il, fact, jlClass, paramTypes, 1);\\n\t\t\t\t// OPTIMIZE cache result of getDeclaredMethod?\\n\t\t\t\til.append(fact.createInvoke(\"java/lang/Class\", \"getDeclaredMethod\", jlrMethod,\\n\t\t\t\t\t\tnew Type[] { j"
  },
  {
    "method_id": "M30",
    "name": "if",
    "return_type": "",
    "signature": "if(arrayEntries == null)",
    "file_id": "F4",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M31",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < arrayEntries.length; i++)",
    "file_id": "F4",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M32",
    "name": "getMember",
    "return_type": "Member",
    "signature": "getMember()",
    "file_id": "F4",
    "start_line": 257,
    "text_preview": "l.append(fact.createConstant(arrayEntries[i]));\\n\t\t\t}\\n\t\t\til.append(InstructionConstants.AASTORE);\\n\t\t}\\n\t}\\n\\n\tpublic Member getMember() {\\n\t\treturn member;\\n\t}\\n\\n\t/**\\n\t * Return an object that can access a particular value of this annotation.\\n\t *\\n\t * @param valueType The type from the annotation that is of interest\\n\t * @param"
  },
  {
    "method_id": "M33",
    "name": "getAccessorForValue",
    "return_type": "Var",
    "signature": "getAccessorForValue(ResolvedType valueType, String formalName)",
    "file_id": "F4",
    "start_line": 269,
    "text_preview": "used to disambiguate\\n\t * @return a variable that represents access to that annotation value\\n\t */\\n\t@Override\\n\tpublic Var getAccessorForValue(ResolvedType valueType, String formalName) {\\n\t\treturn new AnnotationAccessFieldVar(this, valueType, formalName);\\n\t}\\n}\\n"
  },
  {
    "method_id": "M34",
    "name": "AspectInstanceVar",
    "return_type": "",
    "signature": "AspectInstanceVar(ResolvedType type)",
    "file_id": "F5",
    "start_line": 27,
    "text_preview": "etrieve it. For now it only works with singleton aspects.\\n */\\npublic class AspectInstanceVar extends BcelVar {\\n\\n\tpublic AspectInstanceVar(ResolvedType type) {\\n\t\tsuper(type, -1);\\n\t}\\n\\n\t// fact is used in the subtypes\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\\n\t\tthrow new IllegalStateException();\\n\t\t// retu"
  },
  {
    "method_id": "M35",
    "name": "createLoad",
    "return_type": "Instruction",
    "signature": "createLoad(InstructionFactory fact)",
    "file_id": "F5",
    "start_line": 32,
    "text_preview": "blic AspectInstanceVar(ResolvedType type) {\\n\t\tsuper(type, -1);\\n\t}\\n\\n\t// fact is used in the subtypes\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\\n\t\tthrow new IllegalStateException();\\n\t\t// return InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), slot);\\n\t}\\n\\n\tpublic Instruction createStore(Inst"
  },
  {
    "method_id": "M36",
    "name": "createStore",
    "return_type": "Instruction",
    "signature": "createStore(InstructionFactory fact)",
    "file_id": "F5",
    "start_line": 38,
    "text_preview": "xception();\\n\t\t// return InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), slot);\\n\t}\\n\\n\tpublic Instruction createStore(InstructionFactory fact) {\\n\t\tthrow new IllegalStateException();\\n\t\t// return InstructionFactory.createStore(BcelWorld.makeBcelType(getType()), slot);\\n\t}\\n\\n\tpublic void appendStore(Instructio"
  },
  {
    "method_id": "M37",
    "name": "appendStore",
    "return_type": "void",
    "signature": "appendStore(InstructionList il, InstructionFactory fact)",
    "file_id": "F5",
    "start_line": 43,
    "text_preview": "StateException();\\n\t\t// return InstructionFactory.createStore(BcelWorld.makeBcelType(getType()), slot);\\n\t}\\n\\n\tpublic void appendStore(InstructionList il, InstructionFactory fact) {\\n\t\tthrow new IllegalStateException();\\n\t\t// il.append(createStore(fact));\\n\t}\\n\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fa"
  },
  {
    "method_id": "M38",
    "name": "appendLoad",
    "return_type": "void",
    "signature": "appendLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F5",
    "start_line": 48,
    "text_preview": "il, InstructionFactory fact) {\\n\t\tthrow new IllegalStateException();\\n\t\t// il.append(createStore(fact));\\n\t}\\n\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\tthrow new IllegalStateException();\\n\t\t// il.append(createLoad(fact));\\n\t}\\n\\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFa"
  },
  {
    "method_id": "M39",
    "name": "appendLoadAndConvert",
    "return_type": "void",
    "signature": "appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType)",
    "file_id": "F5",
    "start_line": 53,
    "text_preview": " il, InstructionFactory fact) {\\n\t\tthrow new IllegalStateException();\\n\t\t// il.append(createLoad(fact));\\n\t}\\n\\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\\n\t\tthrow new IllegalStateException();\\n\t\t// il.append(createLoad(fact));\\n\t\t// Utility.appendConversion(il, fact, "
  },
  {
    "method_id": "M40",
    "name": "insertLoad",
    "return_type": "void",
    "signature": "insertLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F5",
    "start_line": 59,
    "text_preview": "ption();\\n\t\t// il.append(createLoad(fact));\\n\t\t// Utility.appendConversion(il, fact, getType(), toType);\\n\t}\\n\\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\\n\t\tInstructionList loadInstructions = new InstructionList();\\n\t\tloadInstructions.append(fact.createInvoke(getType().getName(), \"aspectOf\", \"()\" "
  },
  {
    "method_id": "M41",
    "name": "createCopyFrom",
    "return_type": "InstructionList",
    "signature": "createCopyFrom(InstructionFactory fact, int oldSlot)",
    "file_id": "F5",
    "start_line": 68,
    "text_preview": "oadInstructions);\\n\t\t// throw new IllegalStateException();\\n\t\t// il.insert(createLoad(fact));\\n\t}\\n\\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tthrow new IllegalStateException();\\n\t\t// InstructionList il = new InstructionList();\\n\t\t// il.append(InstructionFactory.createLoad(BcelWorld.make"
  },
  {
    "method_id": "M42",
    "name": "appendConvertableArrayLoad",
    "return_type": "void",
    "signature": "appendConvertableArrayLoad(InstructionList il, InstructionFactory fact, int index, ResolvedType convertTo)",
    "file_id": "F5",
    "start_line": 77,
    "text_preview": "keBcelType(getType()), oldSlot));\\n\t\t// il.append(createStore(fact));\\n\t\t// return il;\\n\t}\\n\\n\t// this is an array var\\n\tvoid appendConvertableArrayLoad(InstructionList il, InstructionFactory fact, int index, ResolvedType convertTo) {\\n\t\tthrow new IllegalStateException();\\n\t\t// ResolvedType convertFromType = getType().getResol"
  },
  {
    "method_id": "M43",
    "name": "appendConvertableArrayStore",
    "return_type": "void",
    "signature": "appendConvertableArrayStore(InstructionList il, InstructionFactory fact, int index, BcelVar storee)",
    "file_id": "F5",
    "start_line": 86,
    "text_preview": "elWorld.makeBcelType(convertFromType)));\\n\t\t// Utility.appendConversion(il, fact, convertFromType, convertTo);\\n\t}\\n\\n\tvoid appendConvertableArrayStore(InstructionList il, InstructionFactory fact, int index, BcelVar storee) {\\n\t\tthrow new IllegalStateException();\\n\t\t// ResolvedType convertToType = getType().getResolvedCompon"
  },
  {
    "method_id": "M44",
    "name": "createConvertableArrayStore",
    "return_type": "InstructionList",
    "signature": "createConvertableArrayStore(InstructionFactory fact, int index, BcelVar storee)",
    "file_id": "F5",
    "start_line": 96,
    "text_preview": "Type);\\n\t\t// il.append(InstructionFactory.createArrayStore(BcelWorld.makeBcelType(convertToType)));\\n\t}\\n\\n\tInstructionList createConvertableArrayStore(InstructionFactory fact, int index, BcelVar storee) {\\n\t\tthrow new IllegalStateException();\\n\t\t// InstructionList il = new InstructionList();\\n\t\t// appendConvertableArrayStore"
  },
  {
    "method_id": "M45",
    "name": "createConvertableArrayLoad",
    "return_type": "InstructionList",
    "signature": "createConvertableArrayLoad(InstructionFactory fact, int index, ResolvedType convertTo)",
    "file_id": "F5",
    "start_line": 103,
    "text_preview": " new InstructionList();\\n\t\t// appendConvertableArrayStore(il, fact, index, storee);\\n\t\t// return il;\\n\t}\\n\\n\tInstructionList createConvertableArrayLoad(InstructionFactory fact, int index, ResolvedType convertTo) {\\n\t\tthrow new IllegalStateException();\\n\t\t// InstructionList il = new InstructionList();\\n\t\t// appendConvertableArr"
  },
  {
    "method_id": "M46",
    "name": "getPositionInAroundState",
    "return_type": "int",
    "signature": "getPositionInAroundState()",
    "file_id": "F5",
    "start_line": 110,
    "text_preview": "l = new InstructionList();\\n\t\t// appendConvertableArrayLoad(il, fact, index, convertTo);\\n\t\t// return il;\\n\t}\\n\\n\tpublic int getPositionInAroundState() {\\n\t\tthrow new IllegalStateException();\\n\t\t// return positionInAroundState;\\n\t}\\n\\n\tpublic void setPositionInAroundState(int positionInAroundState) {\\n\t\tthrow new IllegalStateExce"
  },
  {
    "method_id": "M47",
    "name": "setPositionInAroundState",
    "return_type": "void",
    "signature": "setPositionInAroundState(int positionInAroundState)",
    "file_id": "F5",
    "start_line": 115,
    "text_preview": "t getPositionInAroundState() {\\n\t\tthrow new IllegalStateException();\\n\t\t// return positionInAroundState;\\n\t}\\n\\n\tpublic void setPositionInAroundState(int positionInAroundState) {\\n\t\tthrow new IllegalStateException();\\n\t\t// this.positionInAroundState = positionInAroundState;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M48",
    "name": "AjAttributeStruct",
    "return_type": "",
    "signature": "AjAttributeStruct(ResolvedType type, ISourceContext sourceContext, IMessageHandler messageHandler)",
    "file_id": "F6",
    "start_line": 122,
    "text_preview": ")\\n\t\t */\\n\t\tfinal ResolvedType enclosingType;\\n\\n\t\tfinal ISourceContext context;\\n\t\tfinal IMessageHandler handler;\\n\\n\t\tpublic AjAttributeStruct(ResolvedType type, ISourceContext sourceContext, IMessageHandler messageHandler) {\\n\t\t\tenclosingType = type;\\n\t\t\tcontext = sourceContext;\\n\t\t\thandler = messageHandler;\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * "
  },
  {
    "method_id": "M49",
    "name": "AjAttributeMethodStruct",
    "return_type": "",
    "signature": "AjAttributeMethodStruct(Method method, BcelMethod bMethod, ResolvedType type, ISourceContext sourceContext,\n\t\t\t\tIMessageHandler messageHandler)",
    "file_id": "F6",
    "start_line": 145,
    "text_preview": " discovered as\\n\t\t// argNames attribute of\\n\t\t// annotation\\n\\n\t\tfinal Method method;\\n\t\tfinal BcelMethod bMethod;\\n\\n\t\tpublic AjAttributeMethodStruct(Method method, BcelMethod bMethod, ResolvedType type, ISourceContext sourceContext,\\n\t\t\t\tIMessageHandler messageHandler) {\\n\t\t\tsuper(type, sourceContext, messageHandler);\\n\t\t\tthis"
  },
  {
    "method_id": "M50",
    "name": "getArgumentNames",
    "return_type": "String[]",
    "signature": "getArgumentNames()",
    "file_id": "F6",
    "start_line": 152,
    "text_preview": "\tsuper(type, sourceContext, messageHandler);\\n\t\t\tthis.method = method;\\n\t\t\tthis.bMethod = bMethod;\\n\t\t}\\n\\n\t\tpublic String[] getArgumentNames() {\\n\t\t\tif (m_argumentNamesLazy == null) {\\n\t\t\t\tm_argumentNamesLazy = getMethodArgumentNames(method, unparsedArgumentNames, this);\\n\t\t\t}\\n\t\t\treturn m_argumentNamesLazy;\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * A"
  },
  {
    "method_id": "M51",
    "name": "if",
    "return_type": "",
    "signature": "if(m_argumentNamesLazy == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M52",
    "name": "AjAttributeFieldStruct",
    "return_type": "",
    "signature": "AjAttributeFieldStruct(Field field, BcelField bField, ResolvedType type, ISourceContext sourceContext,\n\t\t\t\tIMessageHandler messageHandler)",
    "file_id": "F6",
    "start_line": 169,
    "text_preview": " class AjAttributeFieldStruct extends AjAttributeStruct {\\n\\n\t\tfinal Field field;\\n\\n\t\t// final BcelField bField;\\n\\n\t\tpublic AjAttributeFieldStruct(Field field, BcelField bField, ResolvedType type, ISourceContext sourceContext,\\n\t\t\t\tIMessageHandler messageHandler) {\\n\t\t\tsuper(type, sourceContext, messageHandler);\\n\t\t\tthis.fiel"
  },
  {
    "method_id": "M53",
    "name": "acceptAttribute",
    "return_type": "boolean",
    "signature": "acceptAttribute(Attribute attribute)",
    "file_id": "F6",
    "start_line": 183,
    "text_preview": "timeInvisible ones.\\n\t *\\n\t * @param attribute\\n\t * @return true if runtime visible annotation\\n\t */\\n\tpublic static boolean acceptAttribute(Attribute attribute) {\\n\t\treturn (attribute instanceof RuntimeVisAnnos);\\n\t}\\n\\n\t/**\\n\t * Extract class level annotations and turn them into AjAttributes.\\n\t *\\n\t * @param javaClass\\n\t * @para"
  },
  {
    "method_id": "M54",
    "name": "readAj5ClassAttributes",
    "return_type": "List<AjAttribute>",
    "signature": "readAj5ClassAttributes(AsmManager model, JavaClass javaClass, ReferenceType type,\n\t\t\tISourceContext context, IMessageHandler msgHandler, boolean isCodeStyleAspect)",
    "file_id": "F6",
    "start_line": 196,
    "text_preview": "am type\\n\t * @param context\\n\t * @param msgHandler\\n\t * @return list of AjAttributes\\n\t */\\n\tpublic static List<AjAttribute> readAj5ClassAttributes(AsmManager model, JavaClass javaClass, ReferenceType type,\\n\t\t\tISourceContext context, IMessageHandler msgHandler, boolean isCodeStyleAspect) {\\n\t\tboolean ignoreThisClass = javaCl"
  },
  {
    "method_id": "M55",
    "name": "if",
    "return_type": "",
    "signature": "if(ignoreThisClass)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M56",
    "name": "for",
    "return_type": "",
    "signature": "for(Constant constant : cpool)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M57",
    "name": "if",
    "return_type": "",
    "signature": "if(!containsAnnotationClassReference)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M58",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute attribute : attributes)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M59",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = attributes.length - 1; i >= 0; i--)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M60",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ioe)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M61",
    "name": "if",
    "return_type": "",
    "signature": "if(wvinfo == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M62",
    "name": "if",
    "return_type": "",
    "signature": "if(delegate instanceof BcelObjectType)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M63",
    "name": "if",
    "return_type": "",
    "signature": "if(wvinfo != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M64",
    "name": "if",
    "return_type": "",
    "signature": "if(wvinfo == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M65",
    "name": "if",
    "return_type": "check",
    "signature": "if(hasAtPrecedenceAnnotation && !hasAtAspectAnnotation)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M66",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute mattribute : mattributes)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M67",
    "name": "if",
    "return_type": "",
    "signature": "if(!processedPointcut)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M68",
    "name": "if",
    "return_type": "",
    "signature": "if(processedPointcut)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M69",
    "name": "for",
    "return_type": "",
    "signature": "for(Field field : fs)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M70",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute fattribute : fattributes)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M71",
    "name": "readAj5MethodAttributes",
    "return_type": "List<AjAttribute>",
    "signature": "readAj5MethodAttributes(Method method, BcelMethod bMethod, ResolvedType type,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut, ISourceContext context, IMessageHandler msgHandler)",
    "file_id": "F6",
    "start_line": 409,
    "text_preview": "am type\\n\t * @param context\\n\t * @param msgHandler\\n\t * @return list of AjAttributes\\n\t */\\n\tpublic static List<AjAttribute> readAj5MethodAttributes(Method method, BcelMethod bMethod, ResolvedType type,\\n\t\t\tResolvedPointcutDefinition preResolvedPointcut, ISourceContext context, IMessageHandler msgHandler) {\\n\t\tif (method.getN"
  },
  {
    "method_id": "M72",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute attribute : attributes)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M73",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ReturningFormalNotDeclaredInAdviceSignatureException e)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M74",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ThrownFormalNotDeclaredInAdviceSignatureException e)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M75",
    "name": "readAj5FieldAttributes",
    "return_type": "List<AjAttribute>",
    "signature": "readAj5FieldAttributes(Field field, BcelField bField, ResolvedType type,\n\t\t\tISourceContext context, IMessageHandler msgHandler)",
    "file_id": "F6",
    "start_line": 511,
    "text_preview": "text\\n\t * @param msgHandler\\n\t * @return list of AjAttributes, always empty for now\\n\t */\\n\tpublic static List<AjAttribute> readAj5FieldAttributes(Field field, BcelField bField, ResolvedType type,\\n\t\t\tISourceContext context, IMessageHandler msgHandler) {\\n\t\t// Note: field annotation are for ITD and DEOW - processed at class\\n"
  },
  {
    "method_id": "M76",
    "name": "handleAspectAnnotation",
    "return_type": "boolean",
    "signature": "handleAspectAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeStruct struct)",
    "file_id": "F6",
    "start_line": 241,
    "text_preview": "/ it cannot happen as per JSR175\\n\t\t\t\tif (!isCodeStyleAspect && !javaClass.isInterface()) {\\n\t\t\t\t\thasAtAspectAnnotation = handleAspectAnnotation(rvs, struct);\\n\t\t\t\t\t// TODO AV - if put outside the if isCodeStyleAspect then we\\n\t\t\t\t\t// would enable mix style\\n\t\t\t\t\thasAtPrecedenceAnnotation = handlePrecedenceAnnotation(rvs, s"
  },
  {
    "method_id": "M77",
    "name": "if",
    "return_type": "",
    "signature": "if(aspect != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M78",
    "name": "if",
    "return_type": "",
    "signature": "if(aspectPerClause == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M79",
    "name": "if",
    "return_type": "inherited",
    "signature": "if(!extendsAspect)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M80",
    "name": "if",
    "return_type": "",
    "signature": "if(perClause == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M81",
    "name": "parsePerClausePointcut",
    "return_type": "PerClause",
    "signature": "parsePerClausePointcut(String perClauseString, AjAttributeStruct struct)",
    "file_id": "F6",
    "start_line": 552,
    "text_preview": "lue();\\n\t\t\t\tif (perX == null || perX.length() <= 0) {\\n\t\t\t\t\tperClause = new PerSingleton();\\n\t\t\t\t} else {\\n\t\t\t\t\tperClause = parsePerClausePointcut(perX, struct);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tif (perClause == null) {\\n\t\t\t\t// could not parse it, ignore the aspect\\n\t\t\t\treturn false;\\n\t\t\t} else {\\n\t\t\t\tperClause.setLocation(struct.context, -1, -1"
  },
  {
    "method_id": "M82",
    "name": "handlePrecedenceAnnotation",
    "return_type": "boolean",
    "signature": "handlePrecedenceAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeStruct struct)",
    "file_id": "F6",
    "start_line": 244,
    "text_preview": "DO AV - if put outside the if isCodeStyleAspect then we\\n\t\t\t\t\t// would enable mix style\\n\t\t\t\t\thasAtPrecedenceAnnotation = handlePrecedenceAnnotation(rvs, struct);\\n\t\t\t\t}\\n\t\t\t\t// there can only be one RuntimeVisible bytecode attribute\\n\t\t\t\tbreak;\\n\t\t\t}\\n\t\t}\\n\t\tfor (int i = attributes.length - 1; i >= 0; i--) {\\n\t\t\tAttribute attr"
  },
  {
    "method_id": "M83",
    "name": "if",
    "return_type": "",
    "signature": "if(aspect != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M84",
    "name": "if",
    "return_type": "",
    "signature": "if(precedence != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M85",
    "name": "handleDeclareImplementsAnnotation",
    "return_type": "",
    "signature": "handleDeclareImplementsAnnotation(RuntimeAnnotations runtimeAnnotations,\n\t// AjAttributeFieldStruct\n\t// struct)",
    "file_id": "F6",
    "start_line": 668,
    "text_preview": "*\\n\t// * @param runtimeAnnotations\\n\t// * @param struct\\n\t// * @return true if found\\n\t// */\\n\t// private static boolean\\n\t// handleDeclareImplementsAnnotation(RuntimeAnnotations runtimeAnnotations,\\n\t// AjAttributeFieldStruct\\n\t// struct) {//, ResolvedPointcutDefinition preResolvedPointcut) {\\n\t// Annotation deci = getAnnotati"
  },
  {
    "method_id": "M86",
    "name": "if",
    "return_type": "",
    "signature": "if(deci != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M87",
    "name": "if",
    "return_type": "",
    "signature": "if(deciPattern != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M88",
    "name": "handleDeclareParentsAnnotation",
    "return_type": "boolean",
    "signature": "handleDeclareParentsAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeFieldStruct struct)",
    "file_id": "F6",
    "start_line": 381,
    "text_preview": "eAnnos frvs = (RuntimeAnnos) fattribute;\\n\t\t\t\t\tif (handleDeclareErrorOrWarningAnnotation(model, frvs, fstruct)\\n\t\t\t\t\t\t\t|| handleDeclareParentsAnnotation(frvs, fstruct)) {\\n\t\t\t\t\t\t// semantic check - must be in an @Aspect [remove if\\n\t\t\t\t\t\t// previous block bypassed in advance]\\n\t\t\t\t\t\tif (!type.isAnnotationStyleAspect() && !i"
  },
  {
    "method_id": "M89",
    "name": "if",
    "return_type": "",
    "signature": "if(decpAnno != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M90",
    "name": "if",
    "return_type": "",
    "signature": "if(decpPattern != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M91",
    "name": "if",
    "return_type": "",
    "signature": "if(defaultImplNVP != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M92",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember resolvedMember : mm)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M93",
    "name": "if",
    "return_type": "",
    "signature": "if(defaultVisibilityImpl)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M94",
    "name": "if",
    "return_type": "",
    "signature": "if(hasNoCtorOrANoArgOne)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M95",
    "name": "if",
    "return_type": "",
    "signature": "if(!hasNoCtorOrANoArgOne)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M96",
    "name": "if",
    "return_type": "",
    "signature": "if(foundOneOfIncorrectVisibility != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M97",
    "name": "if",
    "return_type": "",
    "signature": "if(defaultImplClassName == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M98",
    "name": "if",
    "return_type": "type",
    "signature": "if(hasAtLeastOneMethod && defaultImplClassName != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M99",
    "name": "getMethodForMessage",
    "return_type": "String",
    "signature": "getMethodForMessage(AjAttributeMethodStruct methodstructure)",
    "file_id": "F6",
    "start_line": 863,
    "text_preview": "\\n\t/**\\n\t * @return a nicely formatted method string, for example: int X.foo(java.lang.String)\\n\t */\\n\tpublic static String getMethodForMessage(AjAttributeMethodStruct methodstructure) {\\n\t\tStringBuilder sb = new StringBuilder();\\n\t\tsb.append(\"Method '\");\\n\t\tsb.append(methodstructure.method.getReturnType().toString());\\n\t\tsb.a"
  },
  {
    "method_id": "M100",
    "name": "if",
    "return_type": "",
    "signature": "if(args != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M101",
    "name": "for",
    "return_type": "",
    "signature": "for(int t = 0; t < args.length; t++)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M102",
    "name": "if",
    "return_type": "",
    "signature": "if(t > 0)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M103",
    "name": "createImpl",
    "return_type": "I",
    "signature": "createImpl(Object o)",
    "file_id": "F6",
    "start_line": 887,
    "text_preview": "\\n\t/**\\n\t * Process any @DeclareMixin annotation.\\n\t *\\n\t * Example Declaration <br>\\n\t *\\n\t * @DeclareMixin(\"Foo+\") public I createImpl(Object o) { return new Impl(o); }\\n\t *\\n\t * <br>\\n\t * @param runtimeAnnotations\\n\t * @param struct\\n\t * @return true if found\\n\t */\\n\tprivate static boolean handleDeclareMixinAnnotation(RuntimeAnn"
  },
  {
    "method_id": "M104",
    "name": "handleDeclareMixinAnnotation",
    "return_type": "boolean",
    "signature": "handleDeclareMixinAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct)",
    "file_id": "F6",
    "start_line": 354,
    "text_preview": " handlePointcutAnnotation((RuntimeAnnos) mattribute, mstruct);\\n\t\t\t\t\tif (!processedPointcut) {\\n\t\t\t\t\t\tprocessedPointcut = handleDeclareMixinAnnotation((RuntimeAnnos) mattribute, mstruct);\\n\t\t\t\t\t}\\n\t\t\t\t\t// there can only be one RuntimeVisible bytecode attribute\\n\t\t\t\t\tbreak;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tif (processedPointcut) {\\n\t\t\t\tstruct.a"
  },
  {
    "method_id": "M105",
    "name": "if",
    "return_type": "",
    "signature": "if(declareMixinAnnotation == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M106",
    "name": "if",
    "return_type": "",
    "signature": "if(interfaceListSpecified != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M107",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < numberOfTypes; i++)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M108",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType typeForDelegation : newInterfaceTypes)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M109",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember resolvedMember : methods)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M110",
    "name": "if",
    "return_type": "added",
    "signature": "if(hasAtLeastOneMethod)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M111",
    "name": "handleBeforeAnnotation",
    "return_type": "boolean",
    "signature": "handleBeforeAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut)",
    "file_id": "F6",
    "start_line": 441,
    "text_preview": " = (RuntimeAnnos) attribute;\\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\\n\t\t\t\t\t\t\t|| handleBeforeAnnotation(rvs, struct, preResolvedPointcut);\\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\\n\t\t\t\t\t\t\t|| handleAfterAnnotation(rvs, struct, preResolvedPoint"
  },
  {
    "method_id": "M112",
    "name": "if",
    "return_type": "",
    "signature": "if(before != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M113",
    "name": "if",
    "return_type": "",
    "signature": "if(beforeAdvice != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M114",
    "name": "if",
    "return_type": "",
    "signature": "if(argumentNames != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M115",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnreadableDebugInfoException unreadableDebugInfoException)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M116",
    "name": "if",
    "return_type": "",
    "signature": "if(preResolvedPointcut != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M117",
    "name": "if",
    "return_type": "",
    "signature": "if(pc == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M118",
    "name": "handleAfterAnnotation",
    "return_type": "boolean",
    "signature": "handleAfterAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut)",
    "file_id": "F6",
    "start_line": 443,
    "text_preview": "truct, preResolvedPointcut);\\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\\n\t\t\t\t\t\t\t|| handleAfterAnnotation(rvs, struct, preResolvedPointcut);\\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\\n\t\t\t\t\t\t\t|| handleAfterReturningAnnotation(rvs, struct, preResol"
  },
  {
    "method_id": "M119",
    "name": "if",
    "return_type": "",
    "signature": "if(after != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M120",
    "name": "if",
    "return_type": "",
    "signature": "if(afterAdvice != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M121",
    "name": "if",
    "return_type": "",
    "signature": "if(argumentNames != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M122",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnreadableDebugInfoException unreadableDebugInfoException)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M123",
    "name": "if",
    "return_type": "",
    "signature": "if(preResolvedPointcut != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M124",
    "name": "if",
    "return_type": "",
    "signature": "if(pc == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M125",
    "name": "handleAfterReturningAnnotation",
    "return_type": "boolean",
    "signature": "handleAfterReturningAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut, BcelMethod owningMethod)",
    "file_id": "F6",
    "start_line": 445,
    "text_preview": "truct, preResolvedPointcut);\\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\\n\t\t\t\t\t\t\t|| handleAfterReturningAnnotation(rvs, struct, preResolvedPointcut, bMethod);\\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\\n\t\t\t\t\t\t\t|| handleAfterThrowingAnnotation(rvs,"
  },
  {
    "method_id": "M126",
    "name": "if",
    "return_type": "",
    "signature": "if(after != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M127",
    "name": "if",
    "return_type": "",
    "signature": "if(annValue != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M128",
    "name": "if",
    "return_type": "",
    "signature": "if(annReturned != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M129",
    "name": "if",
    "return_type": "",
    "signature": "if(argumentNames != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M130",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnreadableDebugInfoException unreadableDebugInfoException)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M131",
    "name": "if",
    "return_type": "binding",
    "signature": "if(returned != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M132",
    "name": "if",
    "return_type": "",
    "signature": "if(preResolvedPointcut != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M133",
    "name": "if",
    "return_type": "",
    "signature": "if(pc == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M134",
    "name": "handleAfterThrowingAnnotation",
    "return_type": "boolean",
    "signature": "handleAfterThrowingAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut, BcelMethod owningMethod)",
    "file_id": "F6",
    "start_line": 447,
    "text_preview": "eResolvedPointcut, bMethod);\\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\\n\t\t\t\t\t\t\t|| handleAfterThrowingAnnotation(rvs, struct, preResolvedPointcut, bMethod);\\n\t\t\t\t\thasAtAspectJAnnotation = hasAtAspectJAnnotation || handleAroundAnnotation(rvs, struct, preResolvedPointcut);\\n\t\t\t\t\t// ther"
  },
  {
    "method_id": "M135",
    "name": "if",
    "return_type": "",
    "signature": "if(after != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M136",
    "name": "if",
    "return_type": "",
    "signature": "if(annValue != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M137",
    "name": "if",
    "return_type": "",
    "signature": "if(annThrown != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M138",
    "name": "if",
    "return_type": "",
    "signature": "if(argumentNames != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M139",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnreadableDebugInfoException unreadableDebugInfoException)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M140",
    "name": "if",
    "return_type": "binding",
    "signature": "if(thrownFormal != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M141",
    "name": "if",
    "return_type": "",
    "signature": "if(preResolvedPointcut != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M142",
    "name": "if",
    "return_type": "",
    "signature": "if(pc == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M143",
    "name": "handleAroundAnnotation",
    "return_type": "boolean",
    "signature": "handleAroundAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct,\n\t\t\tResolvedPointcutDefinition preResolvedPointcut)",
    "file_id": "F6",
    "start_line": 448,
    "text_preview": "rThrowingAnnotation(rvs, struct, preResolvedPointcut, bMethod);\\n\t\t\t\t\thasAtAspectJAnnotation = hasAtAspectJAnnotation || handleAroundAnnotation(rvs, struct, preResolvedPointcut);\\n\t\t\t\t\t// there can only be one RuntimeVisible bytecode attribute\\n\t\t\t\t\tbreak;\\n\t\t\t\t}\\n\t\t\t} catch (ReturningFormalNotDeclaredInAdviceSignatureExcep"
  },
  {
    "method_id": "M144",
    "name": "if",
    "return_type": "",
    "signature": "if(around != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M145",
    "name": "if",
    "return_type": "",
    "signature": "if(aroundAdvice != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M146",
    "name": "if",
    "return_type": "",
    "signature": "if(argumentNames != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M147",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnreadableDebugInfoException unreadableDebugInfoException)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M148",
    "name": "if",
    "return_type": "",
    "signature": "if(preResolvedPointcut != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M149",
    "name": "if",
    "return_type": "",
    "signature": "if(pc == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M150",
    "name": "handlePointcutAnnotation",
    "return_type": "boolean",
    "signature": "handlePointcutAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeMethodStruct struct)",
    "file_id": "F6",
    "start_line": 352,
    "text_preview": "or fields\\n\t\t\t\t\tmstruct = new AjAttributeMethodStruct(method, null, type, context, msgHandler);\\n\t\t\t\t\tprocessedPointcut = handlePointcutAnnotation((RuntimeAnnos) mattribute, mstruct);\\n\t\t\t\t\tif (!processedPointcut) {\\n\t\t\t\t\t\tprocessedPointcut = handleDeclareMixinAnnotation((RuntimeAnnos) mattribute, mstruct);\\n\t\t\t\t\t}\\n\t\t\t\t\t// "
  },
  {
    "method_id": "M151",
    "name": "if",
    "return_type": "",
    "signature": "if(pointcut == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M152",
    "name": "if",
    "return_type": "",
    "signature": "if(argumentNames != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M153",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnreadableDebugInfoException e)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M154",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < argumentTypes.length; i++)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M155",
    "name": "if",
    "return_type": "",
    "signature": "if(pointcutExpr != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M156",
    "name": "if",
    "return_type": "",
    "signature": "if(pc == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M157",
    "name": "handleDeclareErrorOrWarningAnnotation",
    "return_type": "boolean",
    "signature": "handleDeclareErrorOrWarningAnnotation(AsmManager model, RuntimeAnnos runtimeAnnotations,\n\t\t\tAjAttributeFieldStruct struct)",
    "file_id": "F6",
    "start_line": 380,
    "text_preview": "te : fattributes) {\\n\t\t\t\tif (acceptAttribute(fattribute)) {\\n\t\t\t\t\tRuntimeAnnos frvs = (RuntimeAnnos) fattribute;\\n\t\t\t\t\tif (handleDeclareErrorOrWarningAnnotation(model, frvs, fstruct)\\n\t\t\t\t\t\t\t|| handleDeclareParentsAnnotation(frvs, fstruct)) {\\n\t\t\t\t\t\t// semantic check - must be in an @Aspect [remove if\\n\t\t\t\t\t\t// previous bloc"
  },
  {
    "method_id": "M158",
    "name": "if",
    "return_type": "",
    "signature": "if(error != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M159",
    "name": "if",
    "return_type": "",
    "signature": "if(declareError != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M160",
    "name": "if",
    "return_type": "",
    "signature": "if(pc == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M161",
    "name": "if",
    "return_type": "",
    "signature": "if(warning != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M162",
    "name": "if",
    "return_type": "",
    "signature": "if(declareWarning != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M163",
    "name": "if",
    "return_type": "",
    "signature": "if(pc == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M164",
    "name": "setDeclareErrorOrWarningLocation",
    "return_type": "void",
    "signature": "setDeclareErrorOrWarningLocation(AsmManager model, DeclareErrorOrWarning deow, AjAttributeFieldStruct struct)",
    "file_id": "F6",
    "start_line": 1477,
    "text_preview": "\t\t\t\t\tDeclareErrorOrWarning deow = new DeclareErrorOrWarning(true, pc, struct.field.getConstantValue().toString());\\n\t\t\t\t\tsetDeclareErrorOrWarningLocation(model, deow, struct);\\n\t\t\t\t\tstruct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));\\n\t\t\t\t\thasError = true;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\tAnnotationGen warning = getAnnotatio"
  },
  {
    "method_id": "M165",
    "name": "methodToString",
    "return_type": "String",
    "signature": "methodToString(Method method)",
    "file_id": "F6",
    "start_line": 473,
    "text_preview": "ethod.isPublic()) {\\n\t\t\tmsgHandler.handleMessage(new Message(\"Found @AspectJ annotation on a non public advice '\"\\n\t\t\t\t\t+ methodToString(struct.method) + \"'\", IMessage.ERROR, null, type.getSourceLocation()));\\n\t\t\t// go ahead\\n\t\t}\\n\\n\t\t// semantic check - advice must not be static\\n\t\tif (hasAtAspectJAnnotation && struct.method"
  },
  {
    "method_id": "M166",
    "name": "extractBindings",
    "return_type": "FormalBinding[]",
    "signature": "extractBindings(AjAttributeMethodStruct struct)",
    "file_id": "F6",
    "start_line": 1043,
    "text_preview": "parsedArgumentNames = argumentNames;\\n\t\t\t\t}\\n\t\t\t\tFormalBinding[] bindings = FormalBinding.NONE;\\n\t\t\t\ttry {\\n\t\t\t\t\tbindings = extractBindings(struct);\\n\t\t\t\t} catch (UnreadableDebugInfoException unreadableDebugInfoException) {\\n\t\t\t\t\treturn false;\\n\t\t\t\t}\\n\t\t\t\tIScope binding = new BindingScope(struct.enclosingType, struct.context, "
  },
  {
    "method_id": "M167",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < argumentNames.length; i++)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M168",
    "name": "extractBindings",
    "return_type": "FormalBinding[]",
    "signature": "extractBindings(AjAttributeMethodStruct struct, String excludeFormal)",
    "file_id": "F6",
    "start_line": 1043,
    "text_preview": "parsedArgumentNames = argumentNames;\\n\t\t\t\t}\\n\t\t\t\tFormalBinding[] bindings = FormalBinding.NONE;\\n\t\t\t\ttry {\\n\t\t\t\t\tbindings = extractBindings(struct);\\n\t\t\t\t} catch (UnreadableDebugInfoException unreadableDebugInfoException) {\\n\t\t\t\t\treturn false;\\n\t\t\t\t}\\n\t\t\t\tIScope binding = new BindingScope(struct.enclosingType, struct.context, "
  },
  {
    "method_id": "M169",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < bindings.length; i++)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M170",
    "name": "if",
    "return_type": "",
    "signature": "if(excludeIndex >= 0)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M171",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < bindings.length; i++)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M172",
    "name": "if",
    "return_type": "",
    "signature": "if(i == excludeIndex)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M173",
    "name": "extractExtraArgument",
    "return_type": "int",
    "signature": "extractExtraArgument(Method method)",
    "file_id": "F6",
    "start_line": 1050,
    "text_preview": "ope(struct.enclosingType, struct.context, bindings);\\n\\n\t\t\t\t// joinpoint, staticJoinpoint binding\\n\t\t\t\tint extraArgument = extractExtraArgument(struct.method);\\n\\n\t\t\t\tPointcut pc = null;\\n\t\t\t\tif (preResolvedPointcut != null) {\\n\t\t\t\t\tpc = preResolvedPointcut.getPointcut();\\n\t\t\t\t\t// pc.resolve(binding);\\n\t\t\t\t} else {\\n\t\t\t\t\tpc = pa"
  },
  {
    "method_id": "M174",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < methodArgs.length; i++)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M175",
    "name": "extractExtraArgument",
    "return_type": "int",
    "signature": "extractExtraArgument(String[] argumentSignatures)",
    "file_id": "F6",
    "start_line": 1050,
    "text_preview": "ope(struct.enclosingType, struct.context, bindings);\\n\\n\t\t\t\t// joinpoint, staticJoinpoint binding\\n\t\t\t\tint extraArgument = extractExtraArgument(struct.method);\\n\\n\t\t\t\tPointcut pc = null;\\n\t\t\t\tif (preResolvedPointcut != null) {\\n\t\t\t\t\tpc = preResolvedPointcut.getPointcut();\\n\t\t\t\t\t// pc.resolve(binding);\\n\t\t\t\t} else {\\n\t\t\t\t\tpc = pa"
  },
  {
    "method_id": "M176",
    "name": "for",
    "return_type": "",
    "signature": "for(String argumentSignature : argumentSignatures)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M177",
    "name": "getAnnotation",
    "return_type": "AnnotationGen",
    "signature": "getAnnotation(RuntimeAnnos rvs, UnresolvedType annotationType)",
    "file_id": "F6",
    "start_line": 526,
    "text_preview": "ic boolean handleAspectAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeStruct struct) {\\n\t\tAnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.ASPECT_ANNOTATION);\\n\t\tif (aspect != null) {\\n\t\t\t// semantic check for inheritance (only one level up)\\n\t\t\tboolean extendsAspect = false;\\n\t\t\tif (!\"java.la"
  },
  {
    "method_id": "M178",
    "name": "getAnnotationElement",
    "return_type": "NameValuePair",
    "signature": "getAnnotationElement(AnnotationGen annotation, String elementName)",
    "file_id": "F6",
    "start_line": 538,
    "text_preview": "se;\\n\t\t\t\t}\\n\t\t\t\textendsAspect = struct.enclosingType.getSuperclass().isAspect();\\n\t\t\t}\\n\\n\t\t\tNameValuePair aspectPerClause = getAnnotationElement(aspect, VALUE);\\n\t\t\tfinal PerClause perClause;\\n\t\t\tif (aspectPerClause == null) {\\n\t\t\t\t// empty value means singleton unless inherited\\n\t\t\t\tif (!extendsAspect) {\\n\t\t\t\t\tperClause = new "
  },
  {
    "method_id": "M179",
    "name": "getArgNamesValue",
    "return_type": "String",
    "signature": "getArgNamesValue(AnnotationGen anno)",
    "file_id": "F6",
    "start_line": 1037,
    "text_preview": "tationElement(before, VALUE);\\n\t\t\tif (beforeAdvice != null) {\\n\t\t\t\t// this/target/args binding\\n\t\t\t\tString argumentNames = getArgNamesValue(before);\\n\t\t\t\tif (argumentNames != null) {\\n\t\t\t\t\tstruct.unparsedArgumentNames = argumentNames;\\n\t\t\t\t}\\n\t\t\t\tFormalBinding[] bindings = FormalBinding.NONE;\\n\t\t\t\ttry {\\n\t\t\t\t\tbindings = extract"
  },
  {
    "method_id": "M180",
    "name": "for",
    "return_type": "",
    "signature": "for(NameValuePair element : elements)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M181",
    "name": "lastbit",
    "return_type": "String",
    "signature": "lastbit(String fqname)",
    "file_id": "F6",
    "start_line": 1707,
    "text_preview": ".getNameString())) {\\n\t\t\t\treturn element.getValue().stringifyValue();\\n\t\t\t}\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tprivate static String lastbit(String fqname) {\\n\t\tint i = fqname.lastIndexOf(\".\");\\n\t\tif (i == -1) {\\n\t\t\treturn fqname;\\n\t\t} else {\\n\t\t\treturn fqname.substring(i + 1);\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * Extract the method argument names. First w"
  },
  {
    "method_id": "M182",
    "name": "if",
    "return_type": "",
    "signature": "if(i == -1)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M183",
    "name": "getMethodArgumentNames",
    "return_type": "String[]",
    "signature": "getMethodArgumentNames(Method method, String argNamesFromAnnotation,\n\t\t\tAjAttributeMethodStruct methodStruct)",
    "file_id": "F6",
    "start_line": 154,
    "text_preview": " = bMethod;\\n\t\t}\\n\\n\t\tpublic String[] getArgumentNames() {\\n\t\t\tif (m_argumentNamesLazy == null) {\\n\t\t\t\tm_argumentNamesLazy = getMethodArgumentNames(method, unparsedArgumentNames, this);\\n\t\t\t}\\n\t\t\treturn m_argumentNamesLazy;\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * A struct when we read @AJ on field\\n\t */\\n\tprivate static class AjAttributeFieldStruct e"
  },
  {
    "method_id": "M184",
    "name": "if",
    "return_type": "",
    "signature": "if(lt != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M185",
    "name": "for",
    "return_type": "",
    "signature": "for(LocalVariable localVariable : lvt)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M186",
    "name": "if",
    "return_type": "",
    "signature": "if(localVariable != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M187",
    "name": "if",
    "return_type": "below",
    "signature": "if(argNamesFromAnnotation != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M188",
    "name": "if",
    "return_type": "",
    "signature": "if(argNames.length != 0)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M189",
    "name": "if",
    "return_type": "",
    "signature": "if(lvt.length > 0)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M190",
    "name": "if",
    "return_type": "",
    "signature": "if(localVariable != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M191",
    "name": "if",
    "return_type": "",
    "signature": "if(argNamesFromAnnotation != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M192",
    "name": "if",
    "return_type": "",
    "signature": "if(argNames != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M193",
    "name": "sort",
    "return_type": "",
    "signature": "sort(new Comparator<MethodArgument>()",
    "file_id": "F6",
    "start_line": 1798,
    "text_preview": "f (arguments.size() != method.getArgumentTypes().length) {\\n\t\t\treturn EMPTY_STRINGS;\\n\t\t}\\n\\n\t\t// sort by index\\n\t\targuments.sort(new Comparator<MethodArgument>() {\\n\t\t\tpublic int compare(MethodArgument mo, MethodArgument mo1) {\\n\t\t\t\tif (mo.indexOnStack == mo1.indexOnStack) {\\n\t\t\t\t\treturn 0;\\n\t\t\t\t} else if (mo.indexOnStack > mo"
  },
  {
    "method_id": "M194",
    "name": "compare",
    "return_type": "int",
    "signature": "compare(MethodArgument mo, MethodArgument mo1)",
    "file_id": "F6",
    "start_line": 1799,
    "text_preview": "h) {\\n\t\t\treturn EMPTY_STRINGS;\\n\t\t}\\n\\n\t\t// sort by index\\n\t\targuments.sort(new Comparator<MethodArgument>() {\\n\t\t\tpublic int compare(MethodArgument mo, MethodArgument mo1) {\\n\t\t\t\tif (mo.indexOnStack == mo1.indexOnStack) {\\n\t\t\t\t\treturn 0;\\n\t\t\t\t} else if (mo.indexOnStack > mo1.indexOnStack) {\\n\t\t\t\t\treturn 1;\\n\t\t\t\t} else {\\n\t\t\t\t\tret"
  },
  {
    "method_id": "M195",
    "name": "if",
    "return_type": "",
    "signature": "if(mo.indexOnStack == mo1.indexOnStack)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M196",
    "name": "if",
    "return_type": "else",
    "signature": "if(mo.indexOnStack > mo1.indexOnStack)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M197",
    "name": "for",
    "return_type": "",
    "signature": "for(MethodArgument methodArgument : arguments)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M198",
    "name": "extractArgNamesFromAnnotationValue",
    "return_type": "String[]",
    "signature": "extractArgNamesFromAnnotationValue(Method method, String argNamesFromAnnotation,\n\t\t\tAjAttributeMethodStruct methodStruct)",
    "file_id": "F6",
    "start_line": 1754,
    "text_preview": "21 for a jacoco variant of the cobertura issue below\\n\t\t\t\tif (argNamesFromAnnotation != null) {\\n\t\t\t\t\tString[] argNames = extractArgNamesFromAnnotationValue(method, argNamesFromAnnotation, methodStruct);\\n\t\t\t\t\tif (argNames.length != 0) {\\n\t\t\t\t\t\treturn argNames;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t\t// could be cobertura code where some extra b"
  },
  {
    "method_id": "M199",
    "name": "MethodArgument",
    "return_type": "",
    "signature": "MethodArgument(String name, int indexOnStack)",
    "file_id": "F6",
    "start_line": 1741,
    "text_preview": "(localVariable.getStartPC() == 0) {\\n\t\t\t\t\t\tif (localVariable.getIndex() >= startAtStackIndex) {\\n\t\t\t\t\t\t\targuments.add(new MethodArgument(localVariable.getName(), localVariable.getIndex()));\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t} else {\\n\t\t\t\t\tString typename = (methodStruct.enclosingType != null ? methodStruct.enclosingType.getName() : \"\");"
  },
  {
    "method_id": "M200",
    "name": "LazyResolvedPointcutDefinition",
    "return_type": "",
    "signature": "LazyResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name,\n\t\t\t\tUnresolvedType[] parameterTypes, UnresolvedType returnType, Pointcut pointcut, IScope binding)",
    "file_id": "F6",
    "start_line": 1441,
    "text_preview": "}\\n\t\t// do not resolve binding now but lazily\\n\t\tstruct.ajAttributes.add(new AjAttribute.PointcutDeclarationAttribute(new LazyResolvedPointcutDefinition(\\n\t\t\t\tstruct.enclosingType, struct.method.getModifiers(), struct.method.getName(), argumentTypes, UnresolvedType\\n\t\t\t\t\t\t.forSignature(struct.method.getReturnType().getSign"
  },
  {
    "method_id": "M201",
    "name": "getPointcut",
    "return_type": "Pointcut",
    "signature": "getPointcut()",
    "file_id": "F6",
    "start_line": 1054,
    "text_preview": "aArgument(struct.method);\\n\\n\t\t\t\tPointcut pc = null;\\n\t\t\t\tif (preResolvedPointcut != null) {\\n\t\t\t\t\tpc = preResolvedPointcut.getPointcut();\\n\t\t\t\t\t// pc.resolve(binding);\\n\t\t\t\t} else {\\n\t\t\t\t\tpc = parsePointcut(beforeAdvice.getValue().stringifyValue(), struct, false);\\n\t\t\t\t\tif (pc == null) {\\n\t\t\t\t\t\treturn false;// parse error\\n\t\t\t\t"
  },
  {
    "method_id": "M202",
    "name": "if",
    "return_type": "",
    "signature": "if(m_lazyPointcut == null && m_pointcutUnresolved == null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M203",
    "name": "if",
    "return_type": "",
    "signature": "if(m_lazyPointcut == null && m_pointcutUnresolved != null)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M204",
    "name": "isNullOrEmpty",
    "return_type": "boolean",
    "signature": "isNullOrEmpty(String s)",
    "file_id": "F6",
    "start_line": 1156,
    "text_preview": "= annValue.getValue().stringifyValue();\\n\t\t\t} else {\\n\t\t\t\tpointcut = annPointcut.getValue().stringifyValue();\\n\t\t\t}\\n\t\t\tif (isNullOrEmpty(pointcut)) {\\n\t\t\t\treportError(\"@AfterReturning: either 'value' or 'poincut' must be provided, not both\", struct);\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t\tif (annReturned != null) {\\n\t\t\t\treturned = annRe"
  },
  {
    "method_id": "M205",
    "name": "setIgnoreUnboundBindingNames",
    "return_type": "void",
    "signature": "setIgnoreUnboundBindingNames(Pointcut pointcut, FormalBinding[] bindings)",
    "file_id": "F6",
    "start_line": 1063,
    "text_preview": "truct, false);\\n\t\t\t\t\tif (pc == null) {\\n\t\t\t\t\t\treturn false;// parse error\\n\t\t\t\t\t}\\n\t\t\t\t\tpc = pc.resolve(binding);\\n\t\t\t\t}\\n\t\t\t\tsetIgnoreUnboundBindingNames(pc, bindings);\\n\\n\t\t\t\tISourceLocation sl = struct.context.makeSourceLocation(struct.bMethod.getDeclarationLineNumber(),\\n\t\t\t\t\t\tstruct.bMethod.getDeclarationOffset());\\n\t\t\t\tstr"
  },
  {
    "method_id": "M206",
    "name": "for",
    "return_type": "",
    "signature": "for(FormalBinding formalBinding : bindings)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M207",
    "name": "if",
    "return_type": "",
    "signature": "if(formalBinding instanceof FormalBinding.ImplicitFormalBinding)",
    "file_id": "F6",
    "start_line": 1374,
    "text_preview": "tionElement(pointcut, VALUE);\\n\\n\t\t// semantic check: the method must return void, or be\\n\t\t// \"public static boolean\" for if() support\\n\t\tif (!(Type.VOID.equals(struct.method.getReturnType()) || (Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWa"
  },
  {
    "method_id": "M208",
    "name": "reportError",
    "return_type": "void",
    "signature": "reportError(String message, AjAttributeStruct location)",
    "file_id": "F6",
    "start_line": 532,
    "text_preview": "{\\n\t\t\t\tif (!struct.enclosingType.getSuperclass().isAbstract() && struct.enclosingType.getSuperclass().isAspect()) {\\n\t\t\t\t\treportError(\"cannot extend a concrete aspect\", struct);\\n\t\t\t\t\treturn false;\\n\t\t\t\t}\\n\t\t\t\textendsAspect = struct.enclosingType.getSuperclass().isAspect();\\n\t\t\t}\\n\\n\t\t\tNameValuePair aspectPerClause = getAnnota"
  },
  {
    "method_id": "M209",
    "name": "reportError",
    "return_type": "void",
    "signature": "reportError(String message, IMessageHandler handler, ISourceLocation sourceLocation)",
    "file_id": "F6",
    "start_line": 532,
    "text_preview": "{\\n\t\t\t\tif (!struct.enclosingType.getSuperclass().isAbstract() && struct.enclosingType.getSuperclass().isAspect()) {\\n\t\t\t\t\treportError(\"cannot extend a concrete aspect\", struct);\\n\t\t\t\t\treturn false;\\n\t\t\t\t}\\n\t\t\t\textendsAspect = struct.enclosingType.getSuperclass().isAspect();\\n\t\t\t}\\n\\n\t\t\tNameValuePair aspectPerClause = getAnnota"
  },
  {
    "method_id": "M210",
    "name": "reportWarning",
    "return_type": "void",
    "signature": "reportWarning(String message, AjAttributeStruct location)",
    "file_id": "F6",
    "start_line": 1377,
    "text_preview": "(Type.BOOLEAN.equals(struct.method.getReturnType())\\n\t\t\t\t&& struct.method.isStatic() && struct.method.isPublic()))) {\\n\t\t\treportWarning(\"Found @Pointcut on a method not returning 'void' or not 'public static boolean'\", struct);\\n\t\t\t// no need to stop\\n\t\t}\\n\\n\t\t// semantic check: the method must not throw anything\\n\t\tif (struc"
  },
  {
    "method_id": "M211",
    "name": "parsePointcut",
    "return_type": "Pointcut",
    "signature": "parsePointcut(String pointcutString, AjAttributeStruct struct, boolean allowIf)",
    "file_id": "F6",
    "start_line": 599,
    "text_preview": "tName())) {\\n\t\t\tpointcutString = PerClause.KindAnnotationPrefix.PERCFLOW.extractPointcut(perClauseString);\\n\t\t\tpointcut = parsePointcut(pointcutString, struct, false);\\n\t\t\tperClause = new PerCflow(pointcut, false);\\n\t\t} else if (perClauseString.startsWith(PerClause.KindAnnotationPrefix.PERCFLOWBELOW.getName())) {\\n\t\t\tpointc"
  },
  {
    "method_id": "M212",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ParserException e)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M213",
    "name": "hasIf",
    "return_type": "boolean",
    "signature": "hasIf(Pointcut pointcut)",
    "file_id": "F6",
    "start_line": 1971,
    "text_preview": "kEof();\\n\t\t\tpointcut.check(null, struct.enclosingType.getWorld());\\n\t\t\tif (!allowIf && pointcutString.contains(\"if()\") && hasIf(pointcut)) {\\n\t\t\t\treportError(\"if() pointcut is not allowed at this pointcut location '\" + pointcutString + \"'\", struct);\\n\t\t\t\treturn null;\\n\t\t\t}\\n\t\t\tpointcut.setLocation(struct.context, -1, -1);// "
  },
  {
    "method_id": "M214",
    "name": "parseTypePattern",
    "return_type": "TypePattern",
    "signature": "parseTypePattern(String patternString, AjAttributeStruct location)",
    "file_id": "F6",
    "start_line": 615,
    "text_preview": ") {\\n\t\t\tpointcutString = PerClause.KindAnnotationPrefix.PERTYPEWITHIN.extractPointcut(perClauseString);\\n\t\t\ttypePattern = parseTypePattern(pointcutString, struct);\\n\t\t\tperClause = new PerTypeWithin(typePattern);\\n\t\t} else if (perClauseString.equalsIgnoreCase(PerClause.SINGLETON.getName() + \"()\")) {\\n\t\t\tperClause = new PerSi"
  },
  {
    "method_id": "M215",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ParserException e)",
    "file_id": "F6",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M216",
    "name": "ThrownFormalNotDeclaredInAdviceSignatureException",
    "return_type": "",
    "signature": "ThrownFormalNotDeclaredInAdviceSignatureException(String formalName)",
    "file_id": "F6",
    "start_line": 1259,
    "text_preview": "es();\\n\t\t\t\t\tif (pNames == null || pNames.length == 0 || !Arrays.asList(pNames).contains(thrownFormal)) {\\n\t\t\t\t\t\tthrow new ThrownFormalNotDeclaredInAdviceSignatureException(thrownFormal);\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tString argumentNames = getArgNamesValue(after);\\n\t\t\tif (argumentNames != null) {\\n\t\t\t\tstruct.unparsedArgumentNames ="
  },
  {
    "method_id": "M217",
    "name": "getFormalName",
    "return_type": "String",
    "signature": "getFormalName()",
    "file_id": "F6",
    "start_line": 454,
    "text_preview": "Handler.handleMessage(new Message(WeaverMessages.format(WeaverMessages.RETURNING_FORMAL_NOT_DECLARED_IN_ADVICE,\\n\t\t\t\t\t\te.getFormalName()), IMessage.ERROR, null, bMethod.getSourceLocation()));\\n\t\t\t} catch (ThrownFormalNotDeclaredInAdviceSignatureException e) {\\n\t\t\t\tmsgHandler.handleMessage(new Message(WeaverMessages.format"
  },
  {
    "method_id": "M218",
    "name": "ReturningFormalNotDeclaredInAdviceSignatureException",
    "return_type": "",
    "signature": "ReturningFormalNotDeclaredInAdviceSignatureException(String formalName)",
    "file_id": "F6",
    "start_line": 1169,
    "text_preview": "rNames();\\n\t\t\t\t\tif (pNames == null || pNames.length == 0 || !Arrays.asList(pNames).contains(returned)) {\\n\t\t\t\t\t\tthrow new ReturningFormalNotDeclaredInAdviceSignatureException(returned);\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tString argumentNames = getArgNamesValue(after);\\n\t\t\tif (argumentNames != null) {\\n\t\t\t\tstruct.unparsedArgumentNames = "
  },
  {
    "method_id": "M219",
    "name": "getFormalName",
    "return_type": "String",
    "signature": "getFormalName()",
    "file_id": "F6",
    "start_line": 454,
    "text_preview": "Handler.handleMessage(new Message(WeaverMessages.format(WeaverMessages.RETURNING_FORMAL_NOT_DECLARED_IN_ADVICE,\\n\t\t\t\t\t\te.getFormalName()), IMessage.ERROR, null, bMethod.getSourceLocation()));\\n\t\t\t} catch (ThrownFormalNotDeclaredInAdviceSignatureException e) {\\n\t\t\t\tmsgHandler.handleMessage(new Message(WeaverMessages.format"
  },
  {
    "method_id": "M220",
    "name": "BcelAccessForInlineMunger",
    "return_type": "",
    "signature": "BcelAccessForInlineMunger(ResolvedType aspectType)",
    "file_id": "F7",
    "start_line": 67,
    "text_preview": "er methods representing any created inlineAccessors\\n\t */\\n\tprivate Set<LazyMethodGen> inlineAccessorMethodGens;\\n\\n\tpublic BcelAccessForInlineMunger(ResolvedType aspectType) {\\n\t\tsuper(null, aspectType);\\n\t\tif (aspectType.getWorld().isXnoInline()) {\\n\t\t\tthrow new Error(\"This should not happen\");\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic bo"
  },
  {
    "method_id": "M221",
    "name": "munge",
    "return_type": "boolean",
    "signature": "munge(BcelClassWeaver weaver)",
    "file_id": "F7",
    "start_line": 75,
    "text_preview": "aspectType.getWorld().isXnoInline()) {\\n\t\t\tthrow new Error(\"This should not happen\");\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic boolean munge(BcelClassWeaver weaver) {\\n\t\taspectGen = weaver.getLazyClassGen();\\n\t\tinlineAccessors = new HashMap<>(0);\\n\t\tinlineAccessorMethodGens = new HashSet<>();\\n\\n\t\t// look for all @Around advices\\n\t\tfor (La"
  },
  {
    "method_id": "M222",
    "name": "for",
    "return_type": "accessors",
    "signature": "for(LazyMethodGen lazyMethodGen : inlineAccessorMethodGens)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M223",
    "name": "getMatchingSyntheticMember",
    "return_type": "ResolvedMember",
    "signature": "getMatchingSyntheticMember(Member member)",
    "file_id": "F7",
    "start_line": 103,
    "text_preview": "he wrapper we have added so that we can find their effective signature if needed\\n\t */\\n\t@Override\\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\\n    String name = member.getName();\\n    String signature = name.startsWith(\"ajc$superDispatch$\")\\n      ? member.getSignature()\\n      : member.getSignature()"
  },
  {
    "method_id": "M224",
    "name": "getSignature",
    "return_type": "ResolvedMember",
    "signature": "getSignature()",
    "file_id": "F7",
    "start_line": 106,
    "text_preview": "mber) {\\n    String name = member.getName();\\n    String signature = name.startsWith(\"ajc$superDispatch$\")\\n      ? member.getSignature()\\n      : member.getSignature().replaceFirst(\"\\\\([^;]+;\", \"(\");\\n    ResolvedMember rm = inlineAccessors.get(name + signature);\\n//\t\tSystem.err.println(\"lookup for \" + member.getName() + \":"
  },
  {
    "method_id": "M225",
    "name": "matches",
    "return_type": "boolean",
    "signature": "matches(ResolvedType onType)",
    "file_id": "F7",
    "start_line": 123,
    "text_preview": "ber getSignature() {\\n\t\treturn null;\\n\t}\\n\\n\t/**\\n\t * Match only the aspect for which we act\\n\t */\\n\t@Override\\n\tpublic boolean matches(ResolvedType onType) {\\n\t\treturn aspectType.equals(onType);\\n\t}\\n\\n\t/**\\n\t * Prepare the around advice, flag it as cannot be inlined if it can't be\\n\t */\\n\tprivate void openAroundAdvice(LazyMethodGen"
  },
  {
    "method_id": "M226",
    "name": "openAroundAdvice",
    "return_type": "void",
    "signature": "openAroundAdvice(LazyMethodGen aroundAdvice)",
    "file_id": "F7",
    "start_line": 83,
    "text_preview": ".getMethodGens()) {\\n\t\t\tif (methodGen.hasAnnotation(UnresolvedType.forName(\"org/aspectj/lang/annotation/Around\"))) {\\n\t\t\t\topenAroundAdvice(methodGen);\\n\t\t\t}\\n\t\t}\\n\\n\t\t// add the accessors\\n\t\tfor (LazyMethodGen lazyMethodGen : inlineAccessorMethodGens) {\\n\t\t\taspectGen.addMethodGen(lazyMethodGen);\\n\t\t}\\n\\n\t\t// flush some\\n\t\tinlineAc"
  },
  {
    "method_id": "M227",
    "name": "while",
    "return_type": "",
    "signature": "while(curr != end)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M228",
    "name": "if",
    "return_type": "",
    "signature": "if(realizedCannotInline)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M229",
    "name": "if",
    "return_type": "",
    "signature": "if(invoke instanceof InvokeDynamic)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M230",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember resolvedMember : methods)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M231",
    "name": "if",
    "return_type": "else",
    "signature": "if(inst instanceof FieldInstruction)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M232",
    "name": "if",
    "return_type": "analysis",
    "signature": "if(!realizedCannotInline)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M233",
    "name": "createOrGetInlineAccessorForMethod",
    "return_type": "ResolvedMember",
    "signature": "createOrGetInlineAccessorForMethod(ResolvedMember resolvedMember)",
    "file_id": "F7",
    "start_line": 185,
    "text_preview": "s()), Constants.INVOKEVIRTUAL);\\n\t\t\t\t\t\t\t\tcurr.setInstruction(newInst);\\n\t\t\t\t\t\t\t} else {\\n\t\t\t\t\t\t\t\tResolvedMember accessor = createOrGetInlineAccessorForMethod(resolvedMember);\\n\t\t\t\t\t\t\t\tInvokeInstruction newInst = factory.createInvoke(aspectType.getName(), accessor.getName(),\\n\t\t\t\t\t\t\t\t\t\tBcelWorld.makeBcelType(accessor.getRetu"
  },
  {
    "method_id": "M234",
    "name": "if",
    "return_type": "",
    "signature": "if(inlineAccessor == null)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M235",
    "name": "createOrGetInlineAccessorForSuperDispatch",
    "return_type": "ResolvedMember",
    "signature": "createOrGetInlineAccessorForSuperDispatch(ResolvedMember resolvedMember)",
    "file_id": "F7",
    "start_line": 179,
    "text_preview": "Type.getSuperclass().getName().equals(resolvedMember.getDeclaringType().getName())) {\\n\t\t\t\t\t\t\t\tResolvedMember accessor = createOrGetInlineAccessorForSuperDispatch(resolvedMember);\\n\t\t\t\t\t\t\t\tInvokeInstruction newInst = factory.createInvoke(aspectType.getName(), accessor.getName(),\\n\t\t\t\t\t\t\t\t\t\tBcelWorld.makeBcelType(accessor."
  },
  {
    "method_id": "M236",
    "name": "if",
    "return_type": "",
    "signature": "if(inlineAccessor == null)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M237",
    "name": "createOrGetInlineAccessorForFieldGet",
    "return_type": "ResolvedMember",
    "signature": "createOrGetInlineAccessorForFieldGet(ResolvedMember resolvedMember)",
    "file_id": "F7",
    "start_line": 205,
    "text_preview": "er accessor;\\n\t\t\t\t\t\tif ((inst.opcode == Constants.GETFIELD) || (inst.opcode == Constants.GETSTATIC)) {\\n\t\t\t\t\t\t\taccessor = createOrGetInlineAccessorForFieldGet(resolvedMember);\\n\t\t\t\t\t\t} else {\\n\t\t\t\t\t\t\taccessor = createOrGetInlineAccessorForFieldSet(resolvedMember);\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\tInvokeInstruction newInst = factory.createInv"
  },
  {
    "method_id": "M238",
    "name": "if",
    "return_type": "",
    "signature": "if(inlineAccessor == null)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M239",
    "name": "createOrGetInlineAccessorForFieldSet",
    "return_type": "ResolvedMember",
    "signature": "createOrGetInlineAccessorForFieldSet(ResolvedMember resolvedMember)",
    "file_id": "F7",
    "start_line": 207,
    "text_preview": ".GETSTATIC)) {\\n\t\t\t\t\t\t\taccessor = createOrGetInlineAccessorForFieldGet(resolvedMember);\\n\t\t\t\t\t\t} else {\\n\t\t\t\t\t\t\taccessor = createOrGetInlineAccessorForFieldSet(resolvedMember);\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\tInvokeInstruction newInst = factory.createInvoke(aspectType.getName(), accessor.getName(),\\n\t\t\t\t\t\t\t\tBcelWorld.makeBcelType(accessor.g"
  },
  {
    "method_id": "M240",
    "name": "if",
    "return_type": "",
    "signature": "if(inlineAccessor == null)",
    "file_id": "F7",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M241",
    "name": "BcelAdvice",
    "return_type": "",
    "signature": "BcelAdvice(AjAttribute.AdviceAttribute attribute, Pointcut pointcut, Member adviceSignature, ResolvedType concreteAspect)",
    "file_id": "F8",
    "start_line": 75,
    "text_preview": "eTest;\\n\tprivate ExposedState exposedState;\\n\tprivate int containsInvokedynamic = 0;// 0 = dontknow, 1=no, 2=yes\\n\\n\tpublic BcelAdvice(AjAttribute.AdviceAttribute attribute, Pointcut pointcut, Member adviceSignature, ResolvedType concreteAspect) {\\n\t\tsuper(attribute, pointcut, simplify(attribute.getKind(), adviceSignature))"
  },
  {
    "method_id": "M242",
    "name": "bindsProceedingJoinPoint",
    "return_type": "boolean",
    "signature": "bindsProceedingJoinPoint()",
    "file_id": "F8",
    "start_line": 80,
    "text_preview": " pointcut, simplify(attribute.getKind(), adviceSignature));\\n\t\tthis.concreteAspect = concreteAspect;\\n\t}\\n\\n\tpublic boolean bindsProceedingJoinPoint() {\\n\t\tUnresolvedType[] parameterTypes = signature.getParameterTypes();\\n\t\tfor (UnresolvedType parameterType : parameterTypes) {\\n\t\t\tif (parameterType.equals(UnresolvedType.PROCE"
  },
  {
    "method_id": "M243",
    "name": "for",
    "return_type": "",
    "signature": "for(UnresolvedType parameterType : parameterTypes)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M244",
    "name": "simplify",
    "return_type": "Member",
    "signature": "simplify(AdviceKind kind, Member adviceSignature)",
    "file_id": "F8",
    "start_line": 76,
    "text_preview": "ibute attribute, Pointcut pointcut, Member adviceSignature, ResolvedType concreteAspect) {\\n\t\tsuper(attribute, pointcut, simplify(attribute.getKind(), adviceSignature));\\n\t\tthis.concreteAspect = concreteAspect;\\n\t}\\n\\n\tpublic boolean bindsProceedingJoinPoint() {\\n\t\tUnresolvedType[] parameterTypes = signature.getParameterType"
  },
  {
    "method_id": "M245",
    "name": "if",
    "return_type": "",
    "signature": "if(adviceSignature != null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M246",
    "name": "if",
    "return_type": "",
    "signature": "if(adviceSignature instanceof BcelMethod)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M247",
    "name": "concretize",
    "return_type": "ShadowMunger",
    "signature": "concretize(ResolvedType fromType, World world, PerClause clause)",
    "file_id": "F8",
    "start_line": 118,
    "text_preview": "ameterNames());\\n\t\t\t\t\treturn simplermember;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\treturn adviceSignature;\\n\t}\\n\\n\t@Override\\n\tpublic ShadowMunger concretize(ResolvedType fromType, World world, PerClause clause) {\\n\t\tif (!world.areAllLintIgnored()) {\\n\t\t\tsuppressLintWarnings(world);\\n\t\t}\\n\t\tShadowMunger ret = super.concretize(fromType, world, clause"
  },
  {
    "method_id": "M248",
    "name": "parameterizeWith",
    "return_type": "ShadowMunger",
    "signature": "parameterizeWith(ResolvedType declaringType, Map<String, UnresolvedType> typeVariableMap)",
    "file_id": "F8",
    "start_line": 141,
    "text_preview": "getLint().noGuardForLazyTjp.signal(\"\", getSourceLocation());\\n\t\t\t}\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\t@Override\\n\tpublic ShadowMunger parameterizeWith(ResolvedType declaringType, Map<String, UnresolvedType> typeVariableMap) {\\n\t\tPointcut pc = getPointcut().parameterizeWith(typeVariableMap, declaringType.getWorld());\\n\\n\t\tBcelAdvice ret"
  },
  {
    "method_id": "M249",
    "name": "match",
    "return_type": "boolean",
    "signature": "match(Shadow shadow, World world)",
    "file_id": "F8",
    "start_line": 156,
    "text_preview": " new BcelAdvice(this.attribute, pc, adviceSignature, this.concreteAspect);\\n\t\treturn ret;\\n\t}\\n\\n\t@Override\\n\tpublic boolean match(Shadow shadow, World world) {\\n\t\tif (world.areAllLintIgnored()) {\\n\t\t\treturn super.match(shadow, world);\\n\t\t} else {\\n\t\t\tsuppressLintWarnings(world);\\n\t\t\tboolean ret = super.match(shadow, world);\\n\t\t\t"
  },
  {
    "method_id": "M250",
    "name": "specializeOn",
    "return_type": "void",
    "signature": "specializeOn(Shadow shadow)",
    "file_id": "F8",
    "start_line": 168,
    "text_preview": "adow, world);\\n\t\t\tclearLintSuppressions(world, this.suppressedLintKinds);\\n\t\t\treturn ret;\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic void specializeOn(Shadow shadow) {\\n\t\tif (getKind() == AdviceKind.Around) {\\n\t\t\t((BcelShadow) shadow).initializeForAroundClosure();\\n\t\t}\\n\\n\t\t// XXX this case is just here for supporting lazy test code\\n\t\tif (ge"
  },
  {
    "method_id": "M251",
    "name": "canInline",
    "return_type": "boolean",
    "signature": "canInline(Shadow s)",
    "file_id": "F8",
    "start_line": 230,
    "text_preview": "Shadow) shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow, getSourceLocation());\\n\t\t}\\n\t}\\n\\n\tprivate boolean canInline(Shadow s) {\\n\t\tif (attribute.isProceedInInners()) {\\n\t\t\treturn false;\\n\t\t}\\n\t\t// XXX this guard seems to only be needed for bad test cases\\n\t\tif (concreteAspect == null || concreteAspect.isMissin"
  },
  {
    "method_id": "M252",
    "name": "if",
    "return_type": "",
    "signature": "if(boType == null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M253",
    "name": "if",
    "return_type": "",
    "signature": "if(containsInvokedynamic == 0)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M254",
    "name": "while",
    "return_type": "",
    "signature": "while(lmg == null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M255",
    "name": "if",
    "return_type": "",
    "signature": "if(rtd instanceof BcelObjectType)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M256",
    "name": "if",
    "return_type": "",
    "signature": "if(lmg != null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M257",
    "name": "if",
    "return_type": "",
    "signature": "if(containsInvokedynamic == 2)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M258",
    "name": "aspectIsBroken",
    "return_type": "boolean",
    "signature": "aspectIsBroken()",
    "file_id": "F8",
    "start_line": 285,
    "text_preview": "f (containsInvokedynamic == 2) {\\n\t\t\treturn false;\\n\t\t}\\n\t\treturn boType.getLazyClassGen().isWoven();\\n\t}\\n\\n\tprivate boolean aspectIsBroken() {\\n\t\tif (concreteAspect instanceof ReferenceType) {\\n\t\t\tReferenceTypeDelegate rtDelegate = ((ReferenceType) concreteAspect).getDelegate();\\n\t\t\tif (!(rtDelegate instanceof BcelObjectType)"
  },
  {
    "method_id": "M259",
    "name": "if",
    "return_type": "",
    "signature": "if(concreteAspect instanceof ReferenceType)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M260",
    "name": "implementOn",
    "return_type": "boolean",
    "signature": "implementOn(Shadow s)",
    "file_id": "F8",
    "start_line": 296,
    "text_preview": "if (!(rtDelegate instanceof BcelObjectType)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\t@Override\\n\tpublic boolean implementOn(Shadow s) {\\n\t\thasMatchedAtLeastOnce = true;\\n\\n\t\t// pr263323 - if the aspect is broken then the delegate will not be usable for weaving\\n\t\tif (aspectIsBroken()) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tBcel"
  },
  {
    "method_id": "M261",
    "name": "if",
    "return_type": "",
    "signature": "if(member instanceof BcelMethod)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M262",
    "name": "if",
    "return_type": "",
    "signature": "if(enclosingMember instanceof BcelMethod)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M263",
    "name": "if",
    "return_type": "",
    "signature": "if(runtimeTest == Literal.FALSE)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M264",
    "name": "removeUnnecessaryProblems",
    "return_type": "void",
    "signature": "removeUnnecessaryProblems(BcelMethod method, int problemLineNumber)",
    "file_id": "F8",
    "start_line": 313,
    "text_preview": "getThrownExceptions().isEmpty()) {\\n\t\t\tMember member = shadow.getSignature();\\n\t\t\tif (member instanceof BcelMethod) {\\n\t\t\t\tremoveUnnecessaryProblems((BcelMethod) member, ((BcelMethod) member).getDeclarationLineNumber());\\n\t\t\t} else {\\n\t\t\t\t// we're in a call shadow therefore need the line number of the\\n\t\t\t\t// declared method"
  },
  {
    "method_id": "M265",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceContext instanceof IEclipseSourceContext)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M266",
    "name": "collectCheckedExceptions",
    "return_type": "Collection<ResolvedType>",
    "signature": "collectCheckedExceptions(UnresolvedType[] excs)",
    "file_id": "F8",
    "start_line": 421,
    "text_preview": "moveUnnecessaryProblems(method, problemLineNumber);\\n\t\t}\\n\t}\\n\\n\t// ---- implementations\\n\\n\tprivate Collection<ResolvedType> collectCheckedExceptions(UnresolvedType[] excs) {\\n\t\tif (excs == null || excs.length == 0) {\\n\t\t\treturn Collections.emptyList();\\n\t\t}\\n\\n\t\tCollection<ResolvedType> ret = new ArrayList<>();\\n\t\tWorld world = "
  },
  {
    "method_id": "M267",
    "name": "if",
    "return_type": "",
    "signature": "if(excs == null || excs.length == 0)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M268",
    "name": "for",
    "return_type": "",
    "signature": "for(UnresolvedType exc : excs)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M269",
    "name": "getThrownExceptions",
    "return_type": "Collection<ResolvedType>",
    "signature": "getThrownExceptions()",
    "file_id": "F8",
    "start_line": 310,
    "text_preview": "ly deals with 'declared exception is not thrown'\\n\t\tif (!shadow.getWorld().isIgnoringUnusedDeclaredThrownException() && !getThrownExceptions().isEmpty()) {\\n\t\t\tMember member = shadow.getSignature();\\n\t\t\tif (member instanceof BcelMethod) {\\n\t\t\t\tremoveUnnecessaryProblems((BcelMethod) member, ((BcelMethod) member).getDeclarat"
  },
  {
    "method_id": "M270",
    "name": "if",
    "return_type": "",
    "signature": "if(thrownExceptions == null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M271",
    "name": "if",
    "return_type": "",
    "signature": "if(m == null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M272",
    "name": "mustCheckExceptions",
    "return_type": "boolean",
    "signature": "mustCheckExceptions()",
    "file_id": "F8",
    "start_line": 479,
    "text_preview": "adow in the case of @AJ aspects so that around\\n\t * can throws Throwable\\n\t *\\n\t * @return\\n\t */\\n\t@Override\\n\tpublic boolean mustCheckExceptions() {\\n\t\tif (getConcreteAspect() == null) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn !getConcreteAspect().isAnnotationStyleAspect();\\n\t}\\n\\n\t// only call me after prepare has been called\\n\t@Override\\n"
  },
  {
    "method_id": "M273",
    "name": "hasDynamicTests",
    "return_type": "boolean",
    "signature": "hasDynamicTests()",
    "file_id": "F8",
    "start_line": 389,
    "text_preview": ",\\n\t\t\t\t\t\tshadow.getSourceLocation());\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t\tif (!canInline(s)) {\\n\t\t\t\tshadow.weaveAroundClosure(this, hasDynamicTests());\\n\t\t\t} else {\\n\t\t\t\tshadow.weaveAroundInline(this, hasDynamicTests());\\n\t\t\t}\\n\t\t} else if (getKind() == AdviceKind.InterInitializer) {\\n\t\t\tshadow.weaveAfterReturning(this);\\n\t\t} else if (g"
  },
  {
    "method_id": "M274",
    "name": "getAdviceInstructions",
    "return_type": "InstructionList",
    "signature": "getAdviceInstructions(BcelShadow s, BcelVar extraArgVar, InstructionHandle ifNoAdvice)",
    "file_id": "F8",
    "start_line": 507,
    "text_preview": " * @param ifNoAdvice The instructionHandle to jump to if the dynamic tests for this munger fails.\\n\t */\\n\tInstructionList getAdviceInstructions(BcelShadow s, BcelVar extraArgVar, InstructionHandle ifNoAdvice) {\\n\t\tBcelShadow shadow = s;\\n\t\tInstructionFactory fact = shadow.getFactory();\\n\t\tBcelWorld world = shadow.getWorld()"
  },
  {
    "method_id": "M275",
    "name": "if",
    "return_type": "",
    "signature": "if(b)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M276",
    "name": "if",
    "return_type": "",
    "signature": "if(lineNumber > 0)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M277",
    "name": "if",
    "return_type": "",
    "signature": "if(lvt != null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M278",
    "name": "for",
    "return_type": "",
    "signature": "for(LocalVariable lv : lvTable)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M279",
    "name": "getAdviceArgSetup",
    "return_type": "InstructionList",
    "signature": "getAdviceArgSetup(BcelShadow shadow, BcelVar extraVar, InstructionList closureInstantiation)",
    "file_id": "F8",
    "start_line": 523,
    "text_preview": "est.makeInstanceof(extraArgVar, getExtraParameterType().resolve(world)), null, ifNoAdvice, null));\\n\t\t\t}\\n\t\t}\\n\t\til.append(getAdviceArgSetup(shadow, extraArgVar, null));\\n\t\til.append(getNonTestAdviceInstructions(shadow));\\n\\n\t\tInstructionHandle ifYesAdvice = il.getStart();\\n\t\til.insert(getTestInstructions(shadow, ifYesAdvice,"
  },
  {
    "method_id": "M280",
    "name": "if",
    "return_type": "",
    "signature": "if(targetAspectField != null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M281",
    "name": "if",
    "return_type": "",
    "signature": "if(v == null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M282",
    "name": "if",
    "return_type": "handling",
    "signature": "if(!isAnnotationStyleAspect)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M283",
    "name": "if",
    "return_type": "",
    "signature": "if(previousIsClosure)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M284",
    "name": "if",
    "return_type": "ordering",
    "signature": "if(!isAnnotationStyleAspect)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M285",
    "name": "getNonTestAdviceInstructions",
    "return_type": "InstructionList",
    "signature": "getNonTestAdviceInstructions(BcelShadow shadow)",
    "file_id": "F8",
    "start_line": 524,
    "text_preview": "olve(world)), null, ifNoAdvice, null));\\n\t\t\t}\\n\t\t}\\n\t\til.append(getAdviceArgSetup(shadow, extraArgVar, null));\\n\t\til.append(getNonTestAdviceInstructions(shadow));\\n\\n\t\tInstructionHandle ifYesAdvice = il.getStart();\\n\t\til.insert(getTestInstructions(shadow, ifYesAdvice, ifNoAdvice, ifYesAdvice));\\n\\n\t\t// If inserting instructions"
  },
  {
    "method_id": "M286",
    "name": "getOriginalSignature",
    "return_type": "Member",
    "signature": "getOriginalSignature()",
    "file_id": "F8",
    "start_line": 685,
    "text_preview": "ructions(BcelShadow shadow) {\\n\t\treturn new InstructionList(Utility.createInvoke(shadow.getFactory(), shadow.getWorld(), getOriginalSignature()));\\n\t}\\n\\n\t@Override\\n\tpublic Member getOriginalSignature() {\\n\t\tMember sig = getSignature();\\n\t\tif (sig instanceof ResolvedMember) {\\n\t\t\tResolvedMember rsig = (ResolvedMember) sig;\\n\t\t"
  },
  {
    "method_id": "M287",
    "name": "if",
    "return_type": "",
    "signature": "if(sig instanceof ResolvedMember)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M288",
    "name": "getTestInstructions",
    "return_type": "InstructionList",
    "signature": "getTestInstructions(BcelShadow shadow, InstructionHandle sk, InstructionHandle fk, InstructionHandle next)",
    "file_id": "F8",
    "start_line": 527,
    "text_preview": "ull));\\n\t\til.append(getNonTestAdviceInstructions(shadow));\\n\\n\t\tInstructionHandle ifYesAdvice = il.getStart();\\n\t\til.insert(getTestInstructions(shadow, ifYesAdvice, ifNoAdvice, ifYesAdvice));\\n\\n\t\t// If inserting instructions at the start of a method, we need a nice line number for this entry\\n\t\t// in the stack trace\\n\t\tif (sh"
  },
  {
    "method_id": "M289",
    "name": "compareTo",
    "return_type": "int",
    "signature": "compareTo(Object other)",
    "file_id": "F8",
    "start_line": 705,
    "text_preview": ");\\n\t\treturn BcelRenderer.renderTest(shadow.getFactory(), shadow.getWorld(), runtimeTest, sk, fk, next);\\n\t}\\n\\n\tpublic int compareTo(Object other) {\\n\t\tif (!(other instanceof BcelAdvice)) {\\n\t\t\treturn 0;\\n\t\t}\\n\t\tBcelAdvice o = (BcelAdvice) other;\\n\\n\t\t// System.err.println(\"compareTo: \" + this + \", \" + o);\\n\t\tif (kind.getPrecede"
  },
  {
    "method_id": "M290",
    "name": "if",
    "return_type": "",
    "signature": "if(ret != 0)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M291",
    "name": "if",
    "return_type": "",
    "signature": "if(declaringAspect == o_declaringAspect)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M292",
    "name": "getExposedStateAsBcelVars",
    "return_type": "BcelVar[]",
    "signature": "getExposedStateAsBcelVars(boolean isAround)",
    "file_id": "F8",
    "start_line": 764,
    "text_preview": "(o_declaringAspect.isAssignableFrom(declaringAspect)) {\\n\t\t\treturn +1;\\n\t\t} else {\\n\t\t\treturn 0;\\n\t\t}\\n\t}\\n\\n\tpublic BcelVar[] getExposedStateAsBcelVars(boolean isAround) {\\n\t\t// ATAJ aspect\\n\t\tif (isAround) {\\n\t\t\t// the closure instantiation has the same mapping as the extracted method from wich it is called\\n\t\t\tif (getConcreteA"
  },
  {
    "method_id": "M293",
    "name": "if",
    "return_type": "aspect",
    "signature": "if(isAround)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M294",
    "name": "if",
    "return_type": "",
    "signature": "if(exposedState == null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M295",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < len; i++)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M296",
    "name": "suppressLintWarnings",
    "return_type": "void",
    "signature": "suppressLintWarnings(World inWorld)",
    "file_id": "F8",
    "start_line": 120,
    "text_preview": " ShadowMunger concretize(ResolvedType fromType, World world, PerClause clause) {\\n\t\tif (!world.areAllLintIgnored()) {\\n\t\t\tsuppressLintWarnings(world);\\n\t\t}\\n\t\tShadowMunger ret = super.concretize(fromType, world, clause);\\n\t\tif (!world.areAllLintIgnored()) {\\n\t\t\tclearLintSuppressions(world, this.suppressedLintKinds);\\n\t\t}\\n\t\tIf"
  },
  {
    "method_id": "M297",
    "name": "if",
    "return_type": "",
    "signature": "if(suppressedLintKinds == null)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M298",
    "name": "if",
    "return_type": "",
    "signature": "if(signature instanceof BcelMethod)",
    "file_id": "F8",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M299",
    "name": "clearLintSuppressions",
    "return_type": "void",
    "signature": "clearLintSuppressions(World inWorld, Collection<Lint.Kind> toClear)",
    "file_id": "F8",
    "start_line": 124,
    "text_preview": "ings(world);\\n\t\t}\\n\t\tShadowMunger ret = super.concretize(fromType, world, clause);\\n\t\tif (!world.areAllLintIgnored()) {\\n\t\t\tclearLintSuppressions(world, this.suppressedLintKinds);\\n\t\t}\\n\t\tIfFinder ifinder = new IfFinder();\\n\t\tret.getPointcut().accept(ifinder, null);\\n\t\tboolean hasGuardTest = ifinder.hasIf && getKind() != Advic"
  },
  {
    "method_id": "M300",
    "name": "BcelAdvice",
    "return_type": "",
    "signature": "BcelAdvice(AdviceKind kind, Pointcut pointcut, Member signature, int extraArgumentFlags, int start, int end,\n\t\t\tISourceContext sourceContext, ResolvedType concreteAspect)",
    "file_id": "F8",
    "start_line": 75,
    "text_preview": "eTest;\\n\tprivate ExposedState exposedState;\\n\tprivate int containsInvokedynamic = 0;// 0 = dontknow, 1=no, 2=yes\\n\\n\tpublic BcelAdvice(AjAttribute.AdviceAttribute attribute, Pointcut pointcut, Member adviceSignature, ResolvedType concreteAspect) {\\n\t\tsuper(attribute, pointcut, simplify(attribute.getKind(), adviceSignature))"
  },
  {
    "method_id": "M301",
    "name": "BcelAnnotation",
    "return_type": "",
    "signature": "BcelAnnotation(AnnotationGen theBcelAnnotation, World world)",
    "file_id": "F9",
    "start_line": 37,
    "text_preview": "t\\n */\\npublic class BcelAnnotation extends AbstractAnnotationAJ {\\n\\n\tprivate final AnnotationGen bcelAnnotation;\\n\\n\tpublic BcelAnnotation(AnnotationGen theBcelAnnotation, World world) {\\n\t\tsuper(UnresolvedType.forSignature(theBcelAnnotation.getTypeSignature()).resolve(world));\\n\t\tthis.bcelAnnotation = theBcelAnnotation;\\n\t}\\n"
  },
  {
    "method_id": "M302",
    "name": "BcelAnnotation",
    "return_type": "",
    "signature": "BcelAnnotation(AnnotationGen theBcelAnnotation, ResolvedType resolvedAnnotationType)",
    "file_id": "F9",
    "start_line": 37,
    "text_preview": "t\\n */\\npublic class BcelAnnotation extends AbstractAnnotationAJ {\\n\\n\tprivate final AnnotationGen bcelAnnotation;\\n\\n\tpublic BcelAnnotation(AnnotationGen theBcelAnnotation, World world) {\\n\t\tsuper(UnresolvedType.forSignature(theBcelAnnotation.getTypeSignature()).resolve(world));\\n\t\tthis.bcelAnnotation = theBcelAnnotation;\\n\t}\\n"
  },
  {
    "method_id": "M303",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F9",
    "start_line": 47,
    "text_preview": "esolvedAnnotationType) {\\n\t\tsuper(resolvedAnnotationType);\\n\t\tthis.bcelAnnotation = theBcelAnnotation;\\n\t}\\n\\n\tpublic String toString() {\\n\t\tStringBuilder sb = new StringBuilder();\\n\t\tList<NameValuePair> nvPairs = bcelAnnotation.getValues();\\n\t\tsb.append(\"Anno[\" + getTypeSignature() + \" \" + (isRuntimeVisible() ? \"rVis\" : \"rInv"
  },
  {
    "method_id": "M304",
    "name": "for",
    "return_type": "",
    "signature": "for(NameValuePair element : nvPairs)",
    "file_id": "F9",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M305",
    "name": "if",
    "return_type": "",
    "signature": "if(i > 0)",
    "file_id": "F9",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M306",
    "name": "getTargets",
    "return_type": "Set<String>",
    "signature": "getTargets()",
    "file_id": "F9",
    "start_line": 70,
    "text_preview": "\ti++;\\n\t\t\t}\\n\t\t}\\n\t\tsb.append(\"]\");\\n\t\treturn sb.toString();\\n\t}\\n\\n\t/**\\n\t * {@inheritDoc}\\n\t */\\n\t@Override\\n\tpublic Set<String> getTargets() {\\n\t\tif (!type.equals(UnresolvedType.AT_TARGET)) {\\n\t\t\treturn Collections.emptySet();\\n\t\t}\\n\t\tList<NameValuePair> values = bcelAnnotation.getValues();\\n\t\tNameValuePair envp = values.get(0);\\n\t\t"
  },
  {
    "method_id": "M307",
    "name": "for",
    "return_type": "",
    "signature": "for(ElementValue elementValue : evs)",
    "file_id": "F9",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M308",
    "name": "hasNameValuePair",
    "return_type": "boolean",
    "signature": "hasNameValuePair(String name, String value)",
    "file_id": "F9",
    "start_line": 90,
    "text_preview": "\ttargets.add(ev.getEnumValueString());\\n\t\t}\\n\t\treturn targets;\\n\t}\\n\\n\t/**\\n\t * {@inheritDoc}\\n\t */\\n\t@Override\\n\tpublic boolean hasNameValuePair(String name, String value) {\\n\t\treturn bcelAnnotation.hasNameValuePair(name, value);\\n\t}\\n\\n\t/**\\n\t * {@inheritDoc}\\n\t */\\n\t@Override\\n\tpublic boolean hasNamedValue(String name) {\\n\t\treturn bc"
  },
  {
    "method_id": "M309",
    "name": "hasNamedValue",
    "return_type": "boolean",
    "signature": "hasNamedValue(String name)",
    "file_id": "F9",
    "start_line": 98,
    "text_preview": "ue) {\\n\t\treturn bcelAnnotation.hasNameValuePair(name, value);\\n\t}\\n\\n\t/**\\n\t * {@inheritDoc}\\n\t */\\n\t@Override\\n\tpublic boolean hasNamedValue(String name) {\\n\t\treturn bcelAnnotation.hasNamedValue(name);\\n\t}\\n\\n\t/**\\n\t * {@inheritDoc}\\n\t */\\n\t@Override\\n\tpublic String stringify() {\\n\t\tStringBuilder sb = new StringBuilder();\\n\t\tsb.append("
  },
  {
    "method_id": "M310",
    "name": "stringify",
    "return_type": "String",
    "signature": "stringify()",
    "file_id": "F9",
    "start_line": 106,
    "text_preview": "e(String name) {\\n\t\treturn bcelAnnotation.hasNamedValue(name);\\n\t}\\n\\n\t/**\\n\t * {@inheritDoc}\\n\t */\\n\t@Override\\n\tpublic String stringify() {\\n\t\tStringBuilder sb = new StringBuilder();\\n\t\tsb.append(\"@\").append(type.getClassName());\\n\t\tList<NameValuePair> values = bcelAnnotation.getValues();\\n\t\tif (values != null && values.size() !"
  },
  {
    "method_id": "M311",
    "name": "for",
    "return_type": "",
    "signature": "for(NameValuePair nvPair : values)",
    "file_id": "F9",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M312",
    "name": "isRuntimeVisible",
    "return_type": "boolean",
    "signature": "isRuntimeVisible()",
    "file_id": "F9",
    "start_line": 50,
    "text_preview": "uilder();\\n\t\tList<NameValuePair> nvPairs = bcelAnnotation.getValues();\\n\t\tsb.append(\"Anno[\" + getTypeSignature() + \" \" + (isRuntimeVisible() ? \"rVis\" : \"rInvis\"));\\n\t\tif (nvPairs.size() > 0) {\\n\t\t\tsb.append(\" \");\\n\t\t\tint i = 0;\\n\t\t\tfor (NameValuePair element : nvPairs) {\\n\t\t\t\tif (i > 0) {\\n\t\t\t\t\tsb.append(',');\\n\t\t\t\t}\\n\t\t\t\tsb.app"
  },
  {
    "method_id": "M313",
    "name": "getBcelAnnotation",
    "return_type": "AnnotationGen",
    "signature": "getBcelAnnotation()",
    "file_id": "F9",
    "start_line": 131,
    "text_preview": "ation.isRuntimeVisible();\\n\t}\\n\\n\t/**\\n\t * @return return the real bcel annotation being wrapped\\n\t */\\n\tpublic AnnotationGen getBcelAnnotation() {\\n\t\treturn bcelAnnotation;\\n\t}\\n\\n\t/**\\n\t * {@inheritDoc}\\n\t */\\n\tpublic String getStringFormOfValue(String name) {\\n\t\tList<NameValuePair> annotationValues = this.bcelAnnotation.getValues"
  },
  {
    "method_id": "M314",
    "name": "getStringFormOfValue",
    "return_type": "String",
    "signature": "getStringFormOfValue(String name)",
    "file_id": "F9",
    "start_line": 138,
    "text_preview": " */\\n\tpublic AnnotationGen getBcelAnnotation() {\\n\t\treturn bcelAnnotation;\\n\t}\\n\\n\t/**\\n\t * {@inheritDoc}\\n\t */\\n\tpublic String getStringFormOfValue(String name) {\\n\t\tList<NameValuePair> annotationValues = this.bcelAnnotation.getValues();\\n\t\tif (annotationValues == null || annotationValues.size() == 0) {\\n\t\t\treturn null;\\n\t\t} else"
  },
  {
    "method_id": "M315",
    "name": "for",
    "return_type": "",
    "signature": "for(NameValuePair nvPair : annotationValues)",
    "file_id": "F9",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M316",
    "name": "BcelCflowAccessVar",
    "return_type": "",
    "signature": "BcelCflowAccessVar(ResolvedType type, Member stackField, int index)",
    "file_id": "F10",
    "start_line": 39,
    "text_preview": "to from Object\\n\t * @param stackField the member containing the CFLOW_STACK_TYPE\\n\t * @param index yeah yeah\\n\t */\\n\tpublic BcelCflowAccessVar(ResolvedType type, Member stackField, int index) {\\n\t\tsuper(type, 0);\\n\t\tthis.stackField = stackField;\\n\t\tthis.index = index;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"BcelCflowAccessV"
  },
  {
    "method_id": "M317",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F10",
    "start_line": 45,
    "text_preview": "ber stackField, int index) {\\n\t\tsuper(type, 0);\\n\t\tthis.stackField = stackField;\\n\t\tthis.index = index;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"BcelCflowAccessVar(\" + getType() + \" \" + stackField + \".\" + index + \")\";\\n\t}\\n\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemente"
  },
  {
    "method_id": "M318",
    "name": "createLoad",
    "return_type": "Instruction",
    "signature": "createLoad(InstructionFactory fact)",
    "file_id": "F10",
    "start_line": 49,
    "text_preview": "toString() {\\n\t\treturn \"BcelCflowAccessVar(\" + getType() + \" \" + stackField + \".\" + index + \")\";\\n\t}\\n\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Instruction createStore(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t"
  },
  {
    "method_id": "M319",
    "name": "createStore",
    "return_type": "Instruction",
    "signature": "createStore(InstructionFactory fact)",
    "file_id": "F10",
    "start_line": 53,
    "text_preview": "nstruction createLoad(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Instruction createStore(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tthrow new RuntimeException(\"u"
  },
  {
    "method_id": "M320",
    "name": "createCopyFrom",
    "return_type": "InstructionList",
    "signature": "createCopyFrom(InstructionFactory fact, int oldSlot)",
    "file_id": "F10",
    "start_line": 57,
    "text_preview": "ction createStore(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createLoadI"
  },
  {
    "method_id": "M321",
    "name": "appendLoad",
    "return_type": "void",
    "signature": "appendLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F10",
    "start_line": 61,
    "text_preview": " createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createLoadInstructions(getType(), fact));\\n\t}\\n\\n\tpublic InstructionList createLoadInstructions(ResolvedType toType, InstructionFacto"
  },
  {
    "method_id": "M322",
    "name": "createLoadInstructions",
    "return_type": "InstructionList",
    "signature": "createLoadInstructions(ResolvedType toType, InstructionFactory fact)",
    "file_id": "F10",
    "start_line": 62,
    "text_preview": "ntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createLoadInstructions(getType(), fact));\\n\t}\\n\\n\tpublic InstructionList createLoadInstructions(ResolvedType toType, InstructionFactory fact) {\\n\t\tInstructionList il = new InstructionList();\\n\\n\t\til.append("
  },
  {
    "method_id": "M323",
    "name": "appendLoadAndConvert",
    "return_type": "void",
    "signature": "appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType)",
    "file_id": "F10",
    "start_line": 78,
    "text_preview": "il.append(Utility.createConversion(fact, Type.OBJECT, BcelWorld.makeBcelType(toType)));\\n\\n\t\treturn il;\\n\\n\t}\\n\\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\\n\t\til.append(createLoadInstructions(toType, fact));\\n\\n\t}\\n\\n\tpublic void insertLoad(InstructionList il, Instruction"
  },
  {
    "method_id": "M324",
    "name": "insertLoad",
    "return_type": "void",
    "signature": "insertLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F10",
    "start_line": 83,
    "text_preview": "l, InstructionFactory fact, ResolvedType toType) {\\n\t\til.append(createLoadInstructions(toType, fact));\\n\\n\t}\\n\\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.insert(createLoadInstructions(getType(), fact));\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M325",
    "name": "BcelCflowCounterFieldAdder",
    "return_type": "",
    "signature": "BcelCflowCounterFieldAdder(ResolvedMember cflowCounterField)",
    "file_id": "F11",
    "start_line": 32,
    "text_preview": "*/\\npublic class BcelCflowCounterFieldAdder extends BcelTypeMunger {\\n\tprivate ResolvedMember cflowCounterField;\\n\\n\tpublic BcelCflowCounterFieldAdder(ResolvedMember cflowCounterField) {\\n\t\tsuper(null, (ResolvedType) cflowCounterField.getDeclaringType());\\n\t\tthis.cflowCounterField = cflowCounterField;\\n\t}\\n\\n\tpublic boolean mun"
  },
  {
    "method_id": "M326",
    "name": "munge",
    "return_type": "boolean",
    "signature": "munge(BcelClassWeaver weaver)",
    "file_id": "F11",
    "start_line": 27,
    "text_preview": "ver.ResolvedMember;\\nimport org.aspectj.weaver.ResolvedType;\\n\\n/**\\n * This type munger will modify a given class (see the munge() method) to include a field representing a CflowCounter object.\\n */\\npublic class BcelCflowCounterFieldAdder extends BcelTypeMunger {\\n\tprivate ResolvedMember cflowCounterField;\\n\\n\tpublic BcelCflo"
  },
  {
    "method_id": "M327",
    "name": "getMatchingSyntheticMember",
    "return_type": "ResolvedMember",
    "signature": "getMatchingSyntheticMember(Member member)",
    "file_id": "F11",
    "start_line": 67,
    "text_preview": "ility.createSet(fact, cflowCounterField));\\n\t\tclinit.getBody().insert(setup);\\n\\n\t\treturn true;\\n\t}\\n\\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\\n\t\treturn null;\\n\t}\\n\\n\tpublic ResolvedMember getSignature() {\\n\t\treturn cflowCounterField;\\n\t}\\n\\n\tpublic boolean matches(ResolvedType onType) {\\n\t\treturn onType.eq"
  },
  {
    "method_id": "M328",
    "name": "getSignature",
    "return_type": "ResolvedMember",
    "signature": "getSignature()",
    "file_id": "F11",
    "start_line": 71,
    "text_preview": " true;\\n\t}\\n\\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\\n\t\treturn null;\\n\t}\\n\\n\tpublic ResolvedMember getSignature() {\\n\t\treturn cflowCounterField;\\n\t}\\n\\n\tpublic boolean matches(ResolvedType onType) {\\n\t\treturn onType.equals(cflowCounterField.getDeclaringType());\\n\t}\\n\\n\tpublic boolean existsToSupportShadowM"
  },
  {
    "method_id": "M329",
    "name": "matches",
    "return_type": "boolean",
    "signature": "matches(ResolvedType onType)",
    "file_id": "F11",
    "start_line": 75,
    "text_preview": "er member) {\\n\t\treturn null;\\n\t}\\n\\n\tpublic ResolvedMember getSignature() {\\n\t\treturn cflowCounterField;\\n\t}\\n\\n\tpublic boolean matches(ResolvedType onType) {\\n\t\treturn onType.equals(cflowCounterField.getDeclaringType());\\n\t}\\n\\n\tpublic boolean existsToSupportShadowMunging() {\\n\t\treturn true;\\n\t}\\n\\n\tpublic String toString() {\\n\t\tretur"
  },
  {
    "method_id": "M330",
    "name": "existsToSupportShadowMunging",
    "return_type": "boolean",
    "signature": "existsToSupportShadowMunging()",
    "file_id": "F11",
    "start_line": 79,
    "text_preview": "oolean matches(ResolvedType onType) {\\n\t\treturn onType.equals(cflowCounterField.getDeclaringType());\\n\t}\\n\\n\tpublic boolean existsToSupportShadowMunging() {\\n\t\treturn true;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"(BcelTypeMunger: CflowField \" + cflowCounterField.getDeclaringType().getName() + \" \" + cflowCounterField.getNa"
  },
  {
    "method_id": "M331",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F11",
    "start_line": 83,
    "text_preview": "ounterField.getDeclaringType());\\n\t}\\n\\n\tpublic boolean existsToSupportShadowMunging() {\\n\t\treturn true;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"(BcelTypeMunger: CflowField \" + cflowCounterField.getDeclaringType().getName() + \" \" + cflowCounterField.getName()\\n\t\t\t\t+ \")\";\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M332",
    "name": "BcelCflowStackFieldAdder",
    "return_type": "",
    "signature": "BcelCflowStackFieldAdder(ResolvedMember cflowStackField)",
    "file_id": "F12",
    "start_line": 28,
    "text_preview": "Type;\\n\\npublic class BcelCflowStackFieldAdder extends BcelTypeMunger {\\n\tprivate ResolvedMember cflowStackField;\\n\\n\tpublic BcelCflowStackFieldAdder(ResolvedMember cflowStackField) {\\n\t\tsuper(null, (ResolvedType) cflowStackField.getDeclaringType());\\n\t\tthis.cflowStackField = cflowStackField;\\n\t}\\n\\n\t@Override\\n\tpublic boolean mu"
  },
  {
    "method_id": "M333",
    "name": "munge",
    "return_type": "boolean",
    "signature": "munge(BcelClassWeaver weaver)",
    "file_id": "F12",
    "start_line": 34,
    "text_preview": "lvedType) cflowStackField.getDeclaringType());\\n\t\tthis.cflowStackField = cflowStackField;\\n\t}\\n\\n\t@Override\\n\tpublic boolean munge(BcelClassWeaver weaver) {\\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\\n\t\tif (!gen.getType().equals(cflowStackField.getDeclaringType())) {\\n\t\t\treturn false;\\n\t\t}\\n\t\tFieldGen f = new FieldGen(cflow"
  },
  {
    "method_id": "M334",
    "name": "getMatchingSyntheticMember",
    "return_type": "ResolvedMember",
    "signature": "getMatchingSyntheticMember(Member member)",
    "file_id": "F12",
    "start_line": 58,
    "text_preview": "ateSet(fact, cflowStackField));\\n\t\tclinit.getBody().insert(setup);\\n\\n\t\treturn true;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\\n\t\treturn null;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedMember getSignature() {\\n\t\treturn cflowStackField;\\n\t}\\n\\n\t@Override\\n\tpublic boolean matches(ResolvedType onType) "
  },
  {
    "method_id": "M335",
    "name": "getSignature",
    "return_type": "ResolvedMember",
    "signature": "getSignature()",
    "file_id": "F12",
    "start_line": 63,
    "text_preview": "\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\\n\t\treturn null;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedMember getSignature() {\\n\t\treturn cflowStackField;\\n\t}\\n\\n\t@Override\\n\tpublic boolean matches(ResolvedType onType) {\\n\t\treturn onType.equals(cflowStackField.getDeclaringType());\\n\t}\\n\\n\t@Override\\n\tpublic boolean exis"
  },
  {
    "method_id": "M336",
    "name": "matches",
    "return_type": "boolean",
    "signature": "matches(ResolvedType onType)",
    "file_id": "F12",
    "start_line": 68,
    "text_preview": "n null;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedMember getSignature() {\\n\t\treturn cflowStackField;\\n\t}\\n\\n\t@Override\\n\tpublic boolean matches(ResolvedType onType) {\\n\t\treturn onType.equals(cflowStackField.getDeclaringType());\\n\t}\\n\\n\t@Override\\n\tpublic boolean existsToSupportShadowMunging() {\\n\t\treturn true;\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M337",
    "name": "existsToSupportShadowMunging",
    "return_type": "boolean",
    "signature": "existsToSupportShadowMunging()",
    "file_id": "F12",
    "start_line": 73,
    "text_preview": "tches(ResolvedType onType) {\\n\t\treturn onType.equals(cflowStackField.getDeclaringType());\\n\t}\\n\\n\t@Override\\n\tpublic boolean existsToSupportShadowMunging() {\\n\t\treturn true;\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M338",
    "name": "weave",
    "return_type": "boolean",
    "signature": "weave(BcelWorld world, LazyClassGen clazz, List<ShadowMunger> shadowMungers,\n\t\t\tList<ConcreteTypeMunger> typeMungers, List<ConcreteTypeMunger> lateTypeMungers, boolean inReweavableMode)",
    "file_id": "F13",
    "start_line": 99,
    "text_preview": "er class.\\n\tprivate static final String SWITCH_TABLE_SYNTHETIC_METHOD_PREFIX = \"$SWITCH_TABLE$\";\\n\\n\tpublic static boolean weave(BcelWorld world, LazyClassGen clazz, List<ShadowMunger> shadowMungers,\\n\t\t\tList<ConcreteTypeMunger> typeMungers, List<ConcreteTypeMunger> lateTypeMungers, boolean inReweavableMode) {\\n\t\tBcelClassW"
  },
  {
    "method_id": "M339",
    "name": "BcelClassWeaver",
    "return_type": "",
    "signature": "BcelClassWeaver(BcelWorld world, LazyClassGen clazz, List<ShadowMunger> shadowMungers,\n\t\t\tList<ConcreteTypeMunger> typeMungers, List<ConcreteTypeMunger> lateTypeMungers)",
    "file_id": "F13",
    "start_line": 101,
    "text_preview": " typeMungers, List<ConcreteTypeMunger> lateTypeMungers, boolean inReweavableMode) {\\n\t\tBcelClassWeaver classWeaver = new BcelClassWeaver(world, clazz, shadowMungers, typeMungers, lateTypeMungers);\\n\t\tclassWeaver.setReweavableMode(inReweavableMode);\\n\t\tboolean b = classWeaver.weave();\\n\t\treturn b;\\n\t}\\n\\n\t// ------------------"
  },
  {
    "method_id": "M340",
    "name": "if",
    "return_type": "",
    "signature": "if(!checkedXsetForLowLevelContextCapturing)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M341",
    "name": "if",
    "return_type": "",
    "signature": "if(p != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M342",
    "name": "if",
    "return_type": "",
    "signature": "if(captureLowLevelContext)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M343",
    "name": "canMatch",
    "return_type": "boolean",
    "signature": "canMatch(Shadow.Kind kind)",
    "file_id": "F13",
    "start_line": 172,
    "text_preview": "text for debug/crash messages\"));\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tcheckedXsetForLowLevelContextCapturing = true;\\n\t\t}\\n\t}\\n\\n\tprivate boolean canMatch(Shadow.Kind kind) {\\n\t\treturn indexedShadowMungers[kind.getKey()] != null;\\n\t}\\n\\n\t// private void fastMatchShadowMungers(List shadowMungers, ArrayList\\n\t// mungers, Kind kind) {\\n\t// FastMatchInfo"
  },
  {
    "method_id": "M344",
    "name": "fastMatchShadowMungers",
    "return_type": "void",
    "signature": "fastMatchShadowMungers(List shadowMungers, ArrayList\n\t// mungers, Kind kind)",
    "file_id": "F13",
    "start_line": 176,
    "text_preview": "private boolean canMatch(Shadow.Kind kind) {\\n\t\treturn indexedShadowMungers[kind.getKey()] != null;\\n\t}\\n\\n\t// private void fastMatchShadowMungers(List shadowMungers, ArrayList\\n\t// mungers, Kind kind) {\\n\t// FastMatchInfo info = new FastMatchInfo(clazz.getType(), kind);\\n\t// for (Iterator i = shadowMungers.iterator(); i.hasN"
  },
  {
    "method_id": "M345",
    "name": "initializeSuperInitializerMap",
    "return_type": "void",
    "signature": "initializeSuperInitializerMap(ResolvedType child)",
    "file_id": "F13",
    "start_line": 156,
    "text_preview": "etBcelObjectType();\\n\t\tthis.cpg = clazz.getConstantPool();\\n\t\tthis.fact = clazz.getFactory();\\n\\n\t\tindexShadowMungers();\\n\\n\t\tinitializeSuperInitializerMap(ty.getResolvedTypeX());\\n\t\tif (!checkedXsetForLowLevelContextCapturing) {\\n\t\t\tProperties p = world.getExtraConfiguration();\\n\t\t\tif (p != null) {\\n\t\t\t\tString s = p.getProperty"
  },
  {
    "method_id": "M346",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType superInterface : superInterfaces)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M347",
    "name": "indexShadowMungers",
    "return_type": "void",
    "signature": "indexShadowMungers()",
    "file_id": "F13",
    "start_line": 154,
    "text_preview": "gers;\\n\t\tthis.ty = clazz.getBcelObjectType();\\n\t\tthis.cpg = clazz.getConstantPool();\\n\t\tthis.fact = clazz.getFactory();\\n\\n\t\tindexShadowMungers();\\n\\n\t\tinitializeSuperInitializerMap(ty.getResolvedTypeX());\\n\t\tif (!checkedXsetForLowLevelContextCapturing) {\\n\t\t\tProperties p = world.getExtraConfiguration();\\n\t\t\tif (p != null) {\\n\t\t\t"
  },
  {
    "method_id": "M348",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger shadowMunger : shadowMungers)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M349",
    "name": "for",
    "return_type": "",
    "signature": "for(Shadow.Kind kind : Shadow.SHADOW_KINDS)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M350",
    "name": "if",
    "return_type": "",
    "signature": "if(indexedShadowMungers[k] == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M351",
    "name": "addSuperInitializer",
    "return_type": "boolean",
    "signature": "addSuperInitializer(ResolvedType onType)",
    "file_id": "F13",
    "start_line": 192,
    "text_preview": "edType superInterface : superInterfaces) {\\n\t\t\tif (ty.getResolvedTypeX().isTopmostImplementor(superInterface)) {\\n\t\t\t\tif (addSuperInitializer(superInterface)) {\\n\t\t\t\t\tinitializeSuperInitializerMap(superInterface);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * Process the shadow mungers into array 'buckets', each bucket represents a shadow "
  },
  {
    "method_id": "M352",
    "name": "if",
    "return_type": "",
    "signature": "if(l != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M353",
    "name": "addInitializer",
    "return_type": "void",
    "signature": "addInitializer(ConcreteTypeMunger cm)",
    "file_id": "F13",
    "start_line": 236,
    "text_preview": "rn false;\\n\t\t}\\n\t\tl = new IfaceInitList(onType);\\n\t\taddedSuperInitializers.put(onType, l);\\n\t\treturn true;\\n\t}\\n\\n\tpublic void addInitializer(ConcreteTypeMunger cm) {\\n\t\tNewFieldTypeMunger m = (NewFieldTypeMunger) cm.getMunger();\\n\t\tResolvedType onType = m.getSignature().getDeclaringType().resolve(world);\\n\t\tif (onType.isRawType"
  },
  {
    "method_id": "M354",
    "name": "IfaceInitList",
    "return_type": "",
    "signature": "IfaceInitList(ResolvedType onType)",
    "file_id": "F13",
    "start_line": 231,
    "text_preview": "icType();\\n\t\t}\\n\t\tIfaceInitList l = addedSuperInitializers.get(onType);\\n\t\tif (l != null) {\\n\t\t\treturn false;\\n\t\t}\\n\t\tl = new IfaceInitList(onType);\\n\t\taddedSuperInitializers.put(onType, l);\\n\t\treturn true;\\n\t}\\n\\n\tpublic void addInitializer(ConcreteTypeMunger cm) {\\n\t\tNewFieldTypeMunger m = (NewFieldTypeMunger) cm.getMunger();\\n\t\t"
  },
  {
    "method_id": "M355",
    "name": "compareTo",
    "return_type": "int",
    "signature": "compareTo(Object other)",
    "file_id": "F13",
    "start_line": 263,
    "text_preview": "ypeMunger> list = new ArrayList<>();\\n\\n\t\tIfaceInitList(ResolvedType onType) {\\n\t\t\tthis.onType = onType;\\n\t\t}\\n\\n\t\tpublic int compareTo(Object other) {\\n\t\t\tIfaceInitList o = (IfaceInitList) other;\\n\t\t\tif (onType.isAssignableFrom(o.onType)) {\\n\t\t\t\treturn +1;\\n\t\t\t} else if (o.onType.isAssignableFrom(onType)) {\\n\t\t\t\treturn -1;\\n\t\t\t} "
  },
  {
    "method_id": "M356",
    "name": "fallbackCompareTo",
    "return_type": "int",
    "signature": "fallbackCompareTo(Object other)",
    "file_id": "F13",
    "start_line": 274,
    "text_preview": " +1;\\n\t\t\t} else if (o.onType.isAssignableFrom(onType)) {\\n\t\t\t\treturn -1;\\n\t\t\t} else {\\n\t\t\t\treturn 0;\\n\t\t\t}\\n\t\t}\\n\\n\t\tpublic int fallbackCompareTo(Object other) {\\n\t\t\treturn 0;\\n\t\t}\\n\t}\\n\\n\t// XXX this is being called, but the result doesn't seem to be being used\\n\tpublic boolean addDispatchTarget(ResolvedMember m) {\\n\t\treturn addedDi"
  },
  {
    "method_id": "M357",
    "name": "addDispatchTarget",
    "return_type": "boolean",
    "signature": "addDispatchTarget(ResolvedMember m)",
    "file_id": "F13",
    "start_line": 280,
    "text_preview": "ther) {\\n\t\t\treturn 0;\\n\t\t}\\n\t}\\n\\n\t// XXX this is being called, but the result doesn't seem to be being used\\n\tpublic boolean addDispatchTarget(ResolvedMember m) {\\n\t\treturn addedDispatchTargets.add(m);\\n\t}\\n\\n\tpublic void addLazyMethodGen(LazyMethodGen gen) {\\n\t\taddedLazyMethodGens.add(gen);\\n\t}\\n\\n\tpublic void addOrReplaceLazyMeth"
  },
  {
    "method_id": "M358",
    "name": "addLazyMethodGen",
    "return_type": "void",
    "signature": "addLazyMethodGen(LazyMethodGen gen)",
    "file_id": "F13",
    "start_line": 284,
    "text_preview": "being used\\n\tpublic boolean addDispatchTarget(ResolvedMember m) {\\n\t\treturn addedDispatchTargets.add(m);\\n\t}\\n\\n\tpublic void addLazyMethodGen(LazyMethodGen gen) {\\n\t\taddedLazyMethodGens.add(gen);\\n\t}\\n\\n\tpublic void addOrReplaceLazyMethodGen(LazyMethodGen mg) {\\n\t\tif (alreadyDefined(clazz, mg)) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tfor (Iterator<"
  },
  {
    "method_id": "M359",
    "name": "addOrReplaceLazyMethodGen",
    "return_type": "void",
    "signature": "addOrReplaceLazyMethodGen(LazyMethodGen mg)",
    "file_id": "F13",
    "start_line": 288,
    "text_preview": "Targets.add(m);\\n\t}\\n\\n\tpublic void addLazyMethodGen(LazyMethodGen gen) {\\n\t\taddedLazyMethodGens.add(gen);\\n\t}\\n\\n\tpublic void addOrReplaceLazyMethodGen(LazyMethodGen mg) {\\n\t\tif (alreadyDefined(clazz, mg)) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tfor (Iterator<LazyMethodGen> i = addedLazyMethodGens.iterator(); i.hasNext();) {\\n\t\t\tLazyMethodGen exi"
  },
  {
    "method_id": "M360",
    "name": "if",
    "return_type": "",
    "signature": "if(existing.definingType == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M361",
    "name": "alreadyDefined",
    "return_type": "boolean",
    "signature": "alreadyDefined(LazyClassGen clazz, LazyMethodGen mg)",
    "file_id": "F13",
    "start_line": 289,
    "text_preview": "zyMethodGen gen) {\\n\t\taddedLazyMethodGens.add(gen);\\n\t}\\n\\n\tpublic void addOrReplaceLazyMethodGen(LazyMethodGen mg) {\\n\t\tif (alreadyDefined(clazz, mg)) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tfor (Iterator<LazyMethodGen> i = addedLazyMethodGens.iterator(); i.hasNext();) {\\n\t\t\tLazyMethodGen existing = i.next();\\n\t\t\tif (signaturesMatch(mg, existin"
  },
  {
    "method_id": "M362",
    "name": "signaturesMatch",
    "return_type": "boolean",
    "signature": "signaturesMatch(LazyMethodGen mg, LazyMethodGen existing)",
    "file_id": "F13",
    "start_line": 295,
    "text_preview": "terator<LazyMethodGen> i = addedLazyMethodGens.iterator(); i.hasNext();) {\\n\t\t\tLazyMethodGen existing = i.next();\\n\t\t\tif (signaturesMatch(mg, existing)) {\\n\t\t\t\tif (existing.definingType == null) {\\n\t\t\t\t\t// this means existing was introduced on the class itself\\n\t\t\t\t\treturn;\\n\t\t\t\t} else if (mg.definingType.isAssignableFrom(ex"
  },
  {
    "method_id": "M363",
    "name": "makeBridgeMethod",
    "return_type": "LazyMethodGen",
    "signature": "makeBridgeMethod(LazyClassGen gen, ResolvedMember member)",
    "file_id": "F13",
    "start_line": 333,
    "text_preview": "().equals(existing.getName()) && mg.getSignature().equals(existing.getSignature());\\n\t}\\n\\n\tprotected static LazyMethodGen makeBridgeMethod(LazyClassGen gen, ResolvedMember member) {\\n\\n\t\t// remove abstract modifier\\n\t\tint mods = member.getModifiers();\\n\t\tif (Modifier.isAbstract(mods)) {\\n\t\t\tmods = mods - Modifier.ABSTRACT;\\n\t\t"
  },
  {
    "method_id": "M364",
    "name": "createBridgeMethod",
    "return_type": "void",
    "signature": "createBridgeMethod(BcelWorld world, LazyMethodGen whatToBridgeToMethodGen, LazyClassGen clazz, ResolvedMember theBridgeMethod)",
    "file_id": "F13",
    "start_line": 352,
    "text_preview": "*\\n\t * Create a single bridge method called 'theBridgeMethod' that bridges to 'whatToBridgeTo'\\n\t */\\n\tprivate static void createBridgeMethod(BcelWorld world, LazyMethodGen whatToBridgeToMethodGen, LazyClassGen clazz, ResolvedMember theBridgeMethod) {\\n\t\tInstructionList body;\\n\t\tInstructionFactory fact;\\n\t\tint pos = 0;\\n\\n\t\tRe"
  },
  {
    "method_id": "M365",
    "name": "if",
    "return_type": "",
    "signature": "if(whatToBridgeTo == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M366",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = paramTypes.length; i < len; i++)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M367",
    "name": "if",
    "return_type": "",
    "signature": "if(world.forDEBUG_bridgingCode)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M368",
    "name": "weave",
    "return_type": "boolean",
    "signature": "weave()",
    "file_id": "F13",
    "start_line": 99,
    "text_preview": "er class.\\n\tprivate static final String SWITCH_TABLE_SYNTHETIC_METHOD_PREFIX = \"$SWITCH_TABLE$\";\\n\\n\tpublic static boolean weave(BcelWorld world, LazyClassGen clazz, List<ShadowMunger> shadowMungers,\\n\t\t\tList<ConcreteTypeMunger> typeMungers, List<ConcreteTypeMunger> lateTypeMungers, boolean inReweavableMode) {\\n\t\tBcelClassW"
  },
  {
    "method_id": "M369",
    "name": "for",
    "return_type": "typeMungers",
    "signature": "for(ConcreteTypeMunger o : typeMungers)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M370",
    "name": "if",
    "return_type": "",
    "signature": "if(typeMungerAffectedType)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M371",
    "name": "if",
    "return_type": "",
    "signature": "if(addedSuperInitializersAsList == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M372",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen member : methodGens)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M373",
    "name": "if",
    "return_type": "",
    "signature": "if(shadowMungerMatched)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M374",
    "name": "for",
    "return_type": "shadows",
    "signature": "for(LazyMethodGen methodGen : methodGens)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M375",
    "name": "if",
    "return_type": "mungers",
    "signature": "if(lateTypeMungers != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M376",
    "name": "for",
    "return_type": "",
    "signature": "for(ConcreteTypeMunger lateTypeMunger : lateTypeMungers)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M377",
    "name": "if",
    "return_type": "",
    "signature": "if(typeMungerAffectedType)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M378",
    "name": "if",
    "return_type": "",
    "signature": "if(isChanged)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M379",
    "name": "if",
    "return_type": "",
    "signature": "if(inReweavableMode)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M380",
    "name": "for",
    "return_type": "around",
    "signature": "for(LazyMethodGen mg : methodGens)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M381",
    "name": "if",
    "return_type": "",
    "signature": "if(method != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M382",
    "name": "isOverriding",
    "return_type": "ResolvedMember",
    "signature": "isOverriding(ResolvedType typeToCheck, ResolvedMember methodThatMightBeGettingOverridden,\n\t\t\tString mname, String mrettype, int mmods, boolean inSamePackage, UnresolvedType[] methodParamsArray)",
    "file_id": "F13",
    "start_line": 574,
    "text_preview": "so it can be used from multiple places.\\n\t * @return method that is overriding if it\\n\t */\\n\tprivate static ResolvedMember isOverriding(ResolvedType typeToCheck, ResolvedMember methodThatMightBeGettingOverridden,\\n\t\t\tString mname, String mrettype, int mmods, boolean inSamePackage, UnresolvedType[] methodParamsArray) {\\n\t\t//"
  },
  {
    "method_id": "M383",
    "name": "bound",
    "return_type": "first",
    "signature": "bound(isn't that the same as erasure!\n\t\t\t\tif (parameterType instanceof UnresolvedTypeVariableReferenceType)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M384",
    "name": "if",
    "return_type": "",
    "signature": "if(b)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M385",
    "name": "if",
    "return_type": "",
    "signature": "if(sameParams)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M386",
    "name": "isVisibilityOverride",
    "return_type": "boolean",
    "signature": "isVisibilityOverride(int methodMods, ResolvedMember inheritedMethod, boolean inSamePackage)",
    "file_id": "F13",
    "start_line": 593,
    "text_preview": "rameterTypes().length != methodParamsArray.length) {\\n\t\t\t// not the same number of parameters\\n\t\t\treturn null;\\n\t\t}\\n\t\tif (!isVisibilityOverride(mmods, methodThatMightBeGettingOverridden, inSamePackage)) {\\n\t\t\t// not override from visibility point of view\\n\t\t\treturn null;\\n\t\t}\\n\\n\t\tif (typeToCheck.getWorld().forDEBUG_bridgingCo"
  },
  {
    "method_id": "M387",
    "name": "if",
    "return_type": "",
    "signature": "if(methodMods == inheritedModifiers)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M388",
    "name": "if",
    "return_type": "",
    "signature": "if(isPackageVisible && !inSamePackage)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M389",
    "name": "checkForOverride",
    "return_type": "void",
    "signature": "checkForOverride(ResolvedType typeToCheck, String mname, String mparams, String mrettype,\n\t\t\tint mmods, String mpkg, UnresolvedType[] methodParamsArray, List<ResolvedMember> overriddenMethodsCollector)",
    "file_id": "F13",
    "start_line": 703,
    "text_preview": "rrides the one passed in.\\n\t *\\n\t * @return the method being overridden or null if none is found\\n\t */\\n\tpublic static void checkForOverride(ResolvedType typeToCheck, String mname, String mparams, String mrettype,\\n\t\t\tint mmods, String mpkg, UnresolvedType[] methodParamsArray, List<ResolvedMember> overriddenMethodsCollector"
  },
  {
    "method_id": "M390",
    "name": "if",
    "return_type": "",
    "signature": "if(typeToCheck == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M391",
    "name": "if",
    "return_type": "",
    "signature": "if(typeToCheck instanceof MissingResolvedTypeWithKnownSignature)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M392",
    "name": "if",
    "return_type": "",
    "signature": "if(packageName == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M393",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember methodThatMightBeGettingOverridden : methods)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M394",
    "name": "if",
    "return_type": "",
    "signature": "if(isOverriding != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M395",
    "name": "for",
    "return_type": "",
    "signature": "for(ConcreteTypeMunger o : l)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M396",
    "name": "if",
    "return_type": "",
    "signature": "if(o instanceof BcelTypeMunger)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M397",
    "name": "if",
    "return_type": "",
    "signature": "if(isOverriding != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M398",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType anInterface : interfaces)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M399",
    "name": "calculateAnyRequiredBridgeMethods",
    "return_type": "boolean",
    "signature": "calculateAnyRequiredBridgeMethods(BcelWorld world, LazyClassGen clazz)",
    "file_id": "F13",
    "start_line": 776,
    "text_preview": "type hierarchy for the specified class\\n\t * has changed (via decp/itd).\\n\t *\\n\t * See pr108101\\n\t */\\n\tpublic static boolean calculateAnyRequiredBridgeMethods(BcelWorld world, LazyClassGen clazz) {\\n\t\tworld.ensureAdvancedConfigurationProcessed();\\n\\n\t\tif (!world.isInJava5Mode()) {\\n\t\t\treturn false; // just double check... the c"
  },
  {
    "method_id": "M400",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen aMethod : methods)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M401",
    "name": "for",
    "return_type": "type",
    "signature": "for(LazyMethodGen bridgeToCandidate : methods)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M402",
    "name": "if",
    "return_type": "",
    "signature": "if(world.forDEBUG_bridgingCode)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M403",
    "name": "if",
    "return_type": "",
    "signature": "if(world.forDEBUG_bridgingCode)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M404",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember overriddenMethod : overriddenMethodsCollector)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M405",
    "name": "if",
    "return_type": "",
    "signature": "if(!alreadyHaveABridgeMethod)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M406",
    "name": "if",
    "return_type": "",
    "signature": "if(world.forDEBUG_bridgingCode)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M407",
    "name": "if",
    "return_type": "",
    "signature": "if(bridges== null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M408",
    "name": "for",
    "return_type": "",
    "signature": "for(String anInterface : interfaces)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M409",
    "name": "if",
    "return_type": "",
    "signature": "if(world.forDEBUG_bridgingCode)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M410",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember overriddenMethod : overriddenMethodsCollector)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M411",
    "name": "if",
    "return_type": "",
    "signature": "if(!alreadyHaveABridgeMethod)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M412",
    "name": "if",
    "return_type": "",
    "signature": "if(bridges== null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M413",
    "name": "if",
    "return_type": "",
    "signature": "if(world.forDEBUG_bridgingCode)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M414",
    "name": "if",
    "return_type": "",
    "signature": "if(bridges != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M415",
    "name": "for",
    "return_type": "",
    "signature": "for(BridgeMethodDescriptor bmDescriptor: bridges)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M416",
    "name": "BridgeMethodDescriptor",
    "return_type": "",
    "signature": "BridgeMethodDescriptor(LazyMethodGen bridgeToCandidate, ResolvedMember overriddenMethod)",
    "file_id": "F13",
    "start_line": 841,
    "text_preview": "denMethod + \"'\");\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\tif (bridges== null) {\\n\t\t\t\t\t\t\tbridges = new ArrayList<>();\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\tbridges.add(new BridgeMethodDescriptor(bridgeToCandidate, overriddenMethod));\\n\t\t\t\t\t\t//createBridgeMethod(world, bridgeToCandidate, clazz, overriddenMethod);\\n\t\t\t\t\t\tmethodsSet.add(key);\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\\n\t\t\t// Check s"
  },
  {
    "method_id": "M417",
    "name": "weaveDeclareAtMethodCtor",
    "return_type": "boolean",
    "signature": "weaveDeclareAtMethodCtor(LazyClassGen clazz)",
    "file_id": "F13",
    "start_line": 453,
    "text_preview": "nger.getAspectType().getSignature());\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\t// Weave special half type/half shadow mungers...\\n\t\tisChanged = weaveDeclareAtMethodCtor(clazz) || isChanged;\\n\t\tisChanged = weaveDeclareAtField(clazz) || isChanged;\\n\\n\t\t// XXX do major sort of stuff\\n\t\t// sort according to: Major: type hierarchy\\n\t\t// within each lis"
  },
  {
    "method_id": "M418",
    "name": "if",
    "return_type": "",
    "signature": "if(addedLazyMethodGens!=null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M419",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen method: addedLazyMethodGens)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M420",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation decam: decaMs)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M421",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation decam : worthRetrying)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M422",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation decaM : decaMs)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M423",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationsToAdd == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M424",
    "name": "if",
    "return_type": "",
    "signature": "if(decaMAnnotation == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M425",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation decaM : worthRetrying)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M426",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationsToAdd == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M427",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationsToAdd != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M428",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationGen a : annotationsToAdd)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M429",
    "name": "reportMethodCtorWeavingMessage",
    "return_type": "void",
    "signature": "reportMethodCtorWeavingMessage(LazyClassGen clazz, ResolvedMember member, DeclareAnnotation decaM,\n\t\t\tint memberLineNumber)",
    "file_id": "F13",
    "start_line": 959,
    "text_preview": "odRelationship(decam.getSourceLocation(),\\n\t\t\t\t\t\t\t\tclazz.getName(), resolvedmember, world.getModelAsAsmManager());\\n\t\t\t\t\t\treportMethodCtorWeavingMessage(clazz, resolvedmember, decam, method.getDeclarationLineNumber());\\n\t\t\t\t\t\tisChanged = true;\\n\t\t\t\t\t\tmodificationOccured = true;\\n\t\t\t\t\t\tunusedDecams.remove(decam);\\n\t\t\t\t\t} else"
  },
  {
    "method_id": "M430",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < paramTypes.length; i++)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M431",
    "name": "if",
    "return_type": "",
    "signature": "if(memberLineNumber != -1)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M432",
    "name": "getMatchingSubset",
    "return_type": "List<DeclareAnnotation>",
    "signature": "getMatchingSubset(List<DeclareAnnotation> declareAnnotations, ResolvedType type)",
    "file_id": "F13",
    "start_line": 921,
    "text_preview": " = weaveAtMethodOnITDSRepeatedly(allDecams, itdMethodsCtors, reportedProblems);\\n\t\t}\\n\\n\t\tList<DeclareAnnotation> decaMs = getMatchingSubset(allDecams, clazz.getType());\\n\t\tif (decaMs.isEmpty()) {\\n\t\t\treturn false; // nothing to do\\n\t\t}\\n\\n\t\tSet<DeclareAnnotation> unusedDecams = new HashSet<>(decaMs);\\n\\n\t\t// These methods may h"
  },
  {
    "method_id": "M433",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation da : declareAnnotations)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M434",
    "name": "getITDSubset",
    "return_type": "List<ConcreteTypeMunger>",
    "signature": "getITDSubset(LazyClassGen clazz, ResolvedTypeMunger.Kind wantedKind)",
    "file_id": "F13",
    "start_line": 913,
    "text_preview": " {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tboolean isChanged = false;\\n\\n\t\t// deal with ITDs\\n\t\tList<ConcreteTypeMunger> itdMethodsCtors = getITDSubset(clazz, ResolvedTypeMunger.Method);\\n\t\titdMethodsCtors.addAll(getITDSubset(clazz, ResolvedTypeMunger.Constructor));\\n\t\tif (!itdMethodsCtors.isEmpty()) {\\n\t\t\t// Can't use the subset called 'de"
  },
  {
    "method_id": "M435",
    "name": "locateAnnotationHolderForFieldMunger",
    "return_type": "LazyMethodGen",
    "signature": "locateAnnotationHolderForFieldMunger(LazyClassGen clazz, ConcreteTypeMunger fieldMunger)",
    "file_id": "F13",
    "start_line": 1181,
    "text_preview": ".getMunger().getKind() == wantedKind) {\\n\t\t\t\tsubset.add(typeMunger);\\n\t\t\t}\\n\t\t}\\n\t\treturn subset;\\n\t}\\n\\n\tpublic LazyMethodGen locateAnnotationHolderForFieldMunger(LazyClassGen clazz, ConcreteTypeMunger fieldMunger) {\\n\t\tNewFieldTypeMunger newFieldMunger = (NewFieldTypeMunger) fieldMunger.getMunger();\\n\t\tResolvedMember lookingF"
  },
  {
    "method_id": "M436",
    "name": "locateAnnotationHolderForMethodCtorMunger",
    "return_type": "LazyMethodGen",
    "signature": "locateAnnotationHolderForMethodCtorMunger(LazyClassGen clazz, ConcreteTypeMunger methodCtorMunger)",
    "file_id": "F13",
    "start_line": 1193,
    "text_preview": "())) {\\n\t\t\t\treturn method;\\n\t\t\t}\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\t// FIXME asc refactor this to neaten it up\\n\tpublic LazyMethodGen locateAnnotationHolderForMethodCtorMunger(LazyClassGen clazz, ConcreteTypeMunger methodCtorMunger) {\\n\t\tResolvedTypeMunger rtMunger = methodCtorMunger.getMunger();\\n\t\tResolvedMember lookingFor = null;\\n\t"
  },
  {
    "method_id": "M437",
    "name": "if",
    "return_type": "",
    "signature": "if(rtMunger instanceof NewMethodTypeMunger)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M438",
    "name": "if",
    "return_type": "else",
    "signature": "if(rtMunger instanceof NewConstructorTypeMunger)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M439",
    "name": "ITDfields",
    "return_type": "of",
    "signature": "ITDfields(List<BcelTypeMunger>. It\n\t * will iterate over the fields repeatedly until everything has been applied.\n\t *\n\t */\n\tprivate boolean weaveAtFieldRepeatedly(List<DeclareAnnotation> decaFs, List<ConcreteTypeMunger> itdFields,\n\t\t\tList<Integer> reportedErrors)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M440",
    "name": "for",
    "return_type": "",
    "signature": "for(ConcreteTypeMunger itdField : itdFields)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M441",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation decaF : decaFs)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M442",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation decaF : worthRetrying)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M443",
    "name": "weaveAtMethodOnITDSRepeatedly",
    "return_type": "boolean",
    "signature": "weaveAtMethodOnITDSRepeatedly(List<DeclareAnnotation> decaMCs,\n\t\t\tList<ConcreteTypeMunger> itdsForMethodAndConstructor, List<Integer> reportedErrors)",
    "file_id": "F13",
    "start_line": 918,
    "text_preview": "hodsCtors.isEmpty()) {\\n\t\t\t// Can't use the subset called 'decaMs' as it won't be right for\\n\t\t\t// ITDs...\\n\t\t\tisChanged = weaveAtMethodOnITDSRepeatedly(allDecams, itdMethodsCtors, reportedProblems);\\n\t\t}\\n\\n\t\tList<DeclareAnnotation> decaMs = getMatchingSubset(allDecams, clazz.getType());\\n\t\tif (decaMs.isEmpty()) {\\n\t\t\treturn "
  },
  {
    "method_id": "M444",
    "name": "for",
    "return_type": "",
    "signature": "for(ConcreteTypeMunger methodctorMunger : itdsForMethodAndConstructor)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M445",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation decaMC : decaMCs)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M446",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation decaMC : worthRetrying)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M447",
    "name": "dontAddTwice",
    "return_type": "boolean",
    "signature": "dontAddTwice(DeclareAnnotation decaF, AnnotationAJ[] dontAddMeTwice)",
    "file_id": "F13",
    "start_line": 1359,
    "text_preview": "l.add(decaMC);\\n\t\t\t\t\t}\\n\t\t\t\t\tworthRetrying.removeAll(forRemoval);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\treturn isChanged;\\n\t}\\n\\n\tprivate boolean dontAddTwice(DeclareAnnotation decaF, AnnotationAJ[] dontAddMeTwice) {\\n\t\tfor (AnnotationAJ ann : dontAddMeTwice) {\\n\t\t\tif (ann != null && decaF.getAnnotation().getTypeName().equals(ann.getTypeName())) "
  },
  {
    "method_id": "M448",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ ann : dontAddMeTwice)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M449",
    "name": "removeFromAnnotationsArray",
    "return_type": "AnnotationAJ[]",
    "signature": "removeFromAnnotationsArray(AnnotationAJ[] annotations,AnnotationAJ annotation)",
    "file_id": "F13",
    "start_line": 1371,
    "text_preview": "eturn false;\\n\t}\\n\\n\t/**\\n\t * Remove an annotation from the supplied array, if it is in there.\\n\t */\\n\tprivate AnnotationAJ[] removeFromAnnotationsArray(AnnotationAJ[] annotations,AnnotationAJ annotation) {\\n\t\tfor (int i=0;i<annotations.length;i++) {\\n\t\t\tif (annotations[i] != null && annotation.getTypeName().equals(annotations"
  },
  {
    "method_id": "M450",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0;i<annotations.length;i++)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M451",
    "name": "for",
    "return_type": "",
    "signature": "for(int j=0;j<annotations.length;j++)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M452",
    "name": "if",
    "return_type": "",
    "signature": "if(j!=i)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M453",
    "name": "weaveDeclareAtField",
    "return_type": "boolean",
    "signature": "weaveDeclareAtField(LazyClassGen clazz)",
    "file_id": "F13",
    "start_line": 454,
    "text_preview": "eave special half type/half shadow mungers...\\n\t\tisChanged = weaveDeclareAtMethodCtor(clazz) || isChanged;\\n\t\tisChanged = weaveDeclareAtField(clazz) || isChanged;\\n\\n\t\t// XXX do major sort of stuff\\n\t\t// sort according to: Major: type hierarchy\\n\t\t// within each list: dominates\\n\t\t// don't forget to sort addedThisInitialiers "
  },
  {
    "method_id": "M454",
    "name": "if",
    "return_type": "",
    "signature": "if(relevantItdFields != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M455",
    "name": "if",
    "return_type": "",
    "signature": "if(fields != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M456",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelField field : fields)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M457",
    "name": "for",
    "return_type": "statements",
    "signature": "for(DeclareAnnotation decaf : decafs)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M458",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation decaF : worthRetrying)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M459",
    "name": "checkUnusedDeclareAts",
    "return_type": "void",
    "signature": "checkUnusedDeclareAts(Set<DeclareAnnotation> unusedDecaTs, boolean isDeclareAtField)",
    "file_id": "F13",
    "start_line": 1102,
    "text_preview": "ethod = myGen.getMethod();\\n\t\t\t\t\t\tmembers.set(memberCounter, new LazyMethodGen(newMethod, clazz));\\n\t\t\t\t\t}\\n\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tcheckUnusedDeclareAts(unusedDecams, false);\\n\t\t}\\n\t\treturn isChanged;\\n\t}\\n\\n\t// TAG: WeavingMessage\\n\tprivate void reportMethodCtorWeavingMessage(LazyClassGen clazz, ResolvedMember member, DeclareAnnotatio"
  },
  {
    "method_id": "M460",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation declA : unusedDecaTs)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M461",
    "name": "for",
    "return_type": "",
    "signature": "for(ExactTypePattern exactTypePattern : declaringTypePatterns)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M462",
    "name": "if",
    "return_type": "",
    "signature": "if(shouldCheck)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M463",
    "name": "if",
    "return_type": "",
    "signature": "if(!itdMatch)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M464",
    "name": "if",
    "return_type": "",
    "signature": "if(isDeclareAtField)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M465",
    "name": "reportFieldAnnotationWeavingMessage",
    "return_type": "void",
    "signature": "reportFieldAnnotationWeavingMessage(LazyClassGen clazz, BcelField theField, DeclareAnnotation decaf,\n\t\t\tboolean isRemove)",
    "file_id": "F13",
    "start_line": 1443,
    "text_preview": "elationship(world.getModelAsAsmManager(),\\n\t\t\t\t\t\t\t\t\t\t\tdecaf.getSourceLocation(), clazz.getName(), field, true);\\n\t\t\t\t\t\t\t\t\treportFieldAnnotationWeavingMessage(clazz, field, decaf, true);\\n\t\t\t\t\t\t\t\t\tdontAddMeTwice = removeFromAnnotationsArray(dontAddMeTwice, annotation);\\n\t\t\t\t\t\t\t\t} else {\\n\t\t\t\t\t\t\t\t\tworthRetrying.add(decaf);\\n\t\t"
  },
  {
    "method_id": "M466",
    "name": "doesAlreadyHaveAnnotation",
    "return_type": "boolean",
    "signature": "doesAlreadyHaveAnnotation(ResolvedMember rm, DeclareAnnotation deca, List<Integer> reportedProblems, boolean reportError)",
    "file_id": "F13",
    "start_line": 945,
    "text_preview": "Occured = false;\\n\t\t\t\tfor (DeclareAnnotation decam: decaMs) {\\n\t\t\t\t\tif (decam.matches(resolvedmember, world)) {\\n\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(resolvedmember, decam, reportedProblems,false)) {\\n\t\t\t\t\t\t\t// remove the declare @method since don't want an error when the annotation is already there\\n\t\t\t\t\t\t\tunusedDecams.remo"
  },
  {
    "method_id": "M467",
    "name": "doesAlreadyHaveAnnotation",
    "return_type": "boolean",
    "signature": "doesAlreadyHaveAnnotation(LazyMethodGen rm, ResolvedMember itdfieldsig, DeclareAnnotation deca,\n\t\t\tList<Integer> reportedProblems)",
    "file_id": "F13",
    "start_line": 945,
    "text_preview": "Occured = false;\\n\t\t\t\tfor (DeclareAnnotation decam: decaMs) {\\n\t\t\t\t\tif (decam.matches(resolvedmember, world)) {\\n\t\t\t\t\t\tif (doesAlreadyHaveAnnotation(resolvedmember, decam, reportedProblems,false)) {\\n\t\t\t\t\t\t\t// remove the declare @method since don't want an error when the annotation is already there\\n\t\t\t\t\t\t\tunusedDecams.remo"
  },
  {
    "method_id": "M468",
    "name": "findAspectsForMungers",
    "return_type": "Set<String>",
    "signature": "findAspectsForMungers(LazyMethodGen mg)",
    "file_id": "F13",
    "start_line": 488,
    "text_preview": "\t\t// that affected this type\\n\t\t\t\tif (inReweavableMode || clazz.getType().isAspect()) {\\n\t\t\t\t\taspectsAffectingType.addAll(findAspectsForMungers(member));\\n\t\t\t\t}\\n\t\t\t\tisChanged = true;\\n\t\t\t}\\n\t\t}\\n\\n\t\t// now we weave all but the initialization shadows\\n\t\tfor (LazyMethodGen methodGen : methodGens) {\\n\t\t\tif (!methodGen.hasBody()) {"
  },
  {
    "method_id": "M469",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelShadow shadow : mg.matchedShadows)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M470",
    "name": "if",
    "return_type": "",
    "signature": "if(munger instanceof BcelAdvice)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M471",
    "name": "inlineSelfConstructors",
    "return_type": "boolean",
    "signature": "inlineSelfConstructors(List<LazyMethodGen> methodGens, List<LazyMethodGen> recursiveCtors)",
    "file_id": "F13",
    "start_line": 508,
    "text_preview": " reported\\n\t\t\t// \"Recursive constructor invocation\"\\n\t\t\tList<LazyMethodGen> recursiveCtors = new ArrayList<>();\\n\t\t\twhile (inlineSelfConstructors(methodGens, recursiveCtors)) {\\n\t\t\t}\\n\t\t\tpositionAndImplement(initializationShadows);\\n\t\t}\\n\\n\t\t// now proceed with late type mungers\\n\t\tif (lateTypeMungers != null) {\\n\t\t\tfor (Concret"
  },
  {
    "method_id": "M472",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen methodGen : methodGens)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M473",
    "name": "positionAndImplement",
    "return_type": "void",
    "signature": "positionAndImplement(List<BcelShadow> initializationShadows)",
    "file_id": "F13",
    "start_line": 510,
    "text_preview": "yMethodGen> recursiveCtors = new ArrayList<>();\\n\t\t\twhile (inlineSelfConstructors(methodGens, recursiveCtors)) {\\n\t\t\t}\\n\t\t\tpositionAndImplement(initializationShadows);\\n\t\t}\\n\\n\t\t// now proceed with late type mungers\\n\t\tif (lateTypeMungers != null) {\\n\t\t\tfor (ConcreteTypeMunger lateTypeMunger : lateTypeMungers) {\\n\t\t\t\tBcelTypeMu"
  },
  {
    "method_id": "M474",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelShadow s : initializationShadows)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M475",
    "name": "positionInitializationShadow",
    "return_type": "void",
    "signature": "positionInitializationShadow(BcelShadow s)",
    "file_id": "F13",
    "start_line": 1666,
    "text_preview": "e void positionAndImplement(List<BcelShadow> initializationShadows) {\\n\t\tfor (BcelShadow s : initializationShadows) {\\n\t\t\tpositionInitializationShadow(s);\\n\t\t\t// s.getEnclosingMethod().print();\\n\t\t\ts.implement();\\n\t\t}\\n\t}\\n\\n\tprivate void positionInitializationShadow(BcelShadow s) {\\n\t\tLazyMethodGen mg = s.getEnclosingMethod();"
  },
  {
    "method_id": "M476",
    "name": "isThisCall",
    "return_type": "boolean",
    "signature": "isThisCall(InstructionHandle ih)",
    "file_id": "F13",
    "start_line": 1648,
    "text_preview": ").equals(\"<init>\")) {\\n\t\t\t\tcontinue;\\n\t\t\t}\\n\t\t\tInstructionHandle ih = findSuperOrThisCall(methodGen);\\n\t\t\tif (ih != null && isThisCall(ih)) {\\n\t\t\t\tLazyMethodGen donor = getCalledMethod(ih);\\n\t\t\t\tif (donor.equals(methodGen)) {\\n\t\t\t\t\tnewRecursiveCtors.add(donor);\\n\t\t\t\t} else {\\n\t\t\t\t\tif (!recursiveCtors.contains(donor)) {\\n\t\t\t\t\t\tin"
  },
  {
    "method_id": "M477",
    "name": "inlineMethod",
    "return_type": "void",
    "signature": "inlineMethod(LazyMethodGen donor, LazyMethodGen recipient, InstructionHandle call)",
    "file_id": "F13",
    "start_line": 1654,
    "text_preview": ".equals(methodGen)) {\\n\t\t\t\t\tnewRecursiveCtors.add(donor);\\n\t\t\t\t} else {\\n\t\t\t\t\tif (!recursiveCtors.contains(donor)) {\\n\t\t\t\t\t\tinlineMethod(donor, methodGen, ih);\\n\t\t\t\t\t\tinlinedSomething = true;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\trecursiveCtors.addAll(newRecursiveCtors);\\n\t\treturn inlinedSomething;\\n\t}\\n\\n\tprivate void positionAndImplement(L"
  },
  {
    "method_id": "M478",
    "name": "genTempVar",
    "return_type": "BcelVar",
    "signature": "genTempVar(UnresolvedType typeX)",
    "file_id": "F13",
    "start_line": 1730,
    "text_preview": "ipient.getBody().append(call, inlineInstructions);\\n\t\tUtility.deleteInstruction(call, recipient);\\n\t}\\n\\n\t// public BcelVar genTempVar(UnresolvedType typeX) {\\n\t// return new BcelVar(typeX.resolve(world),\\n\t// genTempVarIndex(typeX.getSize()));\\n\t// }\\n\t//\\n\t// private int genTempVarIndex(int size) {\\n\t// return enclosingMethod."
  },
  {
    "method_id": "M479",
    "name": "genTempVarIndex",
    "return_type": "int",
    "signature": "genTempVarIndex(int size)",
    "file_id": "F13",
    "start_line": 1732,
    "text_preview": " recipient);\\n\t}\\n\\n\t// public BcelVar genTempVar(UnresolvedType typeX) {\\n\t// return new BcelVar(typeX.resolve(world),\\n\t// genTempVarIndex(typeX.getSize()));\\n\t// }\\n\t//\\n\t// private int genTempVarIndex(int size) {\\n\t// return enclosingMethod.allocateLocal(size);\\n\t// }\\n\\n\t/**\\n\t * Input method is a synchronized method, we remov"
  },
  {
    "method_id": "M480",
    "name": "transformSynchronizedMethod",
    "return_type": "void",
    "signature": "transformSynchronizedMethod(LazyMethodGen synchronizedMethod)",
    "file_id": "F13",
    "start_line": 481,
    "text_preview": "SynchronizationEnabled() && world.areSynchronizationPointcutsInUse()\\n\t\t\t\t\t&& member.getMethod().isSynchronized()) {\\n\t\t\t\ttransformSynchronizedMethod(member);\\n\t\t\t}\\n\t\t\tboolean shadowMungerMatched = match(member);\\n\t\t\tif (shadowMungerMatched) {\\n\t\t\t\t// For matching mungers, add their declaring aspects to the list\\n\t\t\t\t// that"
  },
  {
    "method_id": "M481",
    "name": "while",
    "return_type": "",
    "signature": "while(walker != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M482",
    "name": "for",
    "return_type": "",
    "signature": "for(InstructionHandle element : rets)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M483",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof LocalVariableTag)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M484",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof LineNumberTag)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M485",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof InstructionBranch)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M486",
    "name": "while",
    "return_type": "",
    "signature": "while(walker != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M487",
    "name": "for",
    "return_type": "",
    "signature": "for(InstructionHandle ret : rets)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M488",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof LocalVariableTag)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M489",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof LineNumberTag)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M490",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof GOTO ||\n\t\t\t\t\t\t\t\t// targeter instanceof GOTO_W)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M491",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof InstructionBranch)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M492",
    "name": "while",
    "return_type": "",
    "signature": "while(walker != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M493",
    "name": "for",
    "return_type": "",
    "signature": "for(InstructionHandle element : rets)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M494",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof LocalVariableTag)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M495",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof LineNumberTag)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M496",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof GOTO ||\n\t\t\t\t\t\t\t// targeter instanceof GOTO_W)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M497",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof InstructionBranch)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M498",
    "name": "genInlineInstructions",
    "return_type": "InstructionList",
    "signature": "genInlineInstructions(LazyMethodGen donor, LazyMethodGen recipient, IntMap frameEnv,\n\t\t\tInstructionFactory fact, boolean keepReturns)",
    "file_id": "F13",
    "start_line": 1722,
    "text_preview": "ctionList argumentStores = genArgumentStores(donor, recipient, frameEnv, fact);\\n\\n\t\tInstructionList inlineInstructions = genInlineInstructions(donor, recipient, frameEnv, fact, false);\\n\\n\t\tinlineInstructions.insert(argumentStores);\\n\\n\t\trecipient.getBody().append(call, inlineInstructions);\\n\t\tUtility.deleteInstruction(call,"
  },
  {
    "method_id": "M499",
    "name": "if",
    "return_type": "",
    "signature": "if(isAcrossClass)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M500",
    "name": "if",
    "return_type": "",
    "signature": "if(fresh instanceof InvokeDynamic)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M501",
    "name": "if",
    "return_type": "",
    "signature": "if(bootstrapMethods == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M502",
    "name": "if",
    "return_type": "",
    "signature": "if(attributes != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M503",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute attribute: attributes)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M504",
    "name": "if",
    "return_type": "",
    "signature": "if(attribute instanceof BootstrapMethods)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M505",
    "name": "for",
    "return_type": "",
    "signature": "for(int a=0; a<bootstrapMethodArguments.length; a++)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M506",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute attr: newAttributes)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M507",
    "name": "if",
    "return_type": "",
    "signature": "if(attr instanceof BootstrapMethods)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M508",
    "name": "if",
    "return_type": "",
    "signature": "if(newBootstrapMethods == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M509",
    "name": "if",
    "return_type": "",
    "signature": "if(keepReturns)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M510",
    "name": "if",
    "return_type": "else",
    "signature": "if(fresh instanceof InstructionBranch)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M511",
    "name": "if",
    "return_type": "",
    "signature": "if(fresh instanceof RET)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M512",
    "name": "if",
    "return_type": "branches",
    "signature": "if(inst instanceof InstructionBranch)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M513",
    "name": "if",
    "return_type": "",
    "signature": "if(newTarget == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M514",
    "name": "if",
    "return_type": "",
    "signature": "if(branch instanceof InstructionSelect)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M515",
    "name": "for",
    "return_type": "",
    "signature": "for(int k = oldTargets.length - 1; k >= 0; k--)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M516",
    "name": "if",
    "return_type": "",
    "signature": "if(old instanceof Tag)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M517",
    "name": "if",
    "return_type": "",
    "signature": "if(fresh == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M518",
    "name": "if",
    "return_type": "",
    "signature": "if(old instanceof LocalVariableTag)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M519",
    "name": "if",
    "return_type": "else",
    "signature": "if(old instanceof ExceptionRange)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M520",
    "name": "if",
    "return_type": "else",
    "signature": "if(old instanceof ShadowRange)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M521",
    "name": "if",
    "return_type": "",
    "signature": "if(!keepReturns)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M522",
    "name": "if",
    "return_type": "",
    "signature": "if(keepReturns)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M523",
    "name": "if",
    "return_type": "else",
    "signature": "if(fresh instanceof InstructionBranch)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M524",
    "name": "if",
    "return_type": "",
    "signature": "if(fresh instanceof RET)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M525",
    "name": "if",
    "return_type": "",
    "signature": "if(inst instanceof InstructionBranch)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M526",
    "name": "if",
    "return_type": "",
    "signature": "if(newTarget == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M527",
    "name": "if",
    "return_type": "",
    "signature": "if(branch instanceof InstructionSelect)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M528",
    "name": "for",
    "return_type": "",
    "signature": "for(int k = oldTargets.length - 1; k >= 0; k--)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M529",
    "name": "if",
    "return_type": "",
    "signature": "if(old instanceof Tag)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M530",
    "name": "if",
    "return_type": "",
    "signature": "if(fresh == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M531",
    "name": "if",
    "return_type": "else",
    "signature": "if(old instanceof ExceptionRange)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M532",
    "name": "if",
    "return_type": "else",
    "signature": "if(old instanceof ShadowRange)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M533",
    "name": "genArgumentStores",
    "return_type": "InstructionList",
    "signature": "genArgumentStores(LazyMethodGen donor, LazyMethodGen recipient, IntMap frameEnv,\n\t\t\tInstructionFactory fact)",
    "file_id": "F13",
    "start_line": 1720,
    "text_preview": ";\\n\\n\t\tIntMap frameEnv = new IntMap();\\n\\n\t\t// this also sets up the initial environment\\n\t\tInstructionList argumentStores = genArgumentStores(donor, recipient, frameEnv, fact);\\n\\n\t\tInstructionList inlineInstructions = genInlineInstructions(donor, recipient, frameEnv, fact, false);\\n\\n\t\tinlineInstructions.insert(argumentStores"
  },
  {
    "method_id": "M534",
    "name": "for",
    "return_type": "",
    "signature": "for(Type argType : argTypes)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M535",
    "name": "getCalledMethod",
    "return_type": "LazyMethodGen",
    "signature": "getCalledMethod(InstructionHandle ih)",
    "file_id": "F13",
    "start_line": 1649,
    "text_preview": "InstructionHandle ih = findSuperOrThisCall(methodGen);\\n\t\t\tif (ih != null && isThisCall(ih)) {\\n\t\t\t\tLazyMethodGen donor = getCalledMethod(ih);\\n\t\t\t\tif (donor.equals(methodGen)) {\\n\t\t\t\t\tnewRecursiveCtors.add(donor);\\n\t\t\t\t} else {\\n\t\t\t\t\tif (!recursiveCtors.contains(donor)) {\\n\t\t\t\t\t\tinlineMethod(donor, methodGen, ih);\\n\t\t\t\t\t\tinli"
  },
  {
    "method_id": "M536",
    "name": "weaveInAddedMethods",
    "return_type": "void",
    "signature": "weaveInAddedMethods()",
    "file_id": "F13",
    "start_line": 538,
    "text_preview": "changed, we add in the introduced methods.\\n\t\tif (isChanged) {\\n\t\t\tclazz.getOrCreateWeaverStateInfo(inReweavableMode);\\n\t\t\tweaveInAddedMethods();\\n\t\t}\\n\\n\t\tif (inReweavableMode) {\\n\t\t\tWeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo(true);\\n\t\t\twsi.addAspectsAffectingType(aspectsAffectingType);\\n\t\t\tif (!world.isOverWeaving"
  },
  {
    "method_id": "M537",
    "name": "sort",
    "return_type": "",
    "signature": "sort(new Comparator<LazyMethodGen>()",
    "file_id": "F13",
    "start_line": 461,
    "text_preview": "perInitializersAsList = new ArrayList<>(addedSuperInitializers.values());\\n\t\taddedSuperInitializersAsList = PartialOrder.sort(addedSuperInitializersAsList);\\n\t\tif (addedSuperInitializersAsList == null) {\\n\t\t\tthrow new BCException(\"circularity in inter-types\");\\n\t\t}\\n\\n\t\t// this will create a static initializer if there isn't"
  },
  {
    "method_id": "M538",
    "name": "compare",
    "return_type": "int",
    "signature": "compare(LazyMethodGen aa, LazyMethodGen bb)",
    "file_id": "F13",
    "start_line": 2601,
    "text_preview": ");\\n\t}\\n\\n\tprivate void weaveInAddedMethods() {\\n\t\taddedLazyMethodGens.sort(new Comparator<LazyMethodGen>() {\\n\t\t\tpublic int compare(LazyMethodGen aa, LazyMethodGen bb) {\\n\t\t\t\tint i = aa.getName().compareTo(bb.getName());\\n\t\t\t\tif (i != 0) {\\n\t\t\t\t\treturn i;\\n\t\t\t\t}\\n\t\t\t\treturn aa.getSignature().compareTo(bb.getSignature());\\n\t\t\t}\\n\t"
  },
  {
    "method_id": "M539",
    "name": "if",
    "return_type": "",
    "signature": "if(i != 0)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M540",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen addedMember : addedLazyMethodGens)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M541",
    "name": "addPerSingletonField",
    "return_type": "void",
    "signature": "addPerSingletonField(Member field)",
    "file_id": "F13",
    "start_line": 2615,
    "text_preview": "}\\n\t\t});\\n\\n\t\tfor (LazyMethodGen addedMember : addedLazyMethodGens) {\\n\t\t\tclazz.addMethodGen(addedMember);\\n\t\t}\\n\t}\\n\\n\t// void addPerSingletonField(Member field) {\\n\t// ObjectType aspectType = (ObjectType)\\n\t// BcelWorld.makeBcelType(field.getReturnType());\\n\t// String aspectName = field.getReturnType().getName();\\n\t//\\n\t// LazyMe"
  },
  {
    "method_id": "M542",
    "name": "findSuperOrThisCall",
    "return_type": "InstructionHandle",
    "signature": "findSuperOrThisCall(LazyMethodGen mg)",
    "file_id": "F13",
    "start_line": 1647,
    "text_preview": " methodGen : methodGens) {\\n\t\t\tif (!methodGen.getName().equals(\"<init>\")) {\\n\t\t\t\tcontinue;\\n\t\t\t}\\n\t\t\tInstructionHandle ih = findSuperOrThisCall(methodGen);\\n\t\t\tif (ih != null && isThisCall(ih)) {\\n\t\t\t\tLazyMethodGen donor = getCalledMethod(ih);\\n\t\t\t\tif (donor.equals(methodGen)) {\\n\t\t\t\t\tnewRecursiveCtors.add(donor);\\n\t\t\t\t} else {"
  },
  {
    "method_id": "M543",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M544",
    "name": "if",
    "return_type": "",
    "signature": "if(start == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M545",
    "name": "if",
    "return_type": "",
    "signature": "if(depth == 0)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M546",
    "name": "if",
    "return_type": "else",
    "signature": "if(inst.opcode == Constants.NEW)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M547",
    "name": "match",
    "return_type": "boolean",
    "signature": "match(LazyMethodGen mg)",
    "file_id": "F13",
    "start_line": 483,
    "text_preview": "& member.getMethod().isSynchronized()) {\\n\t\t\t\ttransformSynchronizedMethod(member);\\n\t\t\t}\\n\t\t\tboolean shadowMungerMatched = match(member);\\n\t\t\tif (shadowMungerMatched) {\\n\t\t\t\t// For matching mungers, add their declaring aspects to the list\\n\t\t\t\t// that affected this type\\n\t\t\t\tif (inReweavableMode || clazz.getType().isAspect())"
  },
  {
    "method_id": "M548",
    "name": "if",
    "return_type": "",
    "signature": "if(effective == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M549",
    "name": "if",
    "return_type": "",
    "signature": "if(canMatchBodyShadows)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M550",
    "name": "matchInit",
    "return_type": "boolean",
    "signature": "matchInit(LazyMethodGen mg, List<BcelShadow> shadowAccumulator)",
    "file_id": "F13",
    "start_line": 2666,
    "text_preview": " '<';\\n\t\t// we want to match ajsynthetic constructors...\\n\t\tif (startsAngly && mg.getName().equals(\"<init>\")) {\\n\t\t\treturn matchInit(mg, shadowAccumulator);\\n\t\t} else if (!shouldWeaveBody(mg)) {\\n\t\t\treturn false;\\n\t\t} else {\\n\t\t\tif (startsAngly && mg.getName().equals(\"<clinit>\")) {\\n\t\t\t\t// clinitShadow =\\n\t\t\t\tenclosingShadow = "
  },
  {
    "method_id": "M551",
    "name": "if",
    "return_type": "thingie",
    "signature": "if(superOrThisCall == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M552",
    "name": "if",
    "return_type": "",
    "signature": "if(canMatchBodyShadows)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M553",
    "name": "if",
    "return_type": "",
    "signature": "if(h == superOrThisCall)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M554",
    "name": "for",
    "return_type": "",
    "signature": "for(IfaceInitList l : addedSuperInitializersAsList)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M555",
    "name": "shouldWeaveBody",
    "return_type": "boolean",
    "signature": "shouldWeaveBody(LazyMethodGen mg)",
    "file_id": "F13",
    "start_line": 2667,
    "text_preview": "tors...\\n\t\tif (startsAngly && mg.getName().equals(\"<init>\")) {\\n\t\t\treturn matchInit(mg, shadowAccumulator);\\n\t\t} else if (!shouldWeaveBody(mg)) {\\n\t\t\treturn false;\\n\t\t} else {\\n\t\t\tif (startsAngly && mg.getName().equals(\"<clinit>\")) {\\n\t\t\t\t// clinitShadow =\\n\t\t\t\tenclosingShadow = BcelShadow.makeStaticInitialization(world, mg);\\n"
  },
  {
    "method_id": "M556",
    "name": "if",
    "return_type": "",
    "signature": "if(a != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M557",
    "name": "genInitInstructions",
    "return_type": "InstructionList",
    "signature": "genInitInstructions(List<ConcreteTypeMunger> list, boolean isStatic)",
    "file_id": "F13",
    "start_line": 469,
    "text_preview": "s in just as bad taste as NOPs\\n\t\tLazyMethodGen staticInit = clazz.getStaticInitializer();\\n\t\tstaticInit.getBody().insert(genInitInstructions(addedClassInitializers, true));\\n\\n\t\t// now go through each method, and match against each method. This\\n\t\t// sets up each method's {@link LazyMethodGen#matchedShadows} field,\\n\t\t// an"
  },
  {
    "method_id": "M558",
    "name": "if",
    "return_type": "",
    "signature": "if(list == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M559",
    "name": "for",
    "return_type": "",
    "signature": "for(ConcreteTypeMunger cmunger : list)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M560",
    "name": "if",
    "return_type": "",
    "signature": "if(!isStatic)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M561",
    "name": "match",
    "return_type": "void",
    "signature": "match(LazyMethodGen mg, InstructionHandle ih, BcelShadow enclosingShadow, List<BcelShadow> shadowAccumulator)",
    "file_id": "F13",
    "start_line": 483,
    "text_preview": "& member.getMethod().isSynchronized()) {\\n\t\t\t\ttransformSynchronizedMethod(member);\\n\t\t\t}\\n\t\t\tboolean shadowMungerMatched = match(member);\\n\t\t\tif (shadowMungerMatched) {\\n\t\t\t\t// For matching mungers, add their declaring aspects to the list\\n\t\t\t\t// that affected this type\\n\t\t\t\tif (inReweavableMode || clazz.getType().isAspect())"
  },
  {
    "method_id": "M562",
    "name": "for",
    "return_type": "that",
    "signature": "for(InstructionTargeter t : targeters)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M563",
    "name": "if",
    "return_type": "",
    "signature": "if(t instanceof ExceptionRange)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M564",
    "name": "for",
    "return_type": "",
    "signature": "for(InstructionTargeter t2 : targeters)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M565",
    "name": "if",
    "return_type": "",
    "signature": "if(fi.opcode == Constants.PUTFIELD || fi.opcode == Constants.PUTSTATIC)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M566",
    "name": "if",
    "return_type": "",
    "signature": "if(resolvedField == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M567",
    "name": "if",
    "return_type": "else",
    "signature": "if(i instanceof InvokeInstruction)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M568",
    "name": "if",
    "return_type": "else",
    "signature": "if(ii.opcode == Constants.INVOKESPECIAL)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M569",
    "name": "if",
    "return_type": "",
    "signature": "if(i.opcode == Constants.ANEWARRAY)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M570",
    "name": "if",
    "return_type": "else",
    "signature": "if(i.opcode == Constants.NEWARRAY)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M571",
    "name": "if",
    "return_type": "else",
    "signature": "if(i instanceof MULTIANEWARRAY)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M572",
    "name": "if",
    "return_type": "else",
    "signature": "if(i instanceof AALOAD)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M573",
    "name": "if",
    "return_type": "else",
    "signature": "if(i instanceof AASTORE)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M574",
    "name": "isInitFailureHandler",
    "return_type": "boolean",
    "signature": "isInitFailureHandler(InstructionHandle ih)",
    "file_id": "F13",
    "start_line": 2842,
    "text_preview": "= ih\\n\t\t\t\t\tExceptionRange er = (ExceptionRange) t;\\n\t\t\t\t\tif (er.getCatchType() == null) {\\n\t\t\t\t\t\tcontinue;\\n\t\t\t\t\t}\\n\t\t\t\t\tif (isInitFailureHandler(ih)) {\\n\t\t\t\t\t\treturn;\\n\t\t\t\t\t}\\n\t\t\t\t\tif (!ih.getInstruction().isStoreInstruction() && ih.getInstruction().getOpcode() != Constants.NOP) {\\n\t\t\t\t\t\t// If using cobertura, the catch block "
  },
  {
    "method_id": "M575",
    "name": "matchSetInstruction",
    "return_type": "void",
    "signature": "matchSetInstruction(LazyMethodGen mg, InstructionHandle ih, BcelShadow enclosingShadow,\n\t\t\tList<BcelShadow> shadowAccumulator)",
    "file_id": "F13",
    "start_line": 2897,
    "text_preview": " it's\\n\t\t\t\t\t\t// not a join point according to 1.0.6 and 1.1.\\n\t\t\t\t\t} else {\\n\t\t\t\t\t\tif (canMatch(Shadow.FieldSet)) {\\n\t\t\t\t\t\t\tmatchSetInstruction(mg, ih, enclosingShadow, shadowAccumulator);\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t} else {\\n\t\t\t\t\tif (canMatch(Shadow.FieldSet)) {\\n\t\t\t\t\t\tmatchSetInstruction(mg, ih, enclosingShadow, shadowAccumulator)"
  },
  {
    "method_id": "M576",
    "name": "if",
    "return_type": "",
    "signature": "if(resolvedField == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M577",
    "name": "matchGetInstruction",
    "return_type": "void",
    "signature": "matchGetInstruction(LazyMethodGen mg, InstructionHandle ih, BcelShadow enclosingShadow,\n\t\t\tList<BcelShadow> shadowAccumulator)",
    "file_id": "F13",
    "start_line": 2907,
    "text_preview": "ruction(mg, ih, enclosingShadow, shadowAccumulator);\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t} else {\\n\t\t\t\tif (canMatch(Shadow.FieldGet)) {\\n\t\t\t\t\tmatchGetInstruction(mg, ih, enclosingShadow, shadowAccumulator);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t} else if (i instanceof InvokeInstruction) {\\n\t\t\tInvokeInstruction ii = (InvokeInstruction) i;\\n\t\t\tif (ii.getMethodName(claz"
  },
  {
    "method_id": "M578",
    "name": "if",
    "return_type": "",
    "signature": "if(resolvedField == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M579",
    "name": "findResolvedMemberNamed",
    "return_type": "ResolvedMember",
    "signature": "findResolvedMemberNamed(ResolvedType type, String methodName)",
    "file_id": "F13",
    "start_line": 3052,
    "text_preview": " there is only one member with that name in the type as it returns the first one it finds.\\n\t */\\n\tprivate ResolvedMember findResolvedMemberNamed(ResolvedType type, String methodName) {\\n\t\tResolvedMember[] allMethods = type.getDeclaredMethods();\\n\t\tfor (ResolvedMember member : allMethods) {\\n\t\t\tif (member.getName().equals(m"
  },
  {
    "method_id": "M580",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember member : allMethods)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M581",
    "name": "findResolvedMemberNamed",
    "return_type": "ResolvedMember",
    "signature": "findResolvedMemberNamed(ResolvedType type, String methodName, UnresolvedType[] params)",
    "file_id": "F13",
    "start_line": 3052,
    "text_preview": " there is only one member with that name in the type as it returns the first one it finds.\\n\t */\\n\tprivate ResolvedMember findResolvedMemberNamed(ResolvedType type, String methodName) {\\n\t\tResolvedMember[] allMethods = type.getDeclaredMethods();\\n\t\tfor (ResolvedMember member : allMethods) {\\n\t\t\tif (member.getName().equals(m"
  },
  {
    "method_id": "M582",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember candidate : allMethods)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M583",
    "name": "for",
    "return_type": "candidates",
    "signature": "for(ResolvedMember candidate : candidates)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M584",
    "name": "for",
    "return_type": "",
    "signature": "for(int p = 0; p < candidateParams.length; p++)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M585",
    "name": "if",
    "return_type": "",
    "signature": "if(allOK)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M586",
    "name": "fixParameterNamesForResolvedMember",
    "return_type": "void",
    "signature": "fixParameterNamesForResolvedMember(ResolvedMember rm, ResolvedMember declaredSig)",
    "file_id": "F13",
    "start_line": 2698,
    "text_preview": "r them. Storing them\\n\t\t\t\t\t// in the effective signature\\n\t\t\t\t\t// would mean keeping two sets up to date (no way!!)\\n\\n\t\t\t\t\tfixParameterNamesForResolvedMember(rm, mg.getMemberView());\\n\t\t\t\t\tfixAnnotationsForResolvedMember(rm, mg.getMemberView());\\n\\n\t\t\t\t\tenclosingShadow = BcelShadow.makeShadowForMethod(world, mg, effective.ge"
  },
  {
    "method_id": "M587",
    "name": "if",
    "return_type": "",
    "signature": "if(theRealMember != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M588",
    "name": "fixAnnotationsForResolvedMember",
    "return_type": "void",
    "signature": "fixAnnotationsForResolvedMember(ResolvedMember rm, ResolvedMember declaredSig)",
    "file_id": "F13",
    "start_line": 2699,
    "text_preview": "ould mean keeping two sets up to date (no way!!)\\n\\n\t\t\t\t\tfixParameterNamesForResolvedMember(rm, mg.getMemberView());\\n\t\t\t\t\tfixAnnotationsForResolvedMember(rm, mg.getMemberView());\\n\\n\t\t\t\t\tenclosingShadow = BcelShadow.makeShadowForMethod(world, mg, effective.getShadowKind(), rm);\\n\t\t\t\t} else {\\n\t\t\t\t\treturn false;\\n\t\t\t\t}\\n\t\t\t}\\n\\n\t"
  },
  {
    "method_id": "M589",
    "name": "if",
    "return_type": "",
    "signature": "if(!containsKey)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M590",
    "name": "if",
    "return_type": "",
    "signature": "if(realAnnotationHolder == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M591",
    "name": "if",
    "return_type": "M4",
    "signature": "if(realAnnotationHolder == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M592",
    "name": "if",
    "return_type": "",
    "signature": "if(realAnnotationHolder!=null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M593",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationTypes==null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M594",
    "name": "if",
    "return_type": "",
    "signature": "if(annotations==null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M595",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedOperationException ex)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M596",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M597",
    "name": "matchInvokeInstruction",
    "return_type": "void",
    "signature": "matchInvokeInstruction(LazyMethodGen mg, InstructionHandle ih, InvokeInstruction invoke,\n\t\t\tBcelShadow enclosingShadow, List<BcelShadow> shadowAccumulator)",
    "file_id": "F13",
    "start_line": 2920,
    "text_preview": "Name = ii.getClassName(cpg);\\n\t\t\t\tif (onTypeName.equals(mg.getEnclosingClass().getName())) {\\n\t\t\t\t\t// we are private\\n\t\t\t\t\tmatchInvokeInstruction(mg, ih, ii, enclosingShadow, shadowAccumulator);\\n\t\t\t\t} else {\\n\t\t\t\t\t// we are a super call, and this is not a join point in\\n\t\t\t\t\t// AspectJ-1.{0,1}\\n\t\t\t\t}\\n\t\t\t} else {\\n\t\t\t\tif (ii.g"
  },
  {
    "method_id": "M598",
    "name": "if",
    "return_type": "",
    "signature": "if(declaredSig == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M599",
    "name": "if",
    "return_type": "",
    "signature": "if(effectiveSig == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M600",
    "name": "if",
    "return_type": "",
    "signature": "if(proceed)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M601",
    "name": "match",
    "return_type": "boolean",
    "signature": "match(BcelShadow shadow, List<BcelShadow> shadowAccumulator)",
    "file_id": "F13",
    "start_line": 483,
    "text_preview": "& member.getMethod().isSynchronized()) {\\n\t\t\t\ttransformSynchronizedMethod(member);\\n\t\t\t}\\n\t\t\tboolean shadowMungerMatched = match(member);\\n\t\t\tif (shadowMungerMatched) {\\n\t\t\t\t// For matching mungers, add their declaring aspects to the list\\n\t\t\t\t// that affected this type\\n\t\t\t\tif (inReweavableMode || clazz.getType().isAspect())"
  },
  {
    "method_id": "M602",
    "name": "if",
    "return_type": "",
    "signature": "if(captureLowLevelContext)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M603",
    "name": "if",
    "return_type": "",
    "signature": "if(candidateMungers != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M604",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger munger : candidateMungers)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M605",
    "name": "if",
    "return_type": "",
    "signature": "if(isMatched)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M606",
    "name": "if",
    "return_type": "",
    "signature": "if(candidateMungers != null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M607",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger munger : candidateMungers)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M608",
    "name": "if",
    "return_type": "",
    "signature": "if(isMatched)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M609",
    "name": "implement",
    "return_type": "void",
    "signature": "implement(LazyMethodGen mg)",
    "file_id": "F13",
    "start_line": 499,
    "text_preview": "tialization shadows\\n\t\tfor (LazyMethodGen methodGen : methodGens) {\\n\t\t\tif (!methodGen.hasBody()) {\\n\t\t\t\tcontinue;\\n\t\t\t}\\n\t\t\timplement(methodGen);\\n\t\t}\\n\\n\t\t// if we matched any initialization shadows, we inline and weave\\n\t\tif (!initializationShadows.isEmpty()) {\\n\t\t\t// Repeat next step until nothing left to inline...cant go on"
  },
  {
    "method_id": "M610",
    "name": "if",
    "return_type": "",
    "signature": "if(shadows == null)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M611",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelShadow shadow : shadows)",
    "file_id": "F13",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M612",
    "name": "getLazyClassGen",
    "return_type": "LazyClassGen",
    "signature": "getLazyClassGen()",
    "file_id": "F13",
    "start_line": 431,
    "text_preview": "f (clazz.getType().isAspect()) {\\n\t\t\tisChanged = true;\\n\t\t}\\n\\n\t\tWeaverStateInfo typeWeaverState = (world.isOverWeaving() ? getLazyClassGen().getType().getWeaverState() : null);\\n\t\t// start by munging all typeMungers\\n\t\tfor (ConcreteTypeMunger o : typeMungers) {\\n\t\t\tif (!(o instanceof BcelTypeMunger)) {\\n\t\t\t\t// ???System.err.p"
  },
  {
    "method_id": "M613",
    "name": "getWorld",
    "return_type": "BcelWorld",
    "signature": "getWorld()",
    "file_id": "F13",
    "start_line": 118,
    "text_preview": " = false;\\n\\n\tprivate final BcelObjectType ty; // alias of clazz.getType()\\n\tprivate final BcelWorld world; // alias of ty.getWorld()\\n\tprivate final ConstantPool cpg; // alias of clazz.getConstantPoolGen()\\n\tprivate final InstructionFactory fact; // alias of clazz.getFactory();\\n\\n\tprivate final List<LazyMethodGen> addedLazy"
  },
  {
    "method_id": "M614",
    "name": "setReweavableMode",
    "return_type": "void",
    "signature": "setReweavableMode(boolean mode)",
    "file_id": "F13",
    "start_line": 102,
    "text_preview": "ClassWeaver classWeaver = new BcelClassWeaver(world, clazz, shadowMungers, typeMungers, lateTypeMungers);\\n\t\tclassWeaver.setReweavableMode(inReweavableMode);\\n\t\tboolean b = classWeaver.weave();\\n\t\treturn b;\\n\t}\\n\\n\t// --------------------------------------------\\n\\n\tprivate final LazyClassGen clazz;\\n\tprivate final List<ShadowM"
  },
  {
    "method_id": "M615",
    "name": "getReweavableMode",
    "return_type": "boolean",
    "signature": "getReweavableMode()",
    "file_id": "F13",
    "start_line": 3389,
    "text_preview": "d() {\\n\t\treturn world;\\n\t}\\n\\n\tpublic void setReweavableMode(boolean mode) {\\n\t\tinReweavableMode = mode;\\n\t}\\n\\n\tpublic boolean getReweavableMode() {\\n\t\treturn inReweavableMode;\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn \"BcelClassWeaver instance for : \" + clazz;\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M616",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F13",
    "start_line": 183,
    "text_preview": "nger.getPointcut().fastMatch(info);\\n\t// WeaverMetrics.recordFastMatchResult(fb);// Could pass:\\n\t// munger.getPointcut().toString()\\n\t// if (fb.maybeTrue()) mungers.add(munger);\\n\t// }\\n\t// }\\n\\n\tprivate void initializeSuperInitializerMap(ResolvedType child) {\\n\t\tResolvedType[] superInterfaces = child.getDeclaredInterfaces();"
  },
  {
    "method_id": "M617",
    "name": "BcelConstantPoolReader",
    "return_type": "",
    "signature": "BcelConstantPoolReader(ConstantPool constantPool)",
    "file_id": "F14",
    "start_line": 26,
    "text_preview": "t\\n */\\npublic class BcelConstantPoolReader implements ConstantPoolReader {\\n\\n\tprivate ConstantPool constantPool;\\n\\n\tpublic BcelConstantPoolReader(ConstantPool constantPool) {\\n\t\tthis.constantPool = constantPool;\\n\t}\\n\\n\tpublic String readUtf8(int cpIndex) {\\n\t\treturn constantPool.getConstantUtf8(cpIndex).getValue();\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M618",
    "name": "readUtf8",
    "return_type": "String",
    "signature": "readUtf8(int cpIndex)",
    "file_id": "F14",
    "start_line": 30,
    "text_preview": "ol;\\n\\n\tpublic BcelConstantPoolReader(ConstantPool constantPool) {\\n\t\tthis.constantPool = constantPool;\\n\t}\\n\\n\tpublic String readUtf8(int cpIndex) {\\n\t\treturn constantPool.getConstantUtf8(cpIndex).getValue();\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M619",
    "name": "BcelConstantPoolWriter",
    "return_type": "",
    "signature": "BcelConstantPoolWriter(ConstantPool pool)",
    "file_id": "F15",
    "start_line": 26,
    "text_preview": "\\n * @author Andy Clement\\n */\\nclass BcelConstantPoolWriter implements ConstantPoolWriter {\\n\\n\tConstantPool pool;\\n\\n\tpublic BcelConstantPoolWriter(ConstantPool pool) {\\n\t\tthis.pool = pool;\\n\t}\\n\\n\tpublic int writeUtf8(String name) {\\n\t\treturn pool.addUtf8(name);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M620",
    "name": "writeUtf8",
    "return_type": "int",
    "signature": "writeUtf8(String name)",
    "file_id": "F15",
    "start_line": 30,
    "text_preview": "lWriter {\\n\\n\tConstantPool pool;\\n\\n\tpublic BcelConstantPoolWriter(ConstantPool pool) {\\n\t\tthis.pool = pool;\\n\t}\\n\\n\tpublic int writeUtf8(String name) {\\n\t\treturn pool.addUtf8(name);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M621",
    "name": "BcelField",
    "return_type": "",
    "signature": "BcelField(BcelObjectType declaringType, Field field)",
    "file_id": "F16",
    "start_line": 55,
    "text_preview": "ll;\\n\tprivate boolean unpackedGenericSignature = false;\\n\tprivate boolean annotationsOnFieldObjectAreOutOfDate = false;\\n\\n\tBcelField(BcelObjectType declaringType, Field field) {\\n\t\tsuper(FIELD, declaringType.getResolvedTypeX(), field.getModifiers(), field.getName(), field.getSignature());\\n\t\tthis.field = field;\\n\t\tthis.world"
  },
  {
    "method_id": "M622",
    "name": "BcelField",
    "return_type": "",
    "signature": "BcelField(String declaringTypeName, Field field, World world)",
    "file_id": "F16",
    "start_line": 55,
    "text_preview": "ll;\\n\tprivate boolean unpackedGenericSignature = false;\\n\tprivate boolean annotationsOnFieldObjectAreOutOfDate = false;\\n\\n\tBcelField(BcelObjectType declaringType, Field field) {\\n\t\tsuper(FIELD, declaringType.getResolvedTypeX(), field.getModifiers(), field.getName(), field.getSignature());\\n\t\tthis.field = field;\\n\t\tthis.world"
  },
  {
    "method_id": "M623",
    "name": "unpackAttributes",
    "return_type": "void",
    "signature": "unpackAttributes(World world)",
    "file_id": "F16",
    "start_line": 60,
    "text_preview": "his.field = field;\\n\t\tthis.world = declaringType.getResolvedTypeX().getWorld();\\n\t\tthis.bcelObjectType = declaringType;\\n\t\tunpackAttributes(world);\\n\t\tcheckedExceptions = UnresolvedType.NONE;\\n\t}\\n\\n\t/**\\n\t * Constructs an instance that wrappers a Field object, but where we do not (yet) have a BcelObjectType - usually because "
  },
  {
    "method_id": "M624",
    "name": "if",
    "return_type": "",
    "signature": "if(attrs != null && attrs.length > 0)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M625",
    "name": "for",
    "return_type": "",
    "signature": "for(AjAttribute a : as)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M626",
    "name": "if",
    "return_type": "",
    "signature": "if(a instanceof AjAttribute.AjSynthetic)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M627",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = attrs.length - 1; i >= 0; i--)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M628",
    "name": "if",
    "return_type": "",
    "signature": "if(attrs[i] instanceof Synthetic)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M629",
    "name": "isAjSynthetic",
    "return_type": "boolean",
    "signature": "isAjSynthetic()",
    "file_id": "F16",
    "start_line": 111,
    "text_preview": "ttribute\\n\t\tif ((field.getModifiers() & AccSynthetic) != 0) {\\n\t\t\tisSynthetic = true;\\n\t\t}\\n\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAjSynthetic() {\\n\t\treturn isAjSynthetic;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isSynthetic() {\\n\t\treturn isSynthetic;\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\\n\t\tensureAnnotationT"
  },
  {
    "method_id": "M630",
    "name": "isSynthetic",
    "return_type": "boolean",
    "signature": "isSynthetic()",
    "file_id": "F16",
    "start_line": 116,
    "text_preview": "ic = true;\\n\t\t}\\n\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAjSynthetic() {\\n\t\treturn isAjSynthetic;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isSynthetic() {\\n\t\treturn isSynthetic;\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\tfor (ResolvedType aType : annotationTypes) {\\n\t\t\tif (aT"
  },
  {
    "method_id": "M631",
    "name": "hasAnnotation",
    "return_type": "boolean",
    "signature": "hasAnnotation(UnresolvedType ofType)",
    "file_id": "F16",
    "start_line": 121,
    "text_preview": "turn isAjSynthetic;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isSynthetic() {\\n\t\treturn isSynthetic;\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\tfor (ResolvedType aType : annotationTypes) {\\n\t\t\tif (aType.equals(ofType)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\t"
  },
  {
    "method_id": "M632",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType aType : annotationTypes)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M633",
    "name": "getAnnotationTypes",
    "return_type": "ResolvedType[]",
    "signature": "getAnnotationTypes()",
    "file_id": "F16",
    "start_line": 132,
    "text_preview": "Types) {\\n\t\t\tif (aType.equals(ofType)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType[] getAnnotationTypes() {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\treturn annotationTypes;\\n\t}\\n\\n\t@Override\\n\tpublic AnnotationAJ[] getAnnotations() {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\treturn annotations;\\n"
  },
  {
    "method_id": "M634",
    "name": "getAnnotations",
    "return_type": "AnnotationAJ[]",
    "signature": "getAnnotations()",
    "file_id": "F16",
    "start_line": 138,
    "text_preview": "AnnotationTypes() {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\treturn annotationTypes;\\n\t}\\n\\n\t@Override\\n\tpublic AnnotationAJ[] getAnnotations() {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\treturn annotations;\\n\t}\\n\\n\t@Override\\n\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\tfor "
  },
  {
    "method_id": "M635",
    "name": "getAnnotationOfType",
    "return_type": "AnnotationAJ",
    "signature": "getAnnotationOfType(UnresolvedType ofType)",
    "file_id": "F16",
    "start_line": 144,
    "text_preview": "onAJ[] getAnnotations() {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\treturn annotations;\\n\t}\\n\\n\t@Override\\n\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\tfor (AnnotationAJ annotation : annotations) {\\n\t\t\tif (annotation.getTypeName().equals(ofType.getName())) {\\n\t\t\t\treturn "
  },
  {
    "method_id": "M636",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotation : annotations)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M637",
    "name": "ensureAnnotationTypesRetrieved",
    "return_type": "void",
    "signature": "ensureAnnotationTypesRetrieved()",
    "file_id": "F16",
    "start_line": 122,
    "text_preview": "c boolean isSynthetic() {\\n\t\treturn isSynthetic;\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\tfor (ResolvedType aType : annotationTypes) {\\n\t\t\tif (aType.equals(ofType)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType[] getAnnot"
  },
  {
    "method_id": "M638",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationTypes == null)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M639",
    "name": "if",
    "return_type": "",
    "signature": "if(annos.length == 0)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M640",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < annosCount; i++)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M641",
    "name": "addAnnotation",
    "return_type": "void",
    "signature": "addAnnotation(AnnotationAJ annotation)",
    "file_id": "F16",
    "start_line": 174,
    "text_preview": "Annotation(anno, world);\\n\t\t\t\t\tannotationTypes[i] = annotations[i].getType();\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic void addAnnotation(AnnotationAJ annotation) {\\n\t\tensureAnnotationTypesRetrieved();\\n\t\tint len = annotations.length;\\n\t\tAnnotationAJ[] ret = new AnnotationAJ[len + 1];\\n\t\tSystem.arraycopy(annotations, 0, ret, 0"
  },
  {
    "method_id": "M642",
    "name": "removeAnnotation",
    "return_type": "void",
    "signature": "removeAnnotation(AnnotationAJ annotation)",
    "file_id": "F16",
    "start_line": 190,
    "text_preview": "ion.getType();\\n\t\tannotationTypes = newAnnotationTypes;\\n\\n\t\tannotationsOnFieldObjectAreOutOfDate = true;\\n\t}\\n\\n\tpublic void removeAnnotation(AnnotationAJ annotation) {\\n\t\tensureAnnotationTypesRetrieved();\\n\\n\t\tint len = annotations.length;\\n\t\tAnnotationAJ[] ret = new AnnotationAJ[len - 1];\\n\t\tint p = 0;\\n\t\tfor (AnnotationAJ anno"
  },
  {
    "method_id": "M643",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ anno : annotations)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M644",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType anno : annotationTypes)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M645",
    "name": "getGenericReturnType",
    "return_type": "UnresolvedType",
    "signature": "getGenericReturnType()",
    "file_id": "F16",
    "start_line": 220,
    "text_preview": "ady done so, then find the true field type of this\\n\t * field (eg. List<String>).\\n\t */\\n\t@Override\\n\tpublic UnresolvedType getGenericReturnType() {\\n\t\tunpackGenericSignature();\\n\t\treturn genericFieldType;\\n\t}\\n\\n\tpublic Field getFieldAsIs() {\\n\t\treturn field;\\n\t}\\n\\n\tpublic Field getField(ConstantPool cpool) {\\n\t\tif (!annotationsOn"
  },
  {
    "method_id": "M646",
    "name": "getFieldAsIs",
    "return_type": "Field",
    "signature": "getFieldAsIs()",
    "file_id": "F16",
    "start_line": 225,
    "text_preview": "public UnresolvedType getGenericReturnType() {\\n\t\tunpackGenericSignature();\\n\t\treturn genericFieldType;\\n\t}\\n\\n\tpublic Field getFieldAsIs() {\\n\t\treturn field;\\n\t}\\n\\n\tpublic Field getField(ConstantPool cpool) {\\n\t\tif (!annotationsOnFieldObjectAreOutOfDate) {\\n\t\t\treturn field;\\n\t\t}\\n\t\tFieldGen newFieldGen = new FieldGen(field, cpool"
  },
  {
    "method_id": "M647",
    "name": "getField",
    "return_type": "Field",
    "signature": "getField(ConstantPool cpool)",
    "file_id": "F16",
    "start_line": 229,
    "text_preview": "packGenericSignature();\\n\t\treturn genericFieldType;\\n\t}\\n\\n\tpublic Field getFieldAsIs() {\\n\t\treturn field;\\n\t}\\n\\n\tpublic Field getField(ConstantPool cpool) {\\n\t\tif (!annotationsOnFieldObjectAreOutOfDate) {\\n\t\t\treturn field;\\n\t\t}\\n\t\tFieldGen newFieldGen = new FieldGen(field, cpool);\\n\t\tnewFieldGen.removeAnnotations();\\n\t\t// List<Ann"
  },
  {
    "method_id": "M648",
    "name": "if",
    "return_type": "",
    "signature": "if(!annotationsOnFieldObjectAreOutOfDate)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M649",
    "name": "if",
    "return_type": "",
    "signature": "if(annotations != null)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M650",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotation : annotations)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M651",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < annotations.length; i++)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M652",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationGen gen : alreadyHas)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M653",
    "name": "if",
    "return_type": "",
    "signature": "if(!alreadyHasIt)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M654",
    "name": "unpackGenericSignature",
    "return_type": "void",
    "signature": "unpackGenericSignature()",
    "file_id": "F16",
    "start_line": 221,
    "text_preview": "true field type of this\\n\t * field (eg. List<String>).\\n\t */\\n\t@Override\\n\tpublic UnresolvedType getGenericReturnType() {\\n\t\tunpackGenericSignature();\\n\t\treturn genericFieldType;\\n\t}\\n\\n\tpublic Field getFieldAsIs() {\\n\t\treturn field;\\n\t}\\n\\n\tpublic Field getField(ConstantPool cpool) {\\n\t\tif (!annotationsOnFieldObjectAreOutOfDate) {\\n"
  },
  {
    "method_id": "M655",
    "name": "if",
    "return_type": "",
    "signature": "if(unpackedGenericSignature)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M656",
    "name": "if",
    "return_type": "",
    "signature": "if(gSig != null)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M657",
    "name": "catch",
    "return_type": "",
    "signature": "catch(GenericSignatureFormatException e)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M658",
    "name": "evictWeavingState",
    "return_type": "void",
    "signature": "evictWeavingState()",
    "file_id": "F16",
    "start_line": 298,
    "text_preview": "s detected: \" + e.getMessage());\\n\t\t\t}\\n\t\t} else {\\n\t\t\tgenericFieldType = getReturnType();\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic void evictWeavingState() {\\n\t\tif (field != null) {\\n\t\t\tunpackGenericSignature();\\n\t\t\tunpackAttributes(world);\\n\t\t\tensureAnnotationTypesRetrieved();\\n\t\t\t// this.sourceContext = SourceContextImpl.UNKNOWN_SOURCE_C"
  },
  {
    "method_id": "M659",
    "name": "if",
    "return_type": "",
    "signature": "if(field != null)",
    "file_id": "F16",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M660",
    "name": "BcelFieldRef",
    "return_type": "",
    "signature": "BcelFieldRef(ResolvedType type, String className, String fieldName)",
    "file_id": "F17",
    "start_line": 30,
    "text_preview": "ays a static reference.\\n */\\npublic class BcelFieldRef extends BcelVar {\\n\\n\tprivate String className, fieldName;\\n\\n\tpublic BcelFieldRef(ResolvedType type, String className, String fieldName) {\\n\t\tsuper(type, 0);\\n\t\tthis.className = className;\\n\t\tthis.fieldName = fieldName;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"BcelFieldR"
  },
  {
    "method_id": "M661",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F17",
    "start_line": 36,
    "text_preview": "e, String fieldName) {\\n\t\tsuper(type, 0);\\n\t\tthis.className = className;\\n\t\tthis.fieldName = fieldName;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"BcelFieldRef(\" + getType() + \" \" + className + \".\" + fieldName + \")\";\\n\t}\\n\\n\t// public int getSlot() { return slot; }\\n\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\t"
  },
  {
    "method_id": "M662",
    "name": "getSlot",
    "return_type": "int",
    "signature": "getSlot()",
    "file_id": "F17",
    "start_line": 40,
    "text_preview": " String toString() {\\n\t\treturn \"BcelFieldRef(\" + getType() + \" \" + className + \".\" + fieldName + \")\";\\n\t}\\n\\n\t// public int getSlot() { return slot; }\\n\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\treturn fact.createFieldAccess(className, fieldName, BcelWorld.makeBcelType(getType()), Constants.GETSTATIC);\\n\t}\\n"
  },
  {
    "method_id": "M663",
    "name": "createLoad",
    "return_type": "Instruction",
    "signature": "createLoad(InstructionFactory fact)",
    "file_id": "F17",
    "start_line": 42,
    "text_preview": "getType() + \" \" + className + \".\" + fieldName + \")\";\\n\t}\\n\\n\t// public int getSlot() { return slot; }\\n\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\treturn fact.createFieldAccess(className, fieldName, BcelWorld.makeBcelType(getType()), Constants.GETSTATIC);\\n\t}\\n\\n\tpublic Instruction createStore(InstructionFact"
  },
  {
    "method_id": "M664",
    "name": "createStore",
    "return_type": "Instruction",
    "signature": "createStore(InstructionFactory fact)",
    "file_id": "F17",
    "start_line": 46,
    "text_preview": "reateFieldAccess(className, fieldName, BcelWorld.makeBcelType(getType()), Constants.GETSTATIC);\\n\t}\\n\\n\tpublic Instruction createStore(InstructionFactory fact) {\\n\t\treturn fact.createFieldAccess(className, fieldName, BcelWorld.makeBcelType(getType()), Constants.PUTSTATIC);\\n\t}\\n\\n\tpublic InstructionList createCopyFrom(Instruc"
  },
  {
    "method_id": "M665",
    "name": "createCopyFrom",
    "return_type": "InstructionList",
    "signature": "createCopyFrom(InstructionFactory fact, int oldSlot)",
    "file_id": "F17",
    "start_line": 50,
    "text_preview": "eFieldAccess(className, fieldName, BcelWorld.makeBcelType(getType()), Constants.PUTSTATIC);\\n\t}\\n\\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t// this is an array var\\n\t// void appendConvertableArrayLoad(\\n\t// InstructionList il,\\n\t// Inst"
  },
  {
    "method_id": "M666",
    "name": "classTypeSignature2TypeX",
    "return_type": "ResolvedType",
    "signature": "classTypeSignature2TypeX(GenericSignature.ClassTypeSignature aClassTypeSignature,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world)",
    "file_id": "F18",
    "start_line": 38,
    "text_preview": "ace = TraceFactory.getTraceFactory().getTrace(BcelGenericSignatureToTypeXConverter.class);\\n\\n\tpublic static ResolvedType classTypeSignature2TypeX(GenericSignature.ClassTypeSignature aClassTypeSignature,\\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world) throws GenericSignatureFormatException {\\n\t\tMap<Gene"
  },
  {
    "method_id": "M667",
    "name": "classTypeSignature2TypeX",
    "return_type": "ResolvedType",
    "signature": "classTypeSignature2TypeX(GenericSignature.ClassTypeSignature aClassTypeSignature,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)",
    "file_id": "F18",
    "start_line": 38,
    "text_preview": "ace = TraceFactory.getTraceFactory().getTrace(BcelGenericSignatureToTypeXConverter.class);\\n\\n\tpublic static ResolvedType classTypeSignature2TypeX(GenericSignature.ClassTypeSignature aClassTypeSignature,\\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world) throws GenericSignatureFormatException {\\n\t\tMap<Gene"
  },
  {
    "method_id": "M668",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < aClassTypeSignature.nestedTypes.length; i++)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M669",
    "name": "if",
    "return_type": "",
    "signature": "if(aClassTypeSignature.nestedTypes.length > 0)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M670",
    "name": "if",
    "return_type": "",
    "signature": "if(innerType.typeArguments.length > 0)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M671",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < typeArgumentTypes.length; i++)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M672",
    "name": "fieldTypeSignature2TypeX",
    "return_type": "ResolvedType",
    "signature": "fieldTypeSignature2TypeX(GenericSignature.FieldTypeSignature aFieldTypeSignature,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world)",
    "file_id": "F18",
    "start_line": 101,
    "text_preview": "eterized type\\n\t\t\treturn world.resolve(UnresolvedType.forSignature(sig.toString()));\\n\t\t}\\n\t}\\n\\n\tpublic static ResolvedType fieldTypeSignature2TypeX(GenericSignature.FieldTypeSignature aFieldTypeSignature,\\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world) throws GenericSignatureFormatException {\\n\t\tMap<Gene"
  },
  {
    "method_id": "M673",
    "name": "fieldTypeSignature2TypeX",
    "return_type": "ResolvedType",
    "signature": "fieldTypeSignature2TypeX(GenericSignature.FieldTypeSignature aFieldTypeSignature,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)",
    "file_id": "F18",
    "start_line": 101,
    "text_preview": "eterized type\\n\t\t\treturn world.resolve(UnresolvedType.forSignature(sig.toString()));\\n\t\t}\\n\t}\\n\\n\tpublic static ResolvedType fieldTypeSignature2TypeX(GenericSignature.FieldTypeSignature aFieldTypeSignature,\\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world) throws GenericSignatureFormatException {\\n\t\tMap<Gene"
  },
  {
    "method_id": "M674",
    "name": "while",
    "return_type": "",
    "signature": "while(ats instanceof GenericSignature.ArrayTypeSignature)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M675",
    "name": "formalTypeParameter2TypeVariable",
    "return_type": "TypeVariable",
    "signature": "formalTypeParameter2TypeVariable(GenericSignature.FormalTypeParameter aFormalTypeParameter,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world)",
    "file_id": "F18",
    "start_line": 134,
    "text_preview": "ureFormatException(\"Cant understand field type signature: \" + aFieldTypeSignature);\\n\t\t}\\n\t}\\n\\n\tpublic static TypeVariable formalTypeParameter2TypeVariable(GenericSignature.FormalTypeParameter aFormalTypeParameter,\\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world) throws GenericSignatureFormatException {\\n"
  },
  {
    "method_id": "M676",
    "name": "formalTypeParameter2TypeVariable",
    "return_type": "TypeVariable",
    "signature": "formalTypeParameter2TypeVariable(GenericSignature.FormalTypeParameter aFormalTypeParameter,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)",
    "file_id": "F18",
    "start_line": 134,
    "text_preview": "ureFormatException(\"Cant understand field type signature: \" + aFieldTypeSignature);\\n\t\t}\\n\t}\\n\\n\tpublic static TypeVariable formalTypeParameter2TypeVariable(GenericSignature.FormalTypeParameter aFormalTypeParameter,\\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world) throws GenericSignatureFormatException {\\n"
  },
  {
    "method_id": "M677",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < ifBounds.length; i++)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M678",
    "name": "typeArgument2TypeX",
    "return_type": "ResolvedType",
    "signature": "typeArgument2TypeX(GenericSignature.TypeArgument aTypeArgument,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)",
    "file_id": "F18",
    "start_line": 87,
    "text_preview": "ype[innerType.typeArguments.length];\\n\t\t\tfor (int i = 0; i < typeArgumentTypes.length; i++) {\\n\t\t\t\ttypeArgumentTypes[i] = typeArgument2TypeX(innerType.typeArguments[i], typeParams, world,\\n\t\t\t\t\t\tinProgressTypeVariableResolutions);\\n\t\t\t}\\n\t\t\treturn TypeFactory.createParameterizedType(theBaseType, typeArgumentTypes, world);\\n\\n"
  },
  {
    "method_id": "M679",
    "name": "if",
    "return_type": "",
    "signature": "if(aTypeArgument.isWildcard)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M680",
    "name": "if",
    "return_type": "",
    "signature": "if(aTypeArgument.isMinus)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M681",
    "name": "if",
    "return_type": "else",
    "signature": "if(aTypeArgument.isPlus)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M682",
    "name": "typeSignature2TypeX",
    "return_type": "ResolvedType",
    "signature": "typeSignature2TypeX(GenericSignature.TypeSignature aTypeSig,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world)",
    "file_id": "F18",
    "start_line": 124,
    "text_preview": "\tats = ((GenericSignature.ArrayTypeSignature) ats).typeSig;\\n\t\t\t}\\n\t\t\treturn world.resolve(UnresolvedType.makeArray(\\n\t\t\t\t\ttypeSignature2TypeX(ats, typeParams, world, inProgressTypeVariableResolutions), dims));\\n\t\t} else if (aFieldTypeSignature.isTypeVariableSignature()) {\\n\t\t\tResolvedType rtx = typeVariableSignature2TypeX("
  },
  {
    "method_id": "M683",
    "name": "typeSignature2TypeX",
    "return_type": "ResolvedType",
    "signature": "typeSignature2TypeX(GenericSignature.TypeSignature aTypeSig,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)",
    "file_id": "F18",
    "start_line": 124,
    "text_preview": "\tats = ((GenericSignature.ArrayTypeSignature) ats).typeSig;\\n\t\t\t}\\n\t\t\treturn world.resolve(UnresolvedType.makeArray(\\n\t\t\t\t\ttypeSignature2TypeX(ats, typeParams, world, inProgressTypeVariableResolutions), dims));\\n\t\t} else if (aFieldTypeSignature.isTypeVariableSignature()) {\\n\t\t\tResolvedType rtx = typeVariableSignature2TypeX("
  },
  {
    "method_id": "M684",
    "name": "typeVariableSignature2TypeX",
    "return_type": "ResolvedType",
    "signature": "typeVariableSignature2TypeX(GenericSignature.TypeVariableSignature aTypeVarSig,\n\t\t\tGenericSignature.FormalTypeParameter[] typeParams, World world,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> inProgressTypeVariableResolutions)",
    "file_id": "F18",
    "start_line": 126,
    "text_preview": "ssTypeVariableResolutions), dims));\\n\t\t} else if (aFieldTypeSignature.isTypeVariableSignature()) {\\n\t\t\tResolvedType rtx = typeVariableSignature2TypeX((GenericSignature.TypeVariableSignature) aFieldTypeSignature,\\n\t\t\t\t\ttypeParams, world, inProgressTypeVariableResolutions);\\n\t\t\treturn rtx;\\n\t\t} else {\\n\t\t\tthrow new GenericSign"
  },
  {
    "method_id": "M685",
    "name": "for",
    "return_type": "",
    "signature": "for(GenericSignature.FormalTypeParameter typeParam : typeParams)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M686",
    "name": "if",
    "return_type": "",
    "signature": "if(typeVarBounds == null)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M687",
    "name": "fixUpCircularDependencies",
    "return_type": "void",
    "signature": "fixUpCircularDependencies(ResolvedType aTypeX,\n\t\t\tMap<GenericSignature.FormalTypeParameter, ReferenceType> typeVariableResolutions)",
    "file_id": "F18",
    "start_line": 42,
    "text_preview": "ap = new HashMap<>();\\n\t\tResolvedType ret = classTypeSignature2TypeX(aClassTypeSignature, typeParams, world, typeMap);\\n\t\tfixUpCircularDependencies(ret, typeMap);\\n\t\treturn ret;\\n\t}\\n\\n\tprivate static ResolvedType classTypeSignature2TypeX(GenericSignature.ClassTypeSignature aClassTypeSignature,\\n\t\t\tGenericSignature.FormalType"
  },
  {
    "method_id": "M688",
    "name": "if",
    "return_type": "",
    "signature": "if(typeVars != null)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M689",
    "name": "for",
    "return_type": "",
    "signature": "for(TypeVariable typeVar : typeVars)",
    "file_id": "F18",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M690",
    "name": "FTPHolder",
    "return_type": "",
    "signature": "FTPHolder(GenericSignature.FormalTypeParameter ftp, World world)",
    "file_id": "F18",
    "start_line": 227,
    "text_preview": "rn inProgressTypeVariableResolutions.get(typeVarBounds);\\n\t\t}\\n\t\tinProgressTypeVariableResolutions.put(typeVarBounds, new FTPHolder(typeVarBounds, world));\\n\t\tReferenceType ret = new TypeVariableReferenceType(formalTypeParameter2TypeVariable(typeVarBounds, typeParams, world,\\n\t\t\t\tinProgressTypeVariableResolutions), world);"
  },
  {
    "method_id": "M691",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F18",
    "start_line": 72,
    "text_preview": "ts may be array types, class types, or typevariable types\\n\t\t\tResolvedType theBaseType = UnresolvedType.forSignature(sig.toString()).resolve(world);\\n\\n\t\t\t// Sometimes we may find that when the code is being load-time woven that the types have changed.\\n\t\t\t// Perhaps an old form of a library jar is being used - this can me"
  },
  {
    "method_id": "M692",
    "name": "resolve",
    "return_type": "ResolvedType",
    "signature": "resolve(World world)",
    "file_id": "F18",
    "start_line": 72,
    "text_preview": "ray types, class types, or typevariable types\\n\t\t\tResolvedType theBaseType = UnresolvedType.forSignature(sig.toString()).resolve(world);\\n\\n\t\t\t// Sometimes we may find that when the code is being load-time woven that the types have changed.\\n\t\t\t// Perhaps an old form of a library jar is being used - this can mean we discov"
  },
  {
    "method_id": "M693",
    "name": "isCacheable",
    "return_type": "boolean",
    "signature": "isCacheable()",
    "file_id": "F18",
    "start_line": 268,
    "text_preview": " ftpToBeSubstituted.toString();\\n\t\t}\\n\\n\t\tpublic ResolvedType resolve(World world) {\\n\t\t\treturn this;\\n\t\t}\\n\\n\t\tpublic boolean isCacheable() {\\n\t\t\treturn false;\\n\t\t}\\n\t}\\n\\n\tpublic static class GenericSignatureFormatException extends Exception {\\n\t\tpublic GenericSignatureFormatException(String explanation) {\\n\t\t\tsuper(explanation);\\n"
  },
  {
    "method_id": "M694",
    "name": "GenericSignatureFormatException",
    "return_type": "",
    "signature": "GenericSignatureFormatException(String explanation)",
    "file_id": "F18",
    "start_line": 130,
    "text_preview": "aFieldTypeSignature,\\n\t\t\t\t\ttypeParams, world, inProgressTypeVariableResolutions);\\n\t\t\treturn rtx;\\n\t\t} else {\\n\t\t\tthrow new GenericSignatureFormatException(\"Cant understand field type signature: \" + aFieldTypeSignature);\\n\t\t}\\n\t}\\n\\n\tpublic static TypeVariable formalTypeParameter2TypeVariable(GenericSignature.FormalTypeParamet"
  },
  {
    "method_id": "M695",
    "name": "BcelMethod",
    "return_type": "",
    "signature": "BcelMethod(BcelObjectType declaringType, Method method)",
    "file_id": "F19",
    "start_line": 84,
    "text_preview": "meter types\\n\tprivate UnresolvedType genericReturnType = null;\\n\tprivate UnresolvedType[] genericParameterTypes = null;\\n\\n\tBcelMethod(BcelObjectType declaringType, Method method) {\\n\t\tsuper(method.getName().equals(\"<init>\") ? CONSTRUCTOR : (method.getName().equals(\"<clinit>\") ? STATIC_INITIALIZATION\\n\t\t\t\t: METHOD), declarin"
  },
  {
    "method_id": "M696",
    "name": "BcelMethod",
    "return_type": "",
    "signature": "BcelMethod(BcelObjectType declaringType, Method method, List<AjAttribute> attributes)",
    "file_id": "F19",
    "start_line": 84,
    "text_preview": "meter types\\n\tprivate UnresolvedType genericReturnType = null;\\n\tprivate UnresolvedType[] genericParameterTypes = null;\\n\\n\tBcelMethod(BcelObjectType declaringType, Method method) {\\n\t\tsuper(method.getName().equals(\"<init>\") ? CONSTRUCTOR : (method.getName().equals(\"<clinit>\") ? STATIC_INITIALIZATION\\n\t\t\t\t: METHOD), declarin"
  },
  {
    "method_id": "M697",
    "name": "unpackJavaAttributes",
    "return_type": "void",
    "signature": "unpackJavaAttributes()",
    "file_id": "F19",
    "start_line": 90,
    "text_preview": "od = method;\\n\t\tsourceContext = declaringType.getResolvedTypeX().getSourceContext();\\n\t\tbcelObjectType = declaringType;\\n\t\tunpackJavaAttributes();\\n\t\tunpackAjAttributes(bcelObjectType.getWorld());\\n\t}\\n\\n\t/**\\n\t * This constructor expects to be passed the attributes, rather than deserializing them.\\n\t */\\n\tBcelMethod(BcelObjectT"
  },
  {
    "method_id": "M698",
    "name": "getParameterNames",
    "return_type": "String[]",
    "signature": "getParameterNames()",
    "file_id": "F19",
    "start_line": 115,
    "text_preview": "== null) ? UnresolvedType.NONE : UnresolvedType.forNames(exnTable.getExceptionNames());\\n\t}\\n\\n\t@Override\\n\tpublic String[] getParameterNames() {\\n\t\tdetermineParameterNames();\\n\t\treturn super.getParameterNames();\\n\t}\\n\\n\tpublic int getLineNumberOfFirstInstruction() {\\n\t\tLineNumberTable lnt = method.getLineNumberTable();\\n\t\tif (ln"
  },
  {
    "method_id": "M699",
    "name": "getLineNumberOfFirstInstruction",
    "return_type": "int",
    "signature": "getLineNumberOfFirstInstruction()",
    "file_id": "F19",
    "start_line": 120,
    "text_preview": "\tpublic String[] getParameterNames() {\\n\t\tdetermineParameterNames();\\n\t\treturn super.getParameterNames();\\n\t}\\n\\n\tpublic int getLineNumberOfFirstInstruction() {\\n\t\tLineNumberTable lnt = method.getLineNumberTable();\\n\t\tif (lnt == null) {\\n\t\t\treturn -1;\\n\t\t}\\n\t\tLineNumber[] lns = lnt.getLineNumberTable();\\n\t\tif (lns == null || lns."
  },
  {
    "method_id": "M700",
    "name": "if",
    "return_type": "",
    "signature": "if(lnt == null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M701",
    "name": "if",
    "return_type": "",
    "signature": "if(lns == null || lns.length == 0)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M702",
    "name": "determineParameterNames",
    "return_type": "void",
    "signature": "determineParameterNames()",
    "file_id": "F19",
    "start_line": 116,
    "text_preview": "e.NONE : UnresolvedType.forNames(exnTable.getExceptionNames());\\n\t}\\n\\n\t@Override\\n\tpublic String[] getParameterNames() {\\n\t\tdetermineParameterNames();\\n\t\treturn super.getParameterNames();\\n\t}\\n\\n\tpublic int getLineNumberOfFirstInstruction() {\\n\t\tLineNumberTable lnt = method.getLineNumberTable();\\n\t\tif (lnt == null) {\\n\t\t\treturn -"
  },
  {
    "method_id": "M703",
    "name": "if",
    "return_type": "",
    "signature": "if(varTable == null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M704",
    "name": "if",
    "return_type": "",
    "signature": "if(annos != null && annos.length != 0)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M705",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotationX : axs)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M706",
    "name": "if",
    "return_type": "",
    "signature": "if(a != null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M707",
    "name": "for",
    "return_type": "",
    "signature": "for(NameValuePair nvPair : values)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M708",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < len; i++)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M709",
    "name": "if",
    "return_type": "",
    "signature": "if(lv == null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M710",
    "name": "unpackAjAttributes",
    "return_type": "void",
    "signature": "unpackAjAttributes(World world)",
    "file_id": "F19",
    "start_line": 91,
    "text_preview": "xt = declaringType.getResolvedTypeX().getSourceContext();\\n\t\tbcelObjectType = declaringType;\\n\t\tunpackJavaAttributes();\\n\t\tunpackAjAttributes(bcelObjectType.getWorld());\\n\t}\\n\\n\t/**\\n\t * This constructor expects to be passed the attributes, rather than deserializing them.\\n\t */\\n\tBcelMethod(BcelObjectType declaringType, Method "
  },
  {
    "method_id": "M711",
    "name": "processAttributes",
    "return_type": "void",
    "signature": "processAttributes(World world, List<AjAttribute> as)",
    "file_id": "F19",
    "start_line": 104,
    "text_preview": "xt = declaringType.getResolvedTypeX().getSourceContext();\\n\t\tbcelObjectType = declaringType;\\n\t\tunpackJavaAttributes();\\n\t\tprocessAttributes(bcelObjectType.getWorld(), attributes);\\n\t}\\n\\n\t// ----\\n\\n\tprivate void unpackJavaAttributes() {\\n\t\tExceptionTable exnTable = method.getExceptionTable();\\n\t\tcheckedExceptions = (exnTable ="
  },
  {
    "method_id": "M712",
    "name": "for",
    "return_type": "",
    "signature": "for(AjAttribute attr : as)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M713",
    "name": "if",
    "return_type": "",
    "signature": "if(attr instanceof AjAttribute.MethodDeclarationLineNumberAttribute)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M714",
    "name": "if",
    "return_type": "else",
    "signature": "if(attr instanceof AjAttribute.AdviceAttribute)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M715",
    "name": "if",
    "return_type": "else",
    "signature": "if(attr instanceof AjAttribute.AjSynthetic)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M716",
    "name": "if",
    "return_type": "else",
    "signature": "if(attr instanceof AjAttribute.EffectiveSignatureAttribute)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M717",
    "name": "if",
    "return_type": "else",
    "signature": "if(attr instanceof AjAttribute.PointcutDeclarationAttribute)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M718",
    "name": "getAttributes",
    "return_type": "AjAttribute[]",
    "signature": "getAttributes(String name)",
    "file_id": "F19",
    "start_line": 197,
    "text_preview": "eaverVersionAttribute();\\n\t\tList<AjAttribute> as = Utility.readAjAttributes(resolvedDeclaringType.getClassName(), method.getAttributes(),\\n\t\t\t\tresolvedDeclaringType.getSourceContext(), world, wvinfo, new BcelConstantPoolReader(method.getConstantPool()));\\n\t\tprocessAttributes(world, as);\\n\t\tas = AtAjAttributes.readAj5Method"
  },
  {
    "method_id": "M719",
    "name": "getAnnotationDefaultValue",
    "return_type": "String",
    "signature": "getAnnotationDefaultValue()",
    "file_id": "F19",
    "start_line": 246,
    "text_preview": "/ return (AjAttribute[]) results.toArray(new AjAttribute[] {});\\n\t// }\\n\t// return null;\\n\t// }\\n\\n\t@Override\\n\tpublic String getAnnotationDefaultValue() {\\n\t\tAttribute[] attrs = method.getAttributes();\\n\t\tfor (Attribute attribute : attrs) {\\n\t\t\tif (attribute.getName().equals(\"AnnotationDefault\")) {\\n\t\t\t\tAnnotationDefault def = "
  },
  {
    "method_id": "M720",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute attribute : attrs)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M721",
    "name": "getAttributeNames",
    "return_type": "String[]",
    "signature": "getAttributeNames(boolean onlyIncludeAjOnes)",
    "file_id": "F19",
    "start_line": 258,
    "text_preview": "ementValue().stringifyValue();\\n\t\t\t}\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\t// for testing - use with the method above\\n\tpublic String[] getAttributeNames(boolean onlyIncludeAjOnes) {\\n\t\tAttribute[] as = method.getAttributes();\\n\t\tList<String> names = new ArrayList<>();\\n\t\t// String[] strs = new String[as.length];\\n\t\tfor (Attribute a : as)"
  },
  {
    "method_id": "M722",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute a : as)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M723",
    "name": "isAjSynthetic",
    "return_type": "boolean",
    "signature": "isAjSynthetic()",
    "file_id": "F19",
    "start_line": 271,
    "text_preview": "Prefix)) {\\n\t\t\t\tnames.add(a.getName());\\n\t\t\t}\\n\t\t}\\n\t\treturn names.toArray(new String[] {});\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAjSynthetic() {\\n\t\treturn (bitflags & IS_AJ_SYNTHETIC) != 0;\\n\t}\\n\\n\t@Override\\n\tpublic ShadowMunger getAssociatedShadowMunger() {\\n\t\treturn associatedShadowMunger;\\n\t}\\n\\n\t@Override\\n\tpublic AjAttribute.Effe"
  },
  {
    "method_id": "M724",
    "name": "getAssociatedShadowMunger",
    "return_type": "ShadowMunger",
    "signature": "getAssociatedShadowMunger()",
    "file_id": "F19",
    "start_line": 276,
    "text_preview": "rride\\n\tpublic boolean isAjSynthetic() {\\n\t\treturn (bitflags & IS_AJ_SYNTHETIC) != 0;\\n\t}\\n\\n\t@Override\\n\tpublic ShadowMunger getAssociatedShadowMunger() {\\n\t\treturn associatedShadowMunger;\\n\t}\\n\\n\t@Override\\n\tpublic AjAttribute.EffectiveSignatureAttribute getEffectiveSignature() {\\n\t\treturn effectiveSignature;\\n\t}\\n\\n\tpublic boolean"
  },
  {
    "method_id": "M725",
    "name": "getEffectiveSignature",
    "return_type": "EffectiveSignatureAttribute",
    "signature": "getEffectiveSignature()",
    "file_id": "F19",
    "start_line": 281,
    "text_preview": "ociatedShadowMunger() {\\n\t\treturn associatedShadowMunger;\\n\t}\\n\\n\t@Override\\n\tpublic AjAttribute.EffectiveSignatureAttribute getEffectiveSignature() {\\n\t\treturn effectiveSignature;\\n\t}\\n\\n\tpublic boolean hasDeclarationLineNumberInfo() {\\n\t\treturn declarationLineNumber != null;\\n\t}\\n\\n\tpublic int getDeclarationLineNumber() {\\n\t\tif (d"
  },
  {
    "method_id": "M726",
    "name": "hasDeclarationLineNumberInfo",
    "return_type": "boolean",
    "signature": "hasDeclarationLineNumberInfo()",
    "file_id": "F19",
    "start_line": 285,
    "text_preview": "blic AjAttribute.EffectiveSignatureAttribute getEffectiveSignature() {\\n\t\treturn effectiveSignature;\\n\t}\\n\\n\tpublic boolean hasDeclarationLineNumberInfo() {\\n\t\treturn declarationLineNumber != null;\\n\t}\\n\\n\tpublic int getDeclarationLineNumber() {\\n\t\tif (declarationLineNumber != null) {\\n\t\t\treturn declarationLineNumber.getLineNumb"
  },
  {
    "method_id": "M727",
    "name": "getDeclarationLineNumber",
    "return_type": "int",
    "signature": "getDeclarationLineNumber()",
    "file_id": "F19",
    "start_line": 289,
    "text_preview": "Signature;\\n\t}\\n\\n\tpublic boolean hasDeclarationLineNumberInfo() {\\n\t\treturn declarationLineNumber != null;\\n\t}\\n\\n\tpublic int getDeclarationLineNumber() {\\n\t\tif (declarationLineNumber != null) {\\n\t\t\treturn declarationLineNumber.getLineNumber();\\n\t\t} else {\\n\t\t\treturn -1;\\n\t\t}\\n\t}\\n\\n\tpublic int getDeclarationOffset() {\\n\t\tif (declara"
  },
  {
    "method_id": "M728",
    "name": "if",
    "return_type": "",
    "signature": "if(declarationLineNumber != null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M729",
    "name": "getDeclarationOffset",
    "return_type": "int",
    "signature": "getDeclarationOffset()",
    "file_id": "F19",
    "start_line": 297,
    "text_preview": "tionLineNumber != null) {\\n\t\t\treturn declarationLineNumber.getLineNumber();\\n\t\t} else {\\n\t\t\treturn -1;\\n\t\t}\\n\t}\\n\\n\tpublic int getDeclarationOffset() {\\n\t\tif (declarationLineNumber != null) {\\n\t\t\treturn declarationLineNumber.getOffset();\\n\t\t} else {\\n\t\t\treturn -1;\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic ISourceLocation getSourceLocation() {\\n\t"
  },
  {
    "method_id": "M730",
    "name": "if",
    "return_type": "",
    "signature": "if(declarationLineNumber != null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M731",
    "name": "getSourceLocation",
    "return_type": "ISourceLocation",
    "signature": "getSourceLocation()",
    "file_id": "F19",
    "start_line": 306,
    "text_preview": "ull) {\\n\t\t\treturn declarationLineNumber.getOffset();\\n\t\t} else {\\n\t\t\treturn -1;\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic ISourceLocation getSourceLocation() {\\n\t\tISourceLocation ret = super.getSourceLocation();\\n\t\tif ((ret == null || ret.getLine() == 0) && hasDeclarationLineNumberInfo()) {\\n\t\t\t// lets see if we can do better\\n\t\t\tISourceCon"
  },
  {
    "method_id": "M732",
    "name": "if",
    "return_type": "",
    "signature": "if(isc != null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M733",
    "name": "getKind",
    "return_type": "MemberKind",
    "signature": "getKind()",
    "file_id": "F19",
    "start_line": 321,
    "text_preview": "\t\t\tret = new SourceLocation(null, getDeclarationLineNumber());\\n\t\t\t}\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\t@Override\\n\tpublic MemberKind getKind() {\\n\t\tif (associatedShadowMunger != null) {\\n\t\t\treturn ADVICE;\\n\t\t} else {\\n\t\t\treturn super.getKind();\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\\n\t\tensureAnnotation"
  },
  {
    "method_id": "M734",
    "name": "if",
    "return_type": "",
    "signature": "if(associatedShadowMunger != null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M735",
    "name": "hasAnnotation",
    "return_type": "boolean",
    "signature": "hasAnnotation(UnresolvedType ofType)",
    "file_id": "F19",
    "start_line": 330,
    "text_preview": "iatedShadowMunger != null) {\\n\t\t\treturn ADVICE;\\n\t\t} else {\\n\t\t\treturn super.getKind();\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\\n\t\tensureAnnotationsRetrieved();\\n\t\tfor (ResolvedType aType : annotationTypes) {\\n\t\t\tif (aType.equals(ofType)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\t@Ove"
  },
  {
    "method_id": "M736",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType aType : annotationTypes)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M737",
    "name": "getAnnotations",
    "return_type": "AnnotationAJ[]",
    "signature": "getAnnotations()",
    "file_id": "F19",
    "start_line": 141,
    "text_preview": "\t\tif (varTable == null) {\\n\t\t\t// do we have an annotation with the argNames value specified...\\n\t\t\tAnnotationAJ[] annos = getAnnotations();\\n\t\t\tif (annos != null && annos.length != 0) {\\n\t\t\t\tAnnotationAJ[] axs = getAnnotations();\\n\t\t\t\tfor (AnnotationAJ annotationX : axs) {\\n\t\t\t\t\tString typename = annotationX.getTypeName();\\n\t"
  },
  {
    "method_id": "M738",
    "name": "getAnnotationTypes",
    "return_type": "ResolvedType[]",
    "signature": "getAnnotationTypes()",
    "file_id": "F19",
    "start_line": 351,
    "text_preview": "!= 0) {\\n\t\t\treturn annotations;\\n\t\t} else {\\n\t\t\treturn AnnotationAJ.EMPTY_ARRAY;\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType[] getAnnotationTypes() {\\n\t\tensureAnnotationsRetrieved();\\n\t\treturn annotationTypes;\\n\t}\\n\\n\t@Override\\n\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {\\n\t\tensureAnnotationsRetrieved();\\n\t\tif ("
  },
  {
    "method_id": "M739",
    "name": "getAnnotationOfType",
    "return_type": "AnnotationAJ",
    "signature": "getAnnotationOfType(UnresolvedType ofType)",
    "file_id": "F19",
    "start_line": 357,
    "text_preview": "[] getAnnotationTypes() {\\n\t\tensureAnnotationsRetrieved();\\n\t\treturn annotationTypes;\\n\t}\\n\\n\t@Override\\n\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {\\n\t\tensureAnnotationsRetrieved();\\n\t\tif ((bitflags & HAS_ANNOTATIONS) == 0) {\\n\t\t\treturn null;\\n\t\t}\\n\t\tfor (AnnotationAJ annotation : annotations) {\\n\t\t\tif (annot"
  },
  {
    "method_id": "M740",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotation : annotations)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M741",
    "name": "addAnnotation",
    "return_type": "void",
    "signature": "addAnnotation(AnnotationAJ annotation)",
    "file_id": "F19",
    "start_line": 371,
    "text_preview": "on.getTypeName().equals(ofType.getName())) {\\n\t\t\t\treturn annotation;\\n\t\t\t}\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\t@Override\\n\tpublic void addAnnotation(AnnotationAJ annotation) {\\n\t\tensureAnnotationsRetrieved();\\n\t\tif ((bitflags & HAS_ANNOTATIONS) == 0) {\\n\t\t\tannotations = new AnnotationAJ[1];\\n\t\t\tannotations[0] = annotation;\\n\t\t\tannotationT"
  },
  {
    "method_id": "M742",
    "name": "removeAnnotation",
    "return_type": "void",
    "signature": "removeAnnotation(ResolvedType annotationType)",
    "file_id": "F19",
    "start_line": 393,
    "text_preview": "n] = annotation.getType();\\n\t\t\tannotationTypes = newAnnotationTypes;\\n\t\t}\\n\t\tbitflags |= HAS_ANNOTATIONS;\\n\t}\\n\\n\tpublic void removeAnnotation(ResolvedType annotationType) {\\n\t\tensureAnnotationsRetrieved();\\n\t\tif ((bitflags & HAS_ANNOTATIONS) == 0) {\\n\t\t\t// nothing to do, why did we get called?\\n\t\t} else {\\n\t\t\tint len = annotatio"
  },
  {
    "method_id": "M743",
    "name": "if",
    "return_type": "",
    "signature": "if(len == 1)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M744",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotation : annotations)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M745",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotation : annotations)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M746",
    "name": "addParameterAnnotation",
    "return_type": "void",
    "signature": "addParameterAnnotation(int param, AnnotationAJ anno)",
    "file_id": "F19",
    "start_line": 426,
    "text_preview": "annotationType;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tannotationTypes = newAnnotationTypes;\\n\t\t}\\n\t\tbitflags |= HAS_ANNOTATIONS;\\n\t}\\n\\n\tpublic void addParameterAnnotation(int param, AnnotationAJ anno) {\\n\t\tensureParameterAnnotationsRetrieved();\\n\t\tif (parameterAnnotations == NO_PARAMETER_ANNOTATIONXS) {\\n\t\t\t// First time we've added any, so lets set"
  },
  {
    "method_id": "M747",
    "name": "if",
    "return_type": "",
    "signature": "if(parameterAnnotations == NO_PARAMETER_ANNOTATIONXS)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M748",
    "name": "if",
    "return_type": "",
    "signature": "if(existingCount == 0)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M749",
    "name": "ensureAnnotationsRetrieved",
    "return_type": "void",
    "signature": "ensureAnnotationsRetrieved()",
    "file_id": "F19",
    "start_line": 331,
    "text_preview": "VICE;\\n\t\t} else {\\n\t\t\treturn super.getKind();\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\\n\t\tensureAnnotationsRetrieved();\\n\t\tfor (ResolvedType aType : annotationTypes) {\\n\t\t\tif (aType.equals(ofType)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\t@Override\\n\tpublic AnnotationAJ[] getAnnotatio"
  },
  {
    "method_id": "M750",
    "name": "if",
    "return_type": "",
    "signature": "if(method == null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M751",
    "name": "if",
    "return_type": "",
    "signature": "if(annos.length == 0)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M752",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < annoCount; i++)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M753",
    "name": "ensureParameterAnnotationsRetrieved",
    "return_type": "void",
    "signature": "ensureParameterAnnotationsRetrieved()",
    "file_id": "F19",
    "start_line": 427,
    "text_preview": "tionTypes;\\n\t\t}\\n\t\tbitflags |= HAS_ANNOTATIONS;\\n\t}\\n\\n\tpublic void addParameterAnnotation(int param, AnnotationAJ anno) {\\n\t\tensureParameterAnnotationsRetrieved();\\n\t\tif (parameterAnnotations == NO_PARAMETER_ANNOTATIONXS) {\\n\t\t\t// First time we've added any, so lets set up the array\\n\t\t\tparameterAnnotations = new AnnotationAJ["
  },
  {
    "method_id": "M754",
    "name": "if",
    "return_type": "",
    "signature": "if(method == null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M755",
    "name": "if",
    "return_type": "",
    "signature": "if(parameterAnnotationTypes == null || pAnns.length != parameterAnnotationTypes.length)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M756",
    "name": "if",
    "return_type": "",
    "signature": "if(pAnns == Method.NO_PARAMETER_ANNOTATIONS)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M757",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < annos.length; i++)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M758",
    "name": "if",
    "return_type": "",
    "signature": "if(annos[i].length == 0)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M759",
    "name": "for",
    "return_type": "",
    "signature": "for(int j = 0; j < annosOnThisParam.length; j++)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M760",
    "name": "getParameterAnnotations",
    "return_type": "AnnotationAJ[][]",
    "signature": "getParameterAnnotations()",
    "file_id": "F19",
    "start_line": 477,
    "text_preview": "trieved() {\\n\t\tif (method == null) {\\n\t\t\treturn; // must be ok, we have evicted it\\n\t\t}\\n\t\tAnnotationGen[][] pAnns = method.getParameterAnnotations();\\n\t\tif (parameterAnnotationTypes == null || pAnns.length != parameterAnnotationTypes.length) {\\n\t\t\tif (pAnns == Method.NO_PARAMETER_ANNOTATIONS) {\\n\t\t\t\tparameterAnnotationTypes "
  },
  {
    "method_id": "M761",
    "name": "getParameterAnnotationTypes",
    "return_type": "ResolvedType[][]",
    "signature": "getParameterAnnotationTypes()",
    "file_id": "F19",
    "start_line": 512,
    "text_preview": "ons() {\\n\t\tensureParameterAnnotationsRetrieved();\\n\t\treturn parameterAnnotations;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType[][] getParameterAnnotationTypes() {\\n\t\tensureParameterAnnotationsRetrieved();\\n\t\treturn parameterAnnotationTypes;\\n\t}\\n\\n\t/**\\n\t * A method can be parameterized if it has one or more generic parameters. A gener"
  },
  {
    "method_id": "M762",
    "name": "canBeParameterized",
    "return_type": "boolean",
    "signature": "canBeParameterized()",
    "file_id": "F19",
    "start_line": 522,
    "text_preview": "ters. A generic parameter (type variable parameter) is\\n\t * identified by the prefix \"T\"\\n\t */\\n\t@Override\\n\tpublic boolean canBeParameterized() {\\n\t\tunpackGenericSignature();\\n\t\treturn (bitflags & CAN_BE_PARAMETERIZED) != 0;\\n\t}\\n\\n\t@Override\\n\tpublic UnresolvedType[] getGenericParameterTypes() {\\n\t\tunpackGenericSignature();\\n\t\tr"
  },
  {
    "method_id": "M763",
    "name": "getGenericParameterTypes",
    "return_type": "UnresolvedType[]",
    "signature": "getGenericParameterTypes()",
    "file_id": "F19",
    "start_line": 528,
    "text_preview": " {\\n\t\tunpackGenericSignature();\\n\t\treturn (bitflags & CAN_BE_PARAMETERIZED) != 0;\\n\t}\\n\\n\t@Override\\n\tpublic UnresolvedType[] getGenericParameterTypes() {\\n\t\tunpackGenericSignature();\\n\t\treturn genericParameterTypes;\\n\t}\\n\\n\t/**\\n\t * Return the parameterized/generic return type or the normal return type if the method is not generi"
  },
  {
    "method_id": "M764",
    "name": "getGenericReturnType",
    "return_type": "UnresolvedType",
    "signature": "getGenericReturnType()",
    "file_id": "F19",
    "start_line": 537,
    "text_preview": "ized/generic return type or the normal return type if the method is not generic.\\n\t */\\n\t@Override\\n\tpublic UnresolvedType getGenericReturnType() {\\n\t\tunpackGenericSignature();\\n\t\treturn genericReturnType;\\n\t}\\n\\n\t/** For testing only */\\n\tpublic Method getMethod() {\\n\t\treturn method;\\n\t}\\n\\n\tprivate void unpackGenericSignature() {"
  },
  {
    "method_id": "M765",
    "name": "getMethod",
    "return_type": "Method",
    "signature": "getMethod()",
    "file_id": "F19",
    "start_line": 543,
    "text_preview": "nericReturnType() {\\n\t\tunpackGenericSignature();\\n\t\treturn genericReturnType;\\n\t}\\n\\n\t/** For testing only */\\n\tpublic Method getMethod() {\\n\t\treturn method;\\n\t}\\n\\n\tprivate void unpackGenericSignature() {\\n\t\tif ((bitflags & UNPACKED_GENERIC_SIGNATURE) != 0) {\\n\t\t\treturn;\\n\t\t}\\n\t\tbitflags |= UNPACKED_GENERIC_SIGNATURE;\\n\t\tif (!bcelOb"
  },
  {
    "method_id": "M766",
    "name": "unpackGenericSignature",
    "return_type": "void",
    "signature": "unpackGenericSignature()",
    "file_id": "F19",
    "start_line": 523,
    "text_preview": " (type variable parameter) is\\n\t * identified by the prefix \"T\"\\n\t */\\n\t@Override\\n\tpublic boolean canBeParameterized() {\\n\t\tunpackGenericSignature();\\n\t\treturn (bitflags & CAN_BE_PARAMETERIZED) != 0;\\n\t}\\n\\n\t@Override\\n\tpublic UnresolvedType[] getGenericParameterTypes() {\\n\t\tunpackGenericSignature();\\n\t\treturn genericParameterTyp"
  },
  {
    "method_id": "M767",
    "name": "if",
    "return_type": "",
    "signature": "if(gSig != null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M768",
    "name": "if",
    "return_type": "",
    "signature": "if(mSig.formalTypeParameters.length > 0)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M769",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < typeVariables.length; i++)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M770",
    "name": "catch",
    "return_type": "",
    "signature": "catch(GenericSignatureFormatException e)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M771",
    "name": "catch",
    "return_type": "",
    "signature": "catch(GenericSignatureFormatException e)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M772",
    "name": "if",
    "return_type": "",
    "signature": "if(paramTypeSigs.length == 0)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M773",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < paramTypeSigs.length; i++)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M774",
    "name": "catch",
    "return_type": "",
    "signature": "catch(GenericSignatureFormatException e)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M775",
    "name": "if",
    "return_type": "",
    "signature": "if(paramTypeSigs[i] instanceof TypeVariableSignature)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M776",
    "name": "evictWeavingState",
    "return_type": "void",
    "signature": "evictWeavingState()",
    "file_id": "F19",
    "start_line": 623,
    "text_preview": "\t\t\tgenericReturnType = getReturnType();\\n\t\t\tgenericParameterTypes = getParameterTypes();\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic void evictWeavingState() {\\n\t\tif (method != null) {\\n\t\t\tunpackGenericSignature();\\n\t\t\tunpackJavaAttributes();\\n\t\t\tensureAnnotationsRetrieved();\\n\t\t\tensureParameterAnnotationsRetrieved();\\n\t\t\tdetermineParameterNa"
  },
  {
    "method_id": "M777",
    "name": "if",
    "return_type": "",
    "signature": "if(method != null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M778",
    "name": "isSynthetic",
    "return_type": "boolean",
    "signature": "isSynthetic()",
    "file_id": "F19",
    "start_line": 636,
    "text_preview": "\t// this.sourceContext = SourceContextImpl.UNKNOWN_SOURCE_CONTEXT;\\n\t\t\tmethod = null;\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic boolean isSynthetic() {\\n\t\tif ((bitflags & KNOW_IF_SYNTHETIC) == 0) {\\n\t\t\tworkOutIfSynthetic();\\n\t\t}\\n\t\treturn (bitflags & IS_SYNTHETIC) != 0;// isSynthetic;\\n\t}\\n\\n\t// Pre Java5 synthetic is an attribute 'Synthetic"
  },
  {
    "method_id": "M779",
    "name": "workOutIfSynthetic",
    "return_type": "void",
    "signature": "workOutIfSynthetic()",
    "file_id": "F19",
    "start_line": 638,
    "text_preview": "T;\\n\t\t\tmethod = null;\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic boolean isSynthetic() {\\n\t\tif ((bitflags & KNOW_IF_SYNTHETIC) == 0) {\\n\t\t\tworkOutIfSynthetic();\\n\t\t}\\n\t\treturn (bitflags & IS_SYNTHETIC) != 0;// isSynthetic;\\n\t}\\n\\n\t// Pre Java5 synthetic is an attribute 'Synthetic', post Java5 it is a\\n\t// modifier (4096 or 0x1000)\\n\tprivate voi"
  },
  {
    "method_id": "M780",
    "name": "if",
    "return_type": "bit",
    "signature": "if(jc == null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M781",
    "name": "if",
    "return_type": "",
    "signature": "if(synthetics != null)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M782",
    "name": "for",
    "return_type": "",
    "signature": "for(String synthetic : synthetics)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M783",
    "name": "isEquivalentTo",
    "return_type": "boolean",
    "signature": "isEquivalentTo(Object other)",
    "file_id": "F19",
    "start_line": 684,
    "text_preview": "sed within\\n\t// CrosscuttingMembers.replaceWith() to decide if we need\\n\t// to do a full build\\n\t@Override\\n\tpublic boolean isEquivalentTo(Object other) {\\n\t\tif (!(other instanceof BcelMethod)) {\\n\t\t\treturn false;\\n\t\t}\\n\t\tBcelMethod o = (BcelMethod) other;\\n\t\treturn getMethod().getCode().getCodeString().equals(o.getMethod().get"
  },
  {
    "method_id": "M784",
    "name": "isDefaultConstructor",
    "return_type": "boolean",
    "signature": "isDefaultConstructor()",
    "file_id": "F19",
    "start_line": 699,
    "text_preview": "uld tell us.\\n\t *\\n\t * @return true if this BcelMethod represents the default constructor\\n\t */\\n\t@Override\\n\tpublic boolean isDefaultConstructor() {\\n\t\tboolean mightBe = !hasDeclarationLineNumberInfo() && name.equals(\"<init>\") && parameterTypes.length == 0;\\n\t\tif (mightBe) {\\n\t\t\t// TODO would be nice to do a check to see if t"
  },
  {
    "method_id": "M785",
    "name": "if",
    "return_type": "",
    "signature": "if(mightBe)",
    "file_id": "F19",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M786",
    "name": "BcelObjectType",
    "return_type": "",
    "signature": "BcelObjectType(ReferenceType resolvedTypeX, JavaClass javaClass, boolean artificial, boolean exposedToWeaver)",
    "file_id": "F20",
    "start_line": 141,
    "text_preview": "r an annotation is added - ideally BcelObjectType should be immutable but\\n\t * that's a bigger piece of work. XXX\\n\t */\\n\\n\tBcelObjectType(ReferenceType resolvedTypeX, JavaClass javaClass, boolean artificial, boolean exposedToWeaver) {\\n\t\tsuper(resolvedTypeX, exposedToWeaver);\\n\t\tthis.javaClass = javaClass;\\n\t\tthis.artificial"
  },
  {
    "method_id": "M787",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceContext == SourceContextImpl.UNKNOWN_SOURCE_CONTEXT)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M788",
    "name": "setJavaClass",
    "return_type": "void",
    "signature": "setJavaClass(JavaClass newclass, boolean artificial)",
    "file_id": "F20",
    "start_line": 179,
    "text_preview": "ceFileName + \")\");\\n\t\t*/\\n\\n\t\tsetSourcefilename(javaClass.getSourceFileName());\\n\t}\\n\\n\t// repeat initialization\\n\tpublic void setJavaClass(JavaClass newclass, boolean artificial) {\\n\t\tthis.javaClass = newclass;\\n\t\tthis.artificial = artificial;\\n\t\tresetState();\\n\t\tinitializeFromJavaclass();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isCachea"
  },
  {
    "method_id": "M789",
    "name": "isCacheable",
    "return_type": "boolean",
    "signature": "isCacheable()",
    "file_id": "F20",
    "start_line": 187,
    "text_preview": "= newclass;\\n\t\tthis.artificial = artificial;\\n\t\tresetState();\\n\t\tinitializeFromJavaclass();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isCacheable() {\\n\t\treturn true;\\n\t}\\n\\n\tprivate void initializeFromJavaclass() {\\n\t\tisInterface = javaClass.isInterface();\\n\t\tisEnum = javaClass.isEnum();\\n\t\tisAnnotation = javaClass.isAnnotation();\\n\t\tisAnon"
  },
  {
    "method_id": "M790",
    "name": "initializeFromJavaclass",
    "return_type": "void",
    "signature": "initializeFromJavaclass()",
    "file_id": "F20",
    "start_line": 145,
    "text_preview": "sedToWeaver) {\\n\t\tsuper(resolvedTypeX, exposedToWeaver);\\n\t\tthis.javaClass = javaClass;\\n\t\tthis.artificial = artificial;\\n\t\tinitializeFromJavaclass();\\n\\n\t\t// ATAJ: set the delegate right now for @AJ pointcut, else it is done\\n\t\t// too late to lookup\\n\t\t// @AJ pc refs annotation in class hierarchy\\n\t\tresolvedTypeX.setDelegate(t"
  },
  {
    "method_id": "M791",
    "name": "isInterface",
    "return_type": "boolean",
    "signature": "isInterface()",
    "file_id": "F20",
    "start_line": 192,
    "text_preview": "\\n\tpublic boolean isCacheable() {\\n\t\treturn true;\\n\t}\\n\\n\tprivate void initializeFromJavaclass() {\\n\t\tisInterface = javaClass.isInterface();\\n\t\tisEnum = javaClass.isEnum();\\n\t\tisAnnotation = javaClass.isAnnotation();\\n\t\tisAnonymous = javaClass.isAnonymous();\\n\t\tisNested = javaClass.isNested();\\n\t\tmodifiers = javaClass.getModifier"
  },
  {
    "method_id": "M792",
    "name": "isEnum",
    "return_type": "boolean",
    "signature": "isEnum()",
    "file_id": "F20",
    "start_line": 193,
    "text_preview": "eturn true;\\n\t}\\n\\n\tprivate void initializeFromJavaclass() {\\n\t\tisInterface = javaClass.isInterface();\\n\t\tisEnum = javaClass.isEnum();\\n\t\tisAnnotation = javaClass.isAnnotation();\\n\t\tisAnonymous = javaClass.isAnonymous();\\n\t\tisNested = javaClass.isNested();\\n\t\tmodifiers = javaClass.getModifiers();\\n\t\tsuperclassName = javaClass.ge"
  },
  {
    "method_id": "M793",
    "name": "isAnnotation",
    "return_type": "boolean",
    "signature": "isAnnotation()",
    "file_id": "F20",
    "start_line": 194,
    "text_preview": "izeFromJavaclass() {\\n\t\tisInterface = javaClass.isInterface();\\n\t\tisEnum = javaClass.isEnum();\\n\t\tisAnnotation = javaClass.isAnnotation();\\n\t\tisAnonymous = javaClass.isAnonymous();\\n\t\tisNested = javaClass.isNested();\\n\t\tmodifiers = javaClass.getModifiers();\\n\t\tsuperclassName = javaClass.getSuperclassName();\\n\t\tclassName = java"
  },
  {
    "method_id": "M794",
    "name": "isAnonymous",
    "return_type": "boolean",
    "signature": "isAnonymous()",
    "file_id": "F20",
    "start_line": 195,
    "text_preview": "lass.isInterface();\\n\t\tisEnum = javaClass.isEnum();\\n\t\tisAnnotation = javaClass.isAnnotation();\\n\t\tisAnonymous = javaClass.isAnonymous();\\n\t\tisNested = javaClass.isNested();\\n\t\tmodifiers = javaClass.getModifiers();\\n\t\tsuperclassName = javaClass.getSuperclassName();\\n\t\tclassName = javaClass.getClassName();\\n\t\tcachedGenericClass"
  },
  {
    "method_id": "M795",
    "name": "isNested",
    "return_type": "boolean",
    "signature": "isNested()",
    "file_id": "F20",
    "start_line": 196,
    "text_preview": "ss.isEnum();\\n\t\tisAnnotation = javaClass.isAnnotation();\\n\t\tisAnonymous = javaClass.isAnonymous();\\n\t\tisNested = javaClass.isNested();\\n\t\tmodifiers = javaClass.getModifiers();\\n\t\tsuperclassName = javaClass.getSuperclassName();\\n\t\tclassName = javaClass.getClassName();\\n\t\tcachedGenericClassTypeSignature = null;\\n\t}\\n\\n\t// --- gett"
  },
  {
    "method_id": "M796",
    "name": "getModifiers",
    "return_type": "int",
    "signature": "getModifiers()",
    "file_id": "F20",
    "start_line": 197,
    "text_preview": "ass.isAnnotation();\\n\t\tisAnonymous = javaClass.isAnonymous();\\n\t\tisNested = javaClass.isNested();\\n\t\tmodifiers = javaClass.getModifiers();\\n\t\tsuperclassName = javaClass.getSuperclassName();\\n\t\tclassName = javaClass.getClassName();\\n\t\tcachedGenericClassTypeSignature = null;\\n\t}\\n\\n\t// --- getters\\n\\n\t// Java related\\n\tpublic boolea"
  },
  {
    "method_id": "M797",
    "name": "getSuperclass",
    "return_type": "ResolvedType",
    "signature": "getSuperclass()",
    "file_id": "F20",
    "start_line": 233,
    "text_preview": "nt getModifiers() {\\n\t\treturn modifiers;\\n\t}\\n\\n\t/**\\n\t * Must take into account generic signature\\n\t */\\n\tpublic ResolvedType getSuperclass() {\\n\t\tif (isObject) {\\n\t\t\treturn null;\\n\t\t}\\n\t\tResolvedType supertype = superTypeReference.get();\\n\t\tif (supertype == null) {\\n\t\t\tensureGenericSignatureUnpacked();\\n\t\t\tif (superclassSignature "
  },
  {
    "method_id": "M798",
    "name": "if",
    "return_type": "",
    "signature": "if(isObject)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M799",
    "name": "if",
    "return_type": "",
    "signature": "if(supertype == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M800",
    "name": "if",
    "return_type": "",
    "signature": "if(superclassSignature == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M801",
    "name": "if",
    "return_type": "",
    "signature": "if(superclassName == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M802",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F20",
    "start_line": 244,
    "text_preview": "Name == null) {\\n\t\t\t\t\tsuperclassName = javaClass.getSuperclassName();\\n\t\t\t\t}\\n\t\t\t\tsuperclassSignature = getResolvedTypeX().getWorld().resolve(UnresolvedType.forName(superclassName)).getSignature();\\n\t\t\t}\\n\t\t\tWorld world = getResolvedTypeX().getWorld();\\n\t\t\tsupertype = world.resolve(UnresolvedType.forSignature(superclassSigna"
  },
  {
    "method_id": "M803",
    "name": "getDeclaredInterfaces",
    "return_type": "ResolvedType[]",
    "signature": "getDeclaredInterfaces()",
    "file_id": "F20",
    "start_line": 261,
    "text_preview": "the types - this gets around the results of erasure when the class was originally compiled.\\n\t */\\n\tpublic ResolvedType[] getDeclaredInterfaces() {\\n\\n\t\tResolvedType[] cachedInterfaceTypes = superInterfaceReferences.get();\\n\t\tif (cachedInterfaceTypes == null) {\\n\t\t\tensureGenericSignatureUnpacked();\\n\t\t\tResolvedType[] interfac"
  },
  {
    "method_id": "M804",
    "name": "if",
    "return_type": "",
    "signature": "if(cachedInterfaceTypes == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M805",
    "name": "if",
    "return_type": "",
    "signature": "if(interfaceSignatures == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M806",
    "name": "if",
    "return_type": "",
    "signature": "if(names.length == 0)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M807",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = names.length; i < len; i++)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M808",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = interfaceSignatures.length; i < len; i++)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M809",
    "name": "getDeclaredMethods",
    "return_type": "ResolvedMember[]",
    "signature": "getDeclaredMethods()",
    "file_id": "F20",
    "start_line": 293,
    "text_preview": "(interfaceTypes);\\n\t\t\treturn interfaceTypes;\\n\t\t} else {\\n\t\t\treturn cachedInterfaceTypes;\\n\t\t}\\n\t}\\n\\n\tpublic ResolvedMember[] getDeclaredMethods() {\\n\t\tensureGenericSignatureUnpacked();\\n\t\tif (methods == null) {\\n\t\t\tMethod[] ms = javaClass.getMethods();\\n\t\t\tResolvedMember[] newMethods = new ResolvedMember[ms.length];\\n\t\t\tfor (int"
  },
  {
    "method_id": "M810",
    "name": "if",
    "return_type": "",
    "signature": "if(methods == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M811",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = ms.length - 1; i >= 0; i--)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M812",
    "name": "getDeclaredFields",
    "return_type": "ResolvedMember[]",
    "signature": "getDeclaredFields()",
    "file_id": "F20",
    "start_line": 306,
    "text_preview": "hods[i] = new BcelMethod(this, ms[i]);\\n\t\t\t}\\n\t\t\tmethods = newMethods;\\n\t\t}\\n\t\treturn methods;\\n\t}\\n\\n\tpublic ResolvedMember[] getDeclaredFields() {\\n\t\tensureGenericSignatureUnpacked();\\n\t\tif (fields == null) {\\n\t\t\tField[] fs = javaClass.getFields();\\n\t\t\tResolvedMember[] newfields = new ResolvedMember[fs.length];\\n\t\t\tfor (int i = "
  },
  {
    "method_id": "M813",
    "name": "if",
    "return_type": "",
    "signature": "if(fields == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M814",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = fs.length; i < len; i++)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M815",
    "name": "getTypeVariables",
    "return_type": "TypeVariable[]",
    "signature": "getTypeVariables()",
    "file_id": "F20",
    "start_line": 319,
    "text_preview": "\tnewfields[i] = new BcelField(this, fs[i]);\\n\t\t\t}\\n\t\t\tfields = newfields;\\n\t\t}\\n\t\treturn fields;\\n\t}\\n\\n\tpublic TypeVariable[] getTypeVariables() {\\n\t\tif (!isGeneric()) {\\n\t\t\treturn TypeVariable.NONE;\\n\t\t}\\n\\n\t\tif (typeVars == null) {\\n\t\t\tGenericSignature.ClassSignature classSig = getGenericClassTypeSignature();\\n\t\t\ttypeVars = new T"
  },
  {
    "method_id": "M816",
    "name": "if",
    "return_type": "",
    "signature": "if(typeVars == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M817",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < typeVars.length; i++)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M818",
    "name": "catch",
    "return_type": "",
    "signature": "catch(GenericSignatureFormatException e)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M819",
    "name": "getTypeMungers",
    "return_type": "Collection<ConcreteTypeMunger>",
    "signature": "getTypeMungers()",
    "file_id": "F20",
    "start_line": 343,
    "text_preview": " was detected: \"\\n\t\t\t\t\t\t\t+ e.getMessage());\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\treturn typeVars;\\n\t}\\n\\n\tpublic Collection<ConcreteTypeMunger> getTypeMungers() {\\n\t\treturn typeMungers;\\n\t}\\n\\n\tpublic Collection<Declare> getDeclares() {\\n\t\treturn declares;\\n\t}\\n\\n\tpublic Collection<ResolvedMember> getPrivilegedAccesses() {\\n\t\tif (privilegedAccess == n"
  },
  {
    "method_id": "M820",
    "name": "getDeclares",
    "return_type": "Collection<Declare>",
    "signature": "getDeclares()",
    "file_id": "F20",
    "start_line": 347,
    "text_preview": "rs;\\n\t}\\n\\n\tpublic Collection<ConcreteTypeMunger> getTypeMungers() {\\n\t\treturn typeMungers;\\n\t}\\n\\n\tpublic Collection<Declare> getDeclares() {\\n\t\treturn declares;\\n\t}\\n\\n\tpublic Collection<ResolvedMember> getPrivilegedAccesses() {\\n\t\tif (privilegedAccess == null) {\\n\t\t\treturn Collections.emptyList();\\n\t\t}\\n\t\treturn Arrays.asList(priv"
  },
  {
    "method_id": "M821",
    "name": "getPrivilegedAccesses",
    "return_type": "Collection<ResolvedMember>",
    "signature": "getPrivilegedAccesses()",
    "file_id": "F20",
    "start_line": 351,
    "text_preview": " typeMungers;\\n\t}\\n\\n\tpublic Collection<Declare> getDeclares() {\\n\t\treturn declares;\\n\t}\\n\\n\tpublic Collection<ResolvedMember> getPrivilegedAccesses() {\\n\t\tif (privilegedAccess == null) {\\n\t\t\treturn Collections.emptyList();\\n\t\t}\\n\t\treturn Arrays.asList(privilegedAccess);\\n\t}\\n\\n\tpublic ResolvedMember[] getDeclaredPointcuts() {\\n\t\tret"
  },
  {
    "method_id": "M822",
    "name": "if",
    "return_type": "",
    "signature": "if(privilegedAccess == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M823",
    "name": "getDeclaredPointcuts",
    "return_type": "ResolvedMember[]",
    "signature": "getDeclaredPointcuts()",
    "file_id": "F20",
    "start_line": 358,
    "text_preview": "= null) {\\n\t\t\treturn Collections.emptyList();\\n\t\t}\\n\t\treturn Arrays.asList(privilegedAccess);\\n\t}\\n\\n\tpublic ResolvedMember[] getDeclaredPointcuts() {\\n\t\treturn pointcuts;\\n\t}\\n\\n\tpublic boolean isAspect() {\\n\t\treturn perClause != null;\\n\t}\\n\\n\t/**\\n\t * Check if the type is an @AJ aspect (no matter if used from an LTW point of view)."
  },
  {
    "method_id": "M824",
    "name": "isAspect",
    "return_type": "boolean",
    "signature": "isAspect()",
    "file_id": "F20",
    "start_line": 362,
    "text_preview": "asList(privilegedAccess);\\n\t}\\n\\n\tpublic ResolvedMember[] getDeclaredPointcuts() {\\n\t\treturn pointcuts;\\n\t}\\n\\n\tpublic boolean isAspect() {\\n\t\treturn perClause != null;\\n\t}\\n\\n\t/**\\n\t * Check if the type is an @AJ aspect (no matter if used from an LTW point of view). Such aspects are annotated with @Aspect\\n\t *\\n\t * @return true for"
  },
  {
    "method_id": "M825",
    "name": "isAnnotationStyleAspect",
    "return_type": "boolean",
    "signature": "isAnnotationStyleAspect()",
    "file_id": "F20",
    "start_line": 371,
    "text_preview": "an LTW point of view). Such aspects are annotated with @Aspect\\n\t *\\n\t * @return true for @AJ aspect\\n\t */\\n\tpublic boolean isAnnotationStyleAspect() {\\n\t\tif ((bitflag & DISCOVERED_WHETHER_ANNOTATION_STYLE) == 0) {\\n\t\t\tbitflag |= DISCOVERED_WHETHER_ANNOTATION_STYLE;\\n\t\t\tisAnnotationStyleAspect = !isCodeStyleAspect && hasAnnot"
  },
  {
    "method_id": "M826",
    "name": "ensureAspectJAttributesUnpacked",
    "return_type": "void",
    "signature": "ensureAspectJAttributesUnpacked()",
    "file_id": "F20",
    "start_line": 161,
    "text_preview": "which is\\n\t\t// the only class in Java-1.4 with no superclasses\\n\t\tisObject = (javaClass.getSuperclassNameIndex() == 0);\\n\t\tensureAspectJAttributesUnpacked();\\n\\n\t\t// Experimental code leading to undesired ripple effects elsewhere, requiring more rework\\n\t\t/*\\n\t\tfinal String fileName = javaClass.getFileName();\\n\t\tfinal String s"
  },
  {
    "method_id": "M827",
    "name": "catch",
    "return_type": "",
    "signature": "catch(RuntimeException re)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M828",
    "name": "if",
    "return_type": "",
    "signature": "if(deferredAspectAttribute != null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M829",
    "name": "processAttributes",
    "return_type": "Aspect",
    "signature": "processAttributes(List<AjAttribute> attributeList, List<ResolvedPointcutDefinition> pointcuts,\n\t\t\tboolean fromAnnotations)",
    "file_id": "F20",
    "start_line": 400,
    "text_preview": "PointcutDefinition> pointcuts = new ArrayList<>();\\n\t\ttypeMungers = new ArrayList<>();\\n\t\tdeclares = new ArrayList<>();\\n\t\tprocessAttributes(l, pointcuts, false);\\n\t\tReferenceType type = getResolvedTypeX();\\n\t\tAsmManager asmManager = ((BcelWorld) type.getWorld()).getModelAsAsmManager();\\n\t\tl = AtAjAttributes.readAj5ClassAttr"
  },
  {
    "method_id": "M830",
    "name": "for",
    "return_type": "",
    "signature": "for(AjAttribute a : attributeList)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M831",
    "name": "if",
    "return_type": "",
    "signature": "if(a instanceof AjAttribute.Aspect)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M832",
    "name": "if",
    "return_type": "",
    "signature": "if(fromAnnotations)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M833",
    "name": "if",
    "return_type": "else",
    "signature": "if(a instanceof AjAttribute.PointcutDeclarationAttribute)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M834",
    "name": "if",
    "return_type": "else",
    "signature": "if(a instanceof AjAttribute.WeaverState)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M835",
    "name": "if",
    "return_type": "else",
    "signature": "if(a instanceof AjAttribute.TypeMunger)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M836",
    "name": "if",
    "return_type": "else",
    "signature": "if(a instanceof AjAttribute.DeclareAttribute)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M837",
    "name": "if",
    "return_type": "else",
    "signature": "if(a instanceof AjAttribute.PrivilegedAttribute)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M838",
    "name": "if",
    "return_type": "else",
    "signature": "if(a instanceof AjAttribute.SourceContextAttribute)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M839",
    "name": "if",
    "return_type": "else",
    "signature": "if(a instanceof AjAttribute.WeaverVersionInfo)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M840",
    "name": "resolveAnnotationDeclares",
    "return_type": "void",
    "signature": "resolveAnnotationDeclares(List<AjAttribute> attributeList)",
    "file_id": "F20",
    "start_line": 413,
    "text_preview": "inition.NO_POINTCUTS;\\n\t\t} else {\\n\t\t\tthis.pointcuts = pointcuts.toArray(ResolvedPointcutDefinition.NO_POINTCUTS);\\n\t\t}\\n\\n\t\tresolveAnnotationDeclares(l);\\n\\n\t\tif (deferredAspectAttribute != null) {\\n\t\t\t// we can finally process the aspect and its associated perclause...\\n\t\t\tperClause = deferredAspectAttribute.reifyFromAtAspect"
  },
  {
    "method_id": "M841",
    "name": "for",
    "return_type": "",
    "signature": "for(AjAttribute a : attributeList)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M842",
    "name": "if",
    "return_type": "",
    "signature": "if(a instanceof AjAttribute.DeclareAttribute)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M843",
    "name": "if",
    "return_type": "",
    "signature": "if(decl instanceof DeclareErrorOrWarning)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M844",
    "name": "if",
    "return_type": "else",
    "signature": "if(decl instanceof DeclarePrecedence)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M845",
    "name": "getPerClause",
    "return_type": "PerClause",
    "signature": "getPerClause()",
    "file_id": "F20",
    "start_line": 485,
    "text_preview": "Precedence) {\\n\t\t\t\t\t((DeclarePrecedence) decl).setScopeForResolution(bindingScope);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic PerClause getPerClause() {\\n\t\tensureAspectJAttributesUnpacked();\\n\t\treturn perClause;\\n\t}\\n\\n\tpublic JavaClass getJavaClass() {\\n\t\treturn javaClass;\\n\t}\\n\\n\t/**\\n\t * @return true if built from bytes obtained from somewhe"
  },
  {
    "method_id": "M846",
    "name": "getJavaClass",
    "return_type": "JavaClass",
    "signature": "getJavaClass()",
    "file_id": "F20",
    "start_line": 490,
    "text_preview": "}\\n\t}\\n\\n\tpublic PerClause getPerClause() {\\n\t\tensureAspectJAttributesUnpacked();\\n\t\treturn perClause;\\n\t}\\n\\n\tpublic JavaClass getJavaClass() {\\n\t\treturn javaClass;\\n\t}\\n\\n\t/**\\n\t * @return true if built from bytes obtained from somewhere. False if built from bytes retrieved from disk.\\n\t */\\n\tpublic boolean isArtificial() {\\n\t\tretur"
  },
  {
    "method_id": "M847",
    "name": "isArtificial",
    "return_type": "boolean",
    "signature": "isArtificial()",
    "file_id": "F20",
    "start_line": 497,
    "text_preview": "n true if built from bytes obtained from somewhere. False if built from bytes retrieved from disk.\\n\t */\\n\tpublic boolean isArtificial() {\\n\t\treturn artificial;\\n\t}\\n\\n\tpublic void resetState() {\\n\t\tif (javaClass == null) {\\n\t\t\t// we might store the classname and allow reloading?\\n\t\t\t// At this point we are relying on the world"
  },
  {
    "method_id": "M848",
    "name": "resetState",
    "return_type": "void",
    "signature": "resetState()",
    "file_id": "F20",
    "start_line": 182,
    "text_preview": "d setJavaClass(JavaClass newclass, boolean artificial) {\\n\t\tthis.javaClass = newclass;\\n\t\tthis.artificial = artificial;\\n\t\tresetState();\\n\t\tinitializeFromJavaclass();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isCacheable() {\\n\t\treturn true;\\n\t}\\n\\n\tprivate void initializeFromJavaclass() {\\n\t\tisInterface = javaClass.isInterface();\\n\t\tisEnum"
  },
  {
    "method_id": "M849",
    "name": "if",
    "return_type": "",
    "signature": "if(javaClass == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M850",
    "name": "finishedWith",
    "return_type": "void",
    "signature": "finishedWith()",
    "file_id": "F20",
    "start_line": 529,
    "text_preview": "etSuperclassNameIndex() == 0);\\n\t\tisAnnotationStyleAspect = false;\\n\t\tensureAspectJAttributesUnpacked();\\n\t}\\n\\n\tpublic void finishedWith() {\\n\t\t// memory usage experiments....\\n\t\t// this.interfaces = null;\\n\t\t// this.superClass = null;\\n\t\t// this.fields = null;\\n\t\t// this.methods = null;\\n\t\t// this.pointcuts = null;\\n\t\t// this.pe"
  },
  {
    "method_id": "M851",
    "name": "getWeaverState",
    "return_type": "WeaverStateInfo",
    "signature": "getWeaverState()",
    "file_id": "F20",
    "start_line": 545,
    "text_preview": "\t// implications\\n\t\t// before leaving it in.\\n\t\t// getResolvedTypeX().setSourceContext(null);\\n\t}\\n\\n\tpublic WeaverStateInfo getWeaverState() {\\n\t\treturn weaverState;\\n\t}\\n\\n\tvoid setWeaverState(WeaverStateInfo weaverState) {\\n\t\tthis.weaverState = weaverState;\\n\t}\\n\\n\tpublic void printWackyStuff(PrintStream out) {\\n\t\tif (typeMungers"
  },
  {
    "method_id": "M852",
    "name": "setWeaverState",
    "return_type": "void",
    "signature": "setWeaverState(WeaverStateInfo weaverState)",
    "file_id": "F20",
    "start_line": 549,
    "text_preview": "tResolvedTypeX().setSourceContext(null);\\n\t}\\n\\n\tpublic WeaverStateInfo getWeaverState() {\\n\t\treturn weaverState;\\n\t}\\n\\n\tvoid setWeaverState(WeaverStateInfo weaverState) {\\n\t\tthis.weaverState = weaverState;\\n\t}\\n\\n\tpublic void printWackyStuff(PrintStream out) {\\n\t\tif (typeMungers.size() > 0) {\\n\t\t\tout.println(\"  TypeMungers: \" + t"
  },
  {
    "method_id": "M853",
    "name": "printWackyStuff",
    "return_type": "void",
    "signature": "printWackyStuff(PrintStream out)",
    "file_id": "F20",
    "start_line": 553,
    "text_preview": "weaverState;\\n\t}\\n\\n\tvoid setWeaverState(WeaverStateInfo weaverState) {\\n\t\tthis.weaverState = weaverState;\\n\t}\\n\\n\tpublic void printWackyStuff(PrintStream out) {\\n\t\tif (typeMungers.size() > 0) {\\n\t\t\tout.println(\"  TypeMungers: \" + typeMungers);\\n\t\t}\\n\t\tif (declares.size() > 0) {\\n\t\t\tout.println(\"     declares: \" + declares);\\n\t\t}\\n\t"
  },
  {
    "method_id": "M854",
    "name": "getLazyClassGen",
    "return_type": "LazyClassGen",
    "signature": "getLazyClassGen()",
    "file_id": "F20",
    "start_line": 566,
    "text_preview": "ed to inline\\n\t * advice. For non-aspect types, this lazyClassGen is always newly constructed.\\n\t */\\n\tpublic LazyClassGen getLazyClassGen() {\\n\t\tLazyClassGen ret = lazyClassGen;\\n\t\tif (ret == null) {\\n\t\t\t// System.err.println(\"creating lazy class gen for: \" + this);\\n\t\t\tret = new LazyClassGen(this);\\n\t\t\t// ret.print(System.er"
  },
  {
    "method_id": "M855",
    "name": "if",
    "return_type": "",
    "signature": "if(ret == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M856",
    "name": "isSynthetic",
    "return_type": "boolean",
    "signature": "isSynthetic()",
    "file_id": "F20",
    "start_line": 581,
    "text_preview": "avaClass().getSuperclassName );\\n\t\t\tif (isAspect()) {\\n\t\t\t\tlazyClassGen = ret;\\n\t\t\t}\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic boolean isSynthetic() {\\n\t\treturn getResolvedTypeX().isSynthetic();\\n\t}\\n\\n\tpublic AjAttribute.WeaverVersionInfo getWeaverVersionAttribute() {\\n\t\treturn wvInfo;\\n\t}\\n\\n\t// -- annotation related\\n\\n\tpublic ResolvedType["
  },
  {
    "method_id": "M857",
    "name": "getWeaverVersionAttribute",
    "return_type": "WeaverVersionInfo",
    "signature": "getWeaverVersionAttribute()",
    "file_id": "F20",
    "start_line": 585,
    "text_preview": "}\\n\\n\tpublic boolean isSynthetic() {\\n\t\treturn getResolvedTypeX().isSynthetic();\\n\t}\\n\\n\tpublic AjAttribute.WeaverVersionInfo getWeaverVersionAttribute() {\\n\t\treturn wvInfo;\\n\t}\\n\\n\t// -- annotation related\\n\\n\tpublic ResolvedType[] getAnnotationTypes() {\\n\t\tensureAnnotationsUnpacked();\\n\t\treturn annotationTypes;\\n\t}\\n\\n\tpublic Annotat"
  },
  {
    "method_id": "M858",
    "name": "getAnnotationTypes",
    "return_type": "ResolvedType[]",
    "signature": "getAnnotationTypes()",
    "file_id": "F20",
    "start_line": 591,
    "text_preview": ".WeaverVersionInfo getWeaverVersionAttribute() {\\n\t\treturn wvInfo;\\n\t}\\n\\n\t// -- annotation related\\n\\n\tpublic ResolvedType[] getAnnotationTypes() {\\n\t\tensureAnnotationsUnpacked();\\n\t\treturn annotationTypes;\\n\t}\\n\\n\tpublic AnnotationAJ[] getAnnotations() {\\n\t\tensureAnnotationsUnpacked();\\n\t\treturn annotations;\\n\t}\\n\\n\tpublic boolean h"
  },
  {
    "method_id": "M859",
    "name": "getAnnotations",
    "return_type": "AnnotationAJ[]",
    "signature": "getAnnotations()",
    "file_id": "F20",
    "start_line": 596,
    "text_preview": "solvedType[] getAnnotationTypes() {\\n\t\tensureAnnotationsUnpacked();\\n\t\treturn annotationTypes;\\n\t}\\n\\n\tpublic AnnotationAJ[] getAnnotations() {\\n\t\tensureAnnotationsUnpacked();\\n\t\treturn annotations;\\n\t}\\n\\n\tpublic boolean hasAnnotations() {\\n\t\tensureAnnotationsUnpacked();\\n\t\treturn annotations.length != 0;\\n\t}\\n\\n\tpublic boolean hasA"
  },
  {
    "method_id": "M860",
    "name": "hasAnnotations",
    "return_type": "boolean",
    "signature": "hasAnnotations()",
    "file_id": "F20",
    "start_line": 601,
    "text_preview": "\\n\t}\\n\\n\tpublic AnnotationAJ[] getAnnotations() {\\n\t\tensureAnnotationsUnpacked();\\n\t\treturn annotations;\\n\t}\\n\\n\tpublic boolean hasAnnotations() {\\n\t\tensureAnnotationsUnpacked();\\n\t\treturn annotations.length != 0;\\n\t}\\n\\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\\n\t\t// Due to re-entrancy we may be in the middle of unpack"
  },
  {
    "method_id": "M861",
    "name": "hasAnnotation",
    "return_type": "boolean",
    "signature": "hasAnnotation(UnresolvedType ofType)",
    "file_id": "F20",
    "start_line": 374,
    "text_preview": "ON_STYLE) == 0) {\\n\t\t\tbitflag |= DISCOVERED_WHETHER_ANNOTATION_STYLE;\\n\t\t\tisAnnotationStyleAspect = !isCodeStyleAspect && hasAnnotation(AjcMemberMaker.ASPECT_ANNOTATION);\\n\t\t}\\n\t\treturn isAnnotationStyleAspect;\\n\t}\\n\\n\t/**\\n\t * Process any org.aspectj.weaver attributes stored against the class.\\n\t */\\n\tprivate void ensureAspectJ"
  },
  {
    "method_id": "M862",
    "name": "if",
    "return_type": "",
    "signature": "if(annos == null || annos.length == 0)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M863",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationGen annotation : annos)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M864",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, max = annotationTypes.length; i < max; i++)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M865",
    "name": "if",
    "return_type": "",
    "signature": "if(ax == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M866",
    "name": "isAnnotationWithRuntimeRetention",
    "return_type": "boolean",
    "signature": "isAnnotationWithRuntimeRetention()",
    "file_id": "F20",
    "start_line": 636,
    "text_preview": "etName() + \" is null!\");\\n\t\t\t}\\n\t\t\tif (ax.equals(ofType)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\tpublic boolean isAnnotationWithRuntimeRetention() {\\n\t\treturn (getRetentionPolicy() == null ? false : getRetentionPolicy().equals(\"RUNTIME\"));\\n\t}\\n\\n\tpublic String getRetentionPolicy() {\\n\t\tif ((bitflag & DISCOVERED_ANN"
  },
  {
    "method_id": "M867",
    "name": "getRetentionPolicy",
    "return_type": "String",
    "signature": "getRetentionPolicy()",
    "file_id": "F20",
    "start_line": 637,
    "text_preview": "ofType)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\tpublic boolean isAnnotationWithRuntimeRetention() {\\n\t\treturn (getRetentionPolicy() == null ? false : getRetentionPolicy().equals(\"RUNTIME\"));\\n\t}\\n\\n\tpublic String getRetentionPolicy() {\\n\t\tif ((bitflag & DISCOVERED_ANNOTATION_RETENTION_POLICY) == 0) {\\n\t\t\tbitflag |="
  },
  {
    "method_id": "M868",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = annotations.length - 1; i >= 0; i--)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M869",
    "name": "for",
    "return_type": "",
    "signature": "for(NameValuePair element : values)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M870",
    "name": "canAnnotationTargetType",
    "return_type": "boolean",
    "signature": "canAnnotationTargetType()",
    "file_id": "F20",
    "start_line": 662,
    "text_preview": "lueString();\\n\t\t\t\t\t\t\treturn retentionPolicy;\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\treturn retentionPolicy;\\n\t}\\n\\n\tpublic boolean canAnnotationTargetType() {\\n\t\tAnnotationTargetKind[] targetKinds = getAnnotationTargetKinds();\\n\t\tif (targetKinds == null) {\\n\t\t\treturn true;\\n\t\t}\\n\t\tfor (AnnotationTargetKind targetKind : targetKinds) {\\n"
  },
  {
    "method_id": "M871",
    "name": "if",
    "return_type": "",
    "signature": "if(targetKinds == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M872",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationTargetKind targetKind : targetKinds)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M873",
    "name": "getAnnotationTargetKinds",
    "return_type": "AnnotationTargetKind[]",
    "signature": "getAnnotationTargetKinds()",
    "file_id": "F20",
    "start_line": 663,
    "text_preview": "\t}\\n\t\t}\\n\t\treturn retentionPolicy;\\n\t}\\n\\n\tpublic boolean canAnnotationTargetType() {\\n\t\tAnnotationTargetKind[] targetKinds = getAnnotationTargetKinds();\\n\t\tif (targetKinds == null) {\\n\t\t\treturn true;\\n\t\t}\\n\t\tfor (AnnotationTargetKind targetKind : targetKinds) {\\n\t\t\tif (targetKind.equals(AnnotationTargetKind.TYPE)) {\\n\t\t\t\treturn t"
  },
  {
    "method_id": "M874",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ a : annotationsOnThisType)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M875",
    "name": "if",
    "return_type": "",
    "signature": "if(targets != null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M876",
    "name": "for",
    "return_type": "",
    "signature": "for(String targetKind : targets)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M877",
    "name": "isUnpackingAnnotations",
    "return_type": "boolean",
    "signature": "isUnpackingAnnotations()",
    "file_id": "F20",
    "start_line": 609,
    "text_preview": " unpacking the annotations already... in which case use this slow\\n\t\t// alternative until the stack unwinds itself\\n\t\tif (isUnpackingAnnotations()) {\\n\t\t\tAnnotationGen annos[] = javaClass.getAnnotations();\\n\t\t\tif (annos == null || annos.length == 0) {\\n\t\t\t\treturn false;\\n\t\t\t} else {\\n\t\t\t\tString lookingForSignature = ofType.ge"
  },
  {
    "method_id": "M878",
    "name": "ensureAnnotationsUnpacked",
    "return_type": "void",
    "signature": "ensureAnnotationsUnpacked()",
    "file_id": "F20",
    "start_line": 592,
    "text_preview": "verVersionAttribute() {\\n\t\treturn wvInfo;\\n\t}\\n\\n\t// -- annotation related\\n\\n\tpublic ResolvedType[] getAnnotationTypes() {\\n\t\tensureAnnotationsUnpacked();\\n\t\treturn annotationTypes;\\n\t}\\n\\n\tpublic AnnotationAJ[] getAnnotations() {\\n\t\tensureAnnotationsUnpacked();\\n\t\treturn annotations;\\n\t}\\n\\n\tpublic boolean hasAnnotations() {\\n\t\tensur"
  },
  {
    "method_id": "M879",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationTypes == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M880",
    "name": "if",
    "return_type": "",
    "signature": "if(annos == null || annos.length == 0)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M881",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < annos.length; i++)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M882",
    "name": "if",
    "return_type": "",
    "signature": "if(rType == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M883",
    "name": "getDeclaredGenericSignature",
    "return_type": "String",
    "signature": "getDeclaredGenericSignature()",
    "file_id": "F20",
    "start_line": 760,
    "text_preview": "rType);\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t} finally {\\n\t\t\t\tbitflag &= ~ANNOTATION_UNPACK_IN_PROGRESS;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t// ---\\n\\n\tpublic String getDeclaredGenericSignature() {\\n\t\tensureGenericInfoProcessed();\\n\t\treturn declaredSignature;\\n\t}\\n\\n\tprivate void ensureGenericSignatureUnpacked() {\\n\t\tif ((bitflag & UNPACKED_GENERIC_SIGNATURE) != 0) {\\n\t\t"
  },
  {
    "method_id": "M884",
    "name": "ensureGenericSignatureUnpacked",
    "return_type": "void",
    "signature": "ensureGenericSignatureUnpacked()",
    "file_id": "F20",
    "start_line": 239,
    "text_preview": "\tif (isObject) {\\n\t\t\treturn null;\\n\t\t}\\n\t\tResolvedType supertype = superTypeReference.get();\\n\t\tif (supertype == null) {\\n\t\t\tensureGenericSignatureUnpacked();\\n\t\t\tif (superclassSignature == null) {\\n\t\t\t\tif (superclassName == null) {\\n\t\t\t\t\tsuperclassName = javaClass.getSuperclassName();\\n\t\t\t\t}\\n\t\t\t\tsuperclassSignature = getResolv"
  },
  {
    "method_id": "M885",
    "name": "if",
    "return_type": "",
    "signature": "if(cSig != null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M886",
    "name": "if",
    "return_type": "",
    "signature": "if(extraFormals.length > 0)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M887",
    "name": "catch",
    "return_type": "",
    "signature": "catch(GenericSignatureFormatException e)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M888",
    "name": "if",
    "return_type": "",
    "signature": "if(cSig.superInterfaceSignatures.length == 0)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M889",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < cSig.superInterfaceSignatures.length; i++)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M890",
    "name": "catch",
    "return_type": "",
    "signature": "catch(GenericSignatureFormatException e)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M891",
    "name": "if",
    "return_type": "317139",
    "signature": "if(genericType != null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M892",
    "name": "getAllFormals",
    "return_type": "FormalTypeParameter[]",
    "signature": "getAllFormals()",
    "file_id": "F20",
    "start_line": 845,
    "text_preview": "TypeX.getStartPos());\\n\t\t\t\tthis.resolvedTypeX = genericType;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic GenericSignature.FormalTypeParameter[] getAllFormals() {\\n\t\tensureGenericSignatureUnpacked();\\n\t\tif (formalsForResolution == null) {\\n\t\t\treturn FormalTypeParameter.NONE;\\n\t\t} else {\\n\t\t\treturn formalsForResolution;\\n\t\t}\\n\t}\\n\\n\tpublic ResolvedType "
  },
  {
    "method_id": "M893",
    "name": "if",
    "return_type": "",
    "signature": "if(formalsForResolution == null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M894",
    "name": "getOuterClass",
    "return_type": "ResolvedType",
    "signature": "getOuterClass()",
    "file_id": "F20",
    "start_line": 854,
    "text_preview": " == null) {\\n\t\t\treturn FormalTypeParameter.NONE;\\n\t\t} else {\\n\t\t\treturn formalsForResolution;\\n\t\t}\\n\t}\\n\\n\tpublic ResolvedType getOuterClass() {\\n\t\tif (!isNested()) {\\n\t\t\tthrow new IllegalStateException(\"Can't get the outer class of non-nested type: \" + className);\\n\t\t}\\n\\n\t\t// try finding outer class name from InnerClasses attrib"
  },
  {
    "method_id": "M895",
    "name": "if",
    "return_type": "",
    "signature": "if(attr instanceof InnerClasses)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M896",
    "name": "for",
    "return_type": "",
    "signature": "for(InnerClass innerCls : innerClss)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M897",
    "name": "if",
    "return_type": "",
    "signature": "if(attr instanceof EnclosingMethod)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M898",
    "name": "if",
    "return_type": "",
    "signature": "if(lastDollar == -1)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M899",
    "name": "ensureGenericInfoProcessed",
    "return_type": "void",
    "signature": "ensureGenericInfoProcessed()",
    "file_id": "F20",
    "start_line": 761,
    "text_preview": "{\\n\t\t\t\tbitflag &= ~ANNOTATION_UNPACK_IN_PROGRESS;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t// ---\\n\\n\tpublic String getDeclaredGenericSignature() {\\n\t\tensureGenericInfoProcessed();\\n\t\treturn declaredSignature;\\n\t}\\n\\n\tprivate void ensureGenericSignatureUnpacked() {\\n\t\tif ((bitflag & UNPACKED_GENERIC_SIGNATURE) != 0) {\\n\t\t\treturn;\\n\t\t}\\n\t\tbitflag |= UNPACKED"
  },
  {
    "method_id": "M900",
    "name": "if",
    "return_type": "",
    "signature": "if(declaredSignature != null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M901",
    "name": "isGeneric",
    "return_type": "boolean",
    "signature": "isGeneric()",
    "file_id": "F20",
    "start_line": 320,
    "text_preview": "d(this, fs[i]);\\n\t\t\t}\\n\t\t\tfields = newfields;\\n\t\t}\\n\t\treturn fields;\\n\t}\\n\\n\tpublic TypeVariable[] getTypeVariables() {\\n\t\tif (!isGeneric()) {\\n\t\t\treturn TypeVariable.NONE;\\n\t\t}\\n\\n\t\tif (typeVars == null) {\\n\t\t\tGenericSignature.ClassSignature classSig = getGenericClassTypeSignature();\\n\t\t\ttypeVars = new TypeVariable[classSig.formalT"
  },
  {
    "method_id": "M902",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F20",
    "start_line": 334,
    "text_preview": "g, so fail fast with good info\\n\t\t\t\t\tthrow new IllegalStateException(\"While getting the type variables for type \" + this.toString()\\n\t\t\t\t\t\t\t+ \" with generic signature \" + classSig + \" the following error condition was detected: \"\\n\t\t\t\t\t\t\t+ e.getMessage());\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\treturn typeVars;\\n\t}\\n\\n\tpublic Collection<ConcreteT"
  },
  {
    "method_id": "M903",
    "name": "evictWeavingState",
    "return_type": "void",
    "signature": "evictWeavingState()",
    "file_id": "F20",
    "start_line": 941,
    "text_preview": "n (javaClass == null ? \"BcelObjectType\" : \"BcelObjectTypeFor:\" + className);\\n\t}\\n\\n\t// --- state management\\n\\n\tpublic void evictWeavingState() {\\n\t\t// Can't chuck all this away\\n\t\tif (getResolvedTypeX().getWorld().couldIncrementalCompileFollow()) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (javaClass != null) {\\n\t\t\t// Force retrieval of any lazy"
  },
  {
    "method_id": "M904",
    "name": "if",
    "return_type": "",
    "signature": "if(javaClass != null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M905",
    "name": "if",
    "return_type": "info",
    "signature": "if(weaverState != null)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M906",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = methods.length - 1; i >= 0; i--)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M907",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = fields.length - 1; i >= 0; i--)",
    "file_id": "F20",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M908",
    "name": "weavingCompleted",
    "return_type": "void",
    "signature": "weavingCompleted()",
    "file_id": "F20",
    "start_line": 987,
    "text_preview": "// interfaces=null; // force reinit - may get us the right\\n\t\t\t// instances!\\n\t\t\t// superClass=null;\\n\t\t}\\n\t}\\n\\n\tpublic void weavingCompleted() {\\n\t\thasBeenWoven = true;\\n\t\tif (getResolvedTypeX().getWorld().isRunMinimalMemory()) {\\n\t\t\tevictWeavingState();\\n\t\t}\\n\t\tif (getSourceContext() != null && !getResolvedTypeX().isAspect()) "
  },
  {
    "method_id": "M909",
    "name": "hasBeenWoven",
    "return_type": "boolean",
    "signature": "hasBeenWoven()",
    "file_id": "F20",
    "start_line": 997,
    "text_preview": " (getSourceContext() != null && !getResolvedTypeX().isAspect()) {\\n\t\t\tgetSourceContext().tidy();\\n\t\t}\\n\t}\\n\\n\tpublic boolean hasBeenWoven() {\\n\t\treturn hasBeenWoven;\\n\t}\\n\\n\t@Override\\n\tpublic boolean copySourceContext() {\\n\t\treturn false;\\n\t}\\n\\n\tpublic void setExposedToWeaver(boolean b) {\\n\t\texposedToWeaver = b;\\n\t}\\n\\n\t@Override\\n\tpub"
  },
  {
    "method_id": "M910",
    "name": "copySourceContext",
    "return_type": "boolean",
    "signature": "copySourceContext()",
    "file_id": "F20",
    "start_line": 1002,
    "text_preview": "tSourceContext().tidy();\\n\t\t}\\n\t}\\n\\n\tpublic boolean hasBeenWoven() {\\n\t\treturn hasBeenWoven;\\n\t}\\n\\n\t@Override\\n\tpublic boolean copySourceContext() {\\n\t\treturn false;\\n\t}\\n\\n\tpublic void setExposedToWeaver(boolean b) {\\n\t\texposedToWeaver = b;\\n\t}\\n\\n\t@Override\\n\tpublic int getCompilerVersion() {\\n\t\treturn wvInfo.getMajorVersion();\\n\t}\\n\\n\t"
  },
  {
    "method_id": "M911",
    "name": "setExposedToWeaver",
    "return_type": "void",
    "signature": "setExposedToWeaver(boolean b)",
    "file_id": "F20",
    "start_line": 1006,
    "text_preview": "nWoven() {\\n\t\treturn hasBeenWoven;\\n\t}\\n\\n\t@Override\\n\tpublic boolean copySourceContext() {\\n\t\treturn false;\\n\t}\\n\\n\tpublic void setExposedToWeaver(boolean b) {\\n\t\texposedToWeaver = b;\\n\t}\\n\\n\t@Override\\n\tpublic int getCompilerVersion() {\\n\t\treturn wvInfo.getMajorVersion();\\n\t}\\n\\n\tpublic void ensureConsistent() {\\n\t\tsuperTypeReference.c"
  },
  {
    "method_id": "M912",
    "name": "getCompilerVersion",
    "return_type": "int",
    "signature": "getCompilerVersion()",
    "file_id": "F20",
    "start_line": 1011,
    "text_preview": "() {\\n\t\treturn false;\\n\t}\\n\\n\tpublic void setExposedToWeaver(boolean b) {\\n\t\texposedToWeaver = b;\\n\t}\\n\\n\t@Override\\n\tpublic int getCompilerVersion() {\\n\t\treturn wvInfo.getMajorVersion();\\n\t}\\n\\n\tpublic void ensureConsistent() {\\n\t\tsuperTypeReference.clear();\\n\t\tsuperInterfaceReferences.clear();\\n\t}\\n\\n\tpublic boolean isWeavable() {\\n\t\tr"
  },
  {
    "method_id": "M913",
    "name": "ensureConsistent",
    "return_type": "void",
    "signature": "ensureConsistent()",
    "file_id": "F20",
    "start_line": 1015,
    "text_preview": "osedToWeaver = b;\\n\t}\\n\\n\t@Override\\n\tpublic int getCompilerVersion() {\\n\t\treturn wvInfo.getMajorVersion();\\n\t}\\n\\n\tpublic void ensureConsistent() {\\n\t\tsuperTypeReference.clear();\\n\t\tsuperInterfaceReferences.clear();\\n\t}\\n\\n\tpublic boolean isWeavable() {\\n\t\treturn true;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M914",
    "name": "isWeavable",
    "return_type": "boolean",
    "signature": "isWeavable()",
    "file_id": "F20",
    "start_line": 1020,
    "text_preview": "\tpublic void ensureConsistent() {\\n\t\tsuperTypeReference.clear();\\n\t\tsuperInterfaceReferences.clear();\\n\t}\\n\\n\tpublic boolean isWeavable() {\\n\t\treturn true;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M915",
    "name": "BcelPerClauseAspectAdder",
    "return_type": "",
    "signature": "BcelPerClauseAspectAdder(ResolvedType aspect, PerClause.Kind kind)",
    "file_id": "F21",
    "start_line": 46,
    "text_preview": "der extends BcelTypeMunger {\\n\\n\tprivate final PerClause.Kind kind;\\n\\n\tprivate boolean hasGeneratedInner = false;\\n\\n\tpublic BcelPerClauseAspectAdder(ResolvedType aspect, PerClause.Kind kind) {\\n\t\tsuper(null, aspect);\\n\t\tthis.kind = kind;\\n\t\tif (kind == PerClause.SINGLETON || kind == PerClause.PERTYPEWITHIN || kind == PerClaus"
  },
  {
    "method_id": "M916",
    "name": "if",
    "return_type": "",
    "signature": "if(kind == PerClause.SINGLETON || kind == PerClause.PERTYPEWITHIN || kind == PerClause.PERCFLOW)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M917",
    "name": "munge",
    "return_type": "boolean",
    "signature": "munge(BcelClassWeaver weaver)",
    "file_id": "F21",
    "start_line": 55,
    "text_preview": "RTYPEWITHIN || kind == PerClause.PERCFLOW) {\\n\t\t\t// no inner needed\\n\t\t\thasGeneratedInner = true;\\n\t\t}\\n\t}\\n\\n\tpublic boolean munge(BcelClassWeaver weaver) {\\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\\n\\n\t\tdoAggressiveInner(gen);\\n\\n\t\t// Only munge the aspect type\\n\t\tif (!gen.getType().equals(aspectType)) {\\n\t\t\treturn false;\\n\t"
  },
  {
    "method_id": "M918",
    "name": "forceMunge",
    "return_type": "boolean",
    "signature": "forceMunge(LazyClassGen gen, boolean checkAlreadyThere)",
    "file_id": "F21",
    "start_line": 68,
    "text_preview": " type\\n\t\tif (!gen.getType().equals(aspectType)) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\treturn doMunge(gen, true);\\n\t}\\n\\n\tpublic boolean forceMunge(LazyClassGen gen, boolean checkAlreadyThere) {\\n\t\tdoAggressiveInner(gen);\\n\t\treturn doMunge(gen, checkAlreadyThere);\\n\t}\\n\\n\tprivate void doAggressiveInner(LazyClassGen gen) {\\n\t\t// agressively g"
  },
  {
    "method_id": "M919",
    "name": "doAggressiveInner",
    "return_type": "void",
    "signature": "doAggressiveInner(LazyClassGen gen)",
    "file_id": "F21",
    "start_line": 58,
    "text_preview": "Inner = true;\\n\t\t}\\n\t}\\n\\n\tpublic boolean munge(BcelClassWeaver weaver) {\\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\\n\\n\t\tdoAggressiveInner(gen);\\n\\n\t\t// Only munge the aspect type\\n\t\tif (!gen.getType().equals(aspectType)) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\treturn doMunge(gen, true);\\n\t}\\n\\n\tpublic boolean forceMunge(LazyClassGen gen, "
  },
  {
    "method_id": "M920",
    "name": "if",
    "return_type": "",
    "signature": "if(!hasGeneratedInner)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M921",
    "name": "if",
    "return_type": "",
    "signature": "if(kind == PerClause.PEROBJECT)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M922",
    "name": "doMunge",
    "return_type": "boolean",
    "signature": "doMunge(LazyClassGen gen, boolean checkAlreadyThere)",
    "file_id": "F21",
    "start_line": 65,
    "text_preview": "eInner(gen);\\n\\n\t\t// Only munge the aspect type\\n\t\tif (!gen.getType().equals(aspectType)) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\treturn doMunge(gen, true);\\n\t}\\n\\n\tpublic boolean forceMunge(LazyClassGen gen, boolean checkAlreadyThere) {\\n\t\tdoAggressiveInner(gen);\\n\t\treturn doMunge(gen, checkAlreadyThere);\\n\t}\\n\\n\tprivate void doAggressiveInne"
  },
  {
    "method_id": "M923",
    "name": "if",
    "return_type": "",
    "signature": "if(kind == PerClause.SINGLETON)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M924",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == PerClause.PEROBJECT)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M925",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == PerClause.PERCFLOW)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M926",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == PerClause.PERTYPEWITHIN)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M927",
    "name": "getMatchingSyntheticMember",
    "return_type": "ResolvedMember",
    "signature": "getMatchingSyntheticMember(Member member)",
    "file_id": "F21",
    "start_line": 127,
    "text_preview": "\t\tthrow new Error(\"should not happen - not such kind \" + kind.getName());\\n\t\t}\\n\t\treturn true;\\n\t}\\n\\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\\n\t\treturn null;\\n\t}\\n\\n\tpublic ResolvedMember getSignature() {\\n\t\treturn null;\\n\t}\\n\\n\tpublic boolean matches(ResolvedType onType) {\\n\t\t// cannot always do the right"
  },
  {
    "method_id": "M928",
    "name": "getSignature",
    "return_type": "ResolvedMember",
    "signature": "getSignature()",
    "file_id": "F21",
    "start_line": 131,
    "text_preview": " true;\\n\t}\\n\\n\tpublic ResolvedMember getMatchingSyntheticMember(Member member) {\\n\t\treturn null;\\n\t}\\n\\n\tpublic ResolvedMember getSignature() {\\n\t\treturn null;\\n\t}\\n\\n\tpublic boolean matches(ResolvedType onType) {\\n\t\t// cannot always do the right thing because may need to eagerly generate ajcMightHaveAspect interface for LTW (says"
  },
  {
    "method_id": "M929",
    "name": "matches",
    "return_type": "boolean",
    "signature": "matches(ResolvedType onType)",
    "file_id": "F21",
    "start_line": 135,
    "text_preview": "icMember(Member member) {\\n\t\treturn null;\\n\t}\\n\\n\tpublic ResolvedMember getSignature() {\\n\t\treturn null;\\n\t}\\n\\n\tpublic boolean matches(ResolvedType onType) {\\n\t\t// cannot always do the right thing because may need to eagerly generate ajcMightHaveAspect interface for LTW (says Alex)\\n\t\tif (hasGeneratedInner) { // pr237419 - not "
  },
  {
    "method_id": "M930",
    "name": "if",
    "return_type": "",
    "signature": "if(hasGeneratedInner)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M931",
    "name": "hasPerClauseMembersAlready",
    "return_type": "boolean",
    "signature": "hasPerClauseMembersAlready(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 94,
    "text_preview": "nner = true;\\n\t\t}\\n\t}\\n\\n\tprivate boolean doMunge(LazyClassGen gen, boolean checkAlreadyThere) {\\n\t\tif (checkAlreadyThere && hasPerClauseMembersAlready(gen)) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tgeneratePerClauseMembers(gen);\\n\\n\t\tif (kind == PerClause.SINGLETON) {\\n\t\t\tgeneratePerSingletonAspectOfMethod(gen);\\n\t\t\tgeneratePerSingletonHasAs"
  },
  {
    "method_id": "M932",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen method: methodGens)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M933",
    "name": "generatePerClauseMembers",
    "return_type": "void",
    "signature": "generatePerClauseMembers(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 98,
    "text_preview": "gen, boolean checkAlreadyThere) {\\n\t\tif (checkAlreadyThere && hasPerClauseMembersAlready(gen)) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tgeneratePerClauseMembers(gen);\\n\\n\t\tif (kind == PerClause.SINGLETON) {\\n\t\t\tgeneratePerSingletonAspectOfMethod(gen);\\n\t\t\tgeneratePerSingletonHasAspectMethod(gen);\\n\t\t\tgeneratePerSingletonAjcClinitMethod(gen"
  },
  {
    "method_id": "M934",
    "name": "if",
    "return_type": "",
    "signature": "if(kind == PerClause.SINGLETON)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M935",
    "name": "if",
    "return_type": "",
    "signature": "if(kind == PerClause.SINGLETON)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M936",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == PerClause.PEROBJECT)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M937",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == PerClause.PERCFLOW)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M938",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == PerClause.PERTYPEWITHIN)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M939",
    "name": "generatePerSingletonAspectOfMethod",
    "return_type": "void",
    "signature": "generatePerSingletonAspectOfMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 101,
    "text_preview": "eMembersAlready(gen)) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tgeneratePerClauseMembers(gen);\\n\\n\t\tif (kind == PerClause.SINGLETON) {\\n\t\t\tgeneratePerSingletonAspectOfMethod(gen);\\n\t\t\tgeneratePerSingletonHasAspectMethod(gen);\\n\t\t\tgeneratePerSingletonAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PEROBJECT) {\\n\t\t\tgeneratePerObjectAspec"
  },
  {
    "method_id": "M940",
    "name": "generatePerSingletonHasAspectMethod",
    "return_type": "void",
    "signature": "generatePerSingletonHasAspectMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 102,
    "text_preview": "\\n\\n\t\tgeneratePerClauseMembers(gen);\\n\\n\t\tif (kind == PerClause.SINGLETON) {\\n\t\t\tgeneratePerSingletonAspectOfMethod(gen);\\n\t\t\tgeneratePerSingletonHasAspectMethod(gen);\\n\t\t\tgeneratePerSingletonAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PEROBJECT) {\\n\t\t\tgeneratePerObjectAspectOfMethod(gen);\\n\t\t\tgeneratePerObjectHasAspec"
  },
  {
    "method_id": "M941",
    "name": "generatePerSingletonAjcClinitMethod",
    "return_type": "void",
    "signature": "generatePerSingletonAjcClinitMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 103,
    "text_preview": "d == PerClause.SINGLETON) {\\n\t\t\tgeneratePerSingletonAspectOfMethod(gen);\\n\t\t\tgeneratePerSingletonHasAspectMethod(gen);\\n\t\t\tgeneratePerSingletonAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PEROBJECT) {\\n\t\t\tgeneratePerObjectAspectOfMethod(gen);\\n\t\t\tgeneratePerObjectHasAspectMethod(gen);\\n\t\t\tgeneratePerObjectBindMethod("
  },
  {
    "method_id": "M942",
    "name": "generatePerObjectAspectOfMethod",
    "return_type": "void",
    "signature": "generatePerObjectAspectOfMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 105,
    "text_preview": "gletonHasAspectMethod(gen);\\n\t\t\tgeneratePerSingletonAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PEROBJECT) {\\n\t\t\tgeneratePerObjectAspectOfMethod(gen);\\n\t\t\tgeneratePerObjectHasAspectMethod(gen);\\n\t\t\tgeneratePerObjectBindMethod(gen);\\n\t\t\t// these will be added by the PerObjectInterface munger that affects the type - "
  },
  {
    "method_id": "M943",
    "name": "generatePerObjectHasAspectMethod",
    "return_type": "void",
    "signature": "generatePerObjectHasAspectMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 106,
    "text_preview": "rSingletonAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PEROBJECT) {\\n\t\t\tgeneratePerObjectAspectOfMethod(gen);\\n\t\t\tgeneratePerObjectHasAspectMethod(gen);\\n\t\t\tgeneratePerObjectBindMethod(gen);\\n\t\t\t// these will be added by the PerObjectInterface munger that affects the type - pr144602\\n\t\t\t// generatePerObjectGetSetMet"
  },
  {
    "method_id": "M944",
    "name": "generatePerObjectBindMethod",
    "return_type": "void",
    "signature": "generatePerObjectBindMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 107,
    "text_preview": "f (kind == PerClause.PEROBJECT) {\\n\t\t\tgeneratePerObjectAspectOfMethod(gen);\\n\t\t\tgeneratePerObjectHasAspectMethod(gen);\\n\t\t\tgeneratePerObjectBindMethod(gen);\\n\t\t\t// these will be added by the PerObjectInterface munger that affects the type - pr144602\\n\t\t\t// generatePerObjectGetSetMethods(gen);\\n\t\t} else if (kind == PerClause."
  },
  {
    "method_id": "M945",
    "name": "generatePerObjectGetSetMethods",
    "return_type": "void",
    "signature": "generatePerObjectGetSetMethods(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 109,
    "text_preview": "bjectBindMethod(gen);\\n\t\t\t// these will be added by the PerObjectInterface munger that affects the type - pr144602\\n\t\t\t// generatePerObjectGetSetMethods(gen);\\n\t\t} else if (kind == PerClause.PERCFLOW) {\\n\t\t\tgeneratePerCflowAspectOfMethod(gen);\\n\t\t\tgeneratePerCflowHasAspectMethod(gen);\\n\t\t\tgeneratePerCflowPushMethod(gen);\\n\t\t\t"
  },
  {
    "method_id": "M946",
    "name": "generatePerCflowAspectOfMethod",
    "return_type": "void",
    "signature": "generatePerCflowAspectOfMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 111,
    "text_preview": "at affects the type - pr144602\\n\t\t\t// generatePerObjectGetSetMethods(gen);\\n\t\t} else if (kind == PerClause.PERCFLOW) {\\n\t\t\tgeneratePerCflowAspectOfMethod(gen);\\n\t\t\tgeneratePerCflowHasAspectMethod(gen);\\n\t\t\tgeneratePerCflowPushMethod(gen);\\n\t\t\tgeneratePerCflowAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PERTYPEWITHIN)"
  },
  {
    "method_id": "M947",
    "name": "generatePerCflowHasAspectMethod",
    "return_type": "void",
    "signature": "generatePerCflowHasAspectMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 112,
    "text_preview": "eratePerObjectGetSetMethods(gen);\\n\t\t} else if (kind == PerClause.PERCFLOW) {\\n\t\t\tgeneratePerCflowAspectOfMethod(gen);\\n\t\t\tgeneratePerCflowHasAspectMethod(gen);\\n\t\t\tgeneratePerCflowPushMethod(gen);\\n\t\t\tgeneratePerCflowAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PERTYPEWITHIN) {\\n\t\t\tgeneratePerTWAspectOfMethod(gen);\\n"
  },
  {
    "method_id": "M948",
    "name": "generatePerCflowPushMethod",
    "return_type": "void",
    "signature": "generatePerCflowPushMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 113,
    "text_preview": "e if (kind == PerClause.PERCFLOW) {\\n\t\t\tgeneratePerCflowAspectOfMethod(gen);\\n\t\t\tgeneratePerCflowHasAspectMethod(gen);\\n\t\t\tgeneratePerCflowPushMethod(gen);\\n\t\t\tgeneratePerCflowAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PERTYPEWITHIN) {\\n\t\t\tgeneratePerTWAspectOfMethod(gen);\\n\t\t\tgeneratePerTWHasAspectMethod(gen);\\n\t\t\t"
  },
  {
    "method_id": "M949",
    "name": "generatePerCflowAjcClinitMethod",
    "return_type": "void",
    "signature": "generatePerCflowAjcClinitMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 114,
    "text_preview": "\t\t\tgeneratePerCflowAspectOfMethod(gen);\\n\t\t\tgeneratePerCflowHasAspectMethod(gen);\\n\t\t\tgeneratePerCflowPushMethod(gen);\\n\t\t\tgeneratePerCflowAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PERTYPEWITHIN) {\\n\t\t\tgeneratePerTWAspectOfMethod(gen);\\n\t\t\tgeneratePerTWHasAspectMethod(gen);\\n\t\t\tgeneratePerTWGetInstanceMethod(gen);"
  },
  {
    "method_id": "M950",
    "name": "generatePerTWAspectOfMethod",
    "return_type": "void",
    "signature": "generatePerTWAspectOfMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 116,
    "text_preview": "atePerCflowPushMethod(gen);\\n\t\t\tgeneratePerCflowAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PERTYPEWITHIN) {\\n\t\t\tgeneratePerTWAspectOfMethod(gen);\\n\t\t\tgeneratePerTWHasAspectMethod(gen);\\n\t\t\tgeneratePerTWGetInstanceMethod(gen);\\n\t\t\tgeneratePerTWCreateAspectInstanceMethod(gen);\\n\t\t\tgeneratePerTWGetWithinTypeNameMethod"
  },
  {
    "method_id": "M951",
    "name": "getWithinTypeName",
    "return_type": "String",
    "signature": "getWithinTypeName()",
    "file_id": "F21",
    "start_line": 459,
    "text_preview": "dler(tryStart, handler.getPrev(), handler, new ObjectType(\"java.lang.Exception\"), false);\\n\t}\\n\\n\t// Create 'public String getWithinTypeName() { return ajc$withinType;}'\\n\tprivate void generatePerTWGetWithinTypeNameMethod(LazyClassGen classGen) {\\n\t\tInstructionFactory factory = classGen.getFactory();\\n\t\tLazyMethodGen method "
  },
  {
    "method_id": "M952",
    "name": "generatePerTWGetWithinTypeNameMethod",
    "return_type": "void",
    "signature": "generatePerTWGetWithinTypeNameMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 120,
    "text_preview": "ePerTWHasAspectMethod(gen);\\n\t\t\tgeneratePerTWGetInstanceMethod(gen);\\n\t\t\tgeneratePerTWCreateAspectInstanceMethod(gen);\\n\t\t\tgeneratePerTWGetWithinTypeNameMethod(gen);\\n\t\t} else {\\n\t\t\tthrow new Error(\"should not happen - not such kind \" + kind.getName());\\n\t\t}\\n\t\treturn true;\\n\t}\\n\\n\tpublic ResolvedMember getMatchingSyntheticMembe"
  },
  {
    "method_id": "M953",
    "name": "generatePerTWHasAspectMethod",
    "return_type": "void",
    "signature": "generatePerTWHasAspectMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 117,
    "text_preview": "tePerCflowAjcClinitMethod(gen);\\n\t\t} else if (kind == PerClause.PERTYPEWITHIN) {\\n\t\t\tgeneratePerTWAspectOfMethod(gen);\\n\t\t\tgeneratePerTWHasAspectMethod(gen);\\n\t\t\tgeneratePerTWGetInstanceMethod(gen);\\n\t\t\tgeneratePerTWCreateAspectInstanceMethod(gen);\\n\t\t\tgeneratePerTWGetWithinTypeNameMethod(gen);\\n\t\t} else {\\n\t\t\tthrow new Error("
  },
  {
    "method_id": "M954",
    "name": "generatePerTWGetInstanceMethod",
    "return_type": "void",
    "signature": "generatePerTWGetInstanceMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 118,
    "text_preview": "se if (kind == PerClause.PERTYPEWITHIN) {\\n\t\t\tgeneratePerTWAspectOfMethod(gen);\\n\t\t\tgeneratePerTWHasAspectMethod(gen);\\n\t\t\tgeneratePerTWGetInstanceMethod(gen);\\n\t\t\tgeneratePerTWCreateAspectInstanceMethod(gen);\\n\t\t\tgeneratePerTWGetWithinTypeNameMethod(gen);\\n\t\t} else {\\n\t\t\tthrow new Error(\"should not happen - not such kind \" +"
  },
  {
    "method_id": "M955",
    "name": "generatePerTWCreateAspectInstanceMethod",
    "return_type": "void",
    "signature": "generatePerTWCreateAspectInstanceMethod(LazyClassGen classGen)",
    "file_id": "F21",
    "start_line": 119,
    "text_preview": "{\\n\t\t\tgeneratePerTWAspectOfMethod(gen);\\n\t\t\tgeneratePerTWHasAspectMethod(gen);\\n\t\t\tgeneratePerTWGetInstanceMethod(gen);\\n\t\t\tgeneratePerTWCreateAspectInstanceMethod(gen);\\n\t\t\tgeneratePerTWGetWithinTypeNameMethod(gen);\\n\t\t} else {\\n\t\t\tthrow new Error(\"should not happen - not such kind \" + kind.getName());\\n\t\t}\\n\t\treturn true;\\n\t}\\n"
  },
  {
    "method_id": "M956",
    "name": "flagAsSynthetic",
    "return_type": "void",
    "signature": "flagAsSynthetic(LazyMethodGen methodGen, boolean makeJavaSynthetic)",
    "file_id": "F21",
    "start_line": 191,
    "text_preview": "etFactory();\\n\t\tLazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perSingletonAspectOfMethod(aspectType));\\n\t\tflagAsSynthetic(method, false);\\n\t\tclassGen.addMethodGen(method);\\n\\n\t\tInstructionList il = method.getBody();\\n\t\til.append(Utility.createGet(factory, AjcMemberMaker.perSingletonField(aspectType)));\\n\t\tInst"
  },
  {
    "method_id": "M957",
    "name": "if",
    "return_type": "",
    "signature": "if(makeJavaSynthetic)",
    "file_id": "F21",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M958",
    "name": "isLateTypeMunger",
    "return_type": "boolean",
    "signature": "isLateTypeMunger()",
    "file_id": "F21",
    "start_line": 558,
    "text_preview": ".bcelAttribute(new AjAttribute.AjSynthetic(), methodGen.getEnclosingClass().getConstantPool()));\\n\t}\\n\\n\t// public boolean isLateTypeMunger() {\\n\t// return true;\\n\t// }\\n}\\n"
  },
  {
    "method_id": "M959",
    "name": "BcelRenderer",
    "return_type": "",
    "signature": "BcelRenderer(InstructionFactory fact, BcelWorld world)",
    "file_id": "F22",
    "start_line": 52,
    "text_preview": "uctions;\\n\tprivate InstructionFactory fact;\\n\tprivate BcelWorld world;\\n\\n\tInstructionHandle sk, fk, next = null;\\n\\n\tprivate BcelRenderer(InstructionFactory fact, BcelWorld world) {\\n\t\tsuper();\\n\t\tthis.fact = fact;\\n\t\tthis.world = world;\\n\t\tthis.instructions = new InstructionList();\\n\t}\\n\\n\t// ---- renderers\\n\\n\tpublic static Instru"
  },
  {
    "method_id": "M960",
    "name": "renderExpr",
    "return_type": "InstructionList",
    "signature": "renderExpr(InstructionFactory fact, BcelWorld world, Expr e)",
    "file_id": "F22",
    "start_line": 61,
    "text_preview": "this.world = world;\\n\t\tthis.instructions = new InstructionList();\\n\t}\\n\\n\t// ---- renderers\\n\\n\tpublic static InstructionList renderExpr(InstructionFactory fact, BcelWorld world, Expr e) {\\n\t\tBcelRenderer renderer = new BcelRenderer(fact, world);\\n\t\te.accept(renderer);\\n\t\treturn renderer.instructions;\\n\t}\\n\\n\tpublic static Instruc"
  },
  {
    "method_id": "M961",
    "name": "renderExpr",
    "return_type": "InstructionList",
    "signature": "renderExpr(InstructionFactory fact, BcelWorld world, Expr e, Type desiredType)",
    "file_id": "F22",
    "start_line": 61,
    "text_preview": "this.world = world;\\n\t\tthis.instructions = new InstructionList();\\n\t}\\n\\n\t// ---- renderers\\n\\n\tpublic static InstructionList renderExpr(InstructionFactory fact, BcelWorld world, Expr e) {\\n\t\tBcelRenderer renderer = new BcelRenderer(fact, world);\\n\t\te.accept(renderer);\\n\t\treturn renderer.instructions;\\n\t}\\n\\n\tpublic static Instruc"
  },
  {
    "method_id": "M962",
    "name": "renderExprs",
    "return_type": "InstructionList",
    "signature": "renderExprs(InstructionFactory fact, BcelWorld world, Expr[] es)",
    "file_id": "F22",
    "start_line": 75,
    "text_preview": "ateConversion(fact, BcelWorld.makeBcelType(e.getType()), desiredType));\\n\t\treturn il;\\n\t}\\n\\n\tpublic static InstructionList renderExprs(InstructionFactory fact, BcelWorld world, Expr[] es) {\\n\t\tBcelRenderer renderer = new BcelRenderer(fact, world);\\n\t\tfor (int i = es.length - 1; i >= 0; i--) {\\n\t\t\tes[i].accept(renderer);\\n\t\t}\\n"
  },
  {
    "method_id": "M963",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = es.length - 1; i >= 0; i--)",
    "file_id": "F22",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M964",
    "name": "renderTest",
    "return_type": "InstructionList",
    "signature": "renderTest(InstructionFactory fact, BcelWorld world, Test e, InstructionHandle sk,\n\t\t\tInstructionHandle fk, InstructionHandle next)",
    "file_id": "F22",
    "start_line": 97,
    "text_preview": "\t * instruction.\\n\t *\\n\t * @returns the instruction list representing this expression\\n\t */\\n\tpublic static InstructionList renderTest(InstructionFactory fact, BcelWorld world, Test e, InstructionHandle sk,\\n\t\t\tInstructionHandle fk, InstructionHandle next) {\\n\t\tBcelRenderer renderer = new BcelRenderer(fact, world);\\n\t\trendere"
  },
  {
    "method_id": "M965",
    "name": "recur",
    "return_type": "void",
    "signature": "recur(Test e, InstructionHandle sk, InstructionHandle fk, InstructionHandle next)",
    "file_id": "F22",
    "start_line": 100,
    "text_preview": "\\n\t\t\tInstructionHandle fk, InstructionHandle next) {\\n\t\tBcelRenderer renderer = new BcelRenderer(fact, world);\\n\t\trenderer.recur(e, sk, fk, next);\\n\t\treturn renderer.instructions;\\n\t}\\n\\n\t// ---- recurrers\\n\\n\tprivate void recur(Test e, InstructionHandle sk, InstructionHandle fk, InstructionHandle next) {\\n\t\tthis.sk = sk;\\n\t\tthis"
  },
  {
    "method_id": "M966",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(And e)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M967",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(Or e)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M968",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(Not e)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M969",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(Instanceof i)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M970",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(HasAnnotation hasAnnotation)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M971",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(MatchingContextBasedTest matchingContextTest)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M972",
    "name": "createJumpBasedOnBooleanOnStack",
    "return_type": "InstructionList",
    "signature": "createJumpBasedOnBooleanOnStack()",
    "file_id": "F22",
    "start_line": 133,
    "text_preview": "ic void visit(Not e) {\\n\t\trecur(e.getBody(), fk, sk, next);\\n\t}\\n\\n\tpublic void visit(Instanceof i) {\\n\t\tinstructions.insert(createJumpBasedOnBooleanOnStack());\\n\t\tinstructions.insert(Utility.createInstanceof(fact, (ReferenceType) BcelWorld.makeBcelType(i.getType())));\\n\t\ti.getVar().accept(this);\\n\t}\\n\\n\tpublic void visit(HasAnn"
  },
  {
    "method_id": "M973",
    "name": "if",
    "return_type": "",
    "signature": "if(sk == fk)",
    "file_id": "F22",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M974",
    "name": "if",
    "return_type": "matter",
    "signature": "if(sk != next)",
    "file_id": "F22",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M975",
    "name": "if",
    "return_type": "",
    "signature": "if(fk == next)",
    "file_id": "F22",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M976",
    "name": "if",
    "return_type": "else",
    "signature": "if(sk == next)",
    "file_id": "F22",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M977",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(Literal literal)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M978",
    "name": "if",
    "return_type": "",
    "signature": "if(literal == Literal.FALSE)",
    "file_id": "F22",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M979",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(Call call)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M980",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = args.length; i < len; i++)",
    "file_id": "F22",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M981",
    "name": "if",
    "return_type": "162135",
    "signature": "if(arg == null)",
    "file_id": "F22",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M982",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(FieldGetCall fieldGetCall)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M983",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(Var var)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M984",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(FieldGet fieldGet)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M985",
    "name": "visit",
    "return_type": "void",
    "signature": "visit(CallExpr call)",
    "file_id": "F22",
    "start_line": 115,
    "text_preview": " next) {\\n\t\tthis.sk = sk;\\n\t\tthis.fk = fk;\\n\t\tthis.next = next;\\n\t\te.accept(this);\\n\t}\\n\\n\t// ---- test visitors\\n\\n\tpublic void visit(And e) {\\n\t\tInstructionHandle savedFk = fk;\\n\t\trecur(e.getRight(), sk, fk, next);\\n\t\tInstructionHandle ning = instructions.getStart();\\n\t\trecur(e.getLeft(), ning, savedFk, ning);\\n\t}\\n\\n\tpublic void vi"
  },
  {
    "method_id": "M986",
    "name": "BcelShadow",
    "return_type": "",
    "signature": "BcelShadow(BcelWorld world, Kind kind, Member signature, LazyMethodGen enclosingMethod, BcelShadow enclosingShadow)",
    "file_id": "F23",
    "start_line": 143,
    "text_preview": "should be given to a rooted ShadowRange in the {@link ShadowRange#associateWithShadow(BcelShadow)} method.\\n\t */\\n\tpublic BcelShadow(BcelWorld world, Kind kind, Member signature, LazyMethodGen enclosingMethod, BcelShadow enclosingShadow) {\\n\t\tsuper(kind, signature, enclosingShadow);\\n\t\tthis.world = world;\\n\t\tthis.enclosingM"
  },
  {
    "method_id": "M987",
    "name": "copyInto",
    "return_type": "BcelShadow",
    "signature": "copyInto(LazyMethodGen recipient, BcelShadow enclosing)",
    "file_id": "F23",
    "start_line": 151,
    "text_preview": "his.enclosingMethod = enclosingMethod;\\n\t}\\n\\n\t// ---- copies all state, including Shadow's mungers...\\n\\n\tpublic BcelShadow copyInto(LazyMethodGen recipient, BcelShadow enclosing) {\\n\t\tBcelShadow s = new BcelShadow(world, getKind(), getSignature(), recipient, enclosing);\\n\t\tif (mungers.size() > 0) {\\n\t\t\tList<ShadowMunger> src"
  },
  {
    "method_id": "M988",
    "name": "if",
    "return_type": "",
    "signature": "if(s.mungers == Collections.EMPTY_LIST)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M989",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger shadowMunger : src)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M990",
    "name": "getIWorld",
    "return_type": "World",
    "signature": "getIWorld()",
    "file_id": "F23",
    "start_line": 169,
    "text_preview": "r : src) {\\n\t\t\t\tdest.add(shadowMunger);\\n\t\t\t}\\n\t\t}\\n\t\treturn s;\\n\t}\\n\\n\t// ---- overridden behaviour\\n\\n\t@Override\\n\tpublic World getIWorld() {\\n\t\treturn world;\\n\t}\\n\\n\t// see comment in deleteNewAndDup\\n\t// } else if (inst.opcode == Constants.DUP_X2) {\\n\t// // This code seen in the wild (by Brad):\\n\t// // 40: new #12; //class java/lan"
  },
  {
    "method_id": "M991",
    "name": "if",
    "return_type": "else",
    "signature": "if(inst.opcode == Constants.DUP_X2)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M992",
    "name": "deleteNewAndDup",
    "return_type": "boolean",
    "signature": "deleteNewAndDup()",
    "file_id": "F23",
    "start_line": 216,
    "text_preview": "ample see the ctors in grails.util.BuildSettings).\\n\t *\\n\t * @return true if managed to remove them\\n\t */\\n\tprivate boolean deleteNewAndDup() {\\n\t\tfinal ConstantPool cpool = getEnclosingClass().getConstantPool();\\n\t\tint depth = 1;\\n\t\tInstructionHandle ih = range.getStart();\\n\\n\t\t// Go back from where we are looking for 'NEW' th"
  },
  {
    "method_id": "M993",
    "name": "while",
    "return_type": "<init>",
    "signature": "while(ih != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M994",
    "name": "if",
    "return_type": "else",
    "signature": "if(inst.opcode == Constants.NEW)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M995",
    "name": "if",
    "return_type": "",
    "signature": "if(depth == 0)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M996",
    "name": "if",
    "return_type": "",
    "signature": "if(ih == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M997",
    "name": "if",
    "return_type": "",
    "signature": "if(!skipEndRepositioning)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M998",
    "name": "catch",
    "return_type": "",
    "signature": "catch(TargetLostException e)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M999",
    "name": "retargetFrom",
    "return_type": "void",
    "signature": "retargetFrom(InstructionHandle old, InstructionHandle fresh)",
    "file_id": "F23",
    "start_line": 247,
    "text_preview": "nHandle nextHandle;\\n\t\tif (endHandle.getInstruction().opcode == Constants.DUP) {\\n\t\t\tnextHandle = endHandle.getNext();\\n\t\t\tretargetFrom(newHandle, nextHandle);\\n\t\t\tretargetFrom(endHandle, nextHandle);\\n\t\t} else if (endHandle.getInstruction().opcode == Constants.DUP_X1) {\\n\t\t\tInstructionHandle dupHandle = endHandle;\\n\t\t\tendHan"
  },
  {
    "method_id": "M1000",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof ExceptionRange)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1001",
    "name": "addAdvicePreventingLazyTjp",
    "return_type": "void",
    "signature": "addAdvicePreventingLazyTjp(BcelAdvice advice)",
    "file_id": "F23",
    "start_line": 299,
    "text_preview": "rds advice that is stopping us doing the lazyTjp optimization\\n\tprivate List<BcelAdvice> badAdvice = null;\\n\\n\tpublic void addAdvicePreventingLazyTjp(BcelAdvice advice) {\\n\t\tif (badAdvice == null) {\\n\t\t\tbadAdvice = new ArrayList<>();\\n\t\t}\\n\t\tbadAdvice.add(advice);\\n\t}\\n\\n\t@Override\\n\tprotected void prepareForMungers() {\\n\t\t// if w"
  },
  {
    "method_id": "M1002",
    "name": "if",
    "return_type": "",
    "signature": "if(badAdvice == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1003",
    "name": "prepareForMungers",
    "return_type": "void",
    "signature": "prepareForMungers()",
    "file_id": "F23",
    "start_line": 307,
    "text_preview": "\tif (badAdvice == null) {\\n\t\t\tbadAdvice = new ArrayList<>();\\n\t\t}\\n\t\tbadAdvice.add(advice);\\n\t}\\n\\n\t@Override\\n\tprotected void prepareForMungers() {\\n\t\t// if we're a constructor call, we need to remove the new:dup or the new:dup_x1:swap,\\n\t\t// and store all our arguments on the frame.\\n\\n\t\t// ??? This is a bit of a hack (for the "
  },
  {
    "method_id": "M1004",
    "name": "if",
    "return_type": "",
    "signature": "if(t instanceof ExceptionRange)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1005",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger munger : mungers)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1006",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelAdvice element : badAdvice)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1007",
    "name": "if",
    "return_type": "",
    "signature": "if(valid != 0)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1008",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelAdvice element : badAdvice)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1009",
    "name": "if",
    "return_type": "",
    "signature": "if(targetVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1010",
    "name": "if",
    "return_type": "",
    "signature": "if(deletedNewAndDup)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1011",
    "name": "getRange",
    "return_type": "ShadowRange",
    "signature": "getRange()",
    "file_id": "F23",
    "start_line": 273,
    "text_preview": "andle);\\n\t\t\t// add a POP here... we found a NEW w/o a dup or anything else, so\\n\t\t\t// we must be in statement context.\\n\t\t\tgetRange().insert(InstructionConstants.POP, Range.OutsideAfter);\\n\t\t}\\n\t\t// assert (dupHandle.getInstruction() instanceof DUP);\\n\\n\t\ttry {\\n\t\t\trange.getBody().delete(newHandle, endHandle);\\n\t\t} catch (Targe"
  },
  {
    "method_id": "M1012",
    "name": "setRange",
    "return_type": "void",
    "signature": "setRange(ShadowRange range)",
    "file_id": "F23",
    "start_line": 436,
    "text_preview": ";\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t// ---- getters\\n\\n\tpublic ShadowRange getRange() {\\n\t\treturn range;\\n\t}\\n\\n\tpublic void setRange(ShadowRange range) {\\n\t\tthis.range = range;\\n\t}\\n\\n\tprivate int sourceline = -1;\\n\\n\tpublic int getSourceLine() {\\n\t\t// if the kind of join point for which we are a shadow represents\\n\t\t// a method o"
  },
  {
    "method_id": "M1013",
    "name": "getSourceLine",
    "return_type": "int",
    "signature": "getSourceLine()",
    "file_id": "F23",
    "start_line": 442,
    "text_preview": "ge;\\n\t}\\n\\n\tpublic void setRange(ShadowRange range) {\\n\t\tthis.range = range;\\n\t}\\n\\n\tprivate int sourceline = -1;\\n\\n\tpublic int getSourceLine() {\\n\t\t// if the kind of join point for which we are a shadow represents\\n\t\t// a method or constructor execution, then the best source line is\\n\t\t// the one from the enclosingMethod declara"
  },
  {
    "method_id": "M1014",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceline != -1)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1015",
    "name": "if",
    "return_type": "",
    "signature": "if(range == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1016",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceline < 0)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1017",
    "name": "getEnclosingType",
    "return_type": "ResolvedType",
    "signature": "getEnclosingType()",
    "file_id": "F23",
    "start_line": 475,
    "text_preview": "ge.getStart());\\n\t\tif (sourceline < 0) {\\n\t\t\tsourceline = 0;\\n\t\t}\\n\t\treturn sourceline;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType getEnclosingType() {\\n\t\treturn getEnclosingClass().getType();\\n\t}\\n\\n\tpublic LazyClassGen getEnclosingClass() {\\n\t\treturn enclosingMethod.getEnclosingClass();\\n\t}\\n\\n\tpublic BcelWorld getWorld() {\\n\t\treturn wo"
  },
  {
    "method_id": "M1018",
    "name": "getEnclosingClass",
    "return_type": "LazyClassGen",
    "signature": "getEnclosingClass()",
    "file_id": "F23",
    "start_line": 217,
    "text_preview": ".\\n\t *\\n\t * @return true if managed to remove them\\n\t */\\n\tprivate boolean deleteNewAndDup() {\\n\t\tfinal ConstantPool cpool = getEnclosingClass().getConstantPool();\\n\t\tint depth = 1;\\n\t\tInstructionHandle ih = range.getStart();\\n\\n\t\t// Go back from where we are looking for 'NEW' that takes us to a stack depth of 0. INVOKESPECIAL "
  },
  {
    "method_id": "M1019",
    "name": "getWorld",
    "return_type": "BcelWorld",
    "signature": "getWorld()",
    "file_id": "F23",
    "start_line": 483,
    "text_preview": "e();\\n\t}\\n\\n\tpublic LazyClassGen getEnclosingClass() {\\n\t\treturn enclosingMethod.getEnclosingClass();\\n\t}\\n\\n\tpublic BcelWorld getWorld() {\\n\t\treturn world;\\n\t}\\n\\n\t// ---- factory methods\\n\\n\tpublic static BcelShadow makeConstructorExecution(BcelWorld world, LazyMethodGen enclosingMethod,\\n\t\t\tInstructionHandle justBeforeStart) {\\n\t\t"
  },
  {
    "method_id": "M1020",
    "name": "makeConstructorExecution",
    "return_type": "BcelShadow",
    "signature": "makeConstructorExecution(BcelWorld world, LazyMethodGen enclosingMethod,\n\t\t\tInstructionHandle justBeforeStart)",
    "file_id": "F23",
    "start_line": 489,
    "text_preview": "singClass();\\n\t}\\n\\n\tpublic BcelWorld getWorld() {\\n\t\treturn world;\\n\t}\\n\\n\t// ---- factory methods\\n\\n\tpublic static BcelShadow makeConstructorExecution(BcelWorld world, LazyMethodGen enclosingMethod,\\n\t\t\tInstructionHandle justBeforeStart) {\\n\t\tfinal InstructionList body = enclosingMethod.getBody();\\n\t\tBcelShadow s = new BcelShad"
  },
  {
    "method_id": "M1021",
    "name": "makeStaticInitialization",
    "return_type": "BcelShadow",
    "signature": "makeStaticInitialization(BcelWorld world, LazyMethodGen enclosingMethod)",
    "file_id": "F23",
    "start_line": 500,
    "text_preview": "Targets(Range.genStart(body, justBeforeStart.getNext()), Range.genEnd(body));\\n\t\treturn s;\\n\t}\\n\\n\tpublic static BcelShadow makeStaticInitialization(BcelWorld world, LazyMethodGen enclosingMethod) {\\n\t\tInstructionList body = enclosingMethod.getBody();\\n\t\t// move the start past ajc$preClinit\\n\t\tInstructionHandle clinitStart = "
  },
  {
    "method_id": "M1022",
    "name": "makeExceptionHandler",
    "return_type": "BcelShadow",
    "signature": "makeExceptionHandler(BcelWorld world, ExceptionRange exceptionRange, LazyMethodGen enclosingMethod,\n\t\t\tInstructionHandle startOfHandler, BcelShadow enclosingShadow)",
    "file_id": "F23",
    "start_line": 533,
    "text_preview": "er. Currently makes an empty shadow that only allows before advice to be woven into it.\\n\t */\\n\\n\tpublic static BcelShadow makeExceptionHandler(BcelWorld world, ExceptionRange exceptionRange, LazyMethodGen enclosingMethod,\\n\t\t\tInstructionHandle startOfHandler, BcelShadow enclosingShadow) {\\n\t\tInstructionList body = enclosin"
  },
  {
    "method_id": "M1023",
    "name": "findHandlerParamName",
    "return_type": "String",
    "signature": "findHandlerParamName(InstructionHandle startOfHandler)",
    "file_id": "F23",
    "start_line": 540,
    "text_preview": "vedMemberImpl sig = MemberImpl.makeExceptionHandlerSignature(inType, catchType);\\n\t\tsig.setParameterNames(new String[] { findHandlerParamName(startOfHandler) });\\n\\n\t\tBcelShadow s = new BcelShadow(world, ExceptionHandler, sig, enclosingMethod, enclosingShadow);\\n\t\tShadowRange r = new ShadowRange(body);\\n\t\tr.associateWithSha"
  },
  {
    "method_id": "M1024",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof LocalVariableTag)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1025",
    "name": "makeIfaceInitialization",
    "return_type": "BcelShadow",
    "signature": "makeIfaceInitialization(BcelWorld world, LazyMethodGen constructor,\n\t\t\tMember interfaceConstructorSignature)",
    "file_id": "F23",
    "start_line": 572,
    "text_preview": "}\\n\\n\t/** create an init join point associated w/ an interface in the body of a constructor */\\n\\n\tpublic static BcelShadow makeIfaceInitialization(BcelWorld world, LazyMethodGen constructor,\\n\t\t\tMember interfaceConstructorSignature) {\\n\t\t// this call marks the instruction list as changed\\n\t\tconstructor.getBody();\\n\t\t// Unreso"
  },
  {
    "method_id": "M1026",
    "name": "initIfaceInitializer",
    "return_type": "void",
    "signature": "initIfaceInitializer(InstructionHandle end)",
    "file_id": "F23",
    "start_line": 588,
    "text_preview": "tionHandle end = Range.genEnd(body, handle);\\n\t\t//\\n\t\t// r.associateWithTargets(start, end);\\n\t\treturn s;\\n\t}\\n\\n\tpublic void initIfaceInitializer(InstructionHandle end) {\\n\t\tfinal InstructionList body = enclosingMethod.getBody();\\n\t\tShadowRange r = new ShadowRange(body);\\n\t\tr.associateWithShadow(this);\\n\t\tInstructionHandle nop "
  },
  {
    "method_id": "M1027",
    "name": "makeUnfinishedInitialization",
    "return_type": "BcelShadow",
    "signature": "makeUnfinishedInitialization(BcelWorld world, LazyMethodGen constructor)",
    "file_id": "F23",
    "start_line": 632,
    "text_preview": "f constructors.\\n\t *\\n\t * @param constructor The constructor starting this initialization.\\n\t */\\n\tpublic static BcelShadow makeUnfinishedInitialization(BcelWorld world, LazyMethodGen constructor) {\\n\t\tBcelShadow ret = new BcelShadow(world, Initialization, world.makeJoinPointSignatureFromMethod(constructor,\\n\t\t\t\tMember.CONST"
  },
  {
    "method_id": "M1028",
    "name": "makeUnfinishedPreinitialization",
    "return_type": "BcelShadow",
    "signature": "makeUnfinishedPreinitialization(BcelWorld world, LazyMethodGen constructor)",
    "file_id": "F23",
    "start_line": 641,
    "text_preview": "Signature(constructor.getEffectiveSignature().getEffectiveSignature());\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic static BcelShadow makeUnfinishedPreinitialization(BcelWorld world, LazyMethodGen constructor) {\\n\t\tBcelShadow ret = new BcelShadow(world, PreInitialization, world.makeJoinPointSignatureFromMethod(constructor,\\n\t\t\t\tMember"
  },
  {
    "method_id": "M1029",
    "name": "makeMethodExecution",
    "return_type": "BcelShadow",
    "signature": "makeMethodExecution(BcelWorld world, LazyMethodGen enclosingMethod, boolean lazyInit)",
    "file_id": "F23",
    "start_line": 650,
    "text_preview": "Signature(constructor.getEffectiveSignature().getEffectiveSignature());\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic static BcelShadow makeMethodExecution(BcelWorld world, LazyMethodGen enclosingMethod, boolean lazyInit) {\\n\t\tif (!lazyInit) {\\n\t\t\treturn makeMethodExecution(world, enclosingMethod);\\n\t\t}\\n\\n\t\tBcelShadow s = new BcelShadow(w"
  },
  {
    "method_id": "M1030",
    "name": "if",
    "return_type": "",
    "signature": "if(!lazyInit)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1031",
    "name": "init",
    "return_type": "void",
    "signature": "init()",
    "file_id": "F23",
    "start_line": 660,
    "text_preview": "elShadow(world, MethodExecution, enclosingMethod.getMemberView(), enclosingMethod, null);\\n\\n\t\treturn s;\\n\t}\\n\\n\tpublic void init() {\\n\t\tif (range != null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tfinal InstructionList body = enclosingMethod.getBody();\\n\t\tShadowRange r = new ShadowRange(body);\\n\t\tr.associateWithShadow(this);\\n\t\tr.associateWithTarge"
  },
  {
    "method_id": "M1032",
    "name": "if",
    "return_type": "",
    "signature": "if(range != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1033",
    "name": "makeMethodExecution",
    "return_type": "BcelShadow",
    "signature": "makeMethodExecution(BcelWorld world, LazyMethodGen enclosingMethod)",
    "file_id": "F23",
    "start_line": 650,
    "text_preview": "Signature(constructor.getEffectiveSignature().getEffectiveSignature());\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic static BcelShadow makeMethodExecution(BcelWorld world, LazyMethodGen enclosingMethod, boolean lazyInit) {\\n\t\tif (!lazyInit) {\\n\t\t\treturn makeMethodExecution(world, enclosingMethod);\\n\t\t}\\n\\n\t\tBcelShadow s = new BcelShadow(w"
  },
  {
    "method_id": "M1034",
    "name": "makeShadowForMethod",
    "return_type": "BcelShadow",
    "signature": "makeShadowForMethod(BcelWorld world, LazyMethodGen enclosingMethod, Shadow.Kind kind, Member sig)",
    "file_id": "F23",
    "start_line": 672,
    "text_preview": "nd(body));\\n\t}\\n\\n\tpublic static BcelShadow makeMethodExecution(BcelWorld world, LazyMethodGen enclosingMethod) {\\n\t\treturn makeShadowForMethod(world, enclosingMethod, MethodExecution, enclosingMethod.getMemberView());\\n\t}\\n\\n\tpublic static BcelShadow makeShadowForMethod(BcelWorld world, LazyMethodGen enclosingMethod, Shadow."
  },
  {
    "method_id": "M1035",
    "name": "makeAdviceExecution",
    "return_type": "BcelShadow",
    "signature": "makeAdviceExecution(BcelWorld world, LazyMethodGen enclosingMethod)",
    "file_id": "F23",
    "start_line": 685,
    "text_preview": "s of times for all jp kinds...\\n\t\t\t\tRange.genStart(body), Range.genEnd(body));\\n\t\treturn s;\\n\t}\\n\\n\tpublic static BcelShadow makeAdviceExecution(BcelWorld world, LazyMethodGen enclosingMethod) {\\n\t\tfinal InstructionList body = enclosingMethod.getBody();\\n\t\tBcelShadow s = new BcelShadow(world, AdviceExecution,\\n\t\t\t\tworld.makeJo"
  },
  {
    "method_id": "M1036",
    "name": "makeConstructorCall",
    "return_type": "BcelShadow",
    "signature": "makeConstructorCall(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle callHandle,\n\t\t\tBcelShadow enclosingShadow)",
    "file_id": "F23",
    "start_line": 699,
    "text_preview": "NEW instruction inside the join point, which involves putting\\n\t// all the arguments in temps.\\n\tpublic static BcelShadow makeConstructorCall(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle callHandle,\\n\t\t\tBcelShadow enclosingShadow) {\\n\t\tfinal InstructionList body = enclosingMethod.getBody();\\n\\n\t\tMember s"
  },
  {
    "method_id": "M1037",
    "name": "makeArrayConstructorCall",
    "return_type": "BcelShadow",
    "signature": "makeArrayConstructorCall(BcelWorld world, LazyMethodGen enclosingMethod,\n\t\t\tInstructionHandle arrayInstruction, BcelShadow enclosingShadow)",
    "file_id": "F23",
    "start_line": 714,
    "text_preview": "e.genEnd(body, callHandle));\\n\t\tretargetAllBranches(callHandle, r.getStart());\\n\t\treturn s;\\n\t}\\n\\n\tpublic static BcelShadow makeArrayConstructorCall(BcelWorld world, LazyMethodGen enclosingMethod,\\n\t\t\tInstructionHandle arrayInstruction, BcelShadow enclosingShadow) {\\n\t\tfinal InstructionList body = enclosingMethod.getBody();\\n"
  },
  {
    "method_id": "M1038",
    "name": "makeMonitorEnter",
    "return_type": "BcelShadow",
    "signature": "makeMonitorEnter(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle monitorInstruction,\n\t\t\tBcelShadow enclosingShadow)",
    "file_id": "F23",
    "start_line": 726,
    "text_preview": "y, arrayInstruction));\\n\t\tretargetAllBranches(arrayInstruction, r.getStart());\\n\t\treturn s;\\n\t}\\n\\n\tpublic static BcelShadow makeMonitorEnter(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle monitorInstruction,\\n\t\t\tBcelShadow enclosingShadow) {\\n\t\tfinal InstructionList body = enclosingMethod.getBody();\\n\t\tMemb"
  },
  {
    "method_id": "M1039",
    "name": "makeMonitorExit",
    "return_type": "BcelShadow",
    "signature": "makeMonitorExit(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle monitorInstruction,\n\t\t\tBcelShadow enclosingShadow)",
    "file_id": "F23",
    "start_line": 738,
    "text_preview": "onitorInstruction));\\n\t\tretargetAllBranches(monitorInstruction, r.getStart());\\n\t\treturn s;\\n\t}\\n\\n\tpublic static BcelShadow makeMonitorExit(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle monitorInstruction,\\n\t\t\tBcelShadow enclosingShadow) {\\n\t\tfinal InstructionList body = enclosingMethod.getBody();\\n\t\tMembe"
  },
  {
    "method_id": "M1040",
    "name": "makeMethodCall",
    "return_type": "BcelShadow",
    "signature": "makeMethodCall(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle callHandle,\n\t\t\tBcelShadow enclosingShadow)",
    "file_id": "F23",
    "start_line": 775,
    "text_preview": "yInstruction));\\n\t// retargetAllBranches(arrayInstruction, r.getStart());\\n\t// return s;\\n\t// }\\n\\n\tpublic static BcelShadow makeMethodCall(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle callHandle,\\n\t\t\tBcelShadow enclosingShadow) {\\n\t\tfinal InstructionList body = enclosingMethod.getBody();\\n\t\tBcelShadow s ="
  },
  {
    "method_id": "M1041",
    "name": "makeShadowForMethodCall",
    "return_type": "BcelShadow",
    "signature": "makeShadowForMethodCall(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle callHandle,\n\t\t\tBcelShadow enclosingShadow, Kind kind, ResolvedMember sig)",
    "file_id": "F23",
    "start_line": 788,
    "text_preview": "e.genEnd(body, callHandle));\\n\t\tretargetAllBranches(callHandle, r.getStart());\\n\t\treturn s;\\n\t}\\n\\n\tpublic static BcelShadow makeShadowForMethodCall(BcelWorld world, LazyMethodGen enclosingMethod, InstructionHandle callHandle,\\n\t\t\tBcelShadow enclosingShadow, Kind kind, ResolvedMember sig) {\\n\t\tfinal InstructionList body = enc"
  },
  {
    "method_id": "M1042",
    "name": "makeFieldGet",
    "return_type": "BcelShadow",
    "signature": "makeFieldGet(BcelWorld world, ResolvedMember field, LazyMethodGen enclosingMethod,\n\t\t\tInstructionHandle getHandle, BcelShadow enclosingShadow)",
    "file_id": "F23",
    "start_line": 799,
    "text_preview": "e.genEnd(body, callHandle));\\n\t\tretargetAllBranches(callHandle, r.getStart());\\n\t\treturn s;\\n\t}\\n\\n\tpublic static BcelShadow makeFieldGet(BcelWorld world, ResolvedMember field, LazyMethodGen enclosingMethod,\\n\t\t\tInstructionHandle getHandle, BcelShadow enclosingShadow) {\\n\t\tfinal InstructionList body = enclosingMethod.getBody("
  },
  {
    "method_id": "M1043",
    "name": "makeFieldSet",
    "return_type": "BcelShadow",
    "signature": "makeFieldSet(BcelWorld world, ResolvedMember field, LazyMethodGen enclosingMethod,\n\t\t\tInstructionHandle setHandle, BcelShadow enclosingShadow)",
    "file_id": "F23",
    "start_line": 814,
    "text_preview": "nge.genEnd(body, getHandle));\\n\t\tretargetAllBranches(getHandle, r.getStart());\\n\t\treturn s;\\n\t}\\n\\n\tpublic static BcelShadow makeFieldSet(BcelWorld world, ResolvedMember field, LazyMethodGen enclosingMethod,\\n\t\t\tInstructionHandle setHandle, BcelShadow enclosingShadow) {\\n\t\tfinal InstructionList body = enclosingMethod.getBody("
  },
  {
    "method_id": "M1044",
    "name": "retargetAllBranches",
    "return_type": "void",
    "signature": "retargetAllBranches(InstructionHandle from, InstructionHandle to)",
    "file_id": "F23",
    "start_line": 710,
    "text_preview": "r.associateWithShadow(s);\\n\t\tr.associateWithTargets(Range.genStart(body, callHandle), Range.genEnd(body, callHandle));\\n\t\tretargetAllBranches(callHandle, r.getStart());\\n\t\treturn s;\\n\t}\\n\\n\tpublic static BcelShadow makeArrayConstructorCall(BcelWorld world, LazyMethodGen enclosingMethod,\\n\t\t\tInstructionHandle arrayInstruction,"
  },
  {
    "method_id": "M1045",
    "name": "if",
    "return_type": "",
    "signature": "if(source instanceof InstructionBranch)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1046",
    "name": "getTargetBcelType",
    "return_type": "ObjectType",
    "signature": "getTargetBcelType()",
    "file_id": "F23",
    "start_line": 838,
    "text_preview": "ructionBranch) {\\n\t\t\t\tsource.updateTarget(from, to);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t// // ---- type access methods\\n\t// private ObjectType getTargetBcelType() {\\n\t// return (ObjectType) BcelWorld.makeBcelType(getTargetType());\\n\t// }\\n\t// private Type getArgBcelType(int arg) {\\n\t// return BcelWorld.makeBcelType(getArgType(arg));\\n\t// }\\n\\n\t// -"
  },
  {
    "method_id": "M1047",
    "name": "getArgBcelType",
    "return_type": "Type",
    "signature": "getArgBcelType(int arg)",
    "file_id": "F23",
    "start_line": 841,
    "text_preview": "bjectType getTargetBcelType() {\\n\t// return (ObjectType) BcelWorld.makeBcelType(getTargetType());\\n\t// }\\n\t// private Type getArgBcelType(int arg) {\\n\t// return BcelWorld.makeBcelType(getArgType(arg));\\n\t// }\\n\\n\t// ---- kinding\\n\\n\t/**\\n\t * If the end of my range has no real instructions following then my context needs a return"
  },
  {
    "method_id": "M1048",
    "name": "terminatesWithReturn",
    "return_type": "boolean",
    "signature": "terminatesWithReturn()",
    "file_id": "F23",
    "start_line": 850,
    "text_preview": " the end of my range has no real instructions following then my context needs a return at the end.\\n\t */\\n\tpublic boolean terminatesWithReturn() {\\n\t\treturn getRange().getRealNext() == null;\\n\t}\\n\\n\t/**\\n\t * Is arg0 occupied with the value of this\\n\t */\\n\tpublic boolean arg0HoldsThis() {\\n\t\tif (getKind().isEnclosingKind()) {\\n\t\t\t"
  },
  {
    "method_id": "M1049",
    "name": "arg0HoldsThis",
    "return_type": "boolean",
    "signature": "arg0HoldsThis()",
    "file_id": "F23",
    "start_line": 857,
    "text_preview": " {\\n\t\treturn getRange().getRealNext() == null;\\n\t}\\n\\n\t/**\\n\t * Is arg0 occupied with the value of this\\n\t */\\n\tpublic boolean arg0HoldsThis() {\\n\t\tif (getKind().isEnclosingKind()) {\\n\t\t\treturn !Modifier.isStatic(getSignature().getModifiers());\\n\t\t} else if (enclosingShadow == null) {\\n\t\t\t// XXX this is mostly right\\n\t\t\t// this do"
  },
  {
    "method_id": "M1050",
    "name": "if",
    "return_type": "else",
    "signature": "if(enclosingShadow == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1051",
    "name": "getThisVar",
    "return_type": "Var",
    "signature": "getThisVar()",
    "file_id": "F23",
    "start_line": 889,
    "text_preview": " need to call unlink()\\n\t// after the code has been run.\\n\tboolean closureVarInitialized = false;\\n\\n\t@Override\\n\tpublic Var getThisVar() {\\n\t\tif (!hasThis()) {\\n\t\t\tthrow new IllegalStateException(\"no this\");\\n\t\t}\\n\t\tinitializeThisVar();\\n\t\treturn thisVar;\\n\t}\\n\\n\t@Override\\n\tpublic Var getThisAnnotationVar(UnresolvedType forAnnotat"
  },
  {
    "method_id": "M1052",
    "name": "getThisAnnotationVar",
    "return_type": "Var",
    "signature": "getThisAnnotationVar(UnresolvedType forAnnotationType)",
    "file_id": "F23",
    "start_line": 898,
    "text_preview": "\\n\t\t\tthrow new IllegalStateException(\"no this\");\\n\t\t}\\n\t\tinitializeThisVar();\\n\t\treturn thisVar;\\n\t}\\n\\n\t@Override\\n\tpublic Var getThisAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tif (!hasThis()) {\\n\t\t\tthrow new IllegalStateException(\"no this\");\\n\t\t}\\n\t\tinitializeThisAnnotationVars(); // FIXME asc Why bother with this if w"
  },
  {
    "method_id": "M1053",
    "name": "if",
    "return_type": "",
    "signature": "if(v == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1054",
    "name": "getTargetVar",
    "return_type": "Var",
    "signature": "getTargetVar()",
    "file_id": "F23",
    "start_line": 912,
    "text_preview": "notationAccessVar(forAnnotationType.resolve(world), (BcelVar) getThisVar());\\n\t\t}\\n\t\treturn v;\\n\t}\\n\\n\t@Override\\n\tpublic Var getTargetVar() {\\n\t\tif (!hasTarget()) {\\n\t\t\tthrow new IllegalStateException(\"no target\");\\n\t\t}\\n\t\tinitializeTargetVar();\\n\t\treturn targetVar;\\n\t}\\n\\n\t@Override\\n\tpublic Var getTargetAnnotationVar(UnresolvedTyp"
  },
  {
    "method_id": "M1055",
    "name": "getTargetAnnotationVar",
    "return_type": "Var",
    "signature": "getTargetAnnotationVar(UnresolvedType forAnnotationType)",
    "file_id": "F23",
    "start_line": 921,
    "text_preview": "row new IllegalStateException(\"no target\");\\n\t\t}\\n\t\tinitializeTargetVar();\\n\t\treturn targetVar;\\n\t}\\n\\n\t@Override\\n\tpublic Var getTargetAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tif (!hasTarget()) {\\n\t\t\tthrow new IllegalStateException(\"no target\");\\n\t\t}\\n\t\tinitializeTargetAnnotationVars(); // FIXME asc why bother with t"
  },
  {
    "method_id": "M1056",
    "name": "if",
    "return_type": "runtime",
    "signature": "if(v == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1057",
    "name": "getArgVar",
    "return_type": "Var",
    "signature": "getArgVar(int i)",
    "file_id": "F23",
    "start_line": 935,
    "text_preview": "tationAccessVar(forAnnotationType.resolve(world), (BcelVar) getTargetVar());\\n\t\t}\\n\t\treturn v;\\n\t}\\n\\n\t@Override\\n\tpublic Var getArgVar(int i) {\\n\t\tensureInitializedArgVar(i);\\n\t\treturn argVars[i];\\n\t}\\n\\n\t@Override\\n\tpublic Var getArgAnnotationVar(int i, UnresolvedType forAnnotationType) {\\n\t\treturn new TypeAnnotationAccessVar(for"
  },
  {
    "method_id": "M1058",
    "name": "getArgAnnotationVar",
    "return_type": "Var",
    "signature": "getArgAnnotationVar(int i, UnresolvedType forAnnotationType)",
    "file_id": "F23",
    "start_line": 941,
    "text_preview": "\t@Override\\n\tpublic Var getArgVar(int i) {\\n\t\tensureInitializedArgVar(i);\\n\t\treturn argVars[i];\\n\t}\\n\\n\t@Override\\n\tpublic Var getArgAnnotationVar(int i, UnresolvedType forAnnotationType) {\\n\t\treturn new TypeAnnotationAccessVar(forAnnotationType.resolve(world), (BcelVar) getArgVar(i));\\n\t\t// initializeArgAnnotationVars();\\n\t\t//\\n"
  },
  {
    "method_id": "M1059",
    "name": "if",
    "return_type": "",
    "signature": "if(v == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1060",
    "name": "getKindedAnnotationVar",
    "return_type": "Var",
    "signature": "getKindedAnnotationVar(UnresolvedType forAnnotationType)",
    "file_id": "F23",
    "start_line": 953,
    "text_preview": "onAccessVar(forAnnotationType.resolve(world), (BcelVar) getArgVar(i));\\n\t\t// }\\n\t\t// return v;\\n\t}\\n\\n\t@Override\\n\tpublic Var getKindedAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tinitializeKindedAnnotationVars();\\n\t\treturn kindedAnnotationVars.get(forAnnotationType);\\n\t}\\n\\n\t@Override\\n\tpublic Var getWithinAnnotationVar(U"
  },
  {
    "method_id": "M1061",
    "name": "getWithinAnnotationVar",
    "return_type": "Var",
    "signature": "getWithinAnnotationVar(UnresolvedType forAnnotationType)",
    "file_id": "F23",
    "start_line": 959,
    "text_preview": " {\\n\t\tinitializeKindedAnnotationVars();\\n\t\treturn kindedAnnotationVars.get(forAnnotationType);\\n\t}\\n\\n\t@Override\\n\tpublic Var getWithinAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tinitializeWithinAnnotationVars();\\n\t\treturn withinAnnotationVars.get(forAnnotationType);\\n\t}\\n\\n\t@Override\\n\tpublic Var getWithinCodeAnnotationV"
  },
  {
    "method_id": "M1062",
    "name": "getWithinCodeAnnotationVar",
    "return_type": "Var",
    "signature": "getWithinCodeAnnotationVar(UnresolvedType forAnnotationType)",
    "file_id": "F23",
    "start_line": 965,
    "text_preview": " {\\n\t\tinitializeWithinAnnotationVars();\\n\t\treturn withinAnnotationVars.get(forAnnotationType);\\n\t}\\n\\n\t@Override\\n\tpublic Var getWithinCodeAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tinitializeWithinCodeAnnotationVars();\\n\t\treturn withincodeAnnotationVars.get(forAnnotationType);\\n\t}\\n\\n\t// reflective thisJoinPoint suppor"
  },
  {
    "method_id": "M1063",
    "name": "getThisJoinPointStaticPartVar",
    "return_type": "Var",
    "signature": "getThisJoinPointStaticPartVar()",
    "file_id": "F23",
    "start_line": 979,
    "text_preview": "intStaticPartVar = null;\\n\\n\t// private BcelVar thisEnclosingJoinPointStaticPartVar = null;\\n\\n\t@Override\\n\tpublic final Var getThisJoinPointStaticPartVar() {\\n\t\treturn getThisJoinPointStaticPartBcelVar();\\n\t}\\n\\n\t@Override\\n\tpublic final Var getThisEnclosingJoinPointStaticPartVar() {\\n\t\treturn getThisEnclosingJoinPointStaticPart"
  },
  {
    "method_id": "M1064",
    "name": "getThisEnclosingJoinPointStaticPartVar",
    "return_type": "Var",
    "signature": "getThisEnclosingJoinPointStaticPartVar()",
    "file_id": "F23",
    "start_line": 984,
    "text_preview": "al Var getThisJoinPointStaticPartVar() {\\n\t\treturn getThisJoinPointStaticPartBcelVar();\\n\t}\\n\\n\t@Override\\n\tpublic final Var getThisEnclosingJoinPointStaticPartVar() {\\n\t\treturn getThisEnclosingJoinPointStaticPartBcelVar();\\n\t}\\n\\n\tpublic void requireThisJoinPoint(boolean hasGuardTest, boolean isAround) {\\n\t\tif (!isAround) {\\n\t\t\t"
  },
  {
    "method_id": "M1065",
    "name": "requireThisJoinPoint",
    "return_type": "void",
    "signature": "requireThisJoinPoint(boolean hasGuardTest, boolean isAround)",
    "file_id": "F23",
    "start_line": 988,
    "text_preview": " Var getThisEnclosingJoinPointStaticPartVar() {\\n\t\treturn getThisEnclosingJoinPointStaticPartBcelVar();\\n\t}\\n\\n\tpublic void requireThisJoinPoint(boolean hasGuardTest, boolean isAround) {\\n\t\tif (!isAround) {\\n\t\t\tif (!hasGuardTest) {\\n\t\t\t\tisThisJoinPointLazy = false;\\n\t\t\t} else {\\n\t\t\t\tlazyTjpConsumers++;\\n\t\t\t}\\n\t\t}\\n\t\t// if (!hasGua"
  },
  {
    "method_id": "M1066",
    "name": "if",
    "return_type": "",
    "signature": "if(!isAround)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1067",
    "name": "if",
    "return_type": "",
    "signature": "if(!hasGuardTest)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1068",
    "name": "if",
    "return_type": "",
    "signature": "if(!hasGuardTest)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1069",
    "name": "if",
    "return_type": "",
    "signature": "if(thisJoinPointVar == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1070",
    "name": "getThisJoinPointVar",
    "return_type": "Var",
    "signature": "getThisJoinPointVar()",
    "file_id": "F23",
    "start_line": 1007,
    "text_preview": "\\n\t\t\tthisJoinPointVar = genTempVar(UnresolvedType.forName(\"org.aspectj.lang.JoinPoint\"));\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic Var getThisJoinPointVar() {\\n\t\trequireThisJoinPoint(false, false);\\n\t\treturn thisJoinPointVar;\\n\t}\\n\\n\tvoid initializeThisJoinPoint() {\\n\t\tif (thisJoinPointVar == null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (isThisJoinPointLa"
  },
  {
    "method_id": "M1071",
    "name": "initializeThisJoinPoint",
    "return_type": "void",
    "signature": "initializeThisJoinPoint()",
    "file_id": "F23",
    "start_line": 361,
    "text_preview": "/ lazy is default now\\n\\n\t\tbadAdvice = null;\\n\t\tfor (ShadowMunger munger : mungers) {\\n\t\t\tmunger.specializeOn(this);\\n\t\t}\\n\\n\t\tinitializeThisJoinPoint();\\n\\n\t\tif (thisJoinPointVar != null && !isThisJoinPointLazy && badAdvice != null && badAdvice.size() > 1) {\\n\t\t\t// something stopped us making it a lazy tjp\\n\t\t\t// can't build tjp"
  },
  {
    "method_id": "M1072",
    "name": "if",
    "return_type": "",
    "signature": "if(thisJoinPointVar == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1073",
    "name": "if",
    "return_type": "",
    "signature": "if(isThisJoinPointLazy)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1074",
    "name": "if",
    "return_type": "",
    "signature": "if(isThisJoinPointLazy)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1075",
    "name": "if",
    "return_type": "out",
    "signature": "if(lazyTjpConsumers == 1)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1076",
    "name": "checkLazyTjp",
    "return_type": "boolean",
    "signature": "checkLazyTjp()",
    "file_id": "F23",
    "start_line": 1018,
    "text_preview": "isJoinPoint() {\\n\t\tif (thisJoinPointVar == null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (isThisJoinPointLazy) {\\n\t\t\tisThisJoinPointLazy = checkLazyTjp();\\n\t\t}\\n\\n\t\tif (isThisJoinPointLazy) {\\n\t\t\tappliedLazyTjpOptimization = true;\\n\t\t\tcreateThisJoinPoint(); // make sure any state needed is initialized, but throw the instructions out\\n\\n\t\t\tif (l"
  },
  {
    "method_id": "M1077",
    "name": "for",
    "return_type": "advice",
    "signature": "for(ShadowMunger munger : mungers)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1078",
    "name": "if",
    "return_type": "",
    "signature": "if(munger instanceof Advice)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1079",
    "name": "loadThisJoinPoint",
    "return_type": "InstructionList",
    "signature": "loadThisJoinPoint()",
    "file_id": "F23",
    "start_line": 1062,
    "text_preview": "n[]{munger.getSourceLocation()});\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t\treturn false;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\treturn true;\\n\t}\\n\\n\tInstructionList loadThisJoinPoint() {\\n\t\tInstructionFactory fact = getFactory();\\n\t\tInstructionList il = new InstructionList();\\n\\n\t\tif (isThisJoinPointLazy) {\\n\t\t\t// If we're lazy, build the join point right here.\\n\t\t\til."
  },
  {
    "method_id": "M1080",
    "name": "if",
    "return_type": "",
    "signature": "if(isThisJoinPointLazy)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1081",
    "name": "if",
    "return_type": "retrieval",
    "signature": "if(lazyTjpConsumers > 1)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1082",
    "name": "createThisJoinPoint",
    "return_type": "InstructionList",
    "signature": "createThisJoinPoint()",
    "file_id": "F23",
    "start_line": 1023,
    "text_preview": ") {\\n\t\t\tisThisJoinPointLazy = checkLazyTjp();\\n\t\t}\\n\\n\t\tif (isThisJoinPointLazy) {\\n\t\t\tappliedLazyTjpOptimization = true;\\n\t\t\tcreateThisJoinPoint(); // make sure any state needed is initialized, but throw the instructions out\\n\\n\t\t\tif (lazyTjpConsumers == 1) {\\n\t\t\t\treturn; // special case only one lazyTjpUser\\n\t\t\t}\\n\\n\t\t\tInstructi"
  },
  {
    "method_id": "M1083",
    "name": "getThisJoinPointStaticPartBcelVar",
    "return_type": "BcelVar",
    "signature": "getThisJoinPointStaticPartBcelVar()",
    "file_id": "F23",
    "start_line": 980,
    "text_preview": "ar thisEnclosingJoinPointStaticPartVar = null;\\n\\n\t@Override\\n\tpublic final Var getThisJoinPointStaticPartVar() {\\n\t\treturn getThisJoinPointStaticPartBcelVar();\\n\t}\\n\\n\t@Override\\n\tpublic final Var getThisEnclosingJoinPointStaticPartVar() {\\n\t\treturn getThisEnclosingJoinPointStaticPartBcelVar();\\n\t}\\n\\n\tpublic void requireThisJoin"
  },
  {
    "method_id": "M1084",
    "name": "getThisAspectInstanceVar",
    "return_type": "BcelVar",
    "signature": "getThisAspectInstanceVar(ResolvedType aspectType)",
    "file_id": "F23",
    "start_line": 1135,
    "text_preview": "getThisJoinPointStaticPartBcelVar() {\\n\t\treturn getThisJoinPointStaticPartBcelVar(false);\\n\t}\\n\\n\t@Override\\n\tpublic BcelVar getThisAspectInstanceVar(ResolvedType aspectType) {\\n\t\treturn new AspectInstanceVar(aspectType);\\n\t}\\n\\n\t/**\\n\t * Get the Var for the xxxxJpStaticPart, xxx = this or enclosing\\n\t *\\n\t * @param isEnclosingJp "
  },
  {
    "method_id": "M1085",
    "name": "getThisJoinPointStaticPartBcelVar",
    "return_type": "BcelVar",
    "signature": "getThisJoinPointStaticPartBcelVar(final boolean isEnclosingJp)",
    "file_id": "F23",
    "start_line": 980,
    "text_preview": "ar thisEnclosingJoinPointStaticPartVar = null;\\n\\n\t@Override\\n\tpublic final Var getThisJoinPointStaticPartVar() {\\n\t\treturn getThisJoinPointStaticPartBcelVar();\\n\t}\\n\\n\t@Override\\n\tpublic final Var getThisEnclosingJoinPointStaticPartVar() {\\n\t\treturn getThisEnclosingJoinPointStaticPartBcelVar();\\n\t}\\n\\n\tpublic void requireThisJoin"
  },
  {
    "method_id": "M1086",
    "name": "if",
    "return_type": "",
    "signature": "if(thisJoinPointStaticPartVar == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1087",
    "name": "getThisEnclosingJoinPointStaticPartBcelVar",
    "return_type": "BcelVar",
    "signature": "getThisEnclosingJoinPointStaticPartBcelVar()",
    "file_id": "F23",
    "start_line": 985,
    "text_preview": "tThisJoinPointStaticPartBcelVar();\\n\t}\\n\\n\t@Override\\n\tpublic final Var getThisEnclosingJoinPointStaticPartVar() {\\n\t\treturn getThisEnclosingJoinPointStaticPartBcelVar();\\n\t}\\n\\n\tpublic void requireThisJoinPoint(boolean hasGuardTest, boolean isAround) {\\n\t\tif (!isAround) {\\n\t\t\tif (!hasGuardTest) {\\n\t\t\t\tisThisJoinPointLazy = false"
  },
  {
    "method_id": "M1088",
    "name": "if",
    "return_type": "",
    "signature": "if(enclosingShadow == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1089",
    "name": "getEnclosingCodeSignature",
    "return_type": "Member",
    "signature": "getEnclosingCodeSignature()",
    "file_id": "F23",
    "start_line": 1177,
    "text_preview": "StaticPartBcelVar(true);\\n\t\t}\\n\t}\\n\\n\t// ??? need to better understand all the enclosing variants\\n\t@Override\\n\tpublic Member getEnclosingCodeSignature() {\\n\t\tif (getKind().isEnclosingKind()) {\\n\t\t\treturn getSignature();\\n\t\t} else if (getKind() == Shadow.PreInitialization) {\\n\t\t\t// PreInit doesn't enclose code but its signature\\n"
  },
  {
    "method_id": "M1090",
    "name": "if",
    "return_type": "else",
    "signature": "if(enclosingShadow == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1091",
    "name": "getRealEnclosingCodeSignature",
    "return_type": "Member",
    "signature": "getRealEnclosingCodeSignature()",
    "file_id": "F23",
    "start_line": 1191,
    "text_preview": "eturn getEnclosingMethod().getMemberView();\\n\t\t} else {\\n\t\t\treturn enclosingShadow.getSignature();\\n\t\t}\\n\t}\\n\\n\tpublic Member getRealEnclosingCodeSignature() {\\n\t\treturn enclosingMethod.getMemberView();\\n\t}\\n\\n\t// public Member getEnclosingCodeSignatureForModel() {\\n\t// if (getKind().isEnclosingKind()) {\\n\t// return getSignature()"
  },
  {
    "method_id": "M1092",
    "name": "getEnclosingCodeSignatureForModel",
    "return_type": "Member",
    "signature": "getEnclosingCodeSignatureForModel()",
    "file_id": "F23",
    "start_line": 1195,
    "text_preview": "\t}\\n\t}\\n\\n\tpublic Member getRealEnclosingCodeSignature() {\\n\t\treturn enclosingMethod.getMemberView();\\n\t}\\n\\n\t// public Member getEnclosingCodeSignatureForModel() {\\n\t// if (getKind().isEnclosingKind()) {\\n\t// return getSignature();\\n\t// } else if (getKind() == Shadow.PreInitialization) {\\n\t// // PreInit doesn't enclose code but "
  },
  {
    "method_id": "M1093",
    "name": "if",
    "return_type": "else",
    "signature": "if(enclosingShadow == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1094",
    "name": "makeArgsObjectArray",
    "return_type": "InstructionList",
    "signature": "makeArgsObjectArray()",
    "file_id": "F23",
    "start_line": 1121,
    "text_preview": "Type, Type.OBJECT, Type.OBJECT, Type.OBJECT, Type.OBJECT }, Constants.INVOKESTATIC));\\n\t\t\tbreak;\\n\t\tdefault:\\n\t\t\til.append(makeArgsObjectArray());\\n\t\t\til.append(fact.createInvoke(\"org.aspectj.runtime.reflect.Factory\", \"makeJP\", LazyClassGen.tjpType, new Type[] {\\n\t\t\t\t\tLazyClassGen.staticTjpType, Type.OBJECT, Type.OBJECT, ne"
  },
  {
    "method_id": "M1095",
    "name": "initializeThisVar",
    "return_type": "void",
    "signature": "initializeThisVar()",
    "file_id": "F23",
    "start_line": 893,
    "text_preview": " false;\\n\\n\t@Override\\n\tpublic Var getThisVar() {\\n\t\tif (!hasThis()) {\\n\t\t\tthrow new IllegalStateException(\"no this\");\\n\t\t}\\n\t\tinitializeThisVar();\\n\t\treturn thisVar;\\n\t}\\n\\n\t@Override\\n\tpublic Var getThisAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tif (!hasThis()) {\\n\t\t\tthrow new IllegalStateException(\"no this\");\\n\t\t}\\n\t\tinit"
  },
  {
    "method_id": "M1096",
    "name": "if",
    "return_type": "",
    "signature": "if(thisVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1097",
    "name": "initializeTargetVar",
    "return_type": "void",
    "signature": "initializeTargetVar()",
    "file_id": "F23",
    "start_line": 916,
    "text_preview": "}\\n\\n\t@Override\\n\tpublic Var getTargetVar() {\\n\t\tif (!hasTarget()) {\\n\t\t\tthrow new IllegalStateException(\"no target\");\\n\t\t}\\n\t\tinitializeTargetVar();\\n\t\treturn targetVar;\\n\t}\\n\\n\t@Override\\n\tpublic Var getTargetAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tif (!hasTarget()) {\\n\t\t\tthrow new IllegalStateException(\"no target\");\\n"
  },
  {
    "method_id": "M1098",
    "name": "if",
    "return_type": "",
    "signature": "if(targetVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1099",
    "name": "ensureTargetTypeIsCorrect",
    "return_type": "UnresolvedType",
    "signature": "ensureTargetTypeIsCorrect(UnresolvedType tx)",
    "file_id": "F23",
    "start_line": 1258,
    "text_preview": "alizeArgVars(); // gotta pop off the args before we find the target\\n\t\t\tUnresolvedType type = getTargetType();\\n\t\t\ttype = ensureTargetTypeIsCorrect(type);\\n\t\t\ttargetVar = genTempVar(type, \"ajc$target\");\\n\t\t\trange.insert(targetVar.createStore(fact), Range.OutsideBefore);\\n\t\t\ttargetVar.setPositionInAroundState(hasThis() ? 1 :"
  },
  {
    "method_id": "M1100",
    "name": "if",
    "return_type": "",
    "signature": "if(lvt != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1101",
    "name": "ensureInitializedArgVar",
    "return_type": "void",
    "signature": "ensureInitializedArgVar(int argNumber)",
    "file_id": "F23",
    "start_line": 936,
    "text_preview": "notationType.resolve(world), (BcelVar) getTargetVar());\\n\t\t}\\n\t\treturn v;\\n\t}\\n\\n\t@Override\\n\tpublic Var getArgVar(int i) {\\n\t\tensureInitializedArgVar(i);\\n\t\treturn argVars[i];\\n\t}\\n\\n\t@Override\\n\tpublic Var getArgAnnotationVar(int i, UnresolvedType forAnnotationType) {\\n\t\treturn new TypeAnnotationAccessVar(forAnnotationType.resolv"
  },
  {
    "method_id": "M1102",
    "name": "if",
    "return_type": "",
    "signature": "if(argVars == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1103",
    "name": "for",
    "return_type": "stack",
    "signature": "for(int i = len - 1; i >= 0; i--)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1104",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < len; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1105",
    "name": "if",
    "return_type": "",
    "signature": "if(i == argNumber)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1106",
    "name": "initializeArgVars",
    "return_type": "void",
    "signature": "initializeArgVars()",
    "file_id": "F23",
    "start_line": 322,
    "text_preview": "DeclaringType().isArray()) {\\n\t\t\t\tdeletedNewAndDup = deleteNewAndDup(); // no new/dup for new array construction\\n\t\t\t}\\n\t\t\tinitializeArgVars();\\n\t\t} else if (getKind() == PreInitialization) { // pr74952\\n\t\t\tShadowRange range = getRange();\\n\t\t\trange.insert(InstructionConstants.NOP, Range.InsideAfter);\\n\t\t} else if (getKind() ="
  },
  {
    "method_id": "M1107",
    "name": "if",
    "return_type": "",
    "signature": "if(allArgVarsInitialized)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1108",
    "name": "if",
    "return_type": "",
    "signature": "if(argVars == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1109",
    "name": "for",
    "return_type": "stack",
    "signature": "for(int i = len - 1; i >= 0; i--)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1110",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < len; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1111",
    "name": "if",
    "return_type": "",
    "signature": "if(argVars[i] == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1112",
    "name": "initializeForAroundClosure",
    "return_type": "void",
    "signature": "initializeForAroundClosure()",
    "file_id": "F23",
    "start_line": 1418,
    "text_preview": "onOffset);\\n\t\t\t\t}\\n\t\t\t\tindex += type.resolve(world).getSize();\\n\t\t\t}\\n\t\t}\\n\t\tallArgVarsInitialized = true;\\n\\n\t}\\n\\n\tpublic void initializeForAroundClosure() {\\n\t\tinitializeArgVars();\\n\t\tif (hasTarget()) {\\n\t\t\tinitializeTargetVar();\\n\t\t}\\n\t\tif (hasThis()) {\\n\t\t\tinitializeThisVar();\\n\t\t\t// System.out.println(\"initialized: \" + this + \" "
  },
  {
    "method_id": "M1113",
    "name": "initializeThisAnnotationVars",
    "return_type": "void",
    "signature": "initializeThisAnnotationVars()",
    "file_id": "F23",
    "start_line": 902,
    "text_preview": "otationVar(UnresolvedType forAnnotationType) {\\n\t\tif (!hasThis()) {\\n\t\t\tthrow new IllegalStateException(\"no this\");\\n\t\t}\\n\t\tinitializeThisAnnotationVars(); // FIXME asc Why bother with this if we always return one?\\n\t\t// Even if we can't find one, we have to return one as we might have this annotation at runtime\\n\t\tVar v = t"
  },
  {
    "method_id": "M1114",
    "name": "if",
    "return_type": "",
    "signature": "if(thisAnnotationVars != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1115",
    "name": "initializeTargetAnnotationVars",
    "return_type": "void",
    "signature": "initializeTargetAnnotationVars()",
    "file_id": "F23",
    "start_line": 925,
    "text_preview": "ionVar(UnresolvedType forAnnotationType) {\\n\t\tif (!hasTarget()) {\\n\t\t\tthrow new IllegalStateException(\"no target\");\\n\t\t}\\n\t\tinitializeTargetAnnotationVars(); // FIXME asc why bother with this if we always return one?\\n\t\tVar v = targetAnnotationVars.get(forAnnotationType);\\n\t\t// Even if we can't find one, we have to return on"
  },
  {
    "method_id": "M1116",
    "name": "if",
    "return_type": "",
    "signature": "if(targetAnnotationVars != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1117",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType typeX : rtx)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1118",
    "name": "initializeArgAnnotationVars",
    "return_type": "void",
    "signature": "initializeArgAnnotationVars()",
    "file_id": "F23",
    "start_line": 943,
    "text_preview": "rAnnotationType) {\\n\t\treturn new TypeAnnotationAccessVar(forAnnotationType.resolve(world), (BcelVar) getArgVar(i));\\n\t\t// initializeArgAnnotationVars();\\n\t\t//\\n\t\t// Var v = (Var) argAnnotationVars[i].get(forAnnotationType);\\n\t\t// if (v == null) {\\n\t\t// v = new TypeAnnotationAccessVar(forAnnotationType.resolve(world), (BcelVa"
  },
  {
    "method_id": "M1119",
    "name": "if",
    "return_type": "",
    "signature": "if(argAnnotationVars != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1120",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < argAnnotationVars.length; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1121",
    "name": "getRelevantMember",
    "return_type": "ResolvedMember",
    "signature": "getRelevantMember(ResolvedMember foundMember, Member relevantMember, ResolvedType relevantType)",
    "file_id": "F23",
    "start_line": 1471,
    "text_preview": "the full set of annotations could be (due to static/dynamic type differences...)\\n\t// }\\n\t// }\\n\\n\tprotected ResolvedMember getRelevantMember(ResolvedMember foundMember, Member relevantMember, ResolvedType relevantType) {\\n\t\tif (foundMember != null) {\\n\t\t\treturn foundMember;\\n\t\t}\\n\\n\t\tfoundMember = getSignature().resolve(world)"
  },
  {
    "method_id": "M1122",
    "name": "if",
    "return_type": "",
    "signature": "if(foundMember != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1123",
    "name": "if",
    "return_type": "",
    "signature": "if(foundMember == null && relevantMember != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1124",
    "name": "for",
    "return_type": "",
    "signature": "for(ConcreteTypeMunger typeMunger : mungers)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1125",
    "name": "getAnnotations",
    "return_type": "ResolvedType[]",
    "signature": "getAnnotations(ResolvedMember foundMember, Member relevantMember, ResolvedType relevantType)",
    "file_id": "F23",
    "start_line": 1493,
    "text_preview": "\t\t\t\t// ResolvedMember o = AjcMemberMaker.interMethodBody(fakerm, typeMunger.getAspectType());\\n\t\t\t\t\t\t// // Object os = o.getAnnotations();\\n\t\t\t\t\t\t// ResolvedMember foundMember2 = findMethod(typeMunger.getAspectType(), o);\\n\t\t\t\t\t\t// Object os2 = foundMember2.getAnnotations();\\n\t\t\t\t\t\t// int stop = 1;\\n\t\t\t\t\t\t// foundMember = f"
  },
  {
    "method_id": "M1126",
    "name": "if",
    "return_type": "",
    "signature": "if(foundMember == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1127",
    "name": "for",
    "return_type": "",
    "signature": "for(ConcreteTypeMunger typeMunger : mungers)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1128",
    "name": "if",
    "return_type": "",
    "signature": "if(foundMember == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1129",
    "name": "initializeKindedAnnotationVars",
    "return_type": "void",
    "signature": "initializeKindedAnnotationVars()",
    "file_id": "F23",
    "start_line": 954,
    "text_preview": "gVar(i));\\n\t\t// }\\n\t\t// return v;\\n\t}\\n\\n\t@Override\\n\tpublic Var getKindedAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tinitializeKindedAnnotationVars();\\n\t\treturn kindedAnnotationVars.get(forAnnotationType);\\n\t}\\n\\n\t@Override\\n\tpublic Var getWithinAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tinitializeWithinAnnotati"
  },
  {
    "method_id": "M1130",
    "name": "if",
    "return_type": "",
    "signature": "if(kindedAnnotationVars != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1131",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationHolder == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1132",
    "name": "for",
    "return_type": "",
    "signature": "for(ConcreteTypeMunger typeMunger : mungers)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1133",
    "name": "if",
    "return_type": "",
    "signature": "if(annotations == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1134",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType annotationType : annotations)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1135",
    "name": "findMethod2",
    "return_type": "ResolvedMember",
    "signature": "findMethod2(ResolvedMember members[], Member sig)",
    "file_id": "F23",
    "start_line": 1565,
    "text_preview": ";\\n\t\t} else if (getKind() == Shadow.MethodCall || getKind() == Shadow.ConstructorCall) {\\n\t\t\tResolvedMember foundMember = findMethod2(relevantType.resolve(world).getDeclaredMethods(), getSignature());\\n\t\t\tannotations = getAnnotations(foundMember, shadowSignature, relevantType);\\n\t\t\tannotationHolder = getRelevantMember(foun"
  },
  {
    "method_id": "M1136",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember member : members)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1137",
    "name": "findMethod",
    "return_type": "ResolvedMember",
    "signature": "findMethod(ResolvedType aspectType, ResolvedMember ajcMethod)",
    "file_id": "F23",
    "start_line": 1494,
    "text_preview": "fakerm, typeMunger.getAspectType());\\n\t\t\t\t\t\t// // Object os = o.getAnnotations();\\n\t\t\t\t\t\t// ResolvedMember foundMember2 = findMethod(typeMunger.getAspectType(), o);\\n\t\t\t\t\t\t// Object os2 = foundMember2.getAnnotations();\\n\t\t\t\t\t\t// int stop = 1;\\n\t\t\t\t\t\t// foundMember = foundMember2;\\n\t\t\t\t\t\t// foundMember = AjcMemberMaker.interM"
  },
  {
    "method_id": "M1138",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember member : decMethods)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1139",
    "name": "findField",
    "return_type": "ResolvedMember",
    "signature": "findField(ResolvedMember[] members, Member lookingFor)",
    "file_id": "F23",
    "start_line": 1570,
    "text_preview": "pe().resolve(world);\\n\t\t} else if (getKind() == Shadow.FieldSet || getKind() == Shadow.FieldGet) {\\n\t\t\tannotationHolder = findField(relevantType.getDeclaredFields(), getSignature());\\n\\n\t\t\tif (annotationHolder == null) {\\n\t\t\t\t// check the ITD'd dooberries\\n\t\t\t\tList<ConcreteTypeMunger> mungers = relevantType.resolve(world).ge"
  },
  {
    "method_id": "M1140",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember member : members)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1141",
    "name": "initializeWithinAnnotationVars",
    "return_type": "void",
    "signature": "initializeWithinAnnotationVars()",
    "file_id": "F23",
    "start_line": 960,
    "text_preview": "ionVars.get(forAnnotationType);\\n\t}\\n\\n\t@Override\\n\tpublic Var getWithinAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tinitializeWithinAnnotationVars();\\n\t\treturn withinAnnotationVars.get(forAnnotationType);\\n\t}\\n\\n\t@Override\\n\tpublic Var getWithinCodeAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tinitializeWithinCode"
  },
  {
    "method_id": "M1142",
    "name": "if",
    "return_type": "",
    "signature": "if(withinAnnotationVars != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1143",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType ann : annotations)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1144",
    "name": "initializeWithinCodeAnnotationVars",
    "return_type": "void",
    "signature": "initializeWithinCodeAnnotationVars()",
    "file_id": "F23",
    "start_line": 966,
    "text_preview": "ars.get(forAnnotationType);\\n\t}\\n\\n\t@Override\\n\tpublic Var getWithinCodeAnnotationVar(UnresolvedType forAnnotationType) {\\n\t\tinitializeWithinCodeAnnotationVars();\\n\t\treturn withincodeAnnotationVars.get(forAnnotationType);\\n\t}\\n\\n\t// reflective thisJoinPoint support\\n\tprivate BcelVar thisJoinPointVar = null;\\n\tprivate boolean isTh"
  },
  {
    "method_id": "M1145",
    "name": "if",
    "return_type": "",
    "signature": "if(withincodeAnnotationVars != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1146",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType ann : annotations)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1147",
    "name": "weaveBefore",
    "return_type": "void",
    "signature": "weaveBefore(BcelAdvice munger)",
    "file_id": "F23",
    "start_line": 1681,
    "text_preview": "ssVar(this, k, ann, getEnclosingType(),\\n\t\t\t\t\tgetEnclosingCodeSignature(), true));\\n\t\t}\\n\t}\\n\\n\t// ---- weave methods\\n\\n\tvoid weaveBefore(BcelAdvice munger) {\\n\t\trange.insert(munger.getAdviceInstructions(this, null, range.getRealStart()), Range.InsideBefore);\\n\t}\\n\\n\tpublic void weaveAfter(BcelAdvice munger) {\\n\t\tweaveAfterThrowi"
  },
  {
    "method_id": "M1148",
    "name": "weaveAfter",
    "return_type": "void",
    "signature": "weaveAfter(BcelAdvice munger)",
    "file_id": "F23",
    "start_line": 1685,
    "text_preview": " {\\n\t\trange.insert(munger.getAdviceInstructions(this, null, range.getRealStart()), Range.InsideBefore);\\n\t}\\n\\n\tpublic void weaveAfter(BcelAdvice munger) {\\n\t\tweaveAfterThrowing(munger, UnresolvedType.THROWABLE);\\n\t\tweaveAfterReturning(munger);\\n\t}\\n\\n\t/**\\n\t * The basic strategy here is to add a set of instructions at the end o"
  },
  {
    "method_id": "M1149",
    "name": "weaveAfterReturning",
    "return_type": "void",
    "signature": "weaveAfterReturning(BcelAdvice munger)",
    "file_id": "F23",
    "start_line": 1687,
    "text_preview": "sideBefore);\\n\t}\\n\\n\tpublic void weaveAfter(BcelAdvice munger) {\\n\t\tweaveAfterThrowing(munger, UnresolvedType.THROWABLE);\\n\t\tweaveAfterReturning(munger);\\n\t}\\n\\n\t/**\\n\t * The basic strategy here is to add a set of instructions at the end of the shadow range that dispatch the advice, and then\\n\t * return whatever the shadow was g"
  },
  {
    "method_id": "M1150",
    "name": "if",
    "return_type": "",
    "signature": "if(hasReturnInstructions)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1151",
    "name": "if",
    "return_type": "",
    "signature": "if(hasReturnInstructions)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1152",
    "name": "for",
    "return_type": "",
    "signature": "for(InstructionHandle ih : returns)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1153",
    "name": "findReturnInstructions",
    "return_type": "List<InstructionHandle>",
    "signature": "findReturnInstructions()",
    "file_id": "F23",
    "start_line": 1701,
    "text_preview": "he advice specified one.\\n\t */\\n\tpublic void weaveAfterReturning(BcelAdvice munger) {\\n\t\tList<InstructionHandle> returns = findReturnInstructions();\\n\t\tboolean hasReturnInstructions = !returns.isEmpty();\\n\\n\t\t// list of instructions that handle the actual return from the join point\\n\t\tInstructionList retList = new Instruction"
  },
  {
    "method_id": "M1154",
    "name": "generateReturnInstructions",
    "return_type": "BcelVar",
    "signature": "generateReturnInstructions(List<InstructionHandle> returns, InstructionList returnInstructions)",
    "file_id": "F23",
    "start_line": 1711,
    "text_preview": "riable that holds the return value\\n\t\tBcelVar returnValueVar = null;\\n\\n\t\tif (hasReturnInstructions) {\\n\t\t\treturnValueVar = generateReturnInstructions(returns, retList);\\n\t\t} else {\\n\t\t\t// we need at least one instruction, as the target for jumps\\n\t\t\tretList.append(InstructionConstants.NOP);\\n\t\t}\\n\\n\t\t// list of instructions for"
  },
  {
    "method_id": "M1155",
    "name": "while",
    "return_type": "",
    "signature": "while(newReturnInstruction == null && i >= 0)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1156",
    "name": "hasANonVoidReturnType",
    "return_type": "boolean",
    "signature": "hasANonVoidReturnType()",
    "file_id": "F23",
    "start_line": 1760,
    "text_preview": "ions(List<InstructionHandle> returns, InstructionList returnInstructions) {\\n\t\tBcelVar returnValueVar = null;\\n\t\tif (this.hasANonVoidReturnType()) {\\n\t\t\t// Find the last *correct* return - this is a method with a non-void return type\\n\t\t\t// so ignore RETURN\\n\t\t\tInstruction newReturnInstruction = null;\\n\t\t\tint i = returns.siz"
  },
  {
    "method_id": "M1157",
    "name": "getAfterReturningAdviceDispatchInstructions",
    "return_type": "InstructionList",
    "signature": "getAfterReturningAdviceDispatchInstructions(BcelAdvice munger,\n\t\t\tInstructionHandle firstInstructionInReturnSequence)",
    "file_id": "F23",
    "start_line": 1718,
    "text_preview": "structionConstants.NOP);\\n\t\t}\\n\\n\t\t// list of instructions for dispatching to the advice itself\\n\t\tInstructionList advice = getAfterReturningAdviceDispatchInstructions(munger, retList.getStart());\\n\\n\t\tif (hasReturnInstructions) {\\n\t\t\tInstructionHandle gotoTarget = advice.getStart();\\n\t\t\tfor (InstructionHandle ih : returns) {\\n"
  },
  {
    "method_id": "M1158",
    "name": "insertAdviceInstructionsForBindingReturningParameter",
    "return_type": "BcelVar",
    "signature": "insertAdviceInstructionsForBindingReturningParameter(InstructionList advice)",
    "file_id": "F23",
    "start_line": 1803,
    "text_preview": "ructionList advice = new InstructionList();\\n\\n\t\tBcelVar tempVar = null;\\n\t\tif (munger.hasExtraParameter()) {\\n\t\t\ttempVar = insertAdviceInstructionsForBindingReturningParameter(advice);\\n\t\t}\\n\t\tadvice.append(munger.getAdviceInstructions(this, tempVar, firstInstructionInReturnSequence));\\n\t\treturn advice;\\n\t}\\n\\n\t/**\\n\t * If the a"
  },
  {
    "method_id": "M1159",
    "name": "retargetReturnInstruction",
    "return_type": "void",
    "signature": "retargetReturnInstruction(boolean hasReturningParameter, BcelVar returnValueVar, InstructionHandle gotoTarget,\n\t\t\tInstructionHandle returnHandle)",
    "file_id": "F23",
    "start_line": 1723,
    "text_preview": "eturnInstructions) {\\n\t\t\tInstructionHandle gotoTarget = advice.getStart();\\n\t\t\tfor (InstructionHandle ih : returns) {\\n\t\t\t\tretargetReturnInstruction(munger.hasExtraParameter(), returnValueVar, gotoTarget, ih);\\n\t\t\t}\\n\t\t}\\n\\n\t\trange.append(advice);\\n\t\trange.append(retList);\\n\t}\\n\\n\t/**\\n\t * @return a list of all the return instruct"
  },
  {
    "method_id": "M1160",
    "name": "if",
    "return_type": "",
    "signature": "if(returnValueVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1161",
    "name": "if",
    "return_type": "",
    "signature": "if(hasReturningParameter)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1162",
    "name": "isLastInstructionInRange",
    "return_type": "boolean",
    "signature": "isLastInstructionInRange(InstructionHandle ih, ShadowRange aRange)",
    "file_id": "F23",
    "start_line": 1854,
    "text_preview": "\t\t}\\n\t\t\t// store the return value into this var\\n\t\t\treturnValueVar.appendStore(newInstructions, getFactory());\\n\t\t}\\n\t\tif (!isLastInstructionInRange(returnHandle, range)) {\\n\t\t\tnewInstructions.append(InstructionFactory.createBranchInstruction(Constants.GOTO, gotoTarget));\\n\t\t}\\n\t\tif (newInstructions.isEmpty()) {\\n\t\t\tnewInstruc"
  },
  {
    "method_id": "M1163",
    "name": "weaveAfterThrowing",
    "return_type": "void",
    "signature": "weaveAfterThrowing(BcelAdvice munger, UnresolvedType catchType)",
    "file_id": "F23",
    "start_line": 1686,
    "text_preview": "Instructions(this, null, range.getRealStart()), Range.InsideBefore);\\n\t}\\n\\n\tpublic void weaveAfter(BcelAdvice munger) {\\n\t\tweaveAfterThrowing(munger, UnresolvedType.THROWABLE);\\n\t\tweaveAfterReturning(munger);\\n\t}\\n\\n\t/**\\n\t * The basic strategy here is to add a set of instructions at the end of the shadow range that dispatch t"
  },
  {
    "method_id": "M1164",
    "name": "weaveSoftener",
    "return_type": "void",
    "signature": "weaveSoftener(BcelAdvice munger, UnresolvedType catchType)",
    "file_id": "F23",
    "start_line": 1918,
    "text_preview": "t of code with the above weaveAfterThrowing\\n\t// ??? would be nice to abstract that to say things only once\\n\tpublic void weaveSoftener(BcelAdvice munger, UnresolvedType catchType) {\\n\t\t// a good optimization would be not to generate anything here\\n\t\t// if the shadow is GUARANTEED empty (i.e., there's NOTHING, not even\\n\t\t/"
  },
  {
    "method_id": "M1165",
    "name": "weavePerObjectEntry",
    "return_type": "void",
    "signature": "weavePerObjectEntry(final BcelAdvice munger, final BcelVar onVar)",
    "file_id": "F23",
    "start_line": 1969,
    "text_preview": "chType),\\n\t\t\t\t// high priority if our args are on the stack\\n\t\t\t\tgetKind().hasHighPriorityExceptions());\\n\t}\\n\\n\tpublic void weavePerObjectEntry(final BcelAdvice munger, final BcelVar onVar) {\\n\t\tfinal InstructionFactory fact = getFactory();\\n\\n\t\tInstructionList entryInstructions = new InstructionList();\\n\t\tInstructionList entr"
  },
  {
    "method_id": "M1166",
    "name": "weavePerTypeWithinAspectInitialization",
    "return_type": "void",
    "signature": "weavePerTypeWithinAspectInitialization(final BcelAdvice munger, UnresolvedType t)",
    "file_id": "F23",
    "start_line": 1992,
    "text_preview": "*\\n\t * Causes the aspect instance to be *set* for later retrievable through localAspectof()/aspectOf()\\n\t */\\n\tpublic void weavePerTypeWithinAspectInitialization(final BcelAdvice munger, UnresolvedType t) {\\n\t\tResolvedType tResolved = t.resolve(world);\\n\t\tif (tResolved.isInterface()) {\\n\t\t\treturn; // Don't initialize statics"
  },
  {
    "method_id": "M1167",
    "name": "weaveCflowEntry",
    "return_type": "void",
    "signature": "weaveCflowEntry(final BcelAdvice munger, final Member cflowField)",
    "file_id": "F23",
    "start_line": 2025,
    "text_preview": "Instructions.append(entrySuccessInstructions);\\n\\n\t\trange.insert(entryInstructions, Range.InsideBefore);\\n\t}\\n\\n\tpublic void weaveCflowEntry(final BcelAdvice munger, final Member cflowField) {\\n\t\tfinal boolean isPer = munger.getKind() == AdviceKind.PerCflowBelowEntry || munger.getKind() == AdviceKind.PerCflowEntry;\\n\t\tif (!is"
  },
  {
    "method_id": "M1168",
    "name": "if",
    "return_type": "",
    "signature": "if(isPer)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1169",
    "name": "if",
    "return_type": "",
    "signature": "if(cflowStateVars.length == 0)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1170",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < alen; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1171",
    "name": "getAdviceInstructions",
    "return_type": "InstructionList",
    "signature": "getAdviceInstructions(BcelShadow s, BcelVar extraArgVar, InstructionHandle ifNoAdvice)",
    "file_id": "F23",
    "start_line": 1682,
    "text_preview": "ngCodeSignature(), true));\\n\t\t}\\n\t}\\n\\n\t// ---- weave methods\\n\\n\tvoid weaveBefore(BcelAdvice munger) {\\n\t\trange.insert(munger.getAdviceInstructions(this, null, range.getRealStart()), Range.InsideBefore);\\n\t}\\n\\n\tpublic void weaveAfter(BcelAdvice munger) {\\n\t\tweaveAfterThrowing(munger, UnresolvedType.THROWABLE);\\n\t\tweaveAfterRetur"
  },
  {
    "method_id": "M1172",
    "name": "weaveAroundInline",
    "return_type": "void",
    "signature": "weaveAroundInline(BcelAdvice munger, boolean hasDynamicTest)",
    "file_id": "F23",
    "start_line": 2142,
    "text_preview": "-execution, then the new method for the advice can also be re-lined. We are not doing that presently.\\n\t */\\n\tpublic void weaveAroundInline(BcelAdvice munger, boolean hasDynamicTest) {\\n\t\t// !!! THIS BLOCK OF CODE SHOULD BE IN A METHOD CALLED weaveAround(...);\\n\t\tMember mungerSig = munger.getSignature();\\n\t\t// Member origin"
  },
  {
    "method_id": "M1173",
    "name": "if",
    "return_type": "type",
    "signature": "if(mungerSig instanceof ResolvedMember)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1174",
    "name": "if",
    "return_type": "future",
    "signature": "if(thisVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1175",
    "name": "if",
    "return_type": "",
    "signature": "if(targetVar != null && targetVar != thisVar)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1176",
    "name": "if",
    "return_type": "",
    "signature": "if(thisJoinPointVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1177",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = extraParamOffset; i < nVars; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1178",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelVar var : argsToCallLocalAdviceMethodWith)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1179",
    "name": "if",
    "return_type": "",
    "signature": "if(isAnnoStyleConcreteAspect && isAnnoStyleDeclaringAspect)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1180",
    "name": "if",
    "return_type": "shadow",
    "signature": "if(!hasDynamicTest)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1181",
    "name": "while",
    "return_type": "",
    "signature": "while(curr != end)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1182",
    "name": "while",
    "return_type": "",
    "signature": "while(curr != end)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1183",
    "name": "for",
    "return_type": "",
    "signature": "for(int slot = 0; slot < extraParamOffset; argNumber++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1184",
    "name": "isAnnotationStylePassingProceedingJoinPointOutOfAdvice",
    "return_type": "boolean",
    "signature": "isAnnotationStylePassingProceedingJoinPointOutOfAdvice(BcelAdvice munger, boolean hasDynamicTest,\n\t\t\tLazyMethodGen adviceMethod)",
    "file_id": "F23",
    "start_line": 2170,
    "text_preview": "ne()) {\\n\t\t\tweaveAroundClosure(munger, hasDynamicTest);\\n\t\t\treturn;\\n\t\t}\\n\\n\t\t// specific test for @AJ proceedInInners\\n\t\tif (isAnnotationStylePassingProceedingJoinPointOutOfAdvice(munger, hasDynamicTest, adviceMethod)) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\t// We can't inline around methods if they have around advice on them, this\\n\t\t// is bec"
  },
  {
    "method_id": "M1185",
    "name": "while",
    "return_type": "",
    "signature": "while(curr != end)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1186",
    "name": "if",
    "return_type": "",
    "signature": "if(canSeeProceedPassedToOther)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1187",
    "name": "getRedoneProceedCall",
    "return_type": "InstructionList",
    "signature": "getRedoneProceedCall(InstructionFactory fact, LazyMethodGen callbackMethod, BcelAdvice munger,\n\t\t\tLazyMethodGen localAdviceMethod, List<BcelVar> argVarList)",
    "file_id": "F23",
    "start_line": 2349,
    "text_preview": "ceedName.equals(((InvokeInstruction) inst).getMethodName(cpg))) {\\n\\n\t\t\t\t\tlocalAdviceMethod.getBody().append(curr,\\n\t\t\t\t\t\t\tgetRedoneProceedCall(fact, extractedShadowMethod, munger, localAdviceMethod, proceedVarList));\\n\t\t\t\t\tUtility.deleteInstruction(curr, localAdviceMethod);\\n\t\t\t\t}\\n\t\t\t\tcurr = next;\\n\t\t\t}\\n\t\t\t// and that's it."
  },
  {
    "method_id": "M1188",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = stateTypes.length; i < len; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1189",
    "name": "bindsThisOrTarget",
    "return_type": "boolean",
    "signature": "bindsThisOrTarget(Pointcut pointcut)",
    "file_id": "F23",
    "start_line": 2496,
    "text_preview": "eBcelType(munger.getSignature().getReturnType()), world.isInJava5Mode()));\\n\t\treturn ret;\\n\t}\\n\\n\t// private static boolean bindsThisOrTarget(Pointcut pointcut) {\\n\t// ThisTargetFinder visitor = new ThisTargetFinder();\\n\t// pointcut.accept(visitor, null);\\n\t// return visitor.bindsThisOrTarget;\\n\t// }\\n\\n\t// private static class "
  },
  {
    "method_id": "M1190",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(ThisOrTargetPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1191",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(AndPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1192",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(NotPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1193",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(OrPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1194",
    "name": "getRedoneProceedCallForAnnotationStyle",
    "return_type": "InstructionList",
    "signature": "getRedoneProceedCallForAnnotationStyle(InstructionFactory fact, LazyMethodGen callbackMethod,\n\t\t\tBcelAdvice munger, LazyMethodGen localAdviceMethod, List<BcelVar> argVarList, boolean isProceedWithArgs)",
    "file_id": "F23",
    "start_line": 2372,
    "text_preview": "isProceedWithArgs = true;\\n\t\t\t\t\t} else {\\n\t\t\t\t\t\tisProceedWithArgs = false;\\n\t\t\t\t\t}\\n\t\t\t\t\tInstructionList insteadProceedIl = getRedoneProceedCallForAnnotationStyle(fact, extractedShadowMethod, munger,\\n\t\t\t\t\t\t\tlocalAdviceMethod, proceedVarList, isProceedWithArgs);\\n\t\t\t\t\tlocalAdviceMethod.getBody().append(curr, insteadProceedIl"
  },
  {
    "method_id": "M1195",
    "name": "if",
    "return_type": "args",
    "signature": "if(isProceedWithArgs)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1196",
    "name": "if",
    "return_type": "",
    "signature": "if(pointcutBindsThis)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1197",
    "name": "if",
    "return_type": "",
    "signature": "if(pointcutBindsTarget)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1198",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = nextArgumentToProvideForCallback; i < len; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1199",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0, len=stateTypes.length; i < len; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1200",
    "name": "bindsThis",
    "return_type": "boolean",
    "signature": "bindsThis(BcelAdvice munger)",
    "file_id": "F23",
    "start_line": 2561,
    "text_preview": " arguments to process as regular arguments to the invocation at the original join point\\n\\n\t\t\tboolean pointcutBindsThis = bindsThis(munger);\\n\t\t\tboolean pointcutBindsTarget = bindsTarget(munger);\\n\t\t\tboolean targetIsSameAsThis = getKind().isTargetSameAsThis();\\n\\n\t\t\tint nextArgumentToProvideForCallback = 0;\\n\\n\t\t\tif (hasThis()"
  },
  {
    "method_id": "M1201",
    "name": "bindsTarget",
    "return_type": "boolean",
    "signature": "bindsTarget(BcelAdvice munger)",
    "file_id": "F23",
    "start_line": 2562,
    "text_preview": "vocation at the original join point\\n\\n\t\t\tboolean pointcutBindsThis = bindsThis(munger);\\n\t\t\tboolean pointcutBindsTarget = bindsTarget(munger);\\n\t\t\tboolean targetIsSameAsThis = getKind().isTargetSameAsThis();\\n\\n\t\t\tint nextArgumentToProvideForCallback = 0;\\n\\n\t\t\tif (hasThis()) {\\n\t\t\t\tif (!(pointcutBindsTarget && targetIsSameAsT"
  },
  {
    "method_id": "M1202",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(ThisOrTargetPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1203",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(AndPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1204",
    "name": "if",
    "return_type": "",
    "signature": "if(!usesThis)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1205",
    "name": "if",
    "return_type": "",
    "signature": "if(!usesThis)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1206",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(NotPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1207",
    "name": "if",
    "return_type": "",
    "signature": "if(!usesThis)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1208",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(OrPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1209",
    "name": "if",
    "return_type": "",
    "signature": "if(!usesThis)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1210",
    "name": "if",
    "return_type": "",
    "signature": "if(!usesThis)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1211",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(ThisOrTargetPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1212",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(AndPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1213",
    "name": "if",
    "return_type": "",
    "signature": "if(!usesTarget)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1214",
    "name": "if",
    "return_type": "",
    "signature": "if(!usesTarget)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1215",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(NotPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1216",
    "name": "if",
    "return_type": "",
    "signature": "if(!usesTarget)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1217",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(OrPointcut node, Object data)",
    "file_id": "F23",
    "start_line": 2505,
    "text_preview": "c class ThisTargetFinder extends IdentityPointcutVisitor {\\n\t// boolean bindsThisOrTarget = false;\\n\t//\\n\t// public Object visit(ThisOrTargetPointcut node, Object data) {\\n\t// if (node.isBinding()) {\\n\t// bindsThisOrTarget = true;\\n\t// }\\n\t// return node;\\n\t// }\\n\t//\\n\t// public Object visit(AndPointcut node, Object data) {\\n\t// "
  },
  {
    "method_id": "M1218",
    "name": "if",
    "return_type": "",
    "signature": "if(!usesTarget)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1219",
    "name": "if",
    "return_type": "",
    "signature": "if(!usesTarget)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1220",
    "name": "weaveAroundClosure",
    "return_type": "void",
    "signature": "weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest)",
    "file_id": "F23",
    "start_line": 2165,
    "text_preview": "LazyMethodGen adviceMethod = ot.getLazyClassGen().getLazyMethodGen(mungerSig);\\n\t\tif (!adviceMethod.getCanInline()) {\\n\t\t\tweaveAroundClosure(munger, hasDynamicTest);\\n\t\t\treturn;\\n\t\t}\\n\\n\t\t// specific test for @AJ proceedInInners\\n\t\tif (isAnnotationStylePassingProceedingJoinPointOutOfAdvice(munger, hasDynamicTest, adviceMethod"
  },
  {
    "method_id": "M1221",
    "name": "for",
    "return_type": "stack",
    "signature": "for(int i = 0, len = stateTypes.length; i < len; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1222",
    "name": "if",
    "return_type": "",
    "signature": "if(needAroundClosureStacking)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1223",
    "name": "if",
    "return_type": "",
    "signature": "if(needAroundClosureStacking)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1224",
    "name": "if",
    "return_type": "",
    "signature": "if(!hasDynamicTest)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1225",
    "name": "makeCallToCallback",
    "return_type": "InstructionList",
    "signature": "makeCallToCallback(LazyMethodGen callbackMethod)",
    "file_id": "F23",
    "start_line": 2319,
    "text_preview": "} else {\\n\t\t\tInstructionList afterThingie = new InstructionList(InstructionConstants.NOP);\\n\t\t\tInstructionList callback = makeCallToCallback(extractedShadowMethod);\\n\t\t\tif (terminatesWithReturn()) {\\n\t\t\t\tcallback.append(InstructionFactory.createReturn(extractedShadowMethod.getReturnType()));\\n\t\t\t} else {\\n\t\t\t\t// InstructionH"
  },
  {
    "method_id": "M1226",
    "name": "if",
    "return_type": "",
    "signature": "if(thisVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1227",
    "name": "if",
    "return_type": "",
    "signature": "if(targetVar != null && targetVar != thisVar)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1228",
    "name": "if",
    "return_type": "tjps",
    "signature": "if(thisJoinPointVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1229",
    "name": "makeClosureInstantiation",
    "return_type": "InstructionList",
    "signature": "makeClosureInstantiation(Member constructor, BcelVar holder)",
    "file_id": "F23",
    "start_line": 2864,
    "text_preview": "ion) {\\n\t\t\tclosureHolder = genTempVar(AjcMemberMaker.AROUND_CLOSURE_TYPE);\\n\t\t}\\n\\n\t\tInstructionList closureInstantiation = makeClosureInstantiation(constructorSig, closureHolder);\\n\\n\t\t/* LazyMethodGen constructor = */\\n\t\tmakeClosureClassAndReturnConstructor(closureClassName, callbackMethod, makeProceedArgumentMap(adviceVars"
  },
  {
    "method_id": "M1230",
    "name": "if",
    "return_type": "",
    "signature": "if(thisVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1231",
    "name": "if",
    "return_type": "",
    "signature": "if(targetVar != null && targetVar != thisVar)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1232",
    "name": "if",
    "return_type": "",
    "signature": "if(thisJoinPointVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1233",
    "name": "makeProceedArgumentMap",
    "return_type": "IntMap",
    "signature": "makeProceedArgumentMap(BcelVar[] adviceArgs)",
    "file_id": "F23",
    "start_line": 2459,
    "text_preview": "uments for the non-advice call.\\n\\n\t\tBcelVar[] adviceVars = munger.getExposedStateAsBcelVars(true);\\n\t\tIntMap proceedMap = makeProceedArgumentMap(adviceVars);\\n\\n\t\t// System.out.println(proceedMap + \" for \" + this);\\n\t\t// System.out.println(argVarList);\\n\\n\t\tResolvedType[] proceedParamTypes = world.resolve(munger.getSignature("
  },
  {
    "method_id": "M1234",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = adviceArgs.length; i < len; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1235",
    "name": "if",
    "return_type": "",
    "signature": "if(v == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1236",
    "name": "if",
    "return_type": "",
    "signature": "if(pos >= 0)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1237",
    "name": "makeClosureClassAndReturnConstructor",
    "return_type": "LazyMethodGen",
    "signature": "makeClosureClassAndReturnConstructor(String closureClassName, LazyMethodGen callbackMethod,\n\t\t\tIntMap proceedMap)",
    "file_id": "F23",
    "start_line": 2867,
    "text_preview": " closureInstantiation = makeClosureInstantiation(constructorSig, closureHolder);\\n\\n\t\t/* LazyMethodGen constructor = */\\n\t\tmakeClosureClassAndReturnConstructor(closureClassName, callbackMethod, makeProceedArgumentMap(adviceVars));\\n\\n\t\tInstructionList returnConversionCode;\\n\t\tif (getKind() == PreInitialization) {\\n\t\t\treturnCo"
  },
  {
    "method_id": "M1238",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = stateTypes.length; i < len; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1239",
    "name": "extractShadowInstructionsIntoNewMethod",
    "return_type": "LazyMethodGen",
    "signature": "extractShadowInstructionsIntoNewMethod(String extractedMethodName, int extractedMethodVisibilityModifier,\n\t\t\tISourceLocation adviceSourceLocation, List<String> parameterNames, boolean beingPlacedInInterface)",
    "file_id": "F23",
    "start_line": 2190,
    "text_preview": "ew ArrayList<>();\\n\t\tboolean shadowClassIsInterface = shadowClass.isInterface();\\n\t\tLazyMethodGen extractedShadowMethod = extractShadowInstructionsIntoNewMethod(extractedShadowMethodName,\\n\t\t\t\tshadowClassIsInterface?Modifier.PUBLIC:Modifier.PRIVATE,\\n\t\t\t\tmunger.getSourceLocation(), parameterNames,shadowClassIsInterface);\\n\\n"
  },
  {
    "method_id": "M1240",
    "name": "addPreInitializationReturnCode",
    "return_type": "void",
    "signature": "addPreInitializationReturnCode(LazyMethodGen extractedMethod, Type[] superConstructorTypes)",
    "file_id": "F23",
    "start_line": 3189,
    "text_preview": "(newMethod, remapper, (getKind() != PreInitialization) && isFallsThrough());\\n\t\tif (getKind() == PreInitialization) {\\n\t\t\taddPreInitializationReturnCode(newMethod, getSuperConstructorParameterTypes());\\n\t\t}\\n\t\tgetEnclosingClass().addMethodGen(newMethod, adviceSourceLocation);\\n\t\treturn newMethod;\\n\t}\\n\\n\tprivate void addPreIni"
  },
  {
    "method_id": "M1241",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = len - 1; i >= 0; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1242",
    "name": "getSuperConstructorParameterTypes",
    "return_type": "Type[]",
    "signature": "getSuperConstructorParameterTypes()",
    "file_id": "F23",
    "start_line": 2879,
    "text_preview": "undClosurePreInitializationGetter()));\\n\t\t\tstateTempVar.appendStore(returnConversionCode, fact);\\n\\n\t\t\tType[] stateTypes = getSuperConstructorParameterTypes();\\n\\n\t\t\treturnConversionCode.append(InstructionConstants.ALOAD_0); // put \"this\" back on the stack\\n\t\t\tfor (int i = 0, len = stateTypes.length; i < len; i++) {\\n\t\t\t\tUnre"
  },
  {
    "method_id": "M1243",
    "name": "makeRemap",
    "return_type": "IntMap",
    "signature": "makeRemap()",
    "file_id": "F23",
    "start_line": 3186,
    "text_preview": "en(extractedMethodName, extractedMethodVisibilityModifier, parameterNames, beingPlacedInInterface);\\n\t\tIntMap remapper = makeRemap();\\n\t\trange.extractInstructionsInto(newMethod, remapper, (getKind() != PreInitialization) && isFallsThrough());\\n\t\tif (getKind() == PreInitialization) {\\n\t\t\taddPreInitializationReturnCode(newMe"
  },
  {
    "method_id": "M1244",
    "name": "if",
    "return_type": "",
    "signature": "if(thisVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1245",
    "name": "if",
    "return_type": "",
    "signature": "if(targetVar != null && targetVar != thisVar)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1246",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelVar argVar : argVars)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1247",
    "name": "if",
    "return_type": "",
    "signature": "if(thisJoinPointVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1248",
    "name": "createShadowMethodGen",
    "return_type": "LazyMethodGen",
    "signature": "createShadowMethodGen(String newMethodName, int visibilityModifier, List<String> parameterNames, boolean beingPlacedInInterface)",
    "file_id": "F23",
    "start_line": 3185,
    "text_preview": "hod from a shadow kind (\" + getKind()\\n\t\t\t\t\t+ \") that does not support this operation\");\\n\t\t}\\n\t\tLazyMethodGen newMethod = createShadowMethodGen(extractedMethodName, extractedMethodVisibilityModifier, parameterNames, beingPlacedInInterface);\\n\t\tIntMap remapper = makeRemap();\\n\t\trange.extractInstructionsInto(newMethod, remap"
  },
  {
    "method_id": "M1249",
    "name": "if",
    "return_type": "",
    "signature": "if(targetVar != null && targetVar != thisVar)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1250",
    "name": "if",
    "return_type": "",
    "signature": "if(thisVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1251",
    "name": "if",
    "return_type": "",
    "signature": "if(pnames != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1252",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < pnames.length; i++)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1253",
    "name": "if",
    "return_type": "",
    "signature": "if(thisJoinPointVar != null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1254",
    "name": "samePackage",
    "return_type": "boolean",
    "signature": "samePackage(String p1, String p2)",
    "file_id": "F23",
    "start_line": 3303,
    "text_preview": "\\n\t\t\t// pr230075, pr197719\\n\t\t\tif (resolvedMember != null && Modifier.isProtected(resolvedMember.getModifiers())\\n\t\t\t\t\t&& !samePackage(resolvedMember.getDeclaringType().getPackageName(), getEnclosingType().getPackageName())\\n\t\t\t\t\t&& !resolvedMember.getName().equals(\"clone\")) {\\n\t\t\t\tif (!hasThis()) { // pr197719 - static acc"
  },
  {
    "method_id": "M1255",
    "name": "if",
    "return_type": "",
    "signature": "if(p1 == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1256",
    "name": "if",
    "return_type": "",
    "signature": "if(p2 == null)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1257",
    "name": "addTypeToFront",
    "return_type": "Type[]",
    "signature": "addTypeToFront(Type type, Type[] types)",
    "file_id": "F23",
    "start_line": 3318,
    "text_preview": ";\\n\t\t\t// There is a 'target' and it is not the same as 'this', so add it to the parameter list\\n\t\t\tshadowParameterTypes = addTypeToFront(BcelWorld.makeBcelType(targetType), shadowParameterTypes);\\n\t\t}\\n\\n\t\tif (thisVar != null) {\\n\t\t\tUnresolvedType thisType = getThisType();\\n\t\t\tparameterNames.add(0, \"ajc$this\");\\n\t\t\tshadowParam"
  },
  {
    "method_id": "M1258",
    "name": "addTypeToEnd",
    "return_type": "Type[]",
    "signature": "addTypeToEnd(Type type, Type[] types)",
    "file_id": "F23",
    "start_line": 3347,
    "text_preview": "ept (and pass) tjp.\\n\t\tif (thisJoinPointVar != null) {\\n\t\t\tparameterNames.add(\"thisJoinPoint\");\\n\t\t\tshadowParameterTypes = addTypeToEnd(LazyClassGen.tjpType, shadowParameterTypes);\\n\t\t}\\n\\n\t\tUnresolvedType returnType;\\n\t\tif (getKind() == PreInitialization) {\\n\t\t\treturnType = UnresolvedType.OBJECTARRAY;\\n\t\t} else {\\n\t\t\tif (getKin"
  },
  {
    "method_id": "M1259",
    "name": "genTempVar",
    "return_type": "BcelVar",
    "signature": "genTempVar(UnresolvedType utype)",
    "file_id": "F23",
    "start_line": 339,
    "text_preview": " : 0) + ((hasThis() && !getKind().isTargetSameAsThis()) ? 1 : 0);\\n\t\t\tUnresolvedType tx = getArgType(0);\\n\t\t\targVars[0] = genTempVar(tx, \"ajc$arg0\");\\n\t\t\tInstructionHandle insertedInstruction = range.insert(argVars[0].createStore(getFactory()), Range.OutsideBefore);\\n\\n\t\t\t// Now the exception range starts just after our new"
  },
  {
    "method_id": "M1260",
    "name": "genTempVar",
    "return_type": "BcelVar",
    "signature": "genTempVar(UnresolvedType typeX, String localName)",
    "file_id": "F23",
    "start_line": 339,
    "text_preview": " : 0) + ((hasThis() && !getKind().isTargetSameAsThis()) ? 1 : 0);\\n\t\t\tUnresolvedType tx = getArgType(0);\\n\t\t\targVars[0] = genTempVar(tx, \"ajc$arg0\");\\n\t\t\tInstructionHandle insertedInstruction = range.insert(argVars[0].createStore(getFactory()), Range.OutsideBefore);\\n\\n\t\t\t// Now the exception range starts just after our new"
  },
  {
    "method_id": "M1261",
    "name": "if",
    "return_type": "",
    "signature": "if(CREATE_TEMP_NAMES)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1262",
    "name": "genTempVarIndex",
    "return_type": "int",
    "signature": "genTempVarIndex(int size)",
    "file_id": "F23",
    "start_line": 3395,
    "text_preview": "lic BcelVar genTempVar(UnresolvedType utype) {\\n\t\tResolvedType rtype = utype.resolve(world);\\n\t\treturn new BcelVar(rtype, genTempVarIndex(rtype.getSize()));\\n\t}\\n\\n\t// public static final boolean CREATE_TEMP_NAMES = true;\\n\\n\tpublic BcelVar genTempVar(UnresolvedType typeX, String localName) {\\n\t\tBcelVar tv = genTempVar(typeX);"
  },
  {
    "method_id": "M1263",
    "name": "getFactory",
    "return_type": "InstructionFactory",
    "signature": "getFactory()",
    "file_id": "F23",
    "start_line": 340,
    "text_preview": "argVars[0] = genTempVar(tx, \"ajc$arg0\");\\n\t\t\tInstructionHandle insertedInstruction = range.insert(argVars[0].createStore(getFactory()), Range.OutsideBefore);\\n\\n\t\t\t// Now the exception range starts just after our new instruction.\\n\t\t\t// The next bit of code changes the exception range to point at\\n\t\t\t// the store instructio"
  },
  {
    "method_id": "M1264",
    "name": "getSourceLocation",
    "return_type": "ISourceLocation",
    "signature": "getSourceLocation()",
    "file_id": "F23",
    "start_line": 368,
    "text_preview": "ily, no suitable test...\\n\t\t\tint valid = 0;\\n\t\t\tfor (BcelAdvice element : badAdvice) {\\n\t\t\t\tISourceLocation sLoc = element.getSourceLocation();\\n\t\t\t\tif (sLoc != null && sLoc.getLine() > 0) {\\n\t\t\t\t\tvalid++;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tif (valid != 0) {\\n\t\t\t\tISourceLocation[] badLocs = new ISourceLocation[valid];\\n\t\t\t\tint i = 0;\\n\t\t\t\tfor (Bce"
  },
  {
    "method_id": "M1265",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceLine == 0 || sourceLine == -1)",
    "file_id": "F23",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1266",
    "name": "getEnclosingShadow",
    "return_type": "Shadow",
    "signature": "getEnclosingShadow()",
    "file_id": "F23",
    "start_line": 3446,
    "text_preview": "rn getEnclosingClass().getType().getSourceContext().makeSourceLocation(sourceLine, offset);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic Shadow getEnclosingShadow() {\\n\t\treturn enclosingShadow;\\n\t}\\n\\n\tpublic LazyMethodGen getEnclosingMethod() {\\n\t\treturn enclosingMethod;\\n\t}\\n\\n\tpublic boolean isFallsThrough() {\\n\t\treturn !terminatesWithReturn();\\n\t}\\n"
  },
  {
    "method_id": "M1267",
    "name": "getEnclosingMethod",
    "return_type": "LazyMethodGen",
    "signature": "getEnclosingMethod()",
    "file_id": "F23",
    "start_line": 452,
    "text_preview": "ceExecution)\\n\t\t\t\t|| (kind == StaticInitialization) || (kind == PreInitialization) || (kind == Initialization)) {\\n\t\t\tif (getEnclosingMethod().hasDeclaredLineNumberInfo()) {\\n\t\t\t\tsourceline = getEnclosingMethod().getDeclarationLineNumber();\\n\t\t\t\treturn sourceline;\\n\t\t\t}\\n\t\t}\\n\\n\t\tif (range == null) {\\n\t\t\tif (getEnclosingMethod("
  },
  {
    "method_id": "M1268",
    "name": "isFallsThrough",
    "return_type": "boolean",
    "signature": "isFallsThrough()",
    "file_id": "F23",
    "start_line": 1903,
    "text_preview": "dHandler);\\n\t\thandler.append(InstructionConstants.ATHROW);\\n\t\tInstructionHandle handlerStart = handler.getStart();\\n\\n\t\tif (isFallsThrough()) {\\n\t\t\tInstructionHandle jumpTarget = handler.append(InstructionConstants.NOP);\\n\t\t\thandler.insert(InstructionFactory.createBranchInstruction(Constants.GOTO, jumpTarget));\\n\t\t}\\n\t\tInstruc"
  },
  {
    "method_id": "M1269",
    "name": "setActualTargetType",
    "return_type": "void",
    "signature": "setActualTargetType(String className)",
    "file_id": "F23",
    "start_line": 3458,
    "text_preview": ") {\\n\t\treturn enclosingMethod;\\n\t}\\n\\n\tpublic boolean isFallsThrough() {\\n\t\treturn !terminatesWithReturn();\\n\t}\\n\\n\tpublic void setActualTargetType(String className) {\\n\t\tthis.actualInstructionTargetType = className;\\n\t}\\n\\n\tpublic String getActualTargetType() {\\n\t\treturn actualInstructionTargetType;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M1270",
    "name": "getActualTargetType",
    "return_type": "String",
    "signature": "getActualTargetType()",
    "file_id": "F23",
    "start_line": 3295,
    "text_preview": "new around body,\\n\t\t\t// they will still refer to the subtype.\\n\t\t\tif ((getKind() == FieldGet || getKind() == FieldSet) && getActualTargetType() != null\\n\t\t\t\t\t&& !getActualTargetType().equals(targetType.getName())) {\\n\t\t\t\ttargetType = UnresolvedType.forName(getActualTargetType()).resolve(world);\\n\t\t\t}\\n\t\t\tResolvedMember resol"
  },
  {
    "method_id": "M1271",
    "name": "BcelTypeMunger",
    "return_type": "",
    "signature": "BcelTypeMunger(ResolvedTypeMunger munger, ResolvedType aspectType)",
    "file_id": "F24",
    "start_line": 79,
    "text_preview": "tation;\\nimport org.aspectj.weaver.patterns.Pointcut;\\n\\npublic class BcelTypeMunger extends ConcreteTypeMunger {\\n\\n\tpublic BcelTypeMunger(ResolvedTypeMunger munger, ResolvedType aspectType) {\\n\t\tsuper(munger, aspectType);\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn \"(BcelTypeMunger \" + getMunger() + \")\";\\n\t}\\n\\n\t@Over"
  },
  {
    "method_id": "M1272",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F24",
    "start_line": 84,
    "text_preview": "Munger(ResolvedTypeMunger munger, ResolvedType aspectType) {\\n\t\tsuper(munger, aspectType);\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn \"(BcelTypeMunger \" + getMunger() + \")\";\\n\t}\\n\\n\t@Override\\n\tpublic boolean shouldOverwrite() {\\n\t\treturn false;\\n\t}\\n\\n\tpublic boolean munge(BcelClassWeaver weaver) {\\n\t\tContextToken tok "
  },
  {
    "method_id": "M1273",
    "name": "shouldOverwrite",
    "return_type": "boolean",
    "signature": "shouldOverwrite()",
    "file_id": "F24",
    "start_line": 89,
    "text_preview": "\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn \"(BcelTypeMunger \" + getMunger() + \")\";\\n\t}\\n\\n\t@Override\\n\tpublic boolean shouldOverwrite() {\\n\t\treturn false;\\n\t}\\n\\n\tpublic boolean munge(BcelClassWeaver weaver) {\\n\t\tContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.MUNGING_WITH, this)"
  },
  {
    "method_id": "M1274",
    "name": "munge",
    "return_type": "boolean",
    "signature": "munge(BcelClassWeaver weaver)",
    "file_id": "F24",
    "start_line": 93,
    "text_preview": "ypeMunger \" + getMunger() + \")\";\\n\t}\\n\\n\t@Override\\n\tpublic boolean shouldOverwrite() {\\n\t\treturn false;\\n\t}\\n\\n\tpublic boolean munge(BcelClassWeaver weaver) {\\n\t\tContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.MUNGING_WITH, this);\\n\t\tboolean changed = false;\\n\t\tboolean worthReporting = "
  },
  {
    "method_id": "M1275",
    "name": "if",
    "return_type": "",
    "signature": "if(changed && worthReporting)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1276",
    "name": "if",
    "return_type": "",
    "signature": "if(model != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1277",
    "name": "if",
    "return_type": "",
    "signature": "if(munger instanceof NewParentTypeMunger)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1278",
    "name": "if",
    "return_type": "",
    "signature": "if(declareParentsMap == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1279",
    "name": "getShortname",
    "return_type": "String",
    "signature": "getShortname(String path)",
    "file_id": "F24",
    "start_line": 187,
    "text_preview": "e();\\n\t\t\tif (tName.contains(\"no debug info available\")) {\\n\t\t\t\ttName = \"no debug info available\";\\n\t\t\t} else {\\n\t\t\t\ttName = getShortname(weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getPath());\\n\t\t\t}\\n\t\t\tString fName = getShortname(getAspectType().getSourceLocation().getSourceFile().getPath());\\n\t\t\ti"
  },
  {
    "method_id": "M1280",
    "name": "if",
    "return_type": "",
    "signature": "if(takefrom == -1)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1281",
    "name": "mungeNewAnnotationOnType",
    "return_type": "boolean",
    "signature": "mungeNewAnnotationOnType(BcelClassWeaver weaver, AnnotationOnTypeMunger munger)",
    "file_id": "F24",
    "start_line": 130,
    "text_preview": "er, (NewParentTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.AnnotationOnType) {\\n\t\t\tchanged = mungeNewAnnotationOnType(weaver, (AnnotationOnTypeMunger) munger);\\n\t\t\tworthReporting = false;\\n\t\t} else {\\n\t\t\tthrow new RuntimeException(\"unimplemented\");\\n\t\t}\\n\\n\t\tif (changed && munger.changesPublicSigna"
  },
  {
    "method_id": "M1282",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassCastException cce)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1283",
    "name": "mungeNewParent",
    "return_type": "boolean",
    "signature": "mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger typeTransformer)",
    "file_id": "F24",
    "start_line": 128,
    "text_preview": "(weaver, (NewConstructorTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.Parent) {\\n\t\t\tchanged = mungeNewParent(weaver, (NewParentTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.AnnotationOnType) {\\n\t\t\tchanged = mungeNewAnnotationOnType(weaver, (AnnotationOnTypeMunger) mun"
  },
  {
    "method_id": "M1284",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1285",
    "name": "if",
    "return_type": "",
    "signature": "if(!performChange)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1286",
    "name": "enforceDecpRule1_abstractMethodsImplemented",
    "return_type": "boolean",
    "signature": "enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weaver, ISourceLocation mungerLoc,\n\t\t\tLazyClassGen newParentTarget, ResolvedType newParent)",
    "file_id": "F24",
    "start_line": 298,
    "text_preview": "assGen();\\n\t\tResolvedType newParent = typeTransformer.getNewParent();\\n\\n\t\tboolean performChange = true;\\n\t\tperformChange = enforceDecpRule1_abstractMethodsImplemented(weaver, typeTransformer.getSourceLocation(), newParentTarget,\\n\t\t\t\tnewParent);\\n\t\tperformChange = enforceDecpRule2_cantExtendFinalClass(weaver, typeTransforme"
  },
  {
    "method_id": "M1287",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember newParentMethod : newParentMethods)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1288",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember targetMethod : targetMethods)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1289",
    "name": "if",
    "return_type": "else",
    "signature": "if(targetMethod instanceof BcelMethod)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1290",
    "name": "if",
    "return_type": "",
    "signature": "if(targetMethodGenericParameterTypes !=null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1291",
    "name": "for",
    "return_type": "",
    "signature": "for(UnresolvedType p: targetMethodGenericParameterTypes)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1292",
    "name": "if",
    "return_type": "",
    "signature": "if(discoveredImpl != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1293",
    "name": "if",
    "return_type": "",
    "signature": "if(discoveredImpl == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1294",
    "name": "if",
    "return_type": "",
    "signature": "if(actualOccurrence == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1295",
    "name": "if",
    "return_type": "",
    "signature": "if(!satisfiedByITD)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1296",
    "name": "enforceDecpRule2_cantExtendFinalClass",
    "return_type": "boolean",
    "signature": "enforceDecpRule2_cantExtendFinalClass(BcelClassWeaver weaver, ISourceLocation transformerLoc,\n\t\t\tLazyClassGen targetType, ResolvedType newParent)",
    "file_id": "F24",
    "start_line": 300,
    "text_preview": "tractMethodsImplemented(weaver, typeTransformer.getSourceLocation(), newParentTarget,\\n\t\t\t\tnewParent);\\n\t\tperformChange = enforceDecpRule2_cantExtendFinalClass(weaver, typeTransformer.getSourceLocation(), newParentTarget,\\n\t\t\t\tnewParent) && performChange;\\n\\n\t\tList<ResolvedMember> methods = newParent.getMethodsWithoutIterat"
  },
  {
    "method_id": "M1297",
    "name": "enforceDecpRule3_visibilityChanges",
    "return_type": "boolean",
    "signature": "enforceDecpRule3_visibilityChanges(BcelClassWeaver weaver, ResolvedType newParent, ResolvedMember superMethod,\n\t\t\tLazyMethodGen subMethod)",
    "file_id": "F24",
    "start_line": 312,
    "text_preview": "isStatic() && subMethod.getName().startsWith(\"access$\"))) {\\n\t\t\t\t\t\t\t// ignore generated accessors\\n\t\t\t\t\t\t\tperformChange = enforceDecpRule3_visibilityChanges(weaver, newParent, method, subMethod)\\n\t\t\t\t\t\t\t\t\t&& performChange;\\n\t\t\t\t\t\t\tperformChange = enforceDecpRule4_compatibleReturnTypes(weaver, method, subMethod) && performC"
  },
  {
    "method_id": "M1298",
    "name": "enforceDecpRule4_compatibleReturnTypes",
    "return_type": "boolean",
    "signature": "enforceDecpRule4_compatibleReturnTypes(BcelClassWeaver weaver, ResolvedMember superMethod,\n\t\t\tLazyMethodGen subMethod)",
    "file_id": "F24",
    "start_line": 314,
    "text_preview": "orceDecpRule3_visibilityChanges(weaver, newParent, method, subMethod)\\n\t\t\t\t\t\t\t\t\t&& performChange;\\n\t\t\t\t\t\t\tperformChange = enforceDecpRule4_compatibleReturnTypes(weaver, method, subMethod) && performChange;\\n\t\t\t\t\t\t\tperformChange = enforceDecpRule5_cantChangeFromStaticToNonstatic(weaver,\\n\t\t\t\t\t\t\t\t\ttypeTransformer.getSourceLo"
  },
  {
    "method_id": "M1299",
    "name": "if",
    "return_type": "",
    "signature": "if(isError == false)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1300",
    "name": "if",
    "return_type": "",
    "signature": "if(isError)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1301",
    "name": "enforceDecpRule5_cantChangeFromStaticToNonstatic",
    "return_type": "boolean",
    "signature": "enforceDecpRule5_cantChangeFromStaticToNonstatic(BcelClassWeaver weaver, ISourceLocation mungerLoc,\n\t\t\tResolvedMember superMethod, LazyMethodGen subMethod)",
    "file_id": "F24",
    "start_line": 315,
    "text_preview": "formChange = enforceDecpRule4_compatibleReturnTypes(weaver, method, subMethod) && performChange;\\n\t\t\t\t\t\t\tperformChange = enforceDecpRule5_cantChangeFromStaticToNonstatic(weaver,\\n\t\t\t\t\t\t\t\t\ttypeTransformer.getSourceLocation(), method, subMethod)\\n\t\t\t\t\t\t\t\t\t&& performChange;\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\tif (!performChange)"
  },
  {
    "method_id": "M1302",
    "name": "error",
    "return_type": "void",
    "signature": "error(BcelClassWeaver weaver, String text, ISourceLocation primaryLoc, ISourceLocation[] extraLocs)",
    "file_id": "F24",
    "start_line": 429,
    "text_preview": " should be enough, no need to check more\\n\t\t\t\t\t\t\tsatisfiedByITD = true;\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t\tif (!satisfiedByITD) {\\n\t\t\t\t\t\terror(weaver,\\n\t\t\t\t\t\t\t\t\"The type \" + newParentTarget.getName() + \" must implement the inherited abstract method \"\\n\t\t\t\t\t\t\t\t\t\t+ newParentMethod.getDeclaringType() + \".\" + newParentMethodName\\n\t\t\t\t\t\t\t\t\t\t+ "
  },
  {
    "method_id": "M1303",
    "name": "findMatchingMethod",
    "return_type": "LazyMethodGen",
    "signature": "findMatchingMethod(LazyClassGen type, ResolvedMember searchMethod)",
    "file_id": "F24",
    "start_line": 306,
    "text_preview": ");\\n\t\tfor (ResolvedMember method : methods) {\\n\t\t\tif (!method.getName().equals(\"<init>\")) {\\n\t\t\t\tLazyMethodGen subMethod = findMatchingMethod(newParentTarget, method);\\n\t\t\t\t// FIXME asc is this safe for all bridge methods?\\n\t\t\t\tif (subMethod != null && !subMethod.isBridgeMethod()) {\\n\t\t\t\t\tif (!(subMethod.isSynthetic() && met"
  },
  {
    "method_id": "M1304",
    "name": "attemptToModifySuperCalls",
    "return_type": "boolean",
    "signature": "attemptToModifySuperCalls(BcelClassWeaver weaver, LazyClassGen newParentTarget, ResolvedType newParent)",
    "file_id": "F24",
    "start_line": 330,
    "text_preview": " error message already reported\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tif (newParent.isClass()) {\\n\t\t\t// Changing the supertype\\n\t\t\tif (!attemptToModifySuperCalls(weaver, newParentTarget, newParent)) {\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t\tnewParentTarget.setSuperClass(newParent);\\n\t\t} else {\\n\t\t\t// Add a new interface\\n\t\t\tnewParentTarget.addInterfac"
  },
  {
    "method_id": "M1305",
    "name": "for",
    "return_type": "modify",
    "signature": "for(LazyMethodGen aMethod : mgs)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1306",
    "name": "while",
    "return_type": "",
    "signature": "while(handle != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1307",
    "name": "if",
    "return_type": "",
    "signature": "if(newCtor == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1308",
    "name": "if",
    "return_type": "",
    "signature": "if(!satisfiedByITDC)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1309",
    "name": "createReadableCtorSig",
    "return_type": "String",
    "signature": "createReadableCtorSig(ResolvedType newParent, ConstantPool cpg, InvokeInstruction invokeSpecial)",
    "file_id": "F24",
    "start_line": 629,
    "text_preview": "\t\t\t\t\t\t\tsatisfiedByITDC = true;\\n\t\t\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\t}\\n\\n\t\t\t\t\t\t\t\tif (!satisfiedByITDC) {\\n\t\t\t\t\t\t\t\t\tString csig = createReadableCtorSig(newParent, cpg, invokeSpecial);\\n\t\t\t\t\t\t\t\t\tweaver.getWorld()\\n\t\t\t\t\t\t\t\t\t\t\t.getMessageHandler()\\n\t\t\t\t\t\t\t\t\t\t\t.handleMessage(\\n\t\t\t\t\t\t\t\t\t\t\t\t\tMessageUtil.error(\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Unable to mo"
  },
  {
    "method_id": "M1310",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < ctorArgs.length; i++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1311",
    "name": "if",
    "return_type": "",
    "signature": "if(i + 1 < ctorArgs.length)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1312",
    "name": "getConstructorWithSignature",
    "return_type": "ResolvedMember",
    "signature": "getConstructorWithSignature(ResolvedType type, String searchSig)",
    "file_id": "F24",
    "start_line": 612,
    "text_preview": "\\n\t\t\t\t\t\t\t// 1. Check there is a ctor in the new parent with\\n\t\t\t\t\t\t\t// the same signature\\n\t\t\t\t\t\t\tResolvedMember newCtor = getConstructorWithSignature(newParent, invokeSpecial.getSignature(cpg));\\n\\n\t\t\t\t\t\t\tif (newCtor == null) {\\n\\n\t\t\t\t\t\t\t\t// 2. Check ITDCs to see if the necessary ctor is provided that way\\n\t\t\t\t\t\t\t\tboolean sat"
  },
  {
    "method_id": "M1313",
    "name": "mungePrivilegedAccess",
    "return_type": "boolean",
    "signature": "mungePrivilegedAccess(BcelClassWeaver weaver, PrivilegedAccessMunger munger)",
    "file_id": "F24",
    "start_line": 123,
    "text_preview": "eaver);\\n\t\t\tworthReporting = false;\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.PrivilegedAccess) {\\n\t\t\tchanged = mungePrivilegedAccess(weaver, (PrivilegedAccessMunger) munger);\\n\t\t\tworthReporting = false;\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.Constructor) {\\n\t\t\tchanged = mungeNewConstructor(weaver, ("
  },
  {
    "method_id": "M1314",
    "name": "addFieldGetter",
    "return_type": "void",
    "signature": "addFieldGetter(LazyClassGen gen, ResolvedMember field, ResolvedMember accessMethod)",
    "file_id": "F24",
    "start_line": 700,
    "text_preview": "e.equals(gen.getType())) {\\n\t\t\tif (member.getKind() == Member.FIELD) {\\n\t\t\t\t// System.out.println(\"matched: \" + gen);\\n\t\t\t\taddFieldGetter(gen, member,\\n\t\t\t\t\t\tAjcMemberMaker.privilegedAccessMethodForFieldGet(aspectType, member, munger.shortSyntax));\\n\t\t\t\taddFieldSetter(gen, member,\\n\t\t\t\t\t\tAjcMemberMaker.privilegedAccessMethod"
  },
  {
    "method_id": "M1315",
    "name": "addFieldSetter",
    "return_type": "void",
    "signature": "addFieldSetter(LazyClassGen gen, ResolvedMember field, ResolvedMember accessMethod)",
    "file_id": "F24",
    "start_line": 702,
    "text_preview": "etter(gen, member,\\n\t\t\t\t\t\tAjcMemberMaker.privilegedAccessMethodForFieldGet(aspectType, member, munger.shortSyntax));\\n\t\t\t\taddFieldSetter(gen, member,\\n\t\t\t\t\t\tAjcMemberMaker.privilegedAccessMethodForFieldSet(aspectType, member, munger.shortSyntax));\\n\t\t\t\treturn true;\\n\t\t\t} else if (member.getKind() == Member.METHOD) {\\n\t\t\t\tadd"
  },
  {
    "method_id": "M1316",
    "name": "addMethodDispatch",
    "return_type": "void",
    "signature": "addMethodDispatch(LazyClassGen gen, ResolvedMember method, ResolvedMember accessMethod)",
    "file_id": "F24",
    "start_line": 706,
    "text_preview": "ldSet(aspectType, member, munger.shortSyntax));\\n\t\t\t\treturn true;\\n\t\t\t} else if (member.getKind() == Member.METHOD) {\\n\t\t\t\taddMethodDispatch(gen, member, AjcMemberMaker.privilegedAccessMethodForMethod(aspectType, member));\\n\t\t\t\treturn true;\\n\t\t\t} else if (member.getKind() == Member.CONSTRUCTOR) {\\n\t\t\t\tfor (LazyMethodGen m : "
  },
  {
    "method_id": "M1317",
    "name": "for",
    "return_type": "",
    "signature": "for(Type paramType : paramTypes)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1318",
    "name": "makeMethodGen",
    "return_type": "LazyMethodGen",
    "signature": "makeMethodGen(LazyClassGen gen, ResolvedMember member)",
    "file_id": "F24",
    "start_line": 730,
    "text_preview": "private void addFieldGetter(LazyClassGen gen, ResolvedMember field, ResolvedMember accessMethod) {\\n\t\tLazyMethodGen mg = makeMethodGen(gen, accessMethod);\\n\t\tInstructionList il = new InstructionList();\\n\t\tInstructionFactory fact = gen.getFactory();\\n\t\tif (Modifier.isStatic(field.getModifiers())) {\\n\t\t\til.append(fact.createF"
  },
  {
    "method_id": "M1319",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassFormatException cfe)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1320",
    "name": "makeFieldGen",
    "return_type": "FieldGen",
    "signature": "makeFieldGen(LazyClassGen gen, ResolvedMember member)",
    "file_id": "F24",
    "start_line": 807,
    "text_preview": "r method \"+member.getName()+\" in type \"+gen.getName()+\"  ret=\"+member.getReturnType(),cfe);\\n\t\t}\\n\t}\\n\\n\tprotected FieldGen makeFieldGen(LazyClassGen gen, ResolvedMember member) {\\n\t\treturn new FieldGen(member.getModifiers(), BcelWorld.makeBcelType(member.getReturnType()), member.getName(),\\n\t\t\t\tgen.getConstantPool());\\n\t}\\n\\n\t"
  },
  {
    "method_id": "M1321",
    "name": "mungePerObjectInterface",
    "return_type": "boolean",
    "signature": "mungePerObjectInterface(BcelClassWeaver weaver, PerObjectInterfaceTypeMunger munger)",
    "file_id": "F24",
    "start_line": 116,
    "text_preview": "er.FieldHostTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.PerObjectInterface) {\\n\t\t\tchanged = mungePerObjectInterface(weaver, (PerObjectInterfaceTypeMunger) munger);\\n\t\t\tworthReporting = false;\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.PerTypeWithinInterface) {\\n\t\t\t// PTWIMPL Transform"
  },
  {
    "method_id": "M1322",
    "name": "mungePerTypeWithinTransformer",
    "return_type": "boolean",
    "signature": "mungePerTypeWithinTransformer(BcelClassWeaver weaver)",
    "file_id": "F24",
    "start_line": 120,
    "text_preview": "peMunger.PerTypeWithinInterface) {\\n\t\t\t// PTWIMPL Transform the target type (add the aspect instance field)\\n\t\t\tchanged = mungePerTypeWithinTransformer(weaver);\\n\t\t\tworthReporting = false;\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.PrivilegedAccess) {\\n\t\t\tchanged = mungePrivilegedAccess(weaver, (PrivilegedAccessMu"
  },
  {
    "method_id": "M1323",
    "name": "couldMatch",
    "return_type": "boolean",
    "signature": "couldMatch(BcelObjectType bcelObjectType, Pointcut pointcut)",
    "file_id": "F24",
    "start_line": 817,
    "text_preview": "+munger+\"] onto \"+weaver.\\n\t\t// getLazyClassGen().getClassName());\\n\t\tLazyClassGen gen = weaver.getLazyClassGen();\\n\\n\t\tif (couldMatch(gen.getBcelObjectType(), munger.getTestPointcut())) {\\n\t\t\tFieldGen fg = makeFieldGen(gen, AjcMemberMaker.perObjectField(gen.getType(), aspectType));\\n\\n\t\t\tgen.addField(fg, getSourceLocation())"
  },
  {
    "method_id": "M1324",
    "name": "mungeNewMemberType",
    "return_type": "boolean",
    "signature": "mungeNewMemberType(BcelClassWeaver classWeaver, NewMemberClassTypeMunger munger)",
    "file_id": "F24",
    "start_line": 110,
    "text_preview": "d(weaver, (NewMethodTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.InnerClass) {\\n\t\t\tchanged = mungeNewMemberType(weaver, (NewMemberClassTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.MethodDelegate2) {\\n\t\t\tchanged = mungeMethodDelegate(weaver, (MethodDelegateTypeMunger"
  },
  {
    "method_id": "M1325",
    "name": "mungeNewMethod",
    "return_type": "boolean",
    "signature": "mungeNewMethod(BcelClassWeaver classWeaver, NewMethodTypeMunger munger)",
    "file_id": "F24",
    "start_line": 108,
    "text_preview": "wField(weaver, (NewFieldTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.Method) {\\n\t\t\tchanged = mungeNewMethod(weaver, (NewMethodTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.InnerClass) {\\n\t\t\tchanged = mungeNewMemberType(weaver, (NewMemberClassTypeMunger) munger);\\n\t\t} "
  },
  {
    "method_id": "M1326",
    "name": "if",
    "return_type": "",
    "signature": "if(mungingInterface)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1327",
    "name": "if",
    "return_type": "errors",
    "signature": "if(realMember == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1328",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationsOnRealMember != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1329",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ anno : annotationsOnRealMember)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1330",
    "name": "if",
    "return_type": "",
    "signature": "if(realMember != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1331",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation declareAnnotationMC : allDecams)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1332",
    "name": "for",
    "return_type": "",
    "signature": "for(Type paramType : paramTypes)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1333",
    "name": "if",
    "return_type": "",
    "signature": "if(rtx == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1334",
    "name": "if",
    "return_type": "",
    "signature": "if(realMember == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1335",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationsOnRealMember != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1336",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotationX : annotationsOnRealMember)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1337",
    "name": "if",
    "return_type": "",
    "signature": "if(mungingInterface)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1338",
    "name": "for",
    "return_type": "",
    "signature": "for(Type paramType : paramTypes)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1339",
    "name": "createBridgeIfNecessary",
    "return_type": "void",
    "signature": "createBridgeIfNecessary(BcelClassWeaver classWeaver, NewMethodTypeMunger munger,\n\t\t\tResolvedMember unMangledInterMethod, LazyClassGen classGen)",
    "file_id": "F24",
    "start_line": 1174,
    "text_preview": " the topmostimplementor.\\n\\n\t\t\t\t// Check if the munger being processed is a parameterized form of the original munger\\n\t\t\t\tcreateBridgeIfNecessary(classWeaver, munger, unMangledInterMethod, classGen);\\n\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t} else {\\n\t\t\treturn false;\\n\t\t}\\n\t}\\n\\n\tprivate void createBridgeIfNecessary(BcelClassWeaver classWeav"
  },
  {
    "method_id": "M1340",
    "name": "for",
    "return_type": "",
    "signature": "for(int ii = 0; ii < originalParams.length; ii++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1341",
    "name": "if",
    "return_type": "",
    "signature": "if(needsbridging)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1342",
    "name": "copyOverParameterAnnotations",
    "return_type": "void",
    "signature": "copyOverParameterAnnotations(LazyMethodGen receiverMethod, ResolvedMember donorMethod)",
    "file_id": "F24",
    "start_line": 980,
    "text_preview": ", classWeaver.getWorld()));\\n\t\t\t\t\t\taddedAnnotations.add(anno.getType());\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t\tif (realMember != null) {\\n\t\t\t\t\tcopyOverParameterAnnotations(newMethod, realMember);\\n\t\t\t\t}\\n\t\t\t\t// the code below was originally added to cope with the case where an aspect declares an annotation on an ITD\\n\t\t\t\t// declared within itse"
  },
  {
    "method_id": "M1343",
    "name": "if",
    "return_type": "",
    "signature": "if(pAnnos != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1344",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = offset; i < pAnnos.length; i++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1345",
    "name": "if",
    "return_type": "",
    "signature": "if(annosOnParam != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1346",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ anno : annosOnParam)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1347",
    "name": "createBridge",
    "return_type": "void",
    "signature": "createBridge(BcelClassWeaver weaver, ResolvedMember unMangledInterMethod, LazyClassGen classGen,\n\t\t\tResolvedMember toBridgeTo)",
    "file_id": "F24",
    "start_line": 1201,
    "text_preview": "ture().equals(newParams[ii].getErasureSignature())) {\\n\t\t\t\t\tneedsbridging = true;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tif (needsbridging) {\\n\t\t\t\tcreateBridge(classWeaver, unMangledInterMethod, classGen, toBridgeTo);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate void copyOverParameterAnnotations(LazyMethodGen receiverMethod, ResolvedMember donorMethod) {\\n\t\tAnnotationA"
  },
  {
    "method_id": "M1348",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = paramTypes.length; i < len; i++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1349",
    "name": "createSignatureAttribute",
    "return_type": "Signature",
    "signature": "createSignatureAttribute(ConstantPool cp, String signature)",
    "file_id": "F24",
    "start_line": 1034,
    "text_preview": "\t\t\t\tif (!basicSignature.equals(genericSignature)) {\\n\t\t\t\t\t// Add a signature attribute to it\\n\t\t\t\t\tnewMethod.addAttribute(createSignatureAttribute(classGen.getConstantPool(), genericSignature));\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\t// XXX make sure to check that we set exceptions properly on this\\n\t\t\t// guy.\\n\t\t\tclassWeaver.addLazyMethodGen(newM"
  },
  {
    "method_id": "M1350",
    "name": "createAnyBridgeMethodsForCovariance",
    "return_type": "void",
    "signature": "createAnyBridgeMethodsForCovariance(BcelClassWeaver weaver, NewMethodTypeMunger munger,\n\t\t\tResolvedMember unMangledInterMethod, ResolvedType onType, LazyClassGen gen, Type[] paramTypes)",
    "file_id": "F24",
    "start_line": 1020,
    "text_preview": "\t\t\t\tif (classWeaver.getWorld().isInJava5Mode()) { // Don't need bridge\\n\t\t\t\t\t// methods if not in\\n\t\t\t\t\t// 1.5 mode.\\n\t\t\t\t\tcreateAnyBridgeMethodsForCovariance(classWeaver, munger, unMangledInterMethod, onType, classGen, paramTypes);\\n\t\t\t\t}\\n\\n\t\t\t} else {\\n\t\t\t\t// ??? this is okay\\n\t\t\t\t// if (!(mg.getBody() == null)) throw new\\n\t"
  },
  {
    "method_id": "M1351",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember member : localMethods)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1352",
    "name": "if",
    "return_type": "Step2",
    "signature": "if(!alreadyDone)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1353",
    "name": "if",
    "return_type": "",
    "signature": "if(supertype != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1354",
    "name": "createBridgeMethod",
    "return_type": "void",
    "signature": "createBridgeMethod(BcelWorld world, NewMethodTypeMunger munger, ResolvedMember unMangledInterMethod,\n\t\t\tLazyClassGen clazz, Type[] paramTypes, ResolvedMember theBridgeMethod)",
    "file_id": "F24",
    "start_line": 1321,
    "text_preview": "ignature().equals(localReturnTypeESig)\\n\t\t\t\t\t\t\t\t&& !Modifier.isPrivate(aMethod.getModifiers())) {\\n\t\t\t\t\t\t\t// Step3\\n\t\t\t\t\t\t\tcreateBridgeMethod(weaver.getWorld(), munger, unMangledInterMethod, gen, paramTypes, aMethod);\\n\t\t\t\t\t\t\tquitRightNow = true;\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * Create a bridge method for a parti"
  },
  {
    "method_id": "M1355",
    "name": "for",
    "return_type": "",
    "signature": "for(Type paramType : paramTypes)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1356",
    "name": "stringifyMember",
    "return_type": "String",
    "signature": "stringifyMember(ResolvedMember member)",
    "file_id": "F24",
    "start_line": 1378,
    "text_preview": "ethodGen(bridgeMethod);\\n\t}\\n\\n\t// Unlike toString() on a member, this does not include the declaring type\\n\tprivate String stringifyMember(ResolvedMember member) {\\n\t\tStringBuilder buf = new StringBuilder();\\n\t\tbuf.append(member.getReturnType().getName());\\n\t\tbuf.append(' ');\\n\t\tbuf.append(member.getName());\\n\t\tif (member.getK"
  },
  {
    "method_id": "M1357",
    "name": "if",
    "return_type": "",
    "signature": "if(params.length != 0)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1358",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 1, len = params.length; i < len; i++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1359",
    "name": "mungeMethodDelegate",
    "return_type": "boolean",
    "signature": "mungeMethodDelegate(BcelClassWeaver weaver, MethodDelegateTypeMunger munger)",
    "file_id": "F24",
    "start_line": 112,
    "text_preview": "(NewMemberClassTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.MethodDelegate2) {\\n\t\t\tchanged = mungeMethodDelegate(weaver, (MethodDelegateTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.FieldHost) {\\n\t\t\tchanged = mungeFieldHost(weaver, (MethodDelegateTypeMunger.FieldHost"
  },
  {
    "method_id": "M1360",
    "name": "if",
    "return_type": "",
    "signature": "if(shouldApply)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1361",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen m : existingMethods)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1362",
    "name": "if",
    "return_type": "",
    "signature": "if(!isOK)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1363",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember m : ms)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1364",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationsOnRealMember != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1365",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ anno : annotationsOnRealMember)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1366",
    "name": "methodOne",
    "return_type": "void",
    "signature": "methodOne()",
    "file_id": "F24",
    "start_line": 1479,
    "text_preview": "fact = gen.getFactory();\\n\\n\t\t\t// Create a delegate method body which basically looks as follows:\\n\t\t\t//\\n\t\t\t// public void methodOne() {\\n\t\t\t//   if (this.ajc$instance$MyAspect$MyMixin == null) {\\n\t\t\t//     synchronized(this) {\\n\t\t\t//       if (this.ajc$instance$MyAspect$MyMixin == null) {\\n\t\t\t//         this.ajc$instance$MyA"
  },
  {
    "method_id": "M1367",
    "name": "if",
    "return_type": "",
    "signature": "if(this.ajc$instance$MyAspect$MyMixin == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1368",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(this)",
    "file_id": "F24",
    "start_line": 1481,
    "text_preview": "s as follows:\\n\t\t\t//\\n\t\t\t// public void methodOne() {\\n\t\t\t//   if (this.ajc$instance$MyAspect$MyMixin == null) {\\n\t\t\t//     synchronized(this) {\\n\t\t\t//       if (this.ajc$instance$MyAspect$MyMixin == null) {\\n\t\t\t//         this.ajc$instance$MyAspect$MyMixin = MyAspect.aspectOf().createImplementation(this);\\n\t\t\t//       }\\n\t\t\t/"
  },
  {
    "method_id": "M1369",
    "name": "if",
    "return_type": "",
    "signature": "if(this.ajc$instance$MyAspect$MyMixin == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1370",
    "name": "for",
    "return_type": "",
    "signature": "for(Type paramType : paramTypes)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1371",
    "name": "mungeFieldHost",
    "return_type": "boolean",
    "signature": "mungeFieldHost(BcelClassWeaver weaver, MethodDelegateTypeMunger.FieldHostTypeMunger munger)",
    "file_id": "F24",
    "start_line": 114,
    "text_preview": "aver, (MethodDelegateTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.FieldHost) {\\n\t\t\tchanged = mungeFieldHost(weaver, (MethodDelegateTypeMunger.FieldHostTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.PerObjectInterface) {\\n\t\t\tchanged = mungePerObjectInterface(weaver, (P"
  },
  {
    "method_id": "M1372",
    "name": "getRealMemberForITDFromAspect",
    "return_type": "ResolvedMember",
    "signature": "getRealMemberForITDFromAspect(ResolvedType aspectType, ResolvedMember lookingFor, boolean isCtorRelated)",
    "file_id": "F24",
    "start_line": 962,
    "text_preview": "e;\\n\t\t\t\tif (aspectType.isRawType()) {\\n\t\t\t\t\ttoLookOn = aspectType.getGenericType();\\n\t\t\t\t}\\n\t\t\t\tResolvedMember realMember = getRealMemberForITDFromAspect(toLookOn, memberHoldingAnyAnnotations, false);\\n\t\t\t\t// 266602 - consider it missing to mean that the corresponding aspect had errors\\n\t\t\t\tif (realMember == null) {\\n\t\t\t\t\t// "
  },
  {
    "method_id": "M1373",
    "name": "if",
    "return_type": "",
    "signature": "if(debug)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1374",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; realMember == null && i < aspectMethods.length; i++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1375",
    "name": "if",
    "return_type": "",
    "signature": "if(memberParams.length == lookingForParams.length)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1376",
    "name": "for",
    "return_type": "erasure",
    "signature": "for(int j = 0; j < memberParams.length && matchOK; j++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1377",
    "name": "addNeededSuperCallMethods",
    "return_type": "void",
    "signature": "addNeededSuperCallMethods(BcelClassWeaver weaver, ResolvedType onType, Set<ResolvedMember> neededSuperCalls)",
    "file_id": "F24",
    "start_line": 1042,
    "text_preview": "od);\\n\t\t\tclassWeaver.getLazyClassGen().warnOnAddedMethod(newMethod.getMethod(), getSignature().getSourceLocation());\\n\\n\t\t\taddNeededSuperCallMethods(classWeaver, onType, munger.getSuperMethodsCalled());\\n\\n\t\t\treturn true;\\n\\n\t\t} else if (onInterface && !Modifier.isAbstract(unMangledInterMethod.getModifiers())) {\\n\\n\t\t\t// This m"
  },
  {
    "method_id": "M1378",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember superMethod: neededSuperCalls)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1379",
    "name": "if",
    "return_type": "",
    "signature": "if(isSuper)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1380",
    "name": "signalError",
    "return_type": "void",
    "signature": "signalError(String msgid, BcelClassWeaver weaver, UnresolvedType onType)",
    "file_id": "F24",
    "start_line": 922,
    "text_preview": "= onType.getGenericType();\\n\t\t}\\n\\n\t\t// Simple checks, can't ITD on annotations or enums\\n\t\tif (onType.isAnnotation()) {\\n\t\t\tsignalError(WeaverMessages.ITDM_ON_ANNOTATION_NOT_ALLOWED, classWeaver, onType);\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tif (onType.isEnum()) {\\n\t\t\tsignalError(WeaverMessages.ITDM_ON_ENUM_NOT_ALLOWED, classWeaver, onT"
  },
  {
    "method_id": "M1381",
    "name": "signalWarning",
    "return_type": "void",
    "signature": "signalWarning(String msgString, BcelClassWeaver weaver)",
    "file_id": "F24",
    "start_line": 965,
    "text_preview": "\t// 266602 - consider it missing to mean that the corresponding aspect had errors\\n\t\t\t\tif (realMember == null) {\\n\t\t\t\t\t// signalWarning(\"Unable to apply any annotations attached to \" + munger.getSignature(), weaver);\\n\t\t\t\t\t// throw new BCException(\"Couldn't find ITD init member '\" + interMethodBody + \"' on aspect \" + aspe"
  },
  {
    "method_id": "M1382",
    "name": "signalError",
    "return_type": "void",
    "signature": "signalError(String msgString, BcelClassWeaver weaver)",
    "file_id": "F24",
    "start_line": 922,
    "text_preview": "= onType.getGenericType();\\n\t\t}\\n\\n\t\t// Simple checks, can't ITD on annotations or enums\\n\t\tif (onType.isAnnotation()) {\\n\t\t\tsignalError(WeaverMessages.ITDM_ON_ANNOTATION_NOT_ALLOWED, classWeaver, onType);\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tif (onType.isEnum()) {\\n\t\t\tsignalError(WeaverMessages.ITDM_ON_ENUM_NOT_ALLOWED, classWeaver, onT"
  },
  {
    "method_id": "M1383",
    "name": "mungeNewConstructor",
    "return_type": "boolean",
    "signature": "mungeNewConstructor(BcelClassWeaver weaver, NewConstructorTypeMunger newConstructorTypeMunger)",
    "file_id": "F24",
    "start_line": 126,
    "text_preview": "er) munger);\\n\t\t\tworthReporting = false;\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.Constructor) {\\n\t\t\tchanged = mungeNewConstructor(weaver, (NewConstructorTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.Parent) {\\n\t\t\tchanged = mungeNewParent(weaver, (NewParentTypeMunger) munger);\\n\t\t} els"
  },
  {
    "method_id": "M1384",
    "name": "if",
    "return_type": "errors",
    "signature": "if(realMember == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1385",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationsOnRealMember != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1386",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotationX : annotationsOnRealMember)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1387",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareAnnotation decaMC : allDecams)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1388",
    "name": "if",
    "return_type": "",
    "signature": "if(toRemove != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1389",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = declaredParams.length; i < len; i++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1390",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = superParamTypes.length; i < len; i++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1391",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 1, len = postParamTypes.length; i < len; i++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1392",
    "name": "makeDispatcher",
    "return_type": "LazyMethodGen",
    "signature": "makeDispatcher(LazyClassGen onGen, String dispatchName, ResolvedMember superMethod,\n\t\t\tBcelWorld world, boolean isSuper)",
    "file_id": "F24",
    "start_line": 1691,
    "text_preview": " superMethod.getName());\\n\t\t\t\t}\\n\t\t\t\tsuperMethod = superMethod.resolve(weaver.getWorld());\\n\t\t\t\tLazyMethodGen dispatcher = makeDispatcher(gen, dispatchName, superMethod, weaver.getWorld(), isSuper);\\n\t\t\t\tweaver.addLazyMethodGen(dispatcher);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate void signalError(String msgid, BcelClassWeaver weaver, Unreso"
  },
  {
    "method_id": "M1393",
    "name": "for",
    "return_type": "",
    "signature": "for(Type paramType : paramTypes)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1394",
    "name": "if",
    "return_type": "",
    "signature": "if(isSuper)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1395",
    "name": "mungeNewField",
    "return_type": "boolean",
    "signature": "mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger)",
    "file_id": "F24",
    "start_line": 106,
    "text_preview": "lied(getAspectType())) {\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t}\\n\\n\t\tif (munger.getKind() == ResolvedTypeMunger.Field) {\\n\t\t\tchanged = mungeNewField(weaver, (NewFieldTypeMunger) munger);\\n\t\t} else if (munger.getKind() == ResolvedTypeMunger.Method) {\\n\t\t\tchanged = mungeNewMethod(weaver, (NewMethodTypeMunger) munger);\\n\t\t} else if (munger"
  },
  {
    "method_id": "M1396",
    "name": "if",
    "return_type": "",
    "signature": "if(realMember == null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1397",
    "name": "if",
    "return_type": "",
    "signature": "if(onInterface)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1398",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationsOnRealMember != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1399",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotationX : annotationsOnRealMember)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1400",
    "name": "if",
    "return_type": "mungers",
    "signature": "if(munger.version==NewFieldTypeMunger.VersionTwo)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1401",
    "name": "if",
    "return_type": "",
    "signature": "if(!alreadyExists)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1402",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationsOnRealMember != null)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1403",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotationX : annotationsOnRealMember)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1404",
    "name": "if",
    "return_type": "",
    "signature": "if(needsbridging)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1405",
    "name": "if",
    "return_type": "",
    "signature": "if(needsbridging)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1406",
    "name": "createBridgeMethodForITDF",
    "return_type": "void",
    "signature": "createBridgeMethodForITDF(BcelClassWeaver weaver, LazyClassGen gen, ResolvedMember itdfieldSetter,\n\t\t\tResolvedMember bridgingSetter)",
    "file_id": "F24",
    "start_line": 2055,
    "text_preview": "\t\tResolvedMember bridgingGetter = AjcMemberMaker.interFieldInterfaceGetter(toBridgeTo, gen.getType(), aspectType);\\n\t\t\t\t\tcreateBridgeMethodForITDF(weaver, gen, itdfieldGetter, bridgingGetter);\\n\t\t\t\t}\\n\t\t\t}\\n\\n\t\t\tResolvedMember itdfieldSetter = AjcMemberMaker.interFieldInterfaceSetter(field, gen.getType(), aspectType);\\n\t\t\tLa"
  },
  {
    "method_id": "M1407",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = paramTypes.length; i < len; i++)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1408",
    "name": "parameterizedFor",
    "return_type": "ConcreteTypeMunger",
    "signature": "parameterizedFor(ResolvedType target)",
    "file_id": "F24",
    "start_line": 413,
    "text_preview": "urrence = newParentTarget.getType().discoverActualOccurrenceOfTypeInHierarchy(genericOnType);\\n\t\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\t\tm = m.parameterizedFor(actualOccurrence);\\n\t\t\t\t\t\t\t\t\t// possible sig change when type parameters filled in\\n\t\t\t\t\t\t\t\t\tsig = m.getSignature();\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\tif (ResolvedType.matches(\\n\t\t\t\t\t\t\t\t\t\tAjcMemberMaker"
  },
  {
    "method_id": "M1409",
    "name": "parameterizeWith",
    "return_type": "ConcreteTypeMunger",
    "signature": "parameterizeWith(Map<String, UnresolvedType> m, World w)",
    "file_id": "F24",
    "start_line": 2134,
    "text_preview": ") {\\n\t\treturn new BcelTypeMunger(munger.parameterizedFor(target), aspectType);\\n\t}\\n\\n\t@Override\\n\tpublic ConcreteTypeMunger parameterizeWith(Map<String, UnresolvedType> m, World w) {\\n\t\treturn new BcelTypeMunger(munger.parameterizeWith(m, w), aspectType);\\n\t}\\n\\n\t/**\\n\t * Returns a list of type variable aliases used in this mun"
  },
  {
    "method_id": "M1410",
    "name": "m",
    "return_type": "",
    "signature": "m(List&lt;A&gt; las,List&lt;B&gt;\n\t * lbs)",
    "file_id": "F24",
    "start_line": 517,
    "text_preview": "rType.isPrimitiveType()) {\\n\t\t\t\t\tisError = true;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tif (isError == false) {\\n\t\t\t\tif (!superType.isAssignableFrom(subType)) {\\n\t\t\t\t\tisError = true;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\\n\t\t\tif (isError) {\\n\t\t\t\tweaver.getWorld()\\n\t\t\t\t\t\t.getMessageHandler()\\n\t\t\t\t\t\t.handleMessage(\\n\t\t\t\t\t\t\t\tMessageUtil.error(\"The return type is incompatible wit"
  },
  {
    "method_id": "M1411",
    "name": "getTypeVariableAliases",
    "return_type": "List<String>",
    "signature": "getTypeVariableAliases()",
    "file_id": "F24",
    "start_line": 1189,
    "text_preview": "tDeclaredSignature().parameterizedWith(null,\\n\t\t\t\t\tmungerSignature.getDeclaringType().resolve(getWorld()), false, munger.getTypeVariableAliases());\\n\t\t\tif (!toBridgeTo.getReturnType().getErasureSignature().equals(mungerSignature.getReturnType().getErasureSignature())) {\\n\t\t\t\tneedsbridging = true;\\n\t\t\t}\\n\t\t\tUnresolvedType[] "
  },
  {
    "method_id": "M1412",
    "name": "equals",
    "return_type": "boolean",
    "signature": "equals(Object other)",
    "file_id": "F24",
    "start_line": 155,
    "text_preview": "n().getType(), munger, thisAspect);\\n\\n\t\t\t\t\t// Add a relationship on the actual declaring aspect too\\n\t\t\t\t\tif (!thisAspect.equals(declaringAspect)) {\\n\t\t\t\t\t\t// Might be the case the declaring aspect is generic and thisAspect is parameterizing it. In that case\\n\t\t\t\t\t\t// record the actual parameterizations\\n\\n\t\t\t\t\t\tResolvedType"
  },
  {
    "method_id": "M1413",
    "name": "hashCode",
    "return_type": "int",
    "signature": "hashCode()",
    "file_id": "F24",
    "start_line": 2165,
    "text_preview": "andles are improved\\n\t\t// to be independent of location\\n\\n\t}\\n\\n\tprivate volatile int hashCode = 0;\\n\\n\t@Override\\n\tpublic int hashCode() {\\n\t\tif (hashCode == 0) {\\n\t\t\tint result = 17;\\n\t\t\tresult = 37 * result + ((getMunger() == null) ? 0 : getMunger().hashCode());\\n\t\t\tresult = 37 * result + ((getAspectType() == null) ? 0 : getAs"
  },
  {
    "method_id": "M1414",
    "name": "if",
    "return_type": "",
    "signature": "if(hashCode == 0)",
    "file_id": "F24",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1415",
    "name": "BcelVar",
    "return_type": "",
    "signature": "BcelVar(ResolvedType type, int slot)",
    "file_id": "F25",
    "start_line": 27,
    "text_preview": "ver.ast.Var;\\n\\npublic class BcelVar extends Var {\\n\\n\tprivate int positionInAroundState = -1;\\n\\n\tprivate int slot;\\n\\n\tpublic BcelVar(ResolvedType type, int slot) {\\n\t\tsuper(type);\\n\t\tthis.slot = slot;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"BcelVar(\" + getType() + \" \" + slot + ((positionInAroundState != -1) ? (\" \" + positio"
  },
  {
    "method_id": "M1416",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F25",
    "start_line": 32,
    "text_preview": "private int slot;\\n\\n\tpublic BcelVar(ResolvedType type, int slot) {\\n\t\tsuper(type);\\n\t\tthis.slot = slot;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"BcelVar(\" + getType() + \" \" + slot + ((positionInAroundState != -1) ? (\" \" + positionInAroundState) : \"\") +\\n\\n\t\t\")\";\\n\t}\\n\\n\tpublic int getSlot() {\\n\t\treturn slot;\\n\t}\\n\\n\t// fact is us"
  },
  {
    "method_id": "M1417",
    "name": "getSlot",
    "return_type": "int",
    "signature": "getSlot()",
    "file_id": "F25",
    "start_line": 38,
    "text_preview": "getType() + \" \" + slot + ((positionInAroundState != -1) ? (\" \" + positionInAroundState) : \"\") +\\n\\n\t\t\")\";\\n\t}\\n\\n\tpublic int getSlot() {\\n\t\treturn slot;\\n\t}\\n\\n\t// fact is used in the subtypes\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\treturn InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), slot"
  },
  {
    "method_id": "M1418",
    "name": "createLoad",
    "return_type": "Instruction",
    "signature": "createLoad(InstructionFactory fact)",
    "file_id": "F25",
    "start_line": 43,
    "text_preview": "te) : \"\") +\\n\\n\t\t\")\";\\n\t}\\n\\n\tpublic int getSlot() {\\n\t\treturn slot;\\n\t}\\n\\n\t// fact is used in the subtypes\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\treturn InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), slot);\\n\t}\\n\\n\tpublic Instruction createStore(InstructionFactory fact) {\\n\t\treturn Instructi"
  },
  {
    "method_id": "M1419",
    "name": "createStore",
    "return_type": "Instruction",
    "signature": "createStore(InstructionFactory fact)",
    "file_id": "F25",
    "start_line": 47,
    "text_preview": "actory fact) {\\n\t\treturn InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), slot);\\n\t}\\n\\n\tpublic Instruction createStore(InstructionFactory fact) {\\n\t\treturn InstructionFactory.createStore(BcelWorld.makeBcelType(getType()), slot);\\n\t}\\n\\n\tpublic void appendStore(InstructionList il, InstructionFactory fact) {\\n\t\ti"
  },
  {
    "method_id": "M1420",
    "name": "appendStore",
    "return_type": "void",
    "signature": "appendStore(InstructionList il, InstructionFactory fact)",
    "file_id": "F25",
    "start_line": 51,
    "text_preview": "ctionFactory fact) {\\n\t\treturn InstructionFactory.createStore(BcelWorld.makeBcelType(getType()), slot);\\n\t}\\n\\n\tpublic void appendStore(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createStore(fact));\\n\t}\\n\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createLoad(fact));\\n\t}\\n"
  },
  {
    "method_id": "M1421",
    "name": "appendLoad",
    "return_type": "void",
    "signature": "appendLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F25",
    "start_line": 55,
    "text_preview": "public void appendStore(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createStore(fact));\\n\t}\\n\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createLoad(fact));\\n\t}\\n\\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\\n\t\til."
  },
  {
    "method_id": "M1422",
    "name": "appendLoadAndConvert",
    "return_type": "void",
    "signature": "appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType)",
    "file_id": "F25",
    "start_line": 59,
    "text_preview": "\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createLoad(fact));\\n\t}\\n\\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\\n\t\til.append(createLoad(fact));\\n\t\tUtility.appendConversion(il, fact, getType(), toType);\\n\t}\\n\\n\tpublic void insert"
  },
  {
    "method_id": "M1423",
    "name": "insertLoad",
    "return_type": "void",
    "signature": "insertLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F25",
    "start_line": 64,
    "text_preview": "Type toType) {\\n\t\til.append(createLoad(fact));\\n\t\tUtility.appendConversion(il, fact, getType(), toType);\\n\t}\\n\\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.insert(createLoad(fact));\\n\t}\\n\\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tInstructionList il = new I"
  },
  {
    "method_id": "M1424",
    "name": "createCopyFrom",
    "return_type": "InstructionList",
    "signature": "createCopyFrom(InstructionFactory fact, int oldSlot)",
    "file_id": "F25",
    "start_line": 68,
    "text_preview": "id insertLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.insert(createLoad(fact));\\n\t}\\n\\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tInstructionList il = new InstructionList();\\n\t\til.append(InstructionFactory.createLoad(BcelWorld.makeBcelType(getType()), oldSlot));\\n\t\til.append"
  },
  {
    "method_id": "M1425",
    "name": "appendConvertableArrayLoad",
    "return_type": "void",
    "signature": "appendConvertableArrayLoad(InstructionList il, InstructionFactory fact, int index, ResolvedType convertTo)",
    "file_id": "F25",
    "start_line": 76,
    "text_preview": "rld.makeBcelType(getType()), oldSlot));\\n\t\til.append(createStore(fact));\\n\t\treturn il;\\n\t}\\n\\n\t// this is an array var\\n\tvoid appendConvertableArrayLoad(InstructionList il, InstructionFactory fact, int index, ResolvedType convertTo) {\\n\t\tResolvedType convertFromType = getType().getResolvedComponentType();\\n\t\tappendLoad(il, fac"
  },
  {
    "method_id": "M1426",
    "name": "appendConvertableArrayStore",
    "return_type": "void",
    "signature": "appendConvertableArrayStore(InstructionList il, InstructionFactory fact, int index, BcelVar storee)",
    "file_id": "F25",
    "start_line": 84,
    "text_preview": "(BcelWorld.makeBcelType(convertFromType)));\\n\t\tUtility.appendConversion(il, fact, convertFromType, convertTo);\\n\t}\\n\\n\tvoid appendConvertableArrayStore(InstructionList il, InstructionFactory fact, int index, BcelVar storee) {\\n\t\tResolvedType convertToType = getType().getResolvedComponentType();\\n\t\tappendLoad(il, fact);\\n\t\til."
  },
  {
    "method_id": "M1427",
    "name": "createConvertableArrayStore",
    "return_type": "InstructionList",
    "signature": "createConvertableArrayStore(InstructionFactory fact, int index, BcelVar storee)",
    "file_id": "F25",
    "start_line": 93,
    "text_preview": "tToType);\\n\t\til.append(InstructionFactory.createArrayStore(BcelWorld.makeBcelType(convertToType)));\\n\t}\\n\\n\tInstructionList createConvertableArrayStore(InstructionFactory fact, int index, BcelVar storee) {\\n\t\tInstructionList il = new InstructionList();\\n\t\tappendConvertableArrayStore(il, fact, index, storee);\\n\t\treturn il;\\n\t}\\n"
  },
  {
    "method_id": "M1428",
    "name": "createConvertableArrayLoad",
    "return_type": "InstructionList",
    "signature": "createConvertableArrayLoad(InstructionFactory fact, int index, ResolvedType convertTo)",
    "file_id": "F25",
    "start_line": 99,
    "text_preview": "t il = new InstructionList();\\n\t\tappendConvertableArrayStore(il, fact, index, storee);\\n\t\treturn il;\\n\t}\\n\\n\tInstructionList createConvertableArrayLoad(InstructionFactory fact, int index, ResolvedType convertTo) {\\n\t\tInstructionList il = new InstructionList();\\n\t\tappendConvertableArrayLoad(il, fact, index, convertTo);\\n\t\tretur"
  },
  {
    "method_id": "M1429",
    "name": "getPositionInAroundState",
    "return_type": "int",
    "signature": "getPositionInAroundState()",
    "file_id": "F25",
    "start_line": 105,
    "text_preview": "List il = new InstructionList();\\n\t\tappendConvertableArrayLoad(il, fact, index, convertTo);\\n\t\treturn il;\\n\t}\\n\\n\tpublic int getPositionInAroundState() {\\n\t\treturn positionInAroundState;\\n\t}\\n\\n\tpublic void setPositionInAroundState(int positionInAroundState) {\\n\t\tthis.positionInAroundState = positionInAroundState;\\n\t}\\n\\n\t// random"
  },
  {
    "method_id": "M1430",
    "name": "setPositionInAroundState",
    "return_type": "void",
    "signature": "setPositionInAroundState(int positionInAroundState)",
    "file_id": "F25",
    "start_line": 109,
    "text_preview": " convertTo);\\n\t\treturn il;\\n\t}\\n\\n\tpublic int getPositionInAroundState() {\\n\t\treturn positionInAroundState;\\n\t}\\n\\n\tpublic void setPositionInAroundState(int positionInAroundState) {\\n\t\tthis.positionInAroundState = positionInAroundState;\\n\t}\\n\\n\t// random useful fields\\n\\n\tpublic static final BcelVar[] NONE = new BcelVar[] {};\\n\\n}\\n"
  },
  {
    "method_id": "M1431",
    "name": "BcelWeakClassLoaderReference",
    "return_type": "",
    "signature": "BcelWeakClassLoaderReference(ClassLoader loader)",
    "file_id": "F26",
    "start_line": 38,
    "text_preview": "/\\npublic class BcelWeakClassLoaderReference extends WeakClassLoaderReference implements ClassLoaderReference {\\n\\n\tpublic BcelWeakClassLoaderReference(ClassLoader loader) {\\n\t\tsuper(loader);\\n\t}\\n\\n\tpublic boolean equals(Object obj) {\\n\t\tif (!(obj instanceof BcelWeakClassLoaderReference))\\n\t\t\treturn false;\\n\t\tBcelWeakClassLoade"
  },
  {
    "method_id": "M1432",
    "name": "equals",
    "return_type": "boolean",
    "signature": "equals(Object obj)",
    "file_id": "F26",
    "start_line": 42,
    "text_preview": "ClassLoaderReference {\\n\\n\tpublic BcelWeakClassLoaderReference(ClassLoader loader) {\\n\t\tsuper(loader);\\n\t}\\n\\n\tpublic boolean equals(Object obj) {\\n\t\tif (!(obj instanceof BcelWeakClassLoaderReference))\\n\t\t\treturn false;\\n\t\tBcelWeakClassLoaderReference other = (BcelWeakClassLoaderReference) obj;\\n\t\treturn (other.hashcode == hashc"
  },
  {
    "method_id": "M1433",
    "name": "BcelWeaver",
    "return_type": "",
    "signature": "BcelWeaver(BcelWorld world)",
    "file_id": "F27",
    "start_line": 132,
    "text_preview": "atchWeave = true;\\n\\n\tprivate ZipOutputStream zipOutputStream;\\n\tprivate CustomMungerFactory customMungerFactory;\\n\\n\tpublic BcelWeaver(BcelWorld world) {\\n\t\tsuper();\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"<init>\", this, world);\\n\t\t}\\n\t\tthis.world = world;\\n\t\tthis.xcutSet = world.getCrosscuttingMembersSet();\\n\t\tif (trac"
  },
  {
    "method_id": "M1434",
    "name": "addLibraryAspect",
    "return_type": "ResolvedType",
    "signature": "addLibraryAspect(String aspectName)",
    "file_id": "F27",
    "start_line": 150,
    "text_preview": "t DOT for static inner classes as well as DOLLAR\\n\t *\\n\t * @param aspectName\\n\t * @return aspect\\n\t */\\n\tpublic ResolvedType addLibraryAspect(String aspectName) {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"addLibraryAspect\", this, aspectName);\\n\t\t}\\n\\n\t\t// 1 - resolve as is\\n\t\tUnresolvedType unresolvedT = UnresolvedType.fo"
  },
  {
    "method_id": "M1435",
    "name": "while",
    "return_type": "",
    "signature": "while(hasDot > 0)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1436",
    "name": "addLibraryJarFile",
    "return_type": "void",
    "signature": "addLibraryJarFile(File inFile)",
    "file_id": "F27",
    "start_line": 233,
    "text_preview": "return null;\\n\t\t}\\n\t}\\n\\n\t/**\\n\t *\\n\t * @param inFile directory containing classes or zip/jar class archive\\n\t */\\n\tpublic void addLibraryJarFile(File inFile) throws IOException {\\n\t\tList<ResolvedType> addedAspects = null;\\n\t\tif (inFile.isDirectory()) {\\n\t\t\taddedAspects = addAspectsFromDirectory(inFile);\\n\t\t} else {\\n\t\t\taddedAspect"
  },
  {
    "method_id": "M1437",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType addedAspect : addedAspects)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1438",
    "name": "addAspectsFromJarFile",
    "return_type": "List<ResolvedType>",
    "signature": "addAspectsFromJarFile(File inFile)",
    "file_id": "F27",
    "start_line": 238,
    "text_preview": "s = null;\\n\t\tif (inFile.isDirectory()) {\\n\t\t\taddedAspects = addAspectsFromDirectory(inFile);\\n\t\t} else {\\n\t\t\taddedAspects = addAspectsFromJarFile(inFile);\\n\t\t}\\n\t\tfor (ResolvedType addedAspect : addedAspects) {\\n\t\t\txcutSet.addOrReplaceAspect(addedAspect);\\n\t\t}\\n\t}\\n\\n\tprivate List<ResolvedType> addAspectsFromJarFile(File inFile) "
  },
  {
    "method_id": "M1439",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1440",
    "name": "if",
    "return_type": "",
    "signature": "if(entry == null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1441",
    "name": "addAspectsFromDirectory",
    "return_type": "List<ResolvedType>",
    "signature": "addAspectsFromDirectory(File directory)",
    "file_id": "F27",
    "start_line": 236,
    "text_preview": " inFile) throws IOException {\\n\t\tList<ResolvedType> addedAspects = null;\\n\t\tif (inFile.isDirectory()) {\\n\t\t\taddedAspects = addAspectsFromDirectory(inFile);\\n\t\t} else {\\n\t\t\taddedAspects = addAspectsFromJarFile(inFile);\\n\t\t}\\n\t\tfor (ResolvedType addedAspect : addedAspects) {\\n\t\t\txcutSet.addOrReplaceAspect(addedAspect);\\n\t\t}\\n\t}\\n\\n\t"
  },
  {
    "method_id": "M1442",
    "name": "listFiles",
    "return_type": "",
    "signature": "listFiles(directory, new FileFilter()",
    "file_id": "F27",
    "start_line": 290,
    "text_preview": "eNotFoundException, IOException {\\n\t\tList<ResolvedType> addedAspects = new ArrayList<>();\\n\t\tFile[] classFiles = FileUtil.listFiles(directory, new FileFilter() {\\n\t\t\tpublic boolean accept(File pathname) {\\n\t\t\t\treturn pathname.getName().endsWith(\".class\");\\n\t\t\t}\\n\t\t});\\n\t\tfor (File classFile : classFiles) {\\n\t\t\tFileInputStream "
  },
  {
    "method_id": "M1443",
    "name": "accept",
    "return_type": "boolean",
    "signature": "accept(File pathname)",
    "file_id": "F27",
    "start_line": 291,
    "text_preview": "edAspects = new ArrayList<>();\\n\t\tFile[] classFiles = FileUtil.listFiles(directory, new FileFilter() {\\n\t\t\tpublic boolean accept(File pathname) {\\n\t\t\t\treturn pathname.getName().endsWith(\".class\");\\n\t\t\t}\\n\t\t});\\n\t\tfor (File classFile : classFiles) {\\n\t\t\tFileInputStream fis = new FileInputStream(classFile);\\n\t\t\tbyte[] classBytes"
  },
  {
    "method_id": "M1444",
    "name": "for",
    "return_type": "",
    "signature": "for(File classFile : classFiles)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1445",
    "name": "if",
    "return_type": "",
    "signature": "if(aspectType != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1446",
    "name": "isAspect",
    "return_type": "ResolvedType",
    "signature": "isAspect(byte[] classbytes, String name, File dir)",
    "file_id": "F27",
    "start_line": 179,
    "text_preview": ".isMissing()) {\\n\t\t\t\t\tbreak;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\t// System.out.println(\"type: \" + type + \" for \" + aspectName);\\n\t\tif (type.isAspect()) {\\n\t\t\t// Bug 119657 ensure we use the unwoven aspect\\n\t\t\tWeaverStateInfo wsi = type.getWeaverState();\\n\t\t\tif (wsi != null && wsi.isReweavable()) {\\n\t\t\t\tBcelObjectType classType = getClassType("
  },
  {
    "method_id": "M1447",
    "name": "if",
    "return_type": "",
    "signature": "if(end == -1)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1448",
    "name": "addDirectoryContents",
    "return_type": "List<UnwovenClassFile>",
    "signature": "addDirectoryContents(File inFile, File outDir)",
    "file_id": "F27",
    "start_line": 352,
    "text_preview": "ctory (or its\\n\t * subdirectories) are considered resources and are also copied.\\n\t *\\n\t */\\n\tpublic List<UnwovenClassFile> addDirectoryContents(File inFile, File outDir) throws IOException {\\n\t\tList<UnwovenClassFile> addedClassFiles = new ArrayList<>();\\n\\n\t\t// Get a list of all files (i.e. everything that isnt a directory)\\n"
  },
  {
    "method_id": "M1449",
    "name": "listFiles",
    "return_type": "",
    "signature": "listFiles(inFile, new FileFilter()",
    "file_id": "F27",
    "start_line": 290,
    "text_preview": "eNotFoundException, IOException {\\n\t\tList<ResolvedType> addedAspects = new ArrayList<>();\\n\t\tFile[] classFiles = FileUtil.listFiles(directory, new FileFilter() {\\n\t\t\tpublic boolean accept(File pathname) {\\n\t\t\t\treturn pathname.getName().endsWith(\".class\");\\n\t\t\t}\\n\t\t});\\n\t\tfor (File classFile : classFiles) {\\n\t\t\tFileInputStream "
  },
  {
    "method_id": "M1450",
    "name": "accept",
    "return_type": "boolean",
    "signature": "accept(File f)",
    "file_id": "F27",
    "start_line": 291,
    "text_preview": "edAspects = new ArrayList<>();\\n\t\tFile[] classFiles = FileUtil.listFiles(directory, new FileFilter() {\\n\t\t\tpublic boolean accept(File pathname) {\\n\t\t\t\treturn pathname.getName().endsWith(\".class\");\\n\t\t\t}\\n\t\t});\\n\t\tfor (File classFile : classFiles) {\\n\t\t\tFileInputStream fis = new FileInputStream(classFile);\\n\t\t\tbyte[] classBytes"
  },
  {
    "method_id": "M1451",
    "name": "for",
    "return_type": "resource",
    "signature": "for(File file : files)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1452",
    "name": "addJarFile",
    "return_type": "List<UnwovenClassFile>",
    "signature": "addJarFile(File inFile, File outDir, boolean canBeDirectory)",
    "file_id": "F27",
    "start_line": 374,
    "text_preview": "tDir));\\n\t\t}\\n\\n\t\treturn addedClassFiles;\\n\t}\\n\\n\t/**\\n\t * Adds all class files in the jar\\n\t */\\n\tpublic List<UnwovenClassFile> addJarFile(File inFile, File outDir, boolean canBeDirectory) {\\n\t\t// System.err.println(\"? addJarFile(\" + inFile + \", \" + outDir + \")\");\\n\t\tList<UnwovenClassFile> addedClassFiles = new ArrayList<>();\\n\t\t"
  },
  {
    "method_id": "M1453",
    "name": "catch",
    "return_type": "",
    "signature": "catch(FileNotFoundException ex)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1454",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ex)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1455",
    "name": "if",
    "return_type": "",
    "signature": "if(inJar != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1456",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ex)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1457",
    "name": "needToReweaveWorld",
    "return_type": "boolean",
    "signature": "needToReweaveWorld()",
    "file_id": "F27",
    "start_line": 446,
    "text_preview": ");\\n\t\t\t\t\tworld.getMessageHandler().handleMessage(message);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\treturn addedClassFiles;\\n\t}\\n\\n\tpublic boolean needToReweaveWorld() {\\n\t\treturn needToReweaveWorld;\\n\t}\\n\\n\t/**\\n\t * Should be addOrReplace\\n\t */\\n\tpublic ReferenceType addClassFile(UnwovenClassFile classFile, boolean fromInpath) {\\n\t\taddedClasses.add(cla"
  },
  {
    "method_id": "M1458",
    "name": "addClassFile",
    "return_type": "ReferenceType",
    "signature": "addClassFile(UnwovenClassFile classFile, boolean fromInpath)",
    "file_id": "F27",
    "start_line": 365,
    "text_preview": " For each file, add it either as a real .class file or as a resource\\n\t\tfor (File file : files) {\\n\t\t\taddedClassFiles.add(addClassFile(file, inFile, outDir));\\n\t\t}\\n\\n\t\treturn addedClassFiles;\\n\t}\\n\\n\t/**\\n\t * Adds all class files in the jar\\n\t */\\n\tpublic List<UnwovenClassFile> addJarFile(File inFile, File outDir, boolean canBeD"
  },
  {
    "method_id": "M1459",
    "name": "if",
    "return_type": "",
    "signature": "if(fromInpath)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1460",
    "name": "addClassFile",
    "return_type": "UnwovenClassFile",
    "signature": "addClassFile(File classFile, File inPathDir, File outDir)",
    "file_id": "F27",
    "start_line": 365,
    "text_preview": " For each file, add it either as a real .class file or as a resource\\n\t\tfor (File file : files) {\\n\t\t\taddedClassFiles.add(addClassFile(file, inFile, outDir));\\n\t\t}\\n\\n\t\treturn addedClassFiles;\\n\t}\\n\\n\t/**\\n\t * Adds all class files in the jar\\n\t */\\n\tpublic List<UnwovenClassFile> addJarFile(File inFile, File outDir, boolean canBeD"
  },
  {
    "method_id": "M1461",
    "name": "deleteClassFile",
    "return_type": "void",
    "signature": "deleteClassFile(String typename)",
    "file_id": "F27",
    "start_line": 486,
    "text_preview": " this.addClassFile(ucf, false);\\n\t\t\ttype.setBinaryPath(sb.toString());\\n\t\t}\\n\t\tfis.close();\\n\t\treturn ucf;\\n\t}\\n\\n\tpublic void deleteClassFile(String typename) {\\n\t\tdeletedTypenames.add(typename);\\n\t\tworld.deleteSourceObjectType(UnresolvedType.forName(typename));\\n\t}\\n\\n\t// ---- weave preparation\\n\\n\tpublic void setIsBatchWeave(bool"
  },
  {
    "method_id": "M1462",
    "name": "setIsBatchWeave",
    "return_type": "void",
    "signature": "setIsBatchWeave(boolean b)",
    "file_id": "F27",
    "start_line": 493,
    "text_preview": "pename);\\n\t\tworld.deleteSourceObjectType(UnresolvedType.forName(typename));\\n\t}\\n\\n\t// ---- weave preparation\\n\\n\tpublic void setIsBatchWeave(boolean b) {\\n\t\tisBatchWeave = b;\\n\t}\\n\\n\tpublic void prepareForWeave() {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"prepareForWeave\", this);\\n\t\t}\\n\t\tneedToReweaveWorld = xcutSet.hasCha"
  },
  {
    "method_id": "M1463",
    "name": "prepareForWeave",
    "return_type": "void",
    "signature": "prepareForWeave()",
    "file_id": "F27",
    "start_line": 497,
    "text_preview": "ename));\\n\t}\\n\\n\t// ---- weave preparation\\n\\n\tpublic void setIsBatchWeave(boolean b) {\\n\t\tisBatchWeave = b;\\n\t}\\n\\n\tpublic void prepareForWeave() {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"prepareForWeave\", this);\\n\t\t}\\n\t\tneedToReweaveWorld = xcutSet.hasChangedSinceLastReset();\\n\\n\t\t// update mungers\\n\t\tfor (UnwovenClassFile"
  },
  {
    "method_id": "M1464",
    "name": "for",
    "return_type": "mungers",
    "signature": "for(UnwovenClassFile jc : addedClasses)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1465",
    "name": "for",
    "return_type": "",
    "signature": "for(String name : deletedTypenames)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1466",
    "name": "sort",
    "return_type": "",
    "signature": "sort(new Comparator<ShadowMunger>()",
    "file_id": "F27",
    "start_line": 551,
    "text_preview": "starts filling in source locations for mungers,\\n\t\t// this code may need\\n\t\t// a bit of alteration...\\n\\n\t\tshadowMungerList.sort(new Comparator<ShadowMunger>() {\\n\t\t\tpublic int compare(ShadowMunger sm1, ShadowMunger sm2) {\\n\t\t\t\tif (sm1.getSourceLocation() == null) {\\n\t\t\t\t\treturn (sm2.getSourceLocation() == null ? 0 : 1);\\n\t\t\t\t"
  },
  {
    "method_id": "M1467",
    "name": "compare",
    "return_type": "int",
    "signature": "compare(ShadowMunger sm1, ShadowMunger sm2)",
    "file_id": "F27",
    "start_line": 552,
    "text_preview": " this code may need\\n\t\t// a bit of alteration...\\n\\n\t\tshadowMungerList.sort(new Comparator<ShadowMunger>() {\\n\t\t\tpublic int compare(ShadowMunger sm1, ShadowMunger sm2) {\\n\t\t\t\tif (sm1.getSourceLocation() == null) {\\n\t\t\t\t\treturn (sm2.getSourceLocation() == null ? 0 : 1);\\n\t\t\t\t}\\n\t\t\t\tif (sm2.getSourceLocation() == null) {\\n\t\t\t\t\tre"
  },
  {
    "method_id": "M1468",
    "name": "if",
    "return_type": "",
    "signature": "if(inReweavableMode)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1469",
    "name": "addCustomMungers",
    "return_type": "void",
    "signature": "addCustomMungers()",
    "file_id": "F27",
    "start_line": 534,
    "text_preview": "eMungers();\\n\t\tlateTypeMungerList = xcutSet.getLateTypeMungers();\\n\t\tdeclareParentsList = xcutSet.getDeclareParents();\\n\\n\t\taddCustomMungers();\\n\\n\t\t// The ordering here used to be based on a string compare on toString()\\n\t\t// for the two mungers -\\n\t\t// that breaks for the @AJ style where advice names aren't\\n\t\t// programmatic"
  },
  {
    "method_id": "M1470",
    "name": "if",
    "return_type": "",
    "signature": "if(customMungerFactory != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1471",
    "name": "for",
    "return_type": "",
    "signature": "for(UnwovenClassFile jc : addedClasses)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1472",
    "name": "if",
    "return_type": "",
    "signature": "if(shadowMungers != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1473",
    "name": "if",
    "return_type": "",
    "signature": "if(typeMungers != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1474",
    "name": "setCustomMungerFactory",
    "return_type": "void",
    "signature": "setCustomMungerFactory(CustomMungerFactory factory)",
    "file_id": "F27",
    "start_line": 592,
    "text_preview": "type);\\n\t\t\t\t\tif (typeMungers != null) {\\n\t\t\t\t\t\ttypeMungerList.addAll(typeMungers);\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic void setCustomMungerFactory(CustomMungerFactory factory) {\\n\t\tcustomMungerFactory = factory;\\n\t}\\n\\n\t/*\\n\t * Rewrite all of the pointcuts in the world into their most efficient form for subsequent matching. Als"
  },
  {
    "method_id": "M1475",
    "name": "rewritePointcuts",
    "return_type": "void",
    "signature": "rewritePointcuts(List<ShadowMunger> shadowMungers)",
    "file_id": "F27",
    "start_line": 524,
    "text_preview": "e;\\n\t\t\t}\\n\t\t}\\n\\n\t\tshadowMungerList = xcutSet.getShadowMungers();\\n\t\t// world.debug(\"shadow mungers=\" + shadowMungerList);\\n\t\trewritePointcuts(shadowMungerList);\\n\t\t// Sometimes an error occurs during rewriting pointcuts (for example, if\\n\t\t// ambiguous bindings\\n\t\t// are detected) - we ought to fail the prepare when this happe"
  },
  {
    "method_id": "M1476",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger munger : shadowMungers)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1477",
    "name": "if",
    "return_type": "",
    "signature": "if(munger instanceof Advice)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1478",
    "name": "if",
    "return_type": "",
    "signature": "if(numFormals > 0)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1479",
    "name": "if",
    "return_type": "",
    "signature": "if(numFormals > 0)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1480",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger munger: shadowMungers)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1481",
    "name": "shareEntriesFromMap",
    "return_type": "Pointcut",
    "signature": "shareEntriesFromMap(Pointcut p, Map<Pointcut, Pointcut> pcMap)",
    "file_id": "F27",
    "start_line": 648,
    "text_preview": " new HashMap<>();\\n\t\tfor (ShadowMunger munger: shadowMungers) {\\n\t\t\tPointcut p = munger.getPointcut();\\n\t\t\tPointcut newP = shareEntriesFromMap(p, pcMap);\\n\t\t\tnewP.m_ignoreUnboundBindingForNames = p.m_ignoreUnboundBindingForNames;\\n\t\t\tmunger.setPointcut(newP);\\n\t\t}\\n\t}\\n\\n\tprivate Pointcut shareEntriesFromMap(Pointcut p, Map<Poi"
  },
  {
    "method_id": "M1482",
    "name": "if",
    "return_type": "",
    "signature": "if(p instanceof NameBindingPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1483",
    "name": "if",
    "return_type": "",
    "signature": "if(p instanceof IfPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1484",
    "name": "if",
    "return_type": "",
    "signature": "if(p instanceof ConcreteCflowPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1485",
    "name": "if",
    "return_type": "",
    "signature": "if(p instanceof AndPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1486",
    "name": "if",
    "return_type": "else",
    "signature": "if(p instanceof OrPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1487",
    "name": "if",
    "return_type": "else",
    "signature": "if(p instanceof NotPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1488",
    "name": "validateBindings",
    "return_type": "void",
    "signature": "validateBindings(Pointcut dnfPointcut, Pointcut userPointcut, int numFormals, String[] names)",
    "file_id": "F27",
    "start_line": 627,
    "text_preview": "ameterTypes().length;\\n\t\t\t\t\t\tif (numFormals > 0) {\\n\t\t\t\t\t\t\tnames = advice.getSignature().getParameterNames(world);\\n\t\t\t\t\t\t\tvalidateBindings(newP, p, numArgs, names);\\n\t\t\t\t\t\t}\\n\t\t\t\t\t} else {\\n\t\t\t\t\t\tnumFormals = advice.getBaseParameterCount();\\n\t\t\t\t\t\tif (numFormals > 0) {\\n\t\t\t\t\t\t\tnames = advice.getBaseParameterNames(world);\\n\t\t\t\t"
  },
  {
    "method_id": "M1489",
    "name": "if",
    "return_type": "",
    "signature": "if(numFormals == 0)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1490",
    "name": "if",
    "return_type": "",
    "signature": "if(dnfPointcut instanceof OrPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1491",
    "name": "validateOrBranch",
    "return_type": "void",
    "signature": "validateOrBranch(OrPointcut pc, Pointcut userPointcut, int numFormals, String[] names, Pointcut[] leftBindings,\n\t\t\tPointcut[] rightBindings)",
    "file_id": "F27",
    "start_line": 708,
    "text_preview": "tcut;\\n\t\t\tPointcut[] leftBindings = new Pointcut[numFormals];\\n\t\t\tPointcut[] rightBindings = new Pointcut[numFormals];\\n\t\t\tvalidateOrBranch(orBasedDNFPointcut, userPointcut, numFormals, names, leftBindings, rightBindings);\\n\t\t} else {\\n\t\t\tPointcut[] bindings = new Pointcut[numFormals];\\n\t\t\tvalidateSingleBranch(dnfPointcut, u"
  },
  {
    "method_id": "M1492",
    "name": "if",
    "return_type": "",
    "signature": "if(left instanceof OrPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1493",
    "name": "if",
    "return_type": "",
    "signature": "if(right instanceof OrPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1494",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < numFormals; i++)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1495",
    "name": "if",
    "return_type": "",
    "signature": "if(leftBindings[i] == null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1496",
    "name": "if",
    "return_type": "",
    "signature": "if(rightBindings[i] != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1497",
    "name": "validateSingleBranch",
    "return_type": "void",
    "signature": "validateSingleBranch(Pointcut pc, Pointcut userPointcut, int numFormals, String[] names, Pointcut[] bindings)",
    "file_id": "F27",
    "start_line": 711,
    "text_preview": "tcut, numFormals, names, leftBindings, rightBindings);\\n\t\t} else {\\n\t\t\tPointcut[] bindings = new Pointcut[numFormals];\\n\t\t\tvalidateSingleBranch(dnfPointcut, userPointcut, numFormals, names, bindings);\\n\t\t}\\n\t}\\n\\n\tprivate void validateOrBranch(OrPointcut pc, Pointcut userPointcut, int numFormals, String[] names, Pointcut[] le"
  },
  {
    "method_id": "M1498",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < foundFormals.length; i++)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1499",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < foundFormals.length; i++)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1500",
    "name": "if",
    "return_type": "",
    "signature": "if(!foundFormals[i])",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1501",
    "name": "for",
    "return_type": "style",
    "signature": "for(int j = 0; j < userPointcut.m_ignoreUnboundBindingForNames.length; j++)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1502",
    "name": "if",
    "return_type": "",
    "signature": "if(!ignore)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1503",
    "name": "validateSingleBranchRecursion",
    "return_type": "void",
    "signature": "validateSingleBranchRecursion(Pointcut pc, Pointcut userPointcut, boolean[] foundFormals, String[] names,\n\t\t\tPointcut[] bindings)",
    "file_id": "F27",
    "start_line": 763,
    "text_preview": "dFormals = new boolean[numFormals];\\n\t\tfor (int i = 0; i < foundFormals.length; i++) {\\n\t\t\tfoundFormals[i] = false;\\n\t\t}\\n\t\tvalidateSingleBranchRecursion(pc, userPointcut, foundFormals, names, bindings);\\n\t\tfor (int i = 0; i < foundFormals.length; i++) {\\n\t\t\tif (!foundFormals[i]) {\\n\t\t\t\tboolean ignore = false;\\n\t\t\t\t// ATAJ sof"
  },
  {
    "method_id": "M1504",
    "name": "if",
    "return_type": "",
    "signature": "if(pc instanceof NotPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1505",
    "name": "if",
    "return_type": "else",
    "signature": "if(pc instanceof AndPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1506",
    "name": "if",
    "return_type": "else",
    "signature": "if(pc instanceof NameBindingPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1507",
    "name": "for",
    "return_type": "",
    "signature": "for(BindingTypePattern bindingTypePattern: bindingTypePatterns)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1508",
    "name": "if",
    "return_type": "",
    "signature": "if(foundFormals[index])",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1509",
    "name": "for",
    "return_type": "",
    "signature": "for(BindingPattern bindingAnnotationTypePattern: bindingAnnotationTypePatterns)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1510",
    "name": "if",
    "return_type": "",
    "signature": "if(foundFormals[index])",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1511",
    "name": "if",
    "return_type": "else",
    "signature": "if(pc instanceof ConcreteCflowPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1512",
    "name": "for",
    "return_type": "",
    "signature": "for(int slot : slots)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1513",
    "name": "if",
    "return_type": "",
    "signature": "if(foundFormals[slot])",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1514",
    "name": "couldEverMatchSameJoinPoints",
    "return_type": "boolean",
    "signature": "couldEverMatchSameJoinPoints(Pointcut left, Pointcut right)",
    "file_id": "F27",
    "start_line": 736,
    "text_preview": "kindsInCommon = left.couldMatchKinds() & right.couldMatchKinds();\\n\t\tif (kindsInCommon != Shadow.NO_SHADOW_KINDS_BITS && couldEverMatchSameJoinPoints(left, right)) {\\n\t\t\t// we know that every branch binds every formal, so there is no\\n\t\t\t// ambiguity if each branch binds it in exactly the same way...\\n\t\t\tList<String> ambig"
  },
  {
    "method_id": "M1515",
    "name": "if",
    "return_type": "",
    "signature": "if(left instanceof OrPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1516",
    "name": "if",
    "return_type": "",
    "signature": "if(right instanceof OrPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1517",
    "name": "findFirstPointcutIn",
    "return_type": "Pointcut",
    "signature": "findFirstPointcutIn(Pointcut toSearch, Class<?> toLookFor)",
    "file_id": "F27",
    "start_line": 863,
    "text_preview": "())) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t// look for withins\\n\t\tWithinPointcut leftWithin = (WithinPointcut) findFirstPointcutIn(left, WithinPointcut.class);\\n\t\tWithinPointcut rightWithin = (WithinPointcut) findFirstPointcutIn(right, WithinPointcut.class);\\n\t\tif ((leftWithin != null) && (rightWithin != null)) "
  },
  {
    "method_id": "M1518",
    "name": "if",
    "return_type": "",
    "signature": "if(toSearch instanceof NotPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1519",
    "name": "if",
    "return_type": "",
    "signature": "if(toSearch instanceof AndPointcut)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1520",
    "name": "if",
    "return_type": "",
    "signature": "if(left != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1521",
    "name": "raiseNegationBindingError",
    "return_type": "void",
    "signature": "raiseNegationBindingError(Pointcut userPointcut)",
    "file_id": "F27",
    "start_line": 791,
    "text_preview": "ntcut();\\n\t\t\t\tif (!nnbp.getBindingAnnotationTypePatterns().isEmpty() && !nnbp.getBindingTypePatterns().isEmpty()) {\\n\t\t\t\t\traiseNegationBindingError(userPointcut);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t} else if (pc instanceof AndPointcut) {\\n\t\t\tAndPointcut and = (AndPointcut) pc;\\n\t\t\tvalidateSingleBranchRecursion(and.getLeft(), userPointcut, found"
  },
  {
    "method_id": "M1522",
    "name": "raiseAmbiguousBindingError",
    "return_type": "void",
    "signature": "raiseAmbiguousBindingError(String name, Pointcut pointcut)",
    "file_id": "F27",
    "start_line": 804,
    "text_preview": "s) {\\n\t\t\t\tint index = bindingTypePattern.getFormalIndex();\\n\t\t\t\tbindings[index] = pc;\\n\t\t\t\tif (foundFormals[index]) {\\n\t\t\t\t\traiseAmbiguousBindingError(names[index], userPointcut);\\n\t\t\t\t} else {\\n\t\t\t\t\tfoundFormals[index] = true;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tList<BindingPattern> bindingAnnotationTypePatterns = ((NameBindingPointcut) pc).getB"
  },
  {
    "method_id": "M1523",
    "name": "raiseAmbiguityInDisjunctionError",
    "return_type": "void",
    "signature": "raiseAmbiguityInDisjunctionError(Pointcut userPointcut, List<String> names)",
    "file_id": "F27",
    "start_line": 750,
    "text_preview": "gs[i].equals(rightBindings[i])) {\\n\t\t\t\t\tambiguousNames.add(names[i]);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tif (!ambiguousNames.isEmpty()) {\\n\t\t\t\traiseAmbiguityInDisjunctionError(userPointcut, ambiguousNames);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t// pc is a pointcut that does not contain any disjunctions\\n\t// check that every formal is bound (negation doesn't count).\\n"
  },
  {
    "method_id": "M1524",
    "name": "raiseUnboundFormalError",
    "return_type": "void",
    "signature": "raiseUnboundFormalError(String name, Pointcut userPointcut)",
    "file_id": "F27",
    "start_line": 776,
    "text_preview": "erPointcut.m_ignoreUnboundBindingForNames[j])) {\\n\t\t\t\t\t\tignore = true;\\n\t\t\t\t\t\tbreak;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t\tif (!ignore) {\\n\t\t\t\t\traiseUnboundFormalError(names[i], userPointcut);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t// each formal must appear exactly once\\n\tprivate void validateSingleBranchRecursion(Pointcut pc, Pointcut userPointcut, boolean[] f"
  },
  {
    "method_id": "M1525",
    "name": "addManifest",
    "return_type": "void",
    "signature": "addManifest(Manifest newManifest)",
    "file_id": "F27",
    "start_line": 388,
    "text_preview": "edClassFiles.addAll(addDirectoryContents(inFile, outDir));\\n\t\t\t} else {\\n\\n\t\t\t\tinJar = new JarFile(inFile);\\n\t\t\t\ttry {\\n\t\t\t\t\taddManifest(inJar.getManifest());\\n\t\t\t\t\tEnumeration<JarEntry> entries = inJar.entries();\\n\\n\t\t\t\t\twhile (entries.hasMoreElements()) {\\n\t\t\t\t\t\tJarEntry entry = entries.nextElement();\\n\t\t\t\t\t\tInputStream inStre"
  },
  {
    "method_id": "M1526",
    "name": "if",
    "return_type": "",
    "signature": "if(manifest == null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1527",
    "name": "getManifest",
    "return_type": "Manifest",
    "signature": "getManifest(boolean shouldCreate)",
    "file_id": "F27",
    "start_line": 388,
    "text_preview": "l(addDirectoryContents(inFile, outDir));\\n\t\t\t} else {\\n\\n\t\t\t\tinJar = new JarFile(inFile);\\n\t\t\t\ttry {\\n\t\t\t\t\taddManifest(inJar.getManifest());\\n\t\t\t\t\tEnumeration<JarEntry> entries = inJar.entries();\\n\\n\t\t\t\t\twhile (entries.hasMoreElements()) {\\n\t\t\t\t\t\tJarEntry entry = entries.nextElement();\\n\t\t\t\t\t\tInputStream inStream = inJar.getInpu"
  },
  {
    "method_id": "M1528",
    "name": "if",
    "return_type": "",
    "signature": "if(manifest == null && shouldCreate)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1529",
    "name": "weave",
    "return_type": "Collection<String>",
    "signature": "weave(File file)",
    "file_id": "F27",
    "start_line": 960,
    "text_preview": "REATED_BY, WEAVER_CREATED_BY);\\n\t\t}\\n\\n\t\treturn manifest;\\n\t}\\n\\n\t// ---- weaving\\n\\n\t// FOR TESTING\\n\tpublic Collection<String> weave(File file) throws IOException {\\n\t\tOutputStream os = FileUtil.makeOutputStream(file);\\n\t\tthis.zipOutputStream = new ZipOutputStream(os);\\n\t\tprepareForWeave();\\n\t\tCollection<String> c = weave(new ICl"
  },
  {
    "method_id": "M1530",
    "name": "weave",
    "return_type": "",
    "signature": "weave(new IClassFileProvider()",
    "file_id": "F27",
    "start_line": 960,
    "text_preview": "REATED_BY, WEAVER_CREATED_BY);\\n\t\t}\\n\\n\t\treturn manifest;\\n\t}\\n\\n\t// ---- weaving\\n\\n\t// FOR TESTING\\n\tpublic Collection<String> weave(File file) throws IOException {\\n\t\tOutputStream os = FileUtil.makeOutputStream(file);\\n\t\tthis.zipOutputStream = new ZipOutputStream(os);\\n\t\tprepareForWeave();\\n\t\tCollection<String> c = weave(new ICl"
  },
  {
    "method_id": "M1531",
    "name": "isApplyAtAspectJMungersOnly",
    "return_type": "boolean",
    "signature": "isApplyAtAspectJMungersOnly()",
    "file_id": "F27",
    "start_line": 966,
    "text_preview": " ZipOutputStream(os);\\n\t\tprepareForWeave();\\n\t\tCollection<String> c = weave(new IClassFileProvider() {\\n\\n\t\t\tpublic boolean isApplyAtAspectJMungersOnly() {\\n\t\t\t\treturn false;\\n\t\t\t}\\n\\n\t\t\tpublic Iterator<UnwovenClassFile> getClassFileIterator() {\\n\t\t\t\treturn addedClasses.iterator();\\n\t\t\t}\\n\\n\t\t\tpublic IWeaveRequestor getRequestor()"
  },
  {
    "method_id": "M1532",
    "name": "getClassFileIterator",
    "return_type": "Iterator<UnwovenClassFile>",
    "signature": "getClassFileIterator()",
    "file_id": "F27",
    "start_line": 970,
    "text_preview": "der() {\\n\\n\t\t\tpublic boolean isApplyAtAspectJMungersOnly() {\\n\t\t\t\treturn false;\\n\t\t\t}\\n\\n\t\t\tpublic Iterator<UnwovenClassFile> getClassFileIterator() {\\n\t\t\t\treturn addedClasses.iterator();\\n\t\t\t}\\n\\n\t\t\tpublic IWeaveRequestor getRequestor() {\\n\t\t\t\treturn new WeaveRequestor();\\n\t\t\t}\\n\t\t});\\n\t\t// /* BUG 40943*/\\n\t\t// dumpResourcesToOutJar"
  },
  {
    "method_id": "M1533",
    "name": "getRequestor",
    "return_type": "IWeaveRequestor",
    "signature": "getRequestor()",
    "file_id": "F27",
    "start_line": 974,
    "text_preview": "Iterator<UnwovenClassFile> getClassFileIterator() {\\n\t\t\t\treturn addedClasses.iterator();\\n\t\t\t}\\n\\n\t\t\tpublic IWeaveRequestor getRequestor() {\\n\t\t\t\treturn new WeaveRequestor();\\n\t\t\t}\\n\t\t});\\n\t\t// /* BUG 40943*/\\n\t\t// dumpResourcesToOutJar();\\n\t\tzipOutputStream.close(); // this flushes and closes the acutal file\\n\t\treturn c;\\n\t}\\n\\n\tpr"
  },
  {
    "method_id": "M1534",
    "name": "acceptResult",
    "return_type": "void",
    "signature": "acceptResult(IUnwovenClassFile result)",
    "file_id": "F27",
    "start_line": 985,
    "text_preview": "hes and closes the acutal file\\n\t\treturn c;\\n\t}\\n\\n\tprivate class WeaveRequestor implements IWeaveRequestor {\\n\t\tpublic void acceptResult(IUnwovenClassFile result) {\\n\t\t\ttry {\\n\t\t\t\twriteZipEntry(result.getFilename(), result.getBytes());\\n\t\t\t} catch (IOException ex) {\\n\t\t\t}\\n\t\t}\\n\\n\t\tpublic void processingReweavableState() {}\\n\\n\t\tpu"
  },
  {
    "method_id": "M1535",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ex)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1536",
    "name": "processingReweavableState",
    "return_type": "void",
    "signature": "processingReweavableState()",
    "file_id": "F27",
    "start_line": 992,
    "text_preview": "try {\\n\t\t\t\twriteZipEntry(result.getFilename(), result.getBytes());\\n\t\t\t} catch (IOException ex) {\\n\t\t\t}\\n\t\t}\\n\\n\t\tpublic void processingReweavableState() {}\\n\\n\t\tpublic void addingTypeMungers() {}\\n\\n\t\tpublic void weavingAspects() {}\\n\\n\t\tpublic void weavingClasses() {}\\n\\n\t\tpublic void weaveCompleted() {}\\n\t}\\n\\n\tprivate Set<IProgramE"
  },
  {
    "method_id": "M1537",
    "name": "addingTypeMungers",
    "return_type": "void",
    "signature": "addingTypeMungers()",
    "file_id": "F27",
    "start_line": 994,
    "text_preview": "result.getBytes());\\n\t\t\t} catch (IOException ex) {\\n\t\t\t}\\n\t\t}\\n\\n\t\tpublic void processingReweavableState() {}\\n\\n\t\tpublic void addingTypeMungers() {}\\n\\n\t\tpublic void weavingAspects() {}\\n\\n\t\tpublic void weavingClasses() {}\\n\\n\t\tpublic void weaveCompleted() {}\\n\t}\\n\\n\tprivate Set<IProgramElement> candidatesForRemoval = null;\\n\\n\t// vari"
  },
  {
    "method_id": "M1538",
    "name": "weavingAspects",
    "return_type": "void",
    "signature": "weavingAspects()",
    "file_id": "F27",
    "start_line": 996,
    "text_preview": "ption ex) {\\n\t\t\t}\\n\t\t}\\n\\n\t\tpublic void processingReweavableState() {}\\n\\n\t\tpublic void addingTypeMungers() {}\\n\\n\t\tpublic void weavingAspects() {}\\n\\n\t\tpublic void weavingClasses() {}\\n\\n\t\tpublic void weaveCompleted() {}\\n\t}\\n\\n\tprivate Set<IProgramElement> candidatesForRemoval = null;\\n\\n\t// variation of \"weave\" that sources class fi"
  },
  {
    "method_id": "M1539",
    "name": "weavingClasses",
    "return_type": "void",
    "signature": "weavingClasses()",
    "file_id": "F27",
    "start_line": 998,
    "text_preview": " processingReweavableState() {}\\n\\n\t\tpublic void addingTypeMungers() {}\\n\\n\t\tpublic void weavingAspects() {}\\n\\n\t\tpublic void weavingClasses() {}\\n\\n\t\tpublic void weaveCompleted() {}\\n\t}\\n\\n\tprivate Set<IProgramElement> candidatesForRemoval = null;\\n\\n\t// variation of \"weave\" that sources class files from an external source.\\n\tpubli"
  },
  {
    "method_id": "M1540",
    "name": "weaveCompleted",
    "return_type": "void",
    "signature": "weaveCompleted()",
    "file_id": "F27",
    "start_line": 1000,
    "text_preview": "public void addingTypeMungers() {}\\n\\n\t\tpublic void weavingAspects() {}\\n\\n\t\tpublic void weavingClasses() {}\\n\\n\t\tpublic void weaveCompleted() {}\\n\t}\\n\\n\tprivate Set<IProgramElement> candidatesForRemoval = null;\\n\\n\t// variation of \"weave\" that sources class files from an external source.\\n\tpublic Collection<String> weave(IClassFi"
  },
  {
    "method_id": "M1541",
    "name": "weave",
    "return_type": "Collection<String>",
    "signature": "weave(IClassFileProvider input)",
    "file_id": "F27",
    "start_line": 960,
    "text_preview": "REATED_BY, WEAVER_CREATED_BY);\\n\t\t}\\n\\n\t\treturn manifest;\\n\t}\\n\\n\t// ---- weaving\\n\\n\t// FOR TESTING\\n\tpublic Collection<String> weave(File file) throws IOException {\\n\t\tOutputStream os = FileUtil.makeOutputStream(file);\\n\t\tthis.zipOutputStream = new ZipOutputStream(os);\\n\t\tprepareForWeave();\\n\t\tCollection<String> c = weave(new ICl"
  },
  {
    "method_id": "M1542",
    "name": "if",
    "return_type": "",
    "signature": "if(theType != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1543",
    "name": "if",
    "return_type": "",
    "signature": "if(classType == null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1544",
    "name": "for",
    "return_type": "",
    "signature": "for(UnwovenClassFile newClass : newClasses)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1545",
    "name": "if",
    "return_type": "",
    "signature": "if(classType != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1546",
    "name": "if",
    "return_type": "",
    "signature": "if(classType == null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1547",
    "name": "if",
    "return_type": "",
    "signature": "if(classType == null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1548",
    "name": "allWeavingComplete",
    "return_type": "void",
    "signature": "allWeavingComplete()",
    "file_id": "F27",
    "start_line": 1210,
    "text_preview": "() != null && world.isMinimalModel()) {\\n\t\t\tcandidatesForRemoval.clear();\\n\t\t}\\n\t\treturn wovenClassNames;\\n\t}\\n\\n\tpublic void allWeavingComplete() {\\n\t\twarnOnUnmatchedAdvice();\\n\t}\\n\\n\t/**\\n\t * In 1.5 mode and with XLint:adviceDidNotMatch enabled, put out messages for any mungers that did not match anything.\\n\t */\\n\tprivate void wa"
  },
  {
    "method_id": "M1549",
    "name": "warnOnUnmatchedAdvice",
    "return_type": "void",
    "signature": "warnOnUnmatchedAdvice()",
    "file_id": "F27",
    "start_line": 1211,
    "text_preview": "imalModel()) {\\n\t\t\tcandidatesForRemoval.clear();\\n\t\t}\\n\t\treturn wovenClassNames;\\n\t}\\n\\n\tpublic void allWeavingComplete() {\\n\t\twarnOnUnmatchedAdvice();\\n\t}\\n\\n\t/**\\n\t * In 1.5 mode and with XLint:adviceDidNotMatch enabled, put out messages for any mungers that did not match anything.\\n\t */\\n\tprivate void warnOnUnmatchedAdvice() {\\n\\n"
  },
  {
    "method_id": "M1550",
    "name": "AdviceLocation",
    "return_type": "",
    "signature": "AdviceLocation(BcelAdvice advice)",
    "file_id": "F27",
    "start_line": 1223,
    "text_preview": "dAdvice() {\\n\\n\t\tclass AdviceLocation {\\n\t\t\tprivate final int lineNo;\\n\t\t\tprivate final UnresolvedType inAspect;\\n\\n\t\t\tpublic AdviceLocation(BcelAdvice advice) {\\n\t\t\t\tthis.lineNo = advice.getSourceLocation().getLine();\\n\t\t\t\tthis.inAspect = advice.getDeclaringAspect();\\n\t\t\t}\\n\\n\t\t\t@Override\\n\t\t\tpublic boolean equals(Object obj) {\\n\t"
  },
  {
    "method_id": "M1551",
    "name": "equals",
    "return_type": "boolean",
    "signature": "equals(Object obj)",
    "file_id": "F27",
    "start_line": 598,
    "text_preview": "e all of the pointcuts in the world into their most efficient form for subsequent matching. Also ensure that if\\n\t * pc1.equals(pc2) then pc1 == pc2 (for non-binding pcds) by making references all point to the same instance. Since pointcuts\\n\t * remember their match decision on the last shadow, this makes matching faster"
  },
  {
    "method_id": "M1552",
    "name": "if",
    "return_type": "",
    "signature": "if(this.lineNo != other.lineNo)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1553",
    "name": "hashCode",
    "return_type": "int",
    "signature": "hashCode()",
    "file_id": "F27",
    "start_line": 1244,
    "text_preview": "if (!this.inAspect.equals(other.inAspect)) {\\n\t\t\t\t\treturn false;\\n\t\t\t\t}\\n\t\t\t\treturn true;\\n\t\t\t}\\n\\n\t\t\t@Override\\n\t\t\tpublic int hashCode() {\\n\t\t\t\treturn 37 + 17 * lineNo + 17 * inAspect.hashCode();\\n\t\t\t}\\n\t\t}\\n\\n\t\t// FIXME asc Should be factored out into Xlint code and done\\n\t\t// automatically for all xlint messages, ideally.\\n\t\t// i"
  },
  {
    "method_id": "M1554",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger element : l)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1555",
    "name": "if",
    "return_type": "",
    "signature": "if(element instanceof BcelAdvice)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1556",
    "name": "weaveParentsFor",
    "return_type": "void",
    "signature": "weaveParentsFor(List<String> typesForWeaving, String typeToWeave, ResolvedType resolvedTypeToWeave)",
    "file_id": "F27",
    "start_line": 1119,
    "text_preview": "f (clf.shouldBeWoven()) {\\n\t\t\t\ttypesToProcess.add(clf.getClassName());\\n\t\t\t}\\n\t\t}\\n\t\twhile (typesToProcess.size() > 0) {\\n\t\t\tweaveParentsFor(typesToProcess, typesToProcess.get(0), null);\\n\t\t}\\n\\n\t\tfor (Iterator<UnwovenClassFile> i = input.getClassFileIterator(); i.hasNext();) {\\n\t\t\tUnwovenClassFile classFile = i.next();\\n\t\t\tif ("
  },
  {
    "method_id": "M1557",
    "name": "if",
    "return_type": "",
    "signature": "if(resolvedTypeToWeave == null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1558",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType resolvedSuperInterface : interfaceTypes)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1559",
    "name": "prepareToProcessReweavableState",
    "return_type": "void",
    "signature": "prepareToProcessReweavableState()",
    "file_id": "F27",
    "start_line": 1077,
    "text_preview": "oken = CompilationAndWeavingContext.enteringPhase(\\n\t\t\t\tCompilationAndWeavingContext.PROCESSING_REWEAVABLE_STATE, \"\");\\n\t\tprepareToProcessReweavableState();\\n\t\t// clear all state from files we'll be reweaving\\n\t\tfor (Iterator<UnwovenClassFile> i = input.getClassFileIterator(); i.hasNext();) {\\n\t\t\tUnwovenClassFile classFile "
  },
  {
    "method_id": "M1560",
    "name": "processReweavableStateIfPresent",
    "return_type": "void",
    "signature": "processReweavableStateIfPresent(String className, BcelObjectType classType)",
    "file_id": "F27",
    "start_line": 1091,
    "text_preview": "ationAndWeavingContext.enteringPhase(\\n\t\t\t\t\t\t\tCompilationAndWeavingContext.PROCESSING_REWEAVABLE_STATE, className);\\n\t\t\t\t\tprocessReweavableStateIfPresent(className, classType);\\n\t\t\t\t\tCompilationAndWeavingContext.leavingPhase(tok);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\tCompilationAndWeavingContext.leavingPhase(reweaveToken);\\n\\n\t\tContextToken t"
  },
  {
    "method_id": "M1561",
    "name": "for",
    "return_type": "",
    "signature": "for(String requiredTypeSignature : aspectsPreviouslyInWorld)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1562",
    "name": "if",
    "return_type": "",
    "signature": "if(!exists)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1563",
    "name": "if",
    "return_type": "",
    "signature": "if(ucfd.length == 0)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1564",
    "name": "weaveAndNotify",
    "return_type": "void",
    "signature": "weaveAndNotify(UnwovenClassFile classFile, BcelObjectType classType, IWeaveRequestor requestor)",
    "file_id": "F27",
    "start_line": 1158,
    "text_preview": "\\n\\n\t\t\t\t\t\tthrow new BCException(\"Can't find bcel delegate for \" + className + \" type=\" + theType.getClass());\\n\t\t\t\t\t}\\n\t\t\t\t\tweaveAndNotify(classFile, classType, requestor);\\n\t\t\t\t\twovenClassNames.add(className);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\tCompilationAndWeavingContext.leavingPhase(aspectToken);\\n\\n\t\trequestor.weavingClasses();\\n\t\tContext"
  },
  {
    "method_id": "M1565",
    "name": "if",
    "return_type": "",
    "signature": "if(clazz != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1566",
    "name": "for",
    "return_type": "",
    "signature": "for(UnwovenClassFile newClass : newClasses)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1567",
    "name": "getClassType",
    "return_type": "BcelObjectType",
    "signature": "getClassType(String forClass)",
    "file_id": "F27",
    "start_line": 183,
    "text_preview": "WeaverStateInfo wsi = type.getWeaverState();\\n\t\t\tif (wsi != null && wsi.isReweavable()) {\\n\t\t\t\tBcelObjectType classType = getClassType(type.getName());\\n\t\t\t\tJavaClass wovenJavaClass = classType.getJavaClass();\\n\t\t\t\tbyte[] bytes = wsi.getUnwovenClassFileData(wovenJavaClass.getBytes());\\n\t\t\t\tJavaClass unwovenJavaClass = Utili"
  },
  {
    "method_id": "M1568",
    "name": "addParentTypeMungers",
    "return_type": "void",
    "signature": "addParentTypeMungers(String typeName)",
    "file_id": "F27",
    "start_line": 1451,
    "text_preview": "ectType getClassType(String forClass) {\\n\t\treturn BcelWorld.getBcelObjectType(world.resolve(forClass));\\n\t}\\n\\n\tpublic void addParentTypeMungers(String typeName) {\\n\t\tweaveParentTypeMungers(world.resolve(typeName));\\n\t}\\n\\n\tpublic void addNormalTypeMungers(String typeName) {\\n\t\tweaveNormalTypeMungers(world.resolve(typeName));\\n\t"
  },
  {
    "method_id": "M1569",
    "name": "addNormalTypeMungers",
    "return_type": "void",
    "signature": "addNormalTypeMungers(String typeName)",
    "file_id": "F27",
    "start_line": 1126,
    "text_preview": "lassFile classFile = i.next();\\n\t\t\tif (classFile.shouldBeWoven()) {\\n\t\t\t\tString className = classFile.getClassName();\\n\t\t\t\taddNormalTypeMungers(className);\\n\t\t\t}\\n\t\t}\\n\\n\t\tCompilationAndWeavingContext.leavingPhase(typeMungingToken);\\n\\n\t\trequestor.weavingAspects();\\n\t\tContextToken aspectToken = CompilationAndWeavingContext.enter"
  },
  {
    "method_id": "M1570",
    "name": "getClassFilesFor",
    "return_type": "UnwovenClassFile[]",
    "signature": "getClassFilesFor(LazyClassGen clazz)",
    "file_id": "F27",
    "start_line": 1061,
    "text_preview": "ind());\\n\t\t\t\t\t\tselfMunger.forceMunge(clazz, true);\\n\t\t\t\t\t\tclassType.finishedWith();\\n\t\t\t\t\t\tUnwovenClassFile[] newClasses = getClassFilesFor(clazz);\\n\t\t\t\t\t\tfor (UnwovenClassFile newClass : newClasses) {\\n\t\t\t\t\t\t\trequestor.acceptResult(newClass);\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\twovenClassNames.add(classFile.getClassName());\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t"
  },
  {
    "method_id": "M1571",
    "name": "for",
    "return_type": "",
    "signature": "for(UnwovenClassFile.ChildClass element : childClasses)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1572",
    "name": "weaveParentTypeMungers",
    "return_type": "void",
    "signature": "weaveParentTypeMungers(ResolvedType onType)",
    "file_id": "F27",
    "start_line": 1336,
    "text_preview": "te B again, it\\n\t\t// will have been done whilst processing A.\\n\t\tif (!resolvedTypeToWeave.isTypeHierarchyComplete()) {\\n\t\t\tweaveParentTypeMungers(resolvedTypeToWeave);\\n\t\t}\\n\t\tCompilationAndWeavingContext.leavingPhase(tok);\\n\t\ttypesForWeaving.remove(typeToWeave);\\n\t\tresolvedTypeToWeave.tagAsTypeHierarchyComplete();\\n\t}\\n\\n\tpubli"
  },
  {
    "method_id": "M1573",
    "name": "for",
    "return_type": "mungers",
    "signature": "for(DeclareParents decp : declareParentsList)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1574",
    "name": "if",
    "return_type": "",
    "signature": "if(typeChanged)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1575",
    "name": "if",
    "return_type": "",
    "signature": "if(typeChanged)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1576",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareParents decp : decpToRepeat)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1577",
    "name": "if",
    "return_type": "",
    "signature": "if(typeChanged)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1578",
    "name": "if",
    "return_type": "",
    "signature": "if(typeChanged)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1579",
    "name": "applyDeclareAtType",
    "return_type": "boolean",
    "signature": "applyDeclareAtType(DeclareAnnotation decA, ResolvedType onType, boolean reportProblems)",
    "file_id": "F27",
    "start_line": 1501,
    "text_preview": "all dec @type mungers\\n\t\tfor (DeclareAnnotation decA : xcutSet.getDeclareAnnotationOnTypes()) {\\n\t\t\tboolean typeChanged = applyDeclareAtType(decA, onType, true);\\n\t\t\tif (typeChanged) {\\n\t\t\t\tanAnnotationChangeOccurred = true;\\n\t\t\t}\\n\t\t}\\n\\n\t\twhile ((aParentChangeOccurred || anAnnotationChangeOccurred) && !decpToRepeat.isEmpty()"
  },
  {
    "method_id": "M1580",
    "name": "if",
    "return_type": "",
    "signature": "if(theAnnotation == null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1581",
    "name": "if",
    "return_type": "",
    "signature": "if(reportProblems)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1582",
    "name": "if",
    "return_type": "",
    "signature": "if(!problemReported)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1583",
    "name": "verifyTargetIsOK",
    "return_type": "boolean",
    "signature": "verifyTargetIsOK(DeclareAnnotation decA, ResolvedType onType, AnnotationAJ annoX, boolean outputProblems)",
    "file_id": "F27",
    "start_line": 1556,
    "text_preview": "ionAJ annoX = decA.getAnnotation();\\n\\n\t\t\t// check the annotation is suitable for the target\\n\t\t\tboolean problemReported = verifyTargetIsOK(decA, onType, annoX, reportProblems);\\n\\n\t\t\tif (!problemReported) {\\n\t\t\t\tAsmRelationshipProvider.addDeclareAnnotationRelationship(world.getModelAsAsmManager(), decA.getSourceLocation(),\\n"
  },
  {
    "method_id": "M1584",
    "name": "if",
    "return_type": "",
    "signature": "if(outputProblems)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1585",
    "name": "applyDeclareParents",
    "return_type": "boolean",
    "signature": "applyDeclareParents(DeclareParents p, ResolvedType onType)",
    "file_id": "F27",
    "start_line": 1491,
    "text_preview": "e;\\n\t\t// First pass - apply all decp mungers\\n\t\tfor (DeclareParents decp : declareParentsList) {\\n\t\t\tboolean typeChanged = applyDeclareParents(decp, onType);\\n\t\t\tif (typeChanged) {\\n\t\t\t\taParentChangeOccurred = true;\\n\t\t\t} else {\\n\t\t\t\tdecpToRepeat.add(decp);\\n\t\t\t}\\n\t\t}\\n\\n\t\t// Still first pass - apply all dec @type mungers\\n\t\tfor ("
  },
  {
    "method_id": "M1586",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType newParent : newParents)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1587",
    "name": "weaveNormalTypeMungers",
    "return_type": "void",
    "signature": "weaveNormalTypeMungers(ResolvedType onType)",
    "file_id": "F27",
    "start_line": 1456,
    "text_preview": "peName) {\\n\t\tweaveParentTypeMungers(world.resolve(typeName));\\n\t}\\n\\n\tpublic void addNormalTypeMungers(String typeName) {\\n\t\tweaveNormalTypeMungers(world.resolve(typeName));\\n\t}\\n\\n\tpublic UnwovenClassFile[] getClassFilesFor(LazyClassGen clazz) {\\n\t\tList<UnwovenClassFile.ChildClass> childClasses = clazz.getChildClasses(world);\\n"
  },
  {
    "method_id": "M1588",
    "name": "for",
    "return_type": "",
    "signature": "for(ConcreteTypeMunger m : typeMungerList)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1589",
    "name": "weaveWithoutDump",
    "return_type": "LazyClassGen",
    "signature": "weaveWithoutDump(UnwovenClassFile classFile, BcelObjectType classType)",
    "file_id": "F27",
    "start_line": 1420,
    "text_preview": "ngPhase(CompilationAndWeavingContext.WEAVING_TYPE, classType\\n\t\t\t\t.getResolvedTypeX().getName());\\n\t\tLazyClassGen clazz = weaveWithoutDump(classFile, classType);\\n\t\tclassType.finishedWith();\\n\t\t// clazz is null if the classfile was unchanged by weaving...\\n\t\tif (clazz != null) {\\n\t\t\tUnwovenClassFile[] newClasses = getClassFi"
  },
  {
    "method_id": "M1590",
    "name": "weave",
    "return_type": "LazyClassGen",
    "signature": "weave(UnwovenClassFile classFile, BcelObjectType classType)",
    "file_id": "F27",
    "start_line": 960,
    "text_preview": "REATED_BY, WEAVER_CREATED_BY);\\n\t\t}\\n\\n\t\treturn manifest;\\n\t}\\n\\n\t// ---- weaving\\n\\n\t// FOR TESTING\\n\tpublic Collection<String> weave(File file) throws IOException {\\n\t\tOutputStream os = FileUtil.makeOutputStream(file);\\n\t\tthis.zipOutputStream = new ZipOutputStream(os);\\n\t\tprepareForWeave();\\n\t\tCollection<String> c = weave(new ICl"
  },
  {
    "method_id": "M1591",
    "name": "weave",
    "return_type": "LazyClassGen",
    "signature": "weave(UnwovenClassFile classFile, BcelObjectType classType, boolean dump)",
    "file_id": "F27",
    "start_line": 960,
    "text_preview": "REATED_BY, WEAVER_CREATED_BY);\\n\t\t}\\n\\n\t\treturn manifest;\\n\t}\\n\\n\t// ---- weaving\\n\\n\t// FOR TESTING\\n\tpublic Collection<String> weave(File file) throws IOException {\\n\t\tOutputStream os = FileUtil.makeOutputStream(file);\\n\t\tthis.zipOutputStream = new ZipOutputStream(os);\\n\t\tprepareForWeave();\\n\t\tCollection<String> c = weave(new ICl"
  },
  {
    "method_id": "M1592",
    "name": "if",
    "return_type": "classes",
    "signature": "if(dump)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1593",
    "name": "if",
    "return_type": "",
    "signature": "if(dump)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1594",
    "name": "if",
    "return_type": "",
    "signature": "if(mightNeedToWeave || mightNeedBridgeMethods)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1595",
    "name": "if",
    "return_type": "",
    "signature": "if(mightNeedToWeave)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1596",
    "name": "if",
    "return_type": "",
    "signature": "if(mightNeedBridgeMethods)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1597",
    "name": "if",
    "return_type": "",
    "signature": "if(isChanged)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1598",
    "name": "if",
    "return_type": "",
    "signature": "if(dump)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1599",
    "name": "catch",
    "return_type": "",
    "signature": "catch(RuntimeException re)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1600",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable e)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1601",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Error re)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1602",
    "name": "catch",
    "return_type": "",
    "signature": "catch(OutOfMemoryError oome)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1603",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable e)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1604",
    "name": "if",
    "return_type": "TYPE_DECL",
    "signature": "if(parent != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1605",
    "name": "if",
    "return_type": "",
    "signature": "if(dump)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1606",
    "name": "walkUpRemovingEmptyTypesAndPossiblyEmptySourceFile",
    "return_type": "void",
    "signature": "walkUpRemovingEmptyTypesAndPossiblyEmptySourceFile(AspectJElementHierarchy hierarchy, String tname,\n\t\t\tIProgramElement typeThatHasChildRemoved)",
    "file_id": "F27",
    "start_line": 1788,
    "text_preview": "d a\\n\t\t\t\t\t\t\t// child. Now we can check if it still has a child -\\n\t\t\t\t\t\t\t// if it doesn't it can also be removed!\\n\\n\t\t\t\t\t\t\twalkUpRemovingEmptyTypesAndPossiblyEmptySourceFile(hierarchy, tname, parent);\\n\t\t\t\t\t\t}\\n\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\\n\t\t\tif (dump) {\\n\t\t\t\tdumpUnchanged(classFile);\\n\t\t\t\treturn clazz;\\n\t\t\t} else {\\n\t\t\t\t// ATAJ: the cl"
  },
  {
    "method_id": "M1607",
    "name": "if",
    "return_type": "",
    "signature": "if(parent != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1608",
    "name": "removeSourceFileIfNoMoreTypeDeclarationsInside",
    "return_type": "void",
    "signature": "removeSourceFileIfNoMoreTypeDeclarationsInside(AspectJElementHierarchy hierarchy, IProgramElement typeElement,\n\t\t\tIProgramElement sourceFileNode)",
    "file_id": "F27",
    "start_line": 1778,
    "text_preview": "ove\\n\t\t\t\t\t\t// the others too.\\n\t\t\t\t\t\tparent.removeChild(typeElement);\\n\t\t\t\t\t\tif (parent.getKind().isSourceFile()) {\\n\t\t\t\t\t\t\tremoveSourceFileIfNoMoreTypeDeclarationsInside(hierarchy, typeElement, parent);\\n\t\t\t\t\t\t} else {\\n\t\t\t\t\t\t\thierarchy.forget(null, typeElement);\\n\t\t\t\t\t\t\t// At this point, the child has been removed. We\\n\t\t\t\t\t"
  },
  {
    "method_id": "M1609",
    "name": "if",
    "return_type": "it",
    "signature": "if(!anyOtherTypeDeclarations)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1610",
    "name": "if",
    "return_type": "",
    "signature": "if(cuParent != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1611",
    "name": "hasInnerType",
    "return_type": "boolean",
    "signature": "hasInnerType(IProgramElement typeNode)",
    "file_id": "F27",
    "start_line": 1764,
    "text_preview": "eName();\\n\t\t\t\tIProgramElement typeElement = hierarchy.findElementForType(pkgname, tname);\\n\t\t\t\tif (typeElement != null && hasInnerType(typeElement)) {\\n\t\t\t\t\t// Cannot remove it right now (has inner type), schedule it\\n\t\t\t\t\t// for possible deletion later if all inner types are\\n\t\t\t\t\t// removed\\n\t\t\t\t\tcandidatesForRemoval.add(t"
  },
  {
    "method_id": "M1612",
    "name": "if",
    "return_type": "",
    "signature": "if(kind == IProgramElement.Kind.ASPECT)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1613",
    "name": "if",
    "return_type": "",
    "signature": "if(b)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1614",
    "name": "checkDeclareTypeErrorOrWarning",
    "return_type": "void",
    "signature": "checkDeclareTypeErrorOrWarning(BcelWorld world2, BcelObjectType classType)",
    "file_id": "F27",
    "start_line": 1713,
    "text_preview": "ClassWeaver.weave(world, clazz, shadowMungers, typeMungers, lateTypeMungerList,\\n\t\t\t\t\t\t\t\tinReweavableMode);\\n\t\t\t\t\t}\\n\\n\t\t\t\t\tcheckDeclareTypeErrorOrWarning(world, classType);\\n\\n\t\t\t\t\tif (mightNeedBridgeMethods) {\\n\t\t\t\t\t\tisChanged = BcelClassWeaver.calculateAnyRequiredBridgeMethods(world, clazz) || isChanged;\\n\t\t\t\t\t}\\n\\n\t\t\t\t\tif (i"
  },
  {
    "method_id": "M1615",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareTypeErrorOrWarning dteow : dteows)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1616",
    "name": "dumpUnchanged",
    "return_type": "void",
    "signature": "dumpUnchanged(UnwovenClassFile classFile)",
    "file_id": "F27",
    "start_line": 1667,
    "text_preview": ") throws IOException {\\n\\n\t\ttry {\\n\t\t\tif (classType.isSynthetic()) { // Don't touch synthetic classes\\n\t\t\t\tif (dump) {\\n\t\t\t\t\tdumpUnchanged(classFile);\\n\t\t\t\t}\\n\t\t\t\treturn null;\\n\t\t\t}\\n\t\t\tReferenceType resolvedClassType = classType.getResolvedTypeX();\\n\\n\t\t\tif (world.isXmlConfigured() && world.getXmlConfiguration().excludesType(res"
  },
  {
    "method_id": "M1617",
    "name": "if",
    "return_type": "",
    "signature": "if(zipOutputStream != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1618",
    "name": "getEntryName",
    "return_type": "String",
    "signature": "getEntryName(String className)",
    "file_id": "F27",
    "start_line": 1912,
    "text_preview": "e void dumpUnchanged(UnwovenClassFile classFile) throws IOException {\\n\t\tif (zipOutputStream != null) {\\n\t\t\twriteZipEntry(getEntryName(classFile.getJavaClass().getClassName()), classFile.getBytes());\\n\t\t} else {\\n\t\t\tclassFile.writeUnchangedBytes();\\n\t\t}\\n\t}\\n\\n\tprivate String getEntryName(String className) {\\n\t\t// XXX what does"
  },
  {
    "method_id": "M1619",
    "name": "dump",
    "return_type": "void",
    "signature": "dump(UnwovenClassFile classFile, LazyClassGen clazz)",
    "file_id": "F27",
    "start_line": 1721,
    "text_preview": "er.calculateAnyRequiredBridgeMethods(world, clazz) || isChanged;\\n\t\t\t\t\t}\\n\\n\t\t\t\t\tif (isChanged) {\\n\t\t\t\t\t\tif (dump) {\\n\t\t\t\t\t\t\tdump(classFile, clazz);\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\treturn clazz;\\n\t\t\t\t\t}\\n\t\t\t\t} catch (RuntimeException re) {\\n\t\t\t\t\tString classDebugInfo = null;\\n\t\t\t\t\ttry {\\n\t\t\t\t\t\tclassDebugInfo = clazz.toLongString();\\n\t\t\t\t\t} catch ("
  },
  {
    "method_id": "M1620",
    "name": "if",
    "return_type": "",
    "signature": "if(zipOutputStream != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1621",
    "name": "for",
    "return_type": "",
    "signature": "for(UnwovenClassFile.ChildClass c : childClasses)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1622",
    "name": "writeZipEntry",
    "return_type": "void",
    "signature": "writeZipEntry(String name, byte[] bytes)",
    "file_id": "F27",
    "start_line": 987,
    "text_preview": "e class WeaveRequestor implements IWeaveRequestor {\\n\t\tpublic void acceptResult(IUnwovenClassFile result) {\\n\t\t\ttry {\\n\t\t\t\twriteZipEntry(result.getFilename(), result.getBytes());\\n\t\t\t} catch (IOException ex) {\\n\t\t\t}\\n\t\t}\\n\\n\t\tpublic void processingReweavableState() {}\\n\\n\t\tpublic void addingTypeMungers() {}\\n\\n\t\tpublic void weavin"
  },
  {
    "method_id": "M1623",
    "name": "fastMatch",
    "return_type": "List<ShadowMunger>",
    "signature": "fastMatch(List<ShadowMunger> list, ResolvedType type)",
    "file_id": "F27",
    "start_line": 1686,
    "text_preview": "\t\t\t\t}\\n\t\t\t\tif (dump) {\\n\t\t\t\t\tdumpUnchanged(classFile);\\n\t\t\t\t}\\n\t\t\t\treturn null;\\n\t\t\t}\\n\\n\t\t\tList<ShadowMunger> shadowMungers = fastMatch(shadowMungerList, resolvedClassType);\\n\t\t\tList<ConcreteTypeMunger> typeMungers = classType.getResolvedTypeX().getInterTypeMungers();\\n\\n\t\t\tresolvedClassType.checkInterTypeMungers();\\n\\n\t\t\t// Deci"
  },
  {
    "method_id": "M1624",
    "name": "if",
    "return_type": "",
    "signature": "if(list == null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1625",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger munger : list)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1626",
    "name": "if",
    "return_type": "",
    "signature": "if(typeWeaverState != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1627",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger munger : list)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1628",
    "name": "if",
    "return_type": "",
    "signature": "if(typeWeaverState != null)",
    "file_id": "F27",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1629",
    "name": "setReweavableMode",
    "return_type": "void",
    "signature": "setReweavableMode(boolean xNotReweavable)",
    "file_id": "F27",
    "start_line": 2004,
    "text_preview": "ut.fastMatch(info);\\n\t\t\t\tif (fb.maybeTrue()) {\\n\t\t\t\t\tresult.add(munger);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\treturn result;\\n\t}\\n\\n\tpublic void setReweavableMode(boolean xNotReweavable) {\\n\t\tinReweavableMode = !xNotReweavable;\\n\t\tWeaverStateInfo.setReweavableModeDefaults(!xNotReweavable, false, true);\\n\t}\\n\\n\tpublic boolean isReweavable() {\\n\t\tretu"
  },
  {
    "method_id": "M1630",
    "name": "isReweavable",
    "return_type": "boolean",
    "signature": "isReweavable()",
    "file_id": "F27",
    "start_line": 182,
    "text_preview": "/ Bug 119657 ensure we use the unwoven aspect\\n\t\t\tWeaverStateInfo wsi = type.getWeaverState();\\n\t\t\tif (wsi != null && wsi.isReweavable()) {\\n\t\t\t\tBcelObjectType classType = getClassType(type.getName());\\n\t\t\t\tJavaClass wovenJavaClass = classType.getJavaClass();\\n\t\t\t\tbyte[] bytes = wsi.getUnwovenClassFileData(wovenJavaClass.ge"
  },
  {
    "method_id": "M1631",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F27",
    "start_line": 1562,
    "text_preview": "AsAsmManager(), decA.getSourceLocation(),\\n\t\t\t\t\t\tonType.getSourceLocation(), false);\\n\t\t\t\t// TAG: WeavingMessage\\n\t\t\t\tif (!getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {\\n\t\t\t\t\tgetWorld().getMessageHandler().handleMessage(\\n\t\t\t\t\t\t\tWeaveMessage.constructWeavingMessage(\\n\t\t\t\t\t\t\t\t\tWeaveMessage.WEAVEMESSAGE_ANNO"
  },
  {
    "method_id": "M1632",
    "name": "tidyUp",
    "return_type": "void",
    "signature": "tidyUp()",
    "file_id": "F27",
    "start_line": 2017,
    "text_preview": "lic boolean isReweavable() {\\n\t\treturn inReweavableMode;\\n\t}\\n\\n\tpublic World getWorld() {\\n\t\treturn world;\\n\t}\\n\\n\tpublic void tidyUp() {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"tidyUp\", this);\\n\t\t}\\n\t\tshadowMungerList = null; // setup by prepareForWeave\\n\t\ttypeMungerList = null; // setup by prepareForWeave\\n\t\tlateTypeMun"
  },
  {
    "method_id": "M1633",
    "name": "write",
    "return_type": "void",
    "signature": "write(CompressingDataOutputStream dos)",
    "file_id": "F27",
    "start_line": 606,
    "text_preview": "er();\\n\t\tfor (ShadowMunger munger : shadowMungers) {\\n\t\t\tPointcut p = munger.getPointcut();\\n\t\t\tPointcut newP = rewriter.rewrite(p);\\n\t\t\t// validateBindings now whilst we still have around the pointcut\\n\t\t\t// that resembles what the user actually wrote in their program\\n\t\t\t// text.\\n\t\t\tif (munger instanceof Advice) {\\n\t\t\t\tAdvi"
  },
  {
    "method_id": "M1634",
    "name": "setShadowMungers",
    "return_type": "void",
    "signature": "setShadowMungers(List<ShadowMunger> shadowMungers)",
    "file_id": "F27",
    "start_line": 2035,
    "text_preview": "ompressingDataOutputStream dos) throws IOException {\\n\t\txcutSet.write(dos);\\n\t}\\n\\n\t// only called for testing\\n\tpublic void setShadowMungers(List<ShadowMunger> shadowMungers) {\\n\t\tshadowMungerList = shadowMungers;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M1635",
    "name": "createAdviceMunger",
    "return_type": "Advice",
    "signature": "createAdviceMunger(AjAttribute.AdviceAttribute attribute, Pointcut pointcut, Member signature,\n\t\t\tResolvedType concreteAspect)",
    "file_id": "F28",
    "start_line": 33,
    "text_preview": "y bytecode.\\n *\\n * @author Andy Clement\\n */\\npublic class BcelWeavingSupport implements IWeavingSupport {\\n\\n\tpublic Advice createAdviceMunger(AjAttribute.AdviceAttribute attribute, Pointcut pointcut, Member signature,\\n\t\t\tResolvedType concreteAspect) {\\n\t\t// System.err.println(\"concrete advice: \" + signature + \" context \" +"
  },
  {
    "method_id": "M1636",
    "name": "makeCflowStackFieldAdder",
    "return_type": "ConcreteTypeMunger",
    "signature": "makeCflowStackFieldAdder(ResolvedMember cflowField)",
    "file_id": "F28",
    "start_line": 40,
    "text_preview": "sourceContext);\\n\t\treturn new BcelAdvice(attribute, pointcut, signature, concreteAspect);\\n\t}\\n\\n\tpublic ConcreteTypeMunger makeCflowStackFieldAdder(ResolvedMember cflowField) {\\n\t\treturn new BcelCflowStackFieldAdder(cflowField);\\n\t}\\n\\n\tpublic ConcreteTypeMunger makeCflowCounterFieldAdder(ResolvedMember cflowField) {\\n\t\treturn"
  },
  {
    "method_id": "M1637",
    "name": "makeCflowCounterFieldAdder",
    "return_type": "ConcreteTypeMunger",
    "signature": "makeCflowCounterFieldAdder(ResolvedMember cflowField)",
    "file_id": "F28",
    "start_line": 44,
    "text_preview": "eldAdder(ResolvedMember cflowField) {\\n\t\treturn new BcelCflowStackFieldAdder(cflowField);\\n\t}\\n\\n\tpublic ConcreteTypeMunger makeCflowCounterFieldAdder(ResolvedMember cflowField) {\\n\t\treturn new BcelCflowCounterFieldAdder(cflowField);\\n\t}\\n\\n\t/**\\n\t * Register a munger for perclause @AJ aspect so that we add aspectOf(..) to them"
  },
  {
    "method_id": "M1638",
    "name": "makePerClauseAspect",
    "return_type": "ConcreteTypeMunger",
    "signature": "makePerClauseAspect(ResolvedType aspect, PerClause.Kind kind)",
    "file_id": "F28",
    "start_line": 55,
    "text_preview": "aspectOf(..) to them as needed\\n\t *\\n\t * @param aspect\\n\t * @param kind\\n\t * @return munger\\n\t */\\n\tpublic ConcreteTypeMunger makePerClauseAspect(ResolvedType aspect, PerClause.Kind kind) {\\n\t\treturn new BcelPerClauseAspectAdder(aspect, kind);\\n\t}\\n\\n\tpublic Var makeCflowAccessVar(ResolvedType formalType, Member cflowField, int "
  },
  {
    "method_id": "M1639",
    "name": "makeCflowAccessVar",
    "return_type": "Var",
    "signature": "makeCflowAccessVar(ResolvedType formalType, Member cflowField, int arrayIndex)",
    "file_id": "F28",
    "start_line": 59,
    "text_preview": "Aspect(ResolvedType aspect, PerClause.Kind kind) {\\n\t\treturn new BcelPerClauseAspectAdder(aspect, kind);\\n\t}\\n\\n\tpublic Var makeCflowAccessVar(ResolvedType formalType, Member cflowField, int arrayIndex) {\\n\t\treturn new BcelCflowAccessVar(formalType, cflowField, arrayIndex);\\n\t}\\n\\n\tpublic ConcreteTypeMunger concreteTypeMunger("
  },
  {
    "method_id": "M1640",
    "name": "concreteTypeMunger",
    "return_type": "ConcreteTypeMunger",
    "signature": "concreteTypeMunger(ResolvedTypeMunger munger, ResolvedType aspectType)",
    "file_id": "F28",
    "start_line": 63,
    "text_preview": ", int arrayIndex) {\\n\t\treturn new BcelCflowAccessVar(formalType, cflowField, arrayIndex);\\n\t}\\n\\n\tpublic ConcreteTypeMunger concreteTypeMunger(ResolvedTypeMunger munger, ResolvedType aspectType) {\\n\t\treturn new BcelTypeMunger(munger, aspectType);\\n\t}\\n\\n\tpublic ConcreteTypeMunger createAccessForInlineMunger(ResolvedType aspect"
  },
  {
    "method_id": "M1641",
    "name": "createAccessForInlineMunger",
    "return_type": "ConcreteTypeMunger",
    "signature": "createAccessForInlineMunger(ResolvedType aspect)",
    "file_id": "F28",
    "start_line": 67,
    "text_preview": "nger munger, ResolvedType aspectType) {\\n\t\treturn new BcelTypeMunger(munger, aspectType);\\n\t}\\n\\n\tpublic ConcreteTypeMunger createAccessForInlineMunger(ResolvedType aspect) {\\n\t\treturn new BcelAccessForInlineMunger(aspect);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M1642",
    "name": "BcelWorld",
    "return_type": "",
    "signature": "BcelWorld()",
    "file_id": "F29",
    "start_line": 99,
    "text_preview": "ypeDelegateResolvers;\\n\\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelWorld.class);\\n\\n\tpublic BcelWorld() {\\n\t\tthis(\"\");\\n\t}\\n\\n\tpublic BcelWorld(String cp) {\\n\t\tthis(makeDefaultClasspath(cp), IMessageHandler.THROW, null);\\n\t}\\n\\n\tpublic IRelationship.Kind determineRelKind(ShadowMunger munger) {\\n\t\tAdv"
  },
  {
    "method_id": "M1643",
    "name": "BcelWorld",
    "return_type": "",
    "signature": "BcelWorld(String cp)",
    "file_id": "F29",
    "start_line": 99,
    "text_preview": "ypeDelegateResolvers;\\n\\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelWorld.class);\\n\\n\tpublic BcelWorld() {\\n\t\tthis(\"\");\\n\t}\\n\\n\tpublic BcelWorld(String cp) {\\n\t\tthis(makeDefaultClasspath(cp), IMessageHandler.THROW, null);\\n\t}\\n\\n\tpublic IRelationship.Kind determineRelKind(ShadowMunger munger) {\\n\t\tAdv"
  },
  {
    "method_id": "M1644",
    "name": "determineRelKind",
    "return_type": "Kind",
    "signature": "determineRelKind(ShadowMunger munger)",
    "file_id": "F29",
    "start_line": 107,
    "text_preview": "ic BcelWorld(String cp) {\\n\t\tthis(makeDefaultClasspath(cp), IMessageHandler.THROW, null);\\n\t}\\n\\n\tpublic IRelationship.Kind determineRelKind(ShadowMunger munger) {\\n\t\tAdviceKind ak = ((Advice) munger).getKind();\\n\t\tif (ak.getKey() == AdviceKind.Before.getKey()) {\\n\t\t\treturn IRelationship.Kind.ADVICE_BEFORE;\\n\t\t} else if (ak.ge"
  },
  {
    "method_id": "M1645",
    "name": "reportMatch",
    "return_type": "void",
    "signature": "reportMatch(ShadowMunger munger, Shadow shadow)",
    "file_id": "F29",
    "start_line": 131,
    "text_preview": "l;\\n\t\t}\\n\t\tthrow new RuntimeException(\"Shadow.determineRelKind: What the hell is it? \" + ak);\\n\t}\\n\\n\t@Override\\n\tpublic void reportMatch(ShadowMunger munger, Shadow shadow) {\\n\t\tif (getCrossReferenceHandler() != null) {\\n\t\t\tfinal IRelationship.Kind kind = determineRelKind(munger);\\n\t\t\tgetCrossReferenceHandler().addCrossReferen"
  },
  {
    "method_id": "M1646",
    "name": "reportWeavingMessage",
    "return_type": "void",
    "signature": "reportWeavingMessage(ShadowMunger munger, Shadow shadow)",
    "file_id": "F29",
    "start_line": 143,
    "text_preview": "Is a runtime test being stuffed in the code?\\n\t\t\t);\\n\t\t}\\n\\n\t\tif (!getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {\\n\t\t\treportWeavingMessage(munger, shadow);\\n\t\t}\\n\\n\t\tif (getModel() != null) {\\n\t\t\tAsmRelationshipProvider.addAdvisedRelationship(getModelAsAsmManager(), shadow, munger);\\n\t\t}\\n\t}\\n\\n\t/*\\n\t * Report a message about"
  },
  {
    "method_id": "M1647",
    "name": "if",
    "return_type": "",
    "signature": "if(advice.lastReportedMonitorExitJoinpointLocation == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1648",
    "name": "areTheSame",
    "return_type": "boolean",
    "signature": "areTheSame(ISourceLocation locA, ISourceLocation locB)",
    "file_id": "F29",
    "start_line": 178,
    "text_preview": "let's continue...\\n\t\t\t\tadvice.lastReportedMonitorExitJoinpointLocation = shadow.getSourceLocation();\\n\t\t\t} else {\\n\t\t\t\tif (areTheSame(shadow.getSourceLocation(), advice.lastReportedMonitorExitJoinpointLocation)) {\\n\t\t\t\t\t// Don't report it again!\\n\t\t\t\t\tadvice.lastReportedMonitorExitJoinpointLocation = null;\\n\t\t\t\t\treturn;\\n\t\t\t\t"
  },
  {
    "method_id": "M1649",
    "name": "if",
    "return_type": "",
    "signature": "if(locA == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1650",
    "name": "if",
    "return_type": "",
    "signature": "if(locB == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1651",
    "name": "if",
    "return_type": "",
    "signature": "if(fA == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1652",
    "name": "if",
    "return_type": "",
    "signature": "if(fB == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1653",
    "name": "beautifyLocation",
    "return_type": "String",
    "signature": "beautifyLocation(ISourceLocation isl)",
    "file_id": "F29",
    "start_line": 196,
    "text_preview": "msg = WeaveMessage.constructWeavingMessage(\\n\t\t\t\tWeaveMessage.WEAVEMESSAGE_SOFTENS,\\n\t\t\t\tnew String[] {\\n\t\t\t\t\tadvisedType, beautifyLocation(shadow.getSourceLocation()),\\n\t\t\t\t\tadvisingType, beautifyLocation(munger.getSourceLocation())\\n\t\t\t\t},\\n\t\t\t\tadvisedType, advisingType,\\n\t\t\t\tshadow.getSourceLocation(), munger.getSourceLoca"
  },
  {
    "method_id": "M1654",
    "name": "if",
    "return_type": "",
    "signature": "if(takeFrom == -1)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1655",
    "name": "if",
    "return_type": "",
    "signature": "if(binary != -1 && binary < takeFrom)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1656",
    "name": "if",
    "return_type": "",
    "signature": "if(lastSlash == -1)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1657",
    "name": "makeDefaultClasspath",
    "return_type": "List<String>",
    "signature": "makeDefaultClasspath(String cp)",
    "file_id": "F29",
    "start_line": 104,
    "text_preview": "tTraceFactory().getTrace(BcelWorld.class);\\n\\n\tpublic BcelWorld() {\\n\t\tthis(\"\");\\n\t}\\n\\n\tpublic BcelWorld(String cp) {\\n\t\tthis(makeDefaultClasspath(cp), IMessageHandler.THROW, null);\\n\t}\\n\\n\tpublic IRelationship.Kind determineRelKind(ShadowMunger munger) {\\n\t\tAdviceKind ak = ((Advice) munger).getKind();\\n\t\tif (ak.getKey() == Advic"
  },
  {
    "method_id": "M1658",
    "name": "getPathEntries",
    "return_type": "List<String>",
    "signature": "getPathEntries(String s)",
    "file_id": "F29",
    "start_line": 284,
    "text_preview": " static List<String> makeDefaultClasspath(String cp) {\\n\t\tList<String> classPath = new ArrayList<>();\\n\t\tclassPath.addAll(getPathEntries(cp));\\n\t\tclassPath.addAll(getPathEntries(ClassPath.getClassPath()));\\n\t\treturn classPath;\\n\\n\t}\\n\\n\tprivate static List<String> getPathEntries(String s) {\\n\t\tList<String> ret = new ArrayList<>"
  },
  {
    "method_id": "M1659",
    "name": "BcelWorld",
    "return_type": "",
    "signature": "BcelWorld(List classPath, IMessageHandler handler, ICrossReferenceHandler xrefHandler)",
    "file_id": "F29",
    "start_line": 99,
    "text_preview": "ypeDelegateResolvers;\\n\\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelWorld.class);\\n\\n\tpublic BcelWorld() {\\n\t\tthis(\"\");\\n\t}\\n\\n\tpublic BcelWorld(String cp) {\\n\t\tthis(makeDefaultClasspath(cp), IMessageHandler.THROW, null);\\n\t}\\n\\n\tpublic IRelationship.Kind determineRelKind(ShadowMunger munger) {\\n\t\tAdv"
  },
  {
    "method_id": "M1660",
    "name": "BcelWorld",
    "return_type": "",
    "signature": "BcelWorld(ClassPathManager cpm, IMessageHandler handler, ICrossReferenceHandler xrefHandler)",
    "file_id": "F29",
    "start_line": 99,
    "text_preview": "ypeDelegateResolvers;\\n\\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelWorld.class);\\n\\n\tpublic BcelWorld() {\\n\t\tthis(\"\");\\n\t}\\n\\n\tpublic BcelWorld(String cp) {\\n\t\tthis(makeDefaultClasspath(cp), IMessageHandler.THROW, null);\\n\t}\\n\\n\tpublic IRelationship.Kind determineRelKind(ShadowMunger munger) {\\n\t\tAdv"
  },
  {
    "method_id": "M1661",
    "name": "BcelWorld",
    "return_type": "",
    "signature": "BcelWorld(ClassLoader loader, IMessageHandler handler, ICrossReferenceHandler xrefHandler)",
    "file_id": "F29",
    "start_line": 99,
    "text_preview": "ypeDelegateResolvers;\\n\\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(BcelWorld.class);\\n\\n\tpublic BcelWorld() {\\n\t\tthis(\"\");\\n\t}\\n\\n\tpublic BcelWorld(String cp) {\\n\t\tthis(makeDefaultClasspath(cp), IMessageHandler.THROW, null);\\n\t}\\n\\n\tpublic IRelationship.Kind determineRelKind(ShadowMunger munger) {\\n\t\tAdv"
  },
  {
    "method_id": "M1662",
    "name": "ensureRepositorySetup",
    "return_type": "void",
    "signature": "ensureRepositorySetup()",
    "file_id": "F29",
    "start_line": 332,
    "text_preview": "\t// Tell BCEL to use us for resolving any classes\\n\t\t// delegate = getClassLoaderRepositoryFor(loader);\\n\t}\\n\\n\tpublic void ensureRepositorySetup() {\\n\t\tif (delegate == null) {\\n\t\t\tdelegate = getClassLoaderRepositoryFor(loaderRef);\\n\t\t}\\n\t}\\n\\n\tpublic Repository getClassLoaderRepositoryFor(ClassLoaderReference loader) {\\n\t\tif (bc"
  },
  {
    "method_id": "M1663",
    "name": "if",
    "return_type": "",
    "signature": "if(delegate == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1664",
    "name": "getClassLoaderRepositoryFor",
    "return_type": "Repository",
    "signature": "getClassLoaderRepositoryFor(ClassLoaderReference loader)",
    "file_id": "F29",
    "start_line": 329,
    "text_preview": "r(handler);\\n\t\tsetCrossReferenceHandler(xrefHandler);\\n\t\t// Tell BCEL to use us for resolving any classes\\n\t\t// delegate = getClassLoaderRepositoryFor(loader);\\n\t}\\n\\n\tpublic void ensureRepositorySetup() {\\n\t\tif (delegate == null) {\\n\t\t\tdelegate = getClassLoaderRepositoryFor(loaderRef);\\n\t\t}\\n\t}\\n\\n\tpublic Repository getClassLoade"
  },
  {
    "method_id": "M1665",
    "name": "if",
    "return_type": "",
    "signature": "if(bcelRepositoryCaching)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1666",
    "name": "addPath",
    "return_type": "void",
    "signature": "addPath(String name)",
    "file_id": "F29",
    "start_line": 346,
    "text_preview": "w ClassLoaderRepository(loader);\\n\t\t} else {\\n\t\t\treturn new NonCachingClassLoaderRepository(loader);\\n\t\t}\\n\t}\\n\\n\tpublic void addPath(String name) {\\n\t\tclassPath.addPath(name, this.getMessageHandler());\\n\t}\\n\\n\t// ---- various interactions with bcel\\n\\n\tpublic static Type makeBcelType(UnresolvedType type) {\\n\t\treturn Type.getType(t"
  },
  {
    "method_id": "M1667",
    "name": "makeBcelType",
    "return_type": "Type",
    "signature": "makeBcelType(UnresolvedType type)",
    "file_id": "F29",
    "start_line": 352,
    "text_preview": "{\\n\t\tclassPath.addPath(name, this.getMessageHandler());\\n\t}\\n\\n\t// ---- various interactions with bcel\\n\\n\tpublic static Type makeBcelType(UnresolvedType type) {\\n\t\treturn Type.getType(type.getErasureSignature());\\n\t}\\n\\n\tstatic Type[] makeBcelTypes(UnresolvedType[] types) {\\n\t\tType[] ret = new Type[types.length];\\n\t\tfor (int i = "
  },
  {
    "method_id": "M1668",
    "name": "makeBcelTypes",
    "return_type": "Type[]",
    "signature": "makeBcelTypes(UnresolvedType[] types)",
    "file_id": "F29",
    "start_line": 356,
    "text_preview": "c static Type makeBcelType(UnresolvedType type) {\\n\t\treturn Type.getType(type.getErasureSignature());\\n\t}\\n\\n\tstatic Type[] makeBcelTypes(UnresolvedType[] types) {\\n\t\tType[] ret = new Type[types.length];\\n\t\tfor (int i = 0, len = types.length; i < len; i++) {\\n\t\t\tret[i] = makeBcelType(types[i]);\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic s"
  },
  {
    "method_id": "M1669",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = types.length; i < len; i++)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1670",
    "name": "makeBcelTypes",
    "return_type": "Type[]",
    "signature": "makeBcelTypes(String[] types)",
    "file_id": "F29",
    "start_line": 356,
    "text_preview": "c static Type makeBcelType(UnresolvedType type) {\\n\t\treturn Type.getType(type.getErasureSignature());\\n\t}\\n\\n\tstatic Type[] makeBcelTypes(UnresolvedType[] types) {\\n\t\tType[] ret = new Type[types.length];\\n\t\tfor (int i = 0, len = types.length; i < len; i++) {\\n\t\t\tret[i] = makeBcelType(types[i]);\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic s"
  },
  {
    "method_id": "M1671",
    "name": "if",
    "return_type": "",
    "signature": "if(types == null || types.length==0)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1672",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0, len=types.length; i<len; i++)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1673",
    "name": "makeBcelType",
    "return_type": "Type",
    "signature": "makeBcelType(String type)",
    "file_id": "F29",
    "start_line": 352,
    "text_preview": "{\\n\t\tclassPath.addPath(name, this.getMessageHandler());\\n\t}\\n\\n\t// ---- various interactions with bcel\\n\\n\tpublic static Type makeBcelType(UnresolvedType type) {\\n\t\treturn Type.getType(type.getErasureSignature());\\n\t}\\n\\n\tstatic Type[] makeBcelTypes(UnresolvedType[] types) {\\n\t\tType[] ret = new Type[types.length];\\n\t\tfor (int i = "
  },
  {
    "method_id": "M1674",
    "name": "makeBcelTypesAsClassNames",
    "return_type": "String[]",
    "signature": "makeBcelTypesAsClassNames(UnresolvedType[] types)",
    "file_id": "F29",
    "start_line": 380,
    "text_preview": "\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic static Type makeBcelType(String type) {\\n\t\treturn Type.getType(type);\\n\t}\\n\\n\\n\tstatic String[] makeBcelTypesAsClassNames(UnresolvedType[] types) {\\n\t\tString[] ret = new String[types.length];\\n\t\tfor (int i = 0, len = types.length; i < len; i++) {\\n\t\t\tret[i] = types[i].getName();\\n\t\t}\\n\t\treturn ret;\\n\t"
  },
  {
    "method_id": "M1675",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = types.length; i < len; i++)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1676",
    "name": "fromBcel",
    "return_type": "UnresolvedType",
    "signature": "fromBcel(Type t)",
    "file_id": "F29",
    "start_line": 388,
    "text_preview": "len = types.length; i < len; i++) {\\n\t\t\tret[i] = types[i].getName();\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic static UnresolvedType fromBcel(Type t) {\\n\t\treturn UnresolvedType.forSignature(t.getSignature());\\n\t}\\n\\n\tstatic UnresolvedType[] fromBcel(Type[] ts) {\\n\t\tUnresolvedType[] ret = new UnresolvedType[ts.length];\\n\t\tfor (int i = 0, "
  },
  {
    "method_id": "M1677",
    "name": "fromBcel",
    "return_type": "UnresolvedType[]",
    "signature": "fromBcel(Type[] ts)",
    "file_id": "F29",
    "start_line": 388,
    "text_preview": "len = types.length; i < len; i++) {\\n\t\t\tret[i] = types[i].getName();\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic static UnresolvedType fromBcel(Type t) {\\n\t\treturn UnresolvedType.forSignature(t.getSignature());\\n\t}\\n\\n\tstatic UnresolvedType[] fromBcel(Type[] ts) {\\n\t\tUnresolvedType[] ret = new UnresolvedType[ts.length];\\n\t\tfor (int i = 0, "
  },
  {
    "method_id": "M1678",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = ts.length; i < len; i++)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1679",
    "name": "resolve",
    "return_type": "ResolvedType",
    "signature": "resolve(Type t)",
    "file_id": "F29",
    "start_line": 400,
    "text_preview": "or (int i = 0, len = ts.length; i < len; i++) {\\n\t\t\tret[i] = fromBcel(ts[i]);\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic ResolvedType resolve(Type t) {\\n\t\treturn resolve(fromBcel(t));\\n\t}\\n\\n\t@Override\\n\tprotected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {\\n\t\tString name = ty.getName();\\n\t\tensureAdvancedConfigurationProcesse"
  },
  {
    "method_id": "M1680",
    "name": "resolveDelegate",
    "return_type": "ReferenceTypeDelegate",
    "signature": "resolveDelegate(ReferenceType ty)",
    "file_id": "F29",
    "start_line": 405,
    "text_preview": "\\n\\n\tpublic ResolvedType resolve(Type t) {\\n\t\treturn resolve(fromBcel(t));\\n\t}\\n\\n\t@Override\\n\tprotected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {\\n\t\tString name = ty.getName();\\n\t\tensureAdvancedConfigurationProcessed();\\n\t\tJavaClass jc = lookupJavaClass(classPath, name);\\n\t\tif (jc == null) {\\n\t\t\t// Anyone else to "
  },
  {
    "method_id": "M1681",
    "name": "if",
    "return_type": "",
    "signature": "if(jc == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1682",
    "name": "if",
    "return_type": "",
    "signature": "if(typeDelegateResolvers != null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1683",
    "name": "for",
    "return_type": "",
    "signature": "for(TypeDelegateResolver tdr : typeDelegateResolvers)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1684",
    "name": "if",
    "return_type": "",
    "signature": "if(delegate != null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1685",
    "name": "buildBcelDelegate",
    "return_type": "BcelObjectType",
    "signature": "buildBcelDelegate(ReferenceType type, JavaClass jc, boolean artificial, boolean exposedToWeaver)",
    "file_id": "F29",
    "start_line": 421,
    "text_preview": "elegate(ty);\\n\t\t\t\t\tif (delegate != null) {\\n\t\t\t\t\t\treturn delegate;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\treturn null;\\n\t\t} else {\\n\t\t\treturn buildBcelDelegate(ty, jc, false, false);\\n\t\t}\\n\t}\\n\\n\tpublic BcelObjectType buildBcelDelegate(ReferenceType type, JavaClass jc, boolean artificial, boolean exposedToWeaver) {\\n\t\tBcelObjectType ret = new Bc"
  },
  {
    "method_id": "M1686",
    "name": "lookupJavaClass",
    "return_type": "JavaClass",
    "signature": "lookupJavaClass(ClassPathManager classPath, String name)",
    "file_id": "F29",
    "start_line": 408,
    "text_preview": "veDelegate(ReferenceType ty) {\\n\t\tString name = ty.getName();\\n\t\tensureAdvancedConfigurationProcessed();\\n\t\tJavaClass jc = lookupJavaClass(classPath, name);\\n\t\tif (jc == null) {\\n\t\t\t// Anyone else to ask?\\n\t\t\tif (typeDelegateResolvers != null) {\\n\t\t\t\tfor (TypeDelegateResolver tdr : typeDelegateResolvers) {\\n\t\t\t\t\tReferenceTypeD"
  },
  {
    "method_id": "M1687",
    "name": "if",
    "return_type": "",
    "signature": "if(classPath == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1688",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException e)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1689",
    "name": "if",
    "return_type": "",
    "signature": "if(file == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1690",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ioe)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1691",
    "name": "if",
    "return_type": "",
    "signature": "if(file != null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1692",
    "name": "addSourceObjectType",
    "return_type": "BcelObjectType",
    "signature": "addSourceObjectType(JavaClass jc, boolean artificial)",
    "file_id": "F29",
    "start_line": 468,
    "text_preview": "\",ioe);\\n\t\t\t}\\n\t\t\treturn null;\\n\t\t} finally {\\n\t\t\tif (file != null) {\\n\t\t\t\tfile.close();\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic BcelObjectType addSourceObjectType(JavaClass jc, boolean artificial) {\\n\t\treturn addSourceObjectType(jc.getClassName(), jc, artificial);\\n\t}\\n\\n\tpublic BcelObjectType addSourceObjectType(String classname, JavaClass jc, "
  },
  {
    "method_id": "M1693",
    "name": "addSourceObjectType",
    "return_type": "BcelObjectType",
    "signature": "addSourceObjectType(String classname, JavaClass jc, boolean artificial)",
    "file_id": "F29",
    "start_line": 468,
    "text_preview": "\",ioe);\\n\t\t\t}\\n\t\t\treturn null;\\n\t\t} finally {\\n\t\t\tif (file != null) {\\n\t\t\t\tfile.close();\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic BcelObjectType addSourceObjectType(JavaClass jc, boolean artificial) {\\n\t\treturn addSourceObjectType(jc.getClassName(), jc, artificial);\\n\t}\\n\\n\tpublic BcelObjectType addSourceObjectType(String classname, JavaClass jc, "
  },
  {
    "method_id": "M1694",
    "name": "if",
    "return_type": "",
    "signature": "if(referenceTypeFromTypeMap == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1695",
    "name": "addSourceObjectType",
    "return_type": "BcelObjectType",
    "signature": "addSourceObjectType(String classname, byte[] bytes, boolean artificial)",
    "file_id": "F29",
    "start_line": 468,
    "text_preview": "\",ioe);\\n\t\t\t}\\n\t\t\treturn null;\\n\t\t} finally {\\n\t\t\tif (file != null) {\\n\t\t\t\tfile.close();\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic BcelObjectType addSourceObjectType(JavaClass jc, boolean artificial) {\\n\t\treturn addSourceObjectType(jc.getClassName(), jc, artificial);\\n\t}\\n\\n\tpublic BcelObjectType addSourceObjectType(String classname, JavaClass jc, "
  },
  {
    "method_id": "M1696",
    "name": "if",
    "return_type": "",
    "signature": "if(referenceTypeFromTypeMap == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1697",
    "name": "deleteSourceObjectType",
    "return_type": "void",
    "signature": "deleteSourceObjectType(UnresolvedType ty)",
    "file_id": "F29",
    "start_line": 562,
    "text_preview": "renceTypeFromTypeMap, Utility.makeJavaClass(classname, bytes), artificial, true);\\n//\t\t\t}\\n\t\t}\\n\t\treturn retval;\\n\t}\\n\\n\tvoid deleteSourceObjectType(UnresolvedType ty) {\\n\t\ttypeMap.remove(ty.getSignature());\\n\t}\\n\\n\tpublic static Member makeFieldJoinPointSignature(LazyClassGen cg, FieldInstruction fi) {\\n\t\tConstantPool cpg = cg.g"
  },
  {
    "method_id": "M1698",
    "name": "makeFieldJoinPointSignature",
    "return_type": "Member",
    "signature": "makeFieldJoinPointSignature(LazyClassGen cg, FieldInstruction fi)",
    "file_id": "F29",
    "start_line": 566,
    "text_preview": "l;\\n\t}\\n\\n\tvoid deleteSourceObjectType(UnresolvedType ty) {\\n\t\ttypeMap.remove(ty.getSignature());\\n\t}\\n\\n\tpublic static Member makeFieldJoinPointSignature(LazyClassGen cg, FieldInstruction fi) {\\n\t\tConstantPool cpg = cg.getConstantPool();\\n\t\treturn MemberImpl.field(fi.getClassName(cpg),\\n\t\t\t\t(fi.opcode == Constants.GETSTATIC || "
  },
  {
    "method_id": "M1699",
    "name": "makeJoinPointSignatureFromMethod",
    "return_type": "Member",
    "signature": "makeJoinPointSignatureFromMethod(LazyMethodGen mg, MemberKind kind)",
    "file_id": "F29",
    "start_line": 573,
    "text_preview": "fi.opcode == Constants.PUTSTATIC) ? Modifier.STATIC : 0, fi.getName(cpg),\\n\t\t\t\tfi.getSignature(cpg));\\n\t}\\n\\n\tpublic Member makeJoinPointSignatureFromMethod(LazyMethodGen mg, MemberKind kind) {\\n\t\tMember ret = mg.getMemberView();\\n\t\tif (ret == null) {\\n\t\t\tint mods = mg.getAccessFlags();\\n\t\t\tif (mg.getEnclosingClass().isInterfa"
  },
  {
    "method_id": "M1700",
    "name": "if",
    "return_type": "",
    "signature": "if(ret == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1701",
    "name": "makeJoinPointSignatureForMonitorEnter",
    "return_type": "Member",
    "signature": "makeJoinPointSignatureForMonitorEnter(LazyClassGen cg, InstructionHandle h)",
    "file_id": "F29",
    "start_line": 588,
    "text_preview": "etReturnType()),\\n\t\t\t\t\tmg.getName(), fromBcel(mg.getArgumentTypes()));\\n\t\t} else {\\n\t\t\treturn ret;\\n\t\t}\\n\\n\t}\\n\\n\tpublic Member makeJoinPointSignatureForMonitorEnter(LazyClassGen cg, InstructionHandle h) {\\n\t\treturn MemberImpl.monitorEnter();\\n\t}\\n\\n\tpublic Member makeJoinPointSignatureForMonitorExit(LazyClassGen cg, InstructionHa"
  },
  {
    "method_id": "M1702",
    "name": "makeJoinPointSignatureForMonitorExit",
    "return_type": "Member",
    "signature": "makeJoinPointSignatureForMonitorExit(LazyClassGen cg, InstructionHandle h)",
    "file_id": "F29",
    "start_line": 592,
    "text_preview": "SignatureForMonitorEnter(LazyClassGen cg, InstructionHandle h) {\\n\t\treturn MemberImpl.monitorEnter();\\n\t}\\n\\n\tpublic Member makeJoinPointSignatureForMonitorExit(LazyClassGen cg, InstructionHandle h) {\\n\t\treturn MemberImpl.monitorExit();\\n\t}\\n\\n\tpublic Member makeJoinPointSignatureForArrayConstruction(LazyClassGen cg, Instructi"
  },
  {
    "method_id": "M1703",
    "name": "makeJoinPointSignatureForArrayConstruction",
    "return_type": "Member",
    "signature": "makeJoinPointSignatureForArrayConstruction(LazyClassGen cg, InstructionHandle handle)",
    "file_id": "F29",
    "start_line": 596,
    "text_preview": "ntSignatureForMonitorExit(LazyClassGen cg, InstructionHandle h) {\\n\t\treturn MemberImpl.monitorExit();\\n\t}\\n\\n\tpublic Member makeJoinPointSignatureForArrayConstruction(LazyClassGen cg, InstructionHandle handle) {\\n\t\tInstruction i = handle.getInstruction();\\n\t\tConstantPool cpg = cg.getConstantPool();\\n\t\tMember retval = null;\\n\\n\t"
  },
  {
    "method_id": "M1704",
    "name": "if",
    "return_type": "",
    "signature": "if(i.opcode == Constants.ANEWARRAY)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1705",
    "name": "if",
    "return_type": "else",
    "signature": "if(i instanceof MULTIANEWARRAY)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1706",
    "name": "if",
    "return_type": "",
    "signature": "if(ot != null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1707",
    "name": "for",
    "return_type": "",
    "signature": "for(int ii = 0; ii < dimensions; ii++)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1708",
    "name": "if",
    "return_type": "else",
    "signature": "if(i.opcode == Constants.NEWARRAY)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1709",
    "name": "makeJoinPointSignatureForMethodInvocation",
    "return_type": "Member",
    "signature": "makeJoinPointSignatureForMethodInvocation(LazyClassGen cg, InvokeInstruction ii)",
    "file_id": "F29",
    "start_line": 636,
    "text_preview": "nnot create array construction signature for this non-array instruction:\" + i);\\n\t\t}\\n\t\treturn retval;\\n\t}\\n\\n\tpublic Member makeJoinPointSignatureForMethodInvocation(LazyClassGen cg, InvokeInstruction ii) {\\n\t\tConstantPool cpg = cg.getConstantPool();\\n\t\tString name = ii.getName(cpg);\\n\t\tString declaring = ii.getClassName(cpg)"
  },
  {
    "method_id": "M1710",
    "name": "if",
    "return_type": "",
    "signature": "if(indexInAccessorName != -1)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1711",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method: methods)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1712",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1713",
    "name": "if",
    "return_type": "104212",
    "signature": "if(ii.opcode == Constants.INVOKESTATIC)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1714",
    "name": "if",
    "return_type": "",
    "signature": "if(declaringType == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1715",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F29",
    "start_line": 188,
    "text_preview": "astReportedMonitorExitJoinpointLocation = shadow.getSourceLocation();\\n\t\t\t}\\n\t\t}\\n\\n\t\tString description = advice.getKind().toString();\\n\t\tString advisedType = shadow.getEnclosingType().getName();\\n\t\tString advisingType = advice.getConcreteAspect().getName();\\n\t\tMessage msg = null;\\n\t\tif (advice.getKind().equals(AdviceKind.Sof"
  },
  {
    "method_id": "M1716",
    "name": "getBcelObjectType",
    "return_type": "BcelObjectType",
    "signature": "getBcelObjectType(ResolvedType concreteAspect)",
    "file_id": "F29",
    "start_line": 716,
    "text_preview": "nd not a\\n\t * BcelObjectType - this happens quite often when incrementally compiling.\\n\t */\\n\tpublic static BcelObjectType getBcelObjectType(ResolvedType concreteAspect) {\\n\t\tif (concreteAspect == null) {\\n\t\t\treturn null;\\n\t\t}\\n\t\tif (!(concreteAspect instanceof ReferenceType)) { // Might be Missing\\n\t\t\treturn null;\\n\t\t}\\n\t\tRefer"
  },
  {
    "method_id": "M1717",
    "name": "if",
    "return_type": "",
    "signature": "if(concreteAspect == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1718",
    "name": "if",
    "return_type": "",
    "signature": "if(rtDelegate instanceof BcelObjectType)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1719",
    "name": "tidyUp",
    "return_type": "void",
    "signature": "tidyUp()",
    "file_id": "F29",
    "start_line": 731,
    "text_preview": "ate instanceof BcelObjectType) {\\n\t\t\treturn (BcelObjectType) rtDelegate;\\n\t\t} else {\\n\t\t\treturn null;\\n\t\t}\\n\t}\\n\\n\tpublic void tidyUp() {\\n\t\t// At end of compile, close any open files so deletion of those archives\\n\t\t// is possible\\n\t\tclassPath.closeArchives();\\n\t\ttypeMap.report();\\n\t\ttypeMap.demote(true);\\n\t\t// ResolvedType.resetP"
  },
  {
    "method_id": "M1720",
    "name": "findClass",
    "return_type": "JavaClass",
    "signature": "findClass(String className)",
    "file_id": "F29",
    "start_line": 743,
    "text_preview": "te(true);\\n\t\t// ResolvedType.resetPrimitives();\\n\t}\\n\\n\t// / The repository interface methods\\n\\n\t@Override\\n\tpublic JavaClass findClass(String className) {\\n\t\treturn lookupJavaClass(classPath, className);\\n\t}\\n\\n\t@Override\\n\tpublic JavaClass loadClass(String className) throws ClassNotFoundException {\\n\t\treturn lookupJavaClass(clas"
  },
  {
    "method_id": "M1721",
    "name": "loadClass",
    "return_type": "JavaClass",
    "signature": "loadClass(String className)",
    "file_id": "F29",
    "start_line": 434,
    "text_preview": " classPath, String name) {\\n\t\tif (classPath == null) {\\n\t\t\ttry {\\n\t\t\t\tensureRepositorySetup();\\n\t\t\t\tJavaClass jc = delegate.loadClass(name);\\n\t\t\t\tif (trace.isTraceEnabled()) {\\n\t\t\t\t\ttrace.event(\"lookupJavaClass\", this, new Object[] { name, jc });\\n\t\t\t\t}\\n\t\t\t\treturn jc;\\n\t\t\t} catch (ClassNotFoundException e) {\\n\t\t\t\tif (trace.isTr"
  },
  {
    "method_id": "M1722",
    "name": "storeClass",
    "return_type": "void",
    "signature": "storeClass(JavaClass clazz)",
    "file_id": "F29",
    "start_line": 753,
    "text_preview": " className) throws ClassNotFoundException {\\n\t\treturn lookupJavaClass(classPath, className);\\n\t}\\n\\n\t@Override\\n\tpublic void storeClass(JavaClass clazz) {\\n\t\t// doesn't need to do anything\\n\t}\\n\\n\t@Override\\n\tpublic void removeClass(JavaClass clazz) {\\n\t\tthrow new RuntimeException(\"Not implemented\");\\n\t}\\n\\n\t@Override\\n\tpublic JavaCl"
  },
  {
    "method_id": "M1723",
    "name": "removeClass",
    "return_type": "void",
    "signature": "removeClass(JavaClass clazz)",
    "file_id": "F29",
    "start_line": 758,
    "text_preview": "\\n\t}\\n\\n\t@Override\\n\tpublic void storeClass(JavaClass clazz) {\\n\t\t// doesn't need to do anything\\n\t}\\n\\n\t@Override\\n\tpublic void removeClass(JavaClass clazz) {\\n\t\tthrow new RuntimeException(\"Not implemented\");\\n\t}\\n\\n\t@Override\\n\tpublic JavaClass loadClass(Class clazz) throws ClassNotFoundException {\\n\t\tthrow new RuntimeException(\"No"
  },
  {
    "method_id": "M1724",
    "name": "loadClass",
    "return_type": "JavaClass",
    "signature": "loadClass(Class clazz)",
    "file_id": "F29",
    "start_line": 434,
    "text_preview": " classPath, String name) {\\n\t\tif (classPath == null) {\\n\t\t\ttry {\\n\t\t\t\tensureRepositorySetup();\\n\t\t\t\tJavaClass jc = delegate.loadClass(name);\\n\t\t\t\tif (trace.isTraceEnabled()) {\\n\t\t\t\t\ttrace.event(\"lookupJavaClass\", this, new Object[] { name, jc });\\n\t\t\t\t}\\n\t\t\t\treturn jc;\\n\t\t\t} catch (ClassNotFoundException e) {\\n\t\t\t\tif (trace.isTr"
  },
  {
    "method_id": "M1725",
    "name": "clear",
    "return_type": "void",
    "signature": "clear()",
    "file_id": "F29",
    "start_line": 768,
    "text_preview": "ass clazz) throws ClassNotFoundException {\\n\t\tthrow new RuntimeException(\"Not implemented\");\\n\t}\\n\\n\t@Override\\n\tpublic void clear() {\\n\t\tdelegate.clear();\\n\t\t// throw new RuntimeException(\"Not implemented\");\\n\t}\\n\\n\t/**\\n\t * The aim of this method is to make sure a particular type is 'ok'. Some operations on the delegate for a t"
  },
  {
    "method_id": "M1726",
    "name": "validateType",
    "return_type": "void",
    "signature": "validateType(UnresolvedType type)",
    "file_id": "F29",
    "start_line": 778,
    "text_preview": " delegate for a type modify it and\\n\t * this method is intended to undo that... see pr85132\\n\t */\\n\t@Override\\n\tpublic void validateType(UnresolvedType type) {\\n\t\tResolvedType result = typeMap.get(type.getSignature());\\n\t\tif (result == null) {\\n\t\t\treturn; // We haven't heard of it yet\\n\t\t}\\n\t\tif (!result.isExposedToWeaver()) {\\n"
  },
  {
    "method_id": "M1727",
    "name": "if",
    "return_type": "",
    "signature": "if(result == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1728",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassFormatException e)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1729",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1730",
    "name": "applyDeclareParents",
    "return_type": "boolean",
    "signature": "applyDeclareParents(DeclareParents p, ResolvedType onType)",
    "file_id": "F29",
    "start_line": 802,
    "text_preview": "ckTrace();\\n\t\t// }\\n\t}\\n\\n\t/**\\n\t * Apply a single declare parents - return true if we change the type\\n\t */\\n\tprivate boolean applyDeclareParents(DeclareParents p, ResolvedType onType) {\\n\t\tboolean didSomething = false;\\n\t\tList<ResolvedType> newParents = p.findMatchingNewParents(onType, true);\\n\t\tif (!newParents.isEmpty()) {\\n\t\t"
  },
  {
    "method_id": "M1731",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType newParent : newParents)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1732",
    "name": "applyDeclareAtType",
    "return_type": "boolean",
    "signature": "applyDeclareAtType(DeclareAnnotation decA, ResolvedType onType, boolean reportProblems)",
    "file_id": "F29",
    "start_line": 828,
    "text_preview": "\t\t}\\n\t\treturn didSomething;\\n\t}\\n\\n\t/**\\n\t * Apply a declare @type - return true if we change the type\\n\t */\\n\tprivate boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedType onType, boolean reportProblems) {\\n\t\tboolean didSomething = false;\\n\t\tif (decA.matches(onType)) {\\n\\n\t\t\tif (onType.hasAnnotation(decA.getAnnotation("
  },
  {
    "method_id": "M1733",
    "name": "if",
    "return_type": "",
    "signature": "if(isOK)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1734",
    "name": "applyDeclareAtField",
    "return_type": "boolean",
    "signature": "applyDeclareAtField(DeclareAnnotation deca, ResolvedType type)",
    "file_id": "F29",
    "start_line": 859,
    "text_preview": "s matching the declare annotation\\n\t * @return true if something matched and the type was modified\\n\t */\\n\tprivate boolean applyDeclareAtField(DeclareAnnotation deca, ResolvedType type) {\\n\t\tboolean changedType = false;\\n\t\tResolvedMember[] fields = type.getDeclaredFields();\\n\t\tfor (ResolvedMember field: fields) {\\n\t\t\tif (deca"
  },
  {
    "method_id": "M1735",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember field: fields)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1736",
    "name": "checkTargetOK",
    "return_type": "boolean",
    "signature": "checkTargetOK(DeclareAnnotation decA, ResolvedType onType, AnnotationAJ annoX)",
    "file_id": "F29",
    "start_line": 840,
    "text_preview": "\\n\t\t\tAnnotationAJ annoX = decA.getAnnotation();\\n\\n\t\t\t// check the annotation is suitable for the target\\n\t\t\tboolean isOK = checkTargetOK(decA, onType, annoX);\\n\\n\t\t\tif (isOK) {\\n\t\t\t\tdidSomething = true;\\n\t\t\t\tResolvedTypeMunger newAnnotationTM = new AnnotationOnTypeMunger(annoX);\\n\t\t\t\tnewAnnotationTM.setSourceLocation(decA.getS"
  },
  {
    "method_id": "M1737",
    "name": "weaveInterTypeDeclarations",
    "return_type": "void",
    "signature": "weaveInterTypeDeclarations(ResolvedType onType)",
    "file_id": "F29",
    "start_line": 891,
    "text_preview": "s -\\n\t// this code\\n\t// doesn't need to produce errors/warnings though as it won't really be\\n\t// weaving.\\n\tprotected void weaveInterTypeDeclarations(ResolvedType onType) {\\n\\n\t\tList<DeclareParents> declareParentsList = getCrosscuttingMembersSet().getDeclareParents();\\n\t\tif (onType.isRawType()) {\\n\t\t\tonType = onType.getGeneri"
  },
  {
    "method_id": "M1738",
    "name": "for",
    "return_type": "mungers",
    "signature": "for(DeclareParents decp : declareParentsList)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1739",
    "name": "if",
    "return_type": "",
    "signature": "if(typeChanged)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1740",
    "name": "if",
    "return_type": "",
    "signature": "if(typeChanged)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1741",
    "name": "for",
    "return_type": "",
    "signature": "for(DeclareParents decp: decpToRepeat)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1742",
    "name": "getWeavingSupport",
    "return_type": "IWeavingSupport",
    "signature": "getWeavingSupport()",
    "file_id": "F29",
    "start_line": 959,
    "text_preview": "onChangeOccurred = true;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tdecpToRepeat = decpToRepeatNextTime;\\n\t\t}\\n\\n\t}\\n\\n\t@Override\\n\tpublic IWeavingSupport getWeavingSupport() {\\n\t\treturn bcelWeavingSupport;\\n\t}\\n\\n\t@Override\\n\tpublic void reportCheckerMatch(Checker checker, Shadow shadow) {\\n\t\tIMessage iMessage = new Message(checker.getMessage(shadow), shadow"
  },
  {
    "method_id": "M1743",
    "name": "reportCheckerMatch",
    "return_type": "void",
    "signature": "reportCheckerMatch(Checker checker, Shadow shadow)",
    "file_id": "F29",
    "start_line": 964,
    "text_preview": "\\n\\n\t}\\n\\n\t@Override\\n\tpublic IWeavingSupport getWeavingSupport() {\\n\t\treturn bcelWeavingSupport;\\n\t}\\n\\n\t@Override\\n\tpublic void reportCheckerMatch(Checker checker, Shadow shadow) {\\n\t\tIMessage iMessage = new Message(checker.getMessage(shadow), shadow.toString(), checker.isError() ? IMessage.ERROR\\n\t\t\t\t: IMessage.WARNING, shadow."
  },
  {
    "method_id": "M1744",
    "name": "getModelAsAsmManager",
    "return_type": "AsmManager",
    "signature": "getModelAsAsmManager()",
    "file_id": "F29",
    "start_line": 147,
    "text_preview": "eportWeavingMessage(munger, shadow);\\n\t\t}\\n\\n\t\tif (getModel() != null) {\\n\t\t\tAsmRelationshipProvider.addAdvisedRelationship(getModelAsAsmManager(), shadow, munger);\\n\t\t}\\n\t}\\n\\n\t/*\\n\t * Report a message about the advice weave that has occurred. Some messing about to make it pretty ! This code is just asking\\n\t * for an NPE to oc"
  },
  {
    "method_id": "M1745",
    "name": "raiseError",
    "return_type": "void",
    "signature": "raiseError(String message)",
    "file_id": "F29",
    "start_line": 991,
    "text_preview": "elAsAsmManager() {\\n\t\treturn (AsmManager) getModel(); // For now... always an AsmManager in a bcel environment\\n\t}\\n\\n\tvoid raiseError(String message) {\\n\t\tgetMessageHandler().handleMessage(MessageUtil.error(message));\\n\t}\\n\\n\t/**\\n\t * These are aop.xml files that can be used to alter the aspects that actually apply from those "
  },
  {
    "method_id": "M1746",
    "name": "setXmlFiles",
    "return_type": "void",
    "signature": "setXmlFiles(List<File> xmlFiles)",
    "file_id": "F29",
    "start_line": 1001,
    "text_preview": "xmlFiles list of File objects representing any aop.xml files passed in to configure the build process\\n\t */\\n\tpublic void setXmlFiles(List<File> xmlFiles) {\\n\t\tif (!isXmlConfiguredWorld && !xmlFiles.isEmpty()) {\\n\t\t\traiseError(\"xml configuration files only supported by the compiler when -xmlConfigured option specified\");\\n\t"
  },
  {
    "method_id": "M1747",
    "name": "for",
    "return_type": "",
    "signature": "for(File xmlfile : xmlFiles)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1748",
    "name": "catch",
    "return_type": "",
    "signature": "catch(MalformedURLException e)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1749",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1750",
    "name": "addScopedAspect",
    "return_type": "void",
    "signature": "addScopedAspect(String name, String scope)",
    "file_id": "F29",
    "start_line": 1024,
    "text_preview": " where the scoping was defined in an aop.xml file and this world is being used in a LTW configuration\\n\t */\\n\tpublic void addScopedAspect(String name, String scope) {\\n\t\tthis.isXmlConfiguredWorld = true;\\n\t\tif (xmlConfiguration == null) {\\n\t\t\txmlConfiguration = new WeavingXmlConfig(this, WeavingXmlConfig.MODE_LTW);\\n\t\t}\\n\t\txm"
  },
  {
    "method_id": "M1751",
    "name": "if",
    "return_type": "",
    "signature": "if(xmlConfiguration == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1752",
    "name": "setXmlConfigured",
    "return_type": "void",
    "signature": "setXmlConfigured(boolean b)",
    "file_id": "F29",
    "start_line": 1032,
    "text_preview": "eavingXmlConfig(this, WeavingXmlConfig.MODE_LTW);\\n\t\t}\\n\t\txmlConfiguration.addScopedAspect(name, scope);\\n\t}\\n\\n\tpublic void setXmlConfigured(boolean b) {\\n\t\tthis.isXmlConfiguredWorld = b;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isXmlConfigured() {\\n\t\treturn isXmlConfiguredWorld && xmlConfiguration != null;\\n\t}\\n\\n\tpublic WeavingXmlConfi"
  },
  {
    "method_id": "M1753",
    "name": "isXmlConfigured",
    "return_type": "boolean",
    "signature": "isXmlConfigured()",
    "file_id": "F29",
    "start_line": 1037,
    "text_preview": " scope);\\n\t}\\n\\n\tpublic void setXmlConfigured(boolean b) {\\n\t\tthis.isXmlConfiguredWorld = b;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isXmlConfigured() {\\n\t\treturn isXmlConfiguredWorld && xmlConfiguration != null;\\n\t}\\n\\n\tpublic WeavingXmlConfig getXmlConfiguration() {\\n\t\treturn xmlConfiguration;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAspectIn"
  },
  {
    "method_id": "M1754",
    "name": "getXmlConfiguration",
    "return_type": "WeavingXmlConfig",
    "signature": "getXmlConfiguration()",
    "file_id": "F29",
    "start_line": 1041,
    "text_preview": "lic boolean isXmlConfigured() {\\n\t\treturn isXmlConfiguredWorld && xmlConfiguration != null;\\n\t}\\n\\n\tpublic WeavingXmlConfig getXmlConfiguration() {\\n\t\treturn xmlConfiguration;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAspectIncluded(ResolvedType aspectType) {\\n\t\tif (!isXmlConfigured()) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn xmlConfiguration."
  },
  {
    "method_id": "M1755",
    "name": "isAspectIncluded",
    "return_type": "boolean",
    "signature": "isAspectIncluded(ResolvedType aspectType)",
    "file_id": "F29",
    "start_line": 1046,
    "text_preview": "!= null;\\n\t}\\n\\n\tpublic WeavingXmlConfig getXmlConfiguration() {\\n\t\treturn xmlConfiguration;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAspectIncluded(ResolvedType aspectType) {\\n\t\tif (!isXmlConfigured()) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn xmlConfiguration.specifiesInclusionOfAspect(aspectType.getName());\\n\t}\\n\\n\t@Override\\n\tpublic TypePatte"
  },
  {
    "method_id": "M1756",
    "name": "getAspectScope",
    "return_type": "TypePattern",
    "signature": "getAspectScope(ResolvedType declaringType)",
    "file_id": "F29",
    "start_line": 1054,
    "text_preview": "rue;\\n\t\t}\\n\t\treturn xmlConfiguration.specifiesInclusionOfAspect(aspectType.getName());\\n\t}\\n\\n\t@Override\\n\tpublic TypePattern getAspectScope(ResolvedType declaringType) {\\n\t\treturn xmlConfiguration.getScopeFor(declaringType.getName());\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasUnsatisfiedDependency(ResolvedType aspectType) {\\n\t\tString"
  },
  {
    "method_id": "M1757",
    "name": "hasUnsatisfiedDependency",
    "return_type": "boolean",
    "signature": "hasUnsatisfiedDependency(ResolvedType aspectType)",
    "file_id": "F29",
    "start_line": 1059,
    "text_preview": "vedType declaringType) {\\n\t\treturn xmlConfiguration.getScopeFor(declaringType.getName());\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasUnsatisfiedDependency(ResolvedType aspectType) {\\n\t\tString aspectName = aspectType.getName();\\n\\n\t\tif (aspectType.hasAnnotations()) {\\n\t\t\tAnnotationAJ[] annos = aspectType.getAnnotations();\\n\t\t\tfor (Ann"
  },
  {
    "method_id": "M1758",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ anno: annos)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1759",
    "name": "if",
    "return_type": "",
    "signature": "if(aspectRequiredTypes == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1760",
    "name": "if",
    "return_type": "",
    "signature": "if(anythingMissing)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1761",
    "name": "if",
    "return_type": "",
    "signature": "if(aspectRequiredTypes == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1762",
    "name": "if",
    "return_type": "",
    "signature": "if(requiredTypeName==null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1763",
    "name": "addAspectRequires",
    "return_type": "void",
    "signature": "addAspectRequires(String aspectClassName, String requiredType)",
    "file_id": "F29",
    "start_line": 1134,
    "text_preview": "spectRequiredTypesProcessed = new ArrayList<>();\\n\tprivate Map<String, String> aspectRequiredTypes = null;\\n\\n\tpublic void addAspectRequires(String aspectClassName, String requiredType) {\\n\t\tif (aspectRequiredTypes == null) {\\n\t\t\taspectRequiredTypes = new HashMap<>();\\n\t\t}\\n\t\taspectRequiredTypes.put(aspectClassName,requiredTy"
  },
  {
    "method_id": "M1764",
    "name": "if",
    "return_type": "",
    "signature": "if(aspectRequiredTypes == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1765",
    "name": "WeavingXmlConfig",
    "return_type": "",
    "signature": "WeavingXmlConfig(BcelWorld bcelWorld, int mode)",
    "file_id": "F29",
    "start_line": 1007,
    "text_preview": " compiler when -xmlConfigured option specified\");\\n\t\t\treturn;\\n\t\t}\\n\t\tif (!xmlFiles.isEmpty()) {\\n\t\t\txmlConfiguration = new WeavingXmlConfig(this, WeavingXmlConfig.MODE_COMPILE);\\n\t\t}\\n\t\tfor (File xmlfile : xmlFiles) {\\n\t\t\ttry {\\n\t\t\t\tDefinition d = DocumentParser.parse(xmlfile.toURI().toURL());\\n\t\t\t\txmlConfiguration.add(d);\\n\t\t\t"
  },
  {
    "method_id": "M1766",
    "name": "add",
    "return_type": "void",
    "signature": "add(Definition d)",
    "file_id": "F29",
    "start_line": 294,
    "text_preview": "rayList<>();\\n\t\tStringTokenizer tok = new StringTokenizer(s, File.pathSeparator);\\n\t\twhile (tok.hasMoreTokens()) {\\n\t\t\tret.add(tok.nextToken());\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic BcelWorld(List classPath, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {\\n\t\t// this.aspectPath = new ClassPathManager(aspectPath, han"
  },
  {
    "method_id": "M1767",
    "name": "addScopedAspect",
    "return_type": "void",
    "signature": "addScopedAspect(String aspectName, String scope)",
    "file_id": "F29",
    "start_line": 1024,
    "text_preview": " where the scoping was defined in an aop.xml file and this world is being used in a LTW configuration\\n\t */\\n\tpublic void addScopedAspect(String name, String scope) {\\n\t\tthis.isXmlConfiguredWorld = true;\\n\t\tif (xmlConfiguration == null) {\\n\t\t\txmlConfiguration = new WeavingXmlConfig(this, WeavingXmlConfig.MODE_LTW);\\n\t\t}\\n\t\txm"
  },
  {
    "method_id": "M1768",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1769",
    "name": "ensureInitialized",
    "return_type": "void",
    "signature": "ensureInitialized()",
    "file_id": "F29",
    "start_line": 1179,
    "text_preview": "oid add(Definition d) {\\n\t\t\tdefinitions.add(d);\\n\t\t}\\n\\n\t\tpublic void addScopedAspect(String aspectName, String scope) {\\n\t\t\tensureInitialized();\\n\t\t\tresolvedIncludedAspects.add(aspectName);\\n\t\t\ttry {\\n\t\t\t\tTypePattern scopePattern = new PatternParser(scope).parseTypePattern();\\n\t\t\t\tscopePattern.resolve(world);\\n\t\t\t\tscopes.put(as"
  },
  {
    "method_id": "M1770",
    "name": "if",
    "return_type": "",
    "signature": "if(!initialized)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1771",
    "name": "for",
    "return_type": "optimal",
    "signature": "for(Definition definition : definitions)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1772",
    "name": "for",
    "return_type": "",
    "signature": "for(String name : aspectNames)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1773",
    "name": "if",
    "return_type": "",
    "signature": "if(scope != null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1774",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1775",
    "name": "for",
    "return_type": "",
    "signature": "for(String includePattern : includePatterns)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1776",
    "name": "for",
    "return_type": "",
    "signature": "for(String excludePattern : excludePatterns)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1777",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ParserException pe)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1778",
    "name": "specifiesInclusionOfAspect",
    "return_type": "boolean",
    "signature": "specifiesInclusionOfAspect(String name)",
    "file_id": "F29",
    "start_line": 1050,
    "text_preview": "n isAspectIncluded(ResolvedType aspectType) {\\n\t\tif (!isXmlConfigured()) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn xmlConfiguration.specifiesInclusionOfAspect(aspectType.getName());\\n\t}\\n\\n\t@Override\\n\tpublic TypePattern getAspectScope(ResolvedType declaringType) {\\n\t\treturn xmlConfiguration.getScopeFor(declaringType.getName());\\n\t}\\n\\n\t@"
  },
  {
    "method_id": "M1779",
    "name": "getScopeFor",
    "return_type": "TypePattern",
    "signature": "getScopeFor(String name)",
    "file_id": "F29",
    "start_line": 1055,
    "text_preview": "e.getName());\\n\t}\\n\\n\t@Override\\n\tpublic TypePattern getAspectScope(ResolvedType declaringType) {\\n\t\treturn xmlConfiguration.getScopeFor(declaringType.getName());\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasUnsatisfiedDependency(ResolvedType aspectType) {\\n\t\tString aspectName = aspectType.getName();\\n\\n\t\tif (aspectType.hasAnnotations())"
  },
  {
    "method_id": "M1780",
    "name": "excludesType",
    "return_type": "boolean",
    "signature": "excludesType(ResolvedType type)",
    "file_id": "F29",
    "start_line": 1300,
    "text_preview": "\t *\\n\t\t * @return Always false in LTW mode. In CTW mode true for excluded types, false otherwise.\\n\t\t */\\n\t\tpublic boolean excludesType(ResolvedType type) {\\n\t\t\tif (mode == MODE_LTW) {\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t\tString typename = type.getName();\\n\t\t\tboolean excluded = false;\\n\t\t\tfor (String excludedPattern : excludedFastMatch"
  },
  {
    "method_id": "M1781",
    "name": "if",
    "return_type": "",
    "signature": "if(mode == MODE_LTW)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1782",
    "name": "for",
    "return_type": "",
    "signature": "for(String excludedPattern : excludedFastMatchPatterns)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1783",
    "name": "if",
    "return_type": "",
    "signature": "if(!excluded)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1784",
    "name": "for",
    "return_type": "",
    "signature": "for(TypePattern excludedPattern : excludedPatterns)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1785",
    "name": "getTypeMap",
    "return_type": "TypeMap",
    "signature": "getTypeMap()",
    "file_id": "F29",
    "start_line": 1326,
    "text_preview": "(type)) {\\n\t\t\t\t\t\texcluded = true;\\n\t\t\t\t\t\tbreak;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\treturn excluded;\\n\t\t}\\n\\n\t}\\n\\n\t@Override\\n\tpublic TypeMap getTypeMap() {\\n\t\treturn typeMap;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isLoadtimeWeaving() {\\n\t\treturn false;\\n\t}\\n\\n\tpublic void addTypeDelegateResolver(TypeDelegateResolver typeDelegateResolver) {\\n\t\tif (typeDe"
  },
  {
    "method_id": "M1786",
    "name": "isLoadtimeWeaving",
    "return_type": "boolean",
    "signature": "isLoadtimeWeaving()",
    "file_id": "F29",
    "start_line": 1331,
    "text_preview": "\t\t\treturn excluded;\\n\t\t}\\n\\n\t}\\n\\n\t@Override\\n\tpublic TypeMap getTypeMap() {\\n\t\treturn typeMap;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isLoadtimeWeaving() {\\n\t\treturn false;\\n\t}\\n\\n\tpublic void addTypeDelegateResolver(TypeDelegateResolver typeDelegateResolver) {\\n\t\tif (typeDelegateResolvers == null) {\\n\t\t\ttypeDelegateResolvers = new ArrayL"
  },
  {
    "method_id": "M1787",
    "name": "addTypeDelegateResolver",
    "return_type": "void",
    "signature": "addTypeDelegateResolver(TypeDelegateResolver typeDelegateResolver)",
    "file_id": "F29",
    "start_line": 1335,
    "text_preview": " getTypeMap() {\\n\t\treturn typeMap;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isLoadtimeWeaving() {\\n\t\treturn false;\\n\t}\\n\\n\tpublic void addTypeDelegateResolver(TypeDelegateResolver typeDelegateResolver) {\\n\t\tif (typeDelegateResolvers == null) {\\n\t\t\ttypeDelegateResolvers = new ArrayList<>();\\n\t\t}\\n\t\ttypeDelegateResolvers.add(typeDelegateRe"
  },
  {
    "method_id": "M1788",
    "name": "if",
    "return_type": "",
    "signature": "if(typeDelegateResolvers == null)",
    "file_id": "F29",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1789",
    "name": "classWriteEvent",
    "return_type": "void",
    "signature": "classWriteEvent(char[][] compoundName)",
    "file_id": "F29",
    "start_line": 1343,
    "text_preview": "legateResolvers = new ArrayList<>();\\n\t\t}\\n\t\ttypeDelegateResolvers.add(typeDelegateResolver);\\n\t}\\n\\n\t@Override\\n\tpublic void classWriteEvent(char[][] compoundName) {\\n\t\ttypeMap.classWriteEvent(new String(CharOperation.concatWith(compoundName, '.')));\\n\t}\\n\\n\t/**\\n\t * Force demote a type.\\n\t */\\n\tpublic void demote(ResolvedType typ"
  },
  {
    "method_id": "M1790",
    "name": "demote",
    "return_type": "void",
    "signature": "demote(ResolvedType type)",
    "file_id": "F29",
    "start_line": 736,
    "text_preview": "ny open files so deletion of those archives\\n\t\t// is possible\\n\t\tclassPath.closeArchives();\\n\t\ttypeMap.report();\\n\t\ttypeMap.demote(true);\\n\t\t// ResolvedType.resetPrimitives();\\n\t}\\n\\n\t// / The repository interface methods\\n\\n\t@Override\\n\tpublic JavaClass findClass(String className) {\\n\t\treturn lookupJavaClass(classPath, className)"
  },
  {
    "method_id": "M1791",
    "name": "if",
    "return_type": "",
    "signature": "if(maxOpenArchives < 20)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1792",
    "name": "ClassPathManager",
    "return_type": "",
    "signature": "ClassPathManager(List<String> classpath, IMessageHandler handler)",
    "file_id": "F30",
    "start_line": 85,
    "text_preview": "= Integer.parseInt(openzipsString);\\n\t\tif (maxOpenArchives < 20) {\\n\t\t\tmaxOpenArchives = MAXOPEN_DEFAULT;\\n\t\t}\\n\t}\\n\\n\tpublic ClassPathManager(List<String> classpath, IMessageHandler handler) {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"<init>\", this, new Object[] { classpath==null?\"null\":classpath.toString(), handler }"
  },
  {
    "method_id": "M1793",
    "name": "for",
    "return_type": "",
    "signature": "for(String classpathEntry: classpath)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1794",
    "name": "ClassPathManager",
    "return_type": "",
    "signature": "ClassPathManager()",
    "file_id": "F30",
    "start_line": 85,
    "text_preview": "= Integer.parseInt(openzipsString);\\n\t\tif (maxOpenArchives < 20) {\\n\t\t\tmaxOpenArchives = MAXOPEN_DEFAULT;\\n\t\t}\\n\t}\\n\\n\tpublic ClassPathManager(List<String> classpath, IMessageHandler handler) {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"<init>\", this, new Object[] { classpath==null?\"null\":classpath.toString(), handler }"
  },
  {
    "method_id": "M1795",
    "name": "addPath",
    "return_type": "void",
    "signature": "addPath(String name, IMessageHandler handler)",
    "file_id": "F30",
    "start_line": 91,
    "text_preview": "\t}\\n\t\tentries = new ArrayList<>(classpath == null ? 1 : classpath.size());\\n\t\tfor (String classpathEntry: classpath) {\\n\t\t\taddPath(classpathEntry,handler);\\n\t\t}\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.exit(\"<init>\");\\n\t\t}\\n\t}\\n\\n\tprotected ClassPathManager() {\\n\t\tentries = null;\\n\t}\\n\\n\tpublic void addPath(String name, IMessageHa"
  },
  {
    "method_id": "M1796",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ioe)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1797",
    "name": "find",
    "return_type": "ClassFile",
    "signature": "find(UnresolvedType type)",
    "file_id": "F30",
    "start_line": 130,
    "text_preview": "VALID, name, ioe.getMessage()));\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t} else {\\n\t\t\tentries.add(new DirEntry(f));\\n\t\t}\\n\t}\\n\\n\tpublic ClassFile find(UnresolvedType type) {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"find\", this, type);\\n\t\t}\\n\t\tString name = type.getName();\\n\t\tif (notFound.contains(name)) {\\n\t\t\treturn null;\\n\t\t}\\n\t\tfor (Iterator"
  },
  {
    "method_id": "M1798",
    "name": "if",
    "return_type": "",
    "signature": "if(ret != null)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1799",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ioe)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1800",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F30",
    "start_line": 78,
    "text_preview": "ic {\\n\t\tString openzipsString = getSystemPropertyWithoutSecurityException(\"org.aspectj.weaver.openarchives\",\\n\t\t\t\tInteger.toString(MAXOPEN_DEFAULT));\\n\t\tmaxOpenArchives = Integer.parseInt(openzipsString);\\n\t\tif (maxOpenArchives < 20) {\\n\t\t\tmaxOpenArchives = MAXOPEN_DEFAULT;\\n\t\t}\\n\t}\\n\\n\tpublic ClassPathManager(List<String> clas"
  },
  {
    "method_id": "M1801",
    "name": "for",
    "return_type": "",
    "signature": "for(Entry entry : entries)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1802",
    "name": "if",
    "return_type": "",
    "signature": "if(start)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1803",
    "name": "getInputStream",
    "return_type": "InputStream",
    "signature": "getInputStream()",
    "file_id": "F30",
    "start_line": 182,
    "text_preview": "append(entry);\\n\t\t}\\n\t\treturn buf.toString();\\n\t}\\n\\n\tpublic abstract static class ClassFile {\\n\t\tpublic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOExcep"
  },
  {
    "method_id": "M1804",
    "name": "find",
    "return_type": "ClassFile",
    "signature": "find(String name)",
    "file_id": "F30",
    "start_line": 130,
    "text_preview": "VALID, name, ioe.getMessage()));\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t} else {\\n\t\t\tentries.add(new DirEntry(f));\\n\t\t}\\n\t}\\n\\n\tpublic ClassFile find(UnresolvedType type) {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"find\", this, type);\\n\t\t}\\n\t\tString name = type.getName();\\n\t\tif (notFound.contains(name)) {\\n\t\t\treturn null;\\n\t\t}\\n\t\tfor (Iterator"
  },
  {
    "method_id": "M1805",
    "name": "ByteBasedClassFile",
    "return_type": "",
    "signature": "ByteBasedClassFile(byte[] bytes, String path)",
    "file_id": "F30",
    "start_line": 197,
    "text_preview": " ClassFile {\\n\\n\t\tprivate final byte[] bytes;\\n\t\tprivate ByteArrayInputStream bais;\\n\t\tprivate final String path;\\n\\n\t\tpublic ByteBasedClassFile(byte[] bytes, String path) {\\n\t\t\tthis.bytes = bytes;\\n\t\t\tthis.path = path;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic InputStream getInputStream() throws IOException {\\n\t\t\tthis.bais = new ByteArrayInpu"
  },
  {
    "method_id": "M1806",
    "name": "getInputStream",
    "return_type": "InputStream",
    "signature": "getInputStream()",
    "file_id": "F30",
    "start_line": 182,
    "text_preview": "append(entry);\\n\t\t}\\n\t\treturn buf.toString();\\n\t}\\n\\n\tpublic abstract static class ClassFile {\\n\t\tpublic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOExcep"
  },
  {
    "method_id": "M1807",
    "name": "getPath",
    "return_type": "String",
    "signature": "getPath()",
    "file_id": "F30",
    "start_line": 183,
    "text_preview": "ct static class ClassFile {\\n\t\tpublic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOException;\\n\t}\\n\\n\tstatic class ByteBasedClassFile extends ClassFile {"
  },
  {
    "method_id": "M1808",
    "name": "close",
    "return_type": "void",
    "signature": "close()",
    "file_id": "F30",
    "start_line": 184,
    "text_preview": "ic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOException;\\n\t}\\n\\n\tstatic class ByteBasedClassFile extends ClassFile {\\n\\n\t\tprivate final byte[] bytes;\\n\t\t"
  },
  {
    "method_id": "M1809",
    "name": "if",
    "return_type": "",
    "signature": "if(this.bais!=null)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1810",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1811",
    "name": "FileClassFile",
    "return_type": "",
    "signature": "FileClassFile(File file)",
    "file_id": "F30",
    "start_line": 230,
    "text_preview": "\t}\\n\\n\tstatic class FileClassFile extends ClassFile {\\n\t\tprivate final File file;\\n\t\tprivate FileInputStream fis;\\n\\n\t\tpublic FileClassFile(File file) {\\n\t\t\tthis.file = file;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic InputStream getInputStream() throws IOException {\\n\t\t\tfis = new FileInputStream(file);\\n\t\t\treturn fis;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic"
  },
  {
    "method_id": "M1812",
    "name": "getInputStream",
    "return_type": "InputStream",
    "signature": "getInputStream()",
    "file_id": "F30",
    "start_line": 182,
    "text_preview": "append(entry);\\n\t\t}\\n\t\treturn buf.toString();\\n\t}\\n\\n\tpublic abstract static class ClassFile {\\n\t\tpublic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOExcep"
  },
  {
    "method_id": "M1813",
    "name": "close",
    "return_type": "void",
    "signature": "close()",
    "file_id": "F30",
    "start_line": 184,
    "text_preview": "ic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOException;\\n\t}\\n\\n\tstatic class ByteBasedClassFile extends ClassFile {\\n\\n\t\tprivate final byte[] bytes;\\n\t\t"
  },
  {
    "method_id": "M1814",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ioe)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1815",
    "name": "getPath",
    "return_type": "String",
    "signature": "getPath()",
    "file_id": "F30",
    "start_line": 183,
    "text_preview": "ct static class ClassFile {\\n\t\tpublic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOException;\\n\t}\\n\\n\tstatic class ByteBasedClassFile extends ClassFile {"
  },
  {
    "method_id": "M1816",
    "name": "DirEntry",
    "return_type": "",
    "signature": "DirEntry(File dir)",
    "file_id": "F30",
    "start_line": 126,
    "text_preview": "s.format(WeaverMessages.ZIPFILE_ENTRY_INVALID, name, ioe.getMessage()));\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t} else {\\n\t\t\tentries.add(new DirEntry(f));\\n\t\t}\\n\t}\\n\\n\tpublic ClassFile find(UnresolvedType type) {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"find\", this, type);\\n\t\t}\\n\t\tString name = type.getName();\\n\t\tif (notFound.contains(name"
  },
  {
    "method_id": "M1817",
    "name": "DirEntry",
    "return_type": "",
    "signature": "DirEntry(String dirPath)",
    "file_id": "F30",
    "start_line": 126,
    "text_preview": "s.format(WeaverMessages.ZIPFILE_ENTRY_INVALID, name, ioe.getMessage()));\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t} else {\\n\t\t\tentries.add(new DirEntry(f));\\n\t\t}\\n\t}\\n\\n\tpublic ClassFile find(UnresolvedType type) {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"find\", this, type);\\n\t\t}\\n\t\tString name = type.getName();\\n\t\tif (notFound.contains(name"
  },
  {
    "method_id": "M1818",
    "name": "find",
    "return_type": "ClassFile",
    "signature": "find(String name)",
    "file_id": "F30",
    "start_line": 130,
    "text_preview": "VALID, name, ioe.getMessage()));\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t} else {\\n\t\t\tentries.add(new DirEntry(f));\\n\t\t}\\n\t}\\n\\n\tpublic ClassFile find(UnresolvedType type) {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"find\", this, type);\\n\t\t}\\n\t\tString name = type.getName();\\n\t\tif (notFound.contains(name)) {\\n\t\t\treturn null;\\n\t\t}\\n\t\tfor (Iterator"
  },
  {
    "method_id": "M1819",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F30",
    "start_line": 78,
    "text_preview": "ic {\\n\t\tString openzipsString = getSystemPropertyWithoutSecurityException(\"org.aspectj.weaver.openarchives\",\\n\t\t\t\tInteger.toString(MAXOPEN_DEFAULT));\\n\t\tmaxOpenArchives = Integer.parseInt(openzipsString);\\n\t\tif (maxOpenArchives < 20) {\\n\t\t\tmaxOpenArchives = MAXOPEN_DEFAULT;\\n\t\t}\\n\t}\\n\\n\tpublic ClassPathManager(List<String> clas"
  },
  {
    "method_id": "M1820",
    "name": "ZipEntryClassFile",
    "return_type": "",
    "signature": "ZipEntryClassFile(ZipFileEntry zipFile, ZipEntry entry)",
    "file_id": "F30",
    "start_line": 289,
    "text_preview": "s ClassFile {\\n\t\tprivate final ZipEntry entry;\\n\t\tprivate final ZipFileEntry zipFile;\\n\t\tprivate InputStream is;\\n\\n\t\tpublic ZipEntryClassFile(ZipFileEntry zipFile, ZipEntry entry) {\\n\t\t\tthis.zipFile = zipFile;\\n\t\t\tthis.entry = entry;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic InputStream getInputStream() throws IOException {\\n\t\t\tis = zipFile."
  },
  {
    "method_id": "M1821",
    "name": "getInputStream",
    "return_type": "InputStream",
    "signature": "getInputStream()",
    "file_id": "F30",
    "start_line": 182,
    "text_preview": "append(entry);\\n\t\t}\\n\t\treturn buf.toString();\\n\t}\\n\\n\tpublic abstract static class ClassFile {\\n\t\tpublic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOExcep"
  },
  {
    "method_id": "M1822",
    "name": "close",
    "return_type": "void",
    "signature": "close()",
    "file_id": "F30",
    "start_line": 184,
    "text_preview": "ic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOException;\\n\t}\\n\\n\tstatic class ByteBasedClassFile extends ClassFile {\\n\\n\t\tprivate final byte[] bytes;\\n\t\t"
  },
  {
    "method_id": "M1823",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1824",
    "name": "getPath",
    "return_type": "String",
    "signature": "getPath()",
    "file_id": "F30",
    "start_line": 183,
    "text_preview": "ct static class ClassFile {\\n\t\tpublic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOException;\\n\t}\\n\\n\tstatic class ByteBasedClassFile extends ClassFile {"
  },
  {
    "method_id": "M1825",
    "name": "JImageState",
    "return_type": "",
    "signature": "JImageState(String jrtFsPath, FileSystem fs)",
    "file_id": "F30",
    "start_line": 342,
    "text_preview": "HashMap<>();\\n\t\t\tboolean packageCacheInitialized = false;\\n\t\t\tMap<String,Path> packageCache = new HashMap<>();\\n\\n\t\t\tpublic JImageState(String jrtFsPath, FileSystem fs) {\\n\t\t\t\tthis.jrtFsPath = jrtFsPath;\\n\t\t\t\tthis.fs = fs;\\n\t\t\t}\\n\t\t}\\n\\n\t\tpublic JImageEntry(String jrtFsPath) {\\n\t\t\tstate = states.get(jrtFsPath);\\n\t\t\tif (state == nu"
  },
  {
    "method_id": "M1826",
    "name": "JImageEntry",
    "return_type": "",
    "signature": "JImageEntry(String jrtFsPath)",
    "file_id": "F30",
    "start_line": 116,
    "text_preview": "\\n\t\t\t\t}\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t\ttry {\\n\t\t\t\tif (name.toLowerCase().endsWith(LangUtil.JRT_FS)) { // Java9+\\n\t\t\t\t\tentries.add(new JImageEntry(name));\\n\t\t\t\t} else {\\n\t\t\t\t\tentries.add(new ZipFileEntry(f));\\n\t\t\t\t}\\n\t\t\t} catch (IOException ioe) {\\n\t\t\t\tMessageUtil.warn(handler,\\n\t\t\t\t\t\tWeaverMessages.format(WeaverMessages.ZIPFILE_ENTRY_INVA"
  },
  {
    "method_id": "M1827",
    "name": "if",
    "return_type": "",
    "signature": "if(state == null)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1828",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(states)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1829",
    "name": "if",
    "return_type": "",
    "signature": "if(state == null)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1830",
    "name": "catch",
    "return_type": "",
    "signature": "catch(MalformedURLException e)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1831",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1832",
    "name": "visitFile",
    "return_type": "FileVisitResult",
    "signature": "visitFile(Path file, BasicFileAttributes attrs)",
    "file_id": "F30",
    "start_line": 385,
    "text_preview": "}\\n\t\t\t}\\n\t\t}\\n\\n\t\tclass PackageCacheBuilderVisitor extends SimpleFileVisitor<Path> {\\n\t\t\t@Override\\n\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\\n\t\t\t\tif (file.getNameCount() > 3 && file.toString().endsWith(\".class\")) {\\n\t\t\t\t\tint fnc = file.getNameCount();\\n\t\t\t\t\tif (fnc > 3) { //"
  },
  {
    "method_id": "M1833",
    "name": "if",
    "return_type": "",
    "signature": "if(fnc > 3)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1834",
    "name": "buildPackageMap",
    "return_type": "void",
    "signature": "buildPackageMap()",
    "file_id": "F30",
    "start_line": 374,
    "text_preview": "_URI, env, loader);\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\tstate = new JImageState(jrtFsPath, fs);\\n\t\t\t\t\t\t\tstates.put(jrtFsPath, state);\\n\t\t\t\t\t\t\tbuildPackageMap();\\n\t\t\t\t\t\t} catch (Throwable t) {\\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Unexpectedly unable to initialize a JRT filesystem\", t);\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\tclass PackageCacheBui"
  },
  {
    "method_id": "M1835",
    "name": "if",
    "return_type": "",
    "signature": "if(!state.packageCacheInitialized)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1836",
    "name": "for",
    "return_type": "",
    "signature": "for(java.nio.file.Path path : roots)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1837",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1838",
    "name": "TypeIdentifier",
    "return_type": "",
    "signature": "TypeIdentifier(String name)",
    "file_id": "F30",
    "start_line": 427,
    "text_preview": ";\\n\\n\t\t\t// Basic metric count of how many files we checked before finding it\\n\t\t\tpublic int filesSearchedCount;\\n\\n\t\t\tpublic TypeIdentifier(String name) {\\n\t\t\t\tthis.name = name;\\n\t\t\t}\\n\\n\t\t\t@Override\\n\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\\n\t\t\t\tfilesSearchedCount++;\\n\t\t\t\tif ("
  },
  {
    "method_id": "M1839",
    "name": "visitFile",
    "return_type": "FileVisitResult",
    "signature": "visitFile(Path file, BasicFileAttributes attrs)",
    "file_id": "F30",
    "start_line": 385,
    "text_preview": "}\\n\t\t\t}\\n\t\t}\\n\\n\t\tclass PackageCacheBuilderVisitor extends SimpleFileVisitor<Path> {\\n\t\t\t@Override\\n\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\\n\t\t\t\tif (file.getNameCount() > 3 && file.toString().endsWith(\".class\")) {\\n\t\t\t\t\tint fnc = file.getNameCount();\\n\t\t\t\t\tif (fnc > 3) { //"
  },
  {
    "method_id": "M1840",
    "name": "searchForFileAndCache",
    "return_type": "Path",
    "signature": "searchForFileAndCache(final Path startPath, final String name)",
    "file_id": "F30",
    "start_line": 448,
    "text_preview": "ile;\\n\t\t\t\t\t\treturn FileVisitResult.TERMINATE;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t\treturn FileVisitResult.CONTINUE;\\n\t\t\t}\\n\t\t}\\n\\n\t\tprivate Path searchForFileAndCache(final Path startPath, final String name) {\\n\t\t\tTypeIdentifier locator = new TypeIdentifier(name);\\n\t\t\ttry {\\n\t\t\t\tFiles.walkFileTree(startPath, locator);\\n\t\t\t} catch (IOException e) {"
  },
  {
    "method_id": "M1841",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1842",
    "name": "find",
    "return_type": "ClassFile",
    "signature": "find(String name)",
    "file_id": "F30",
    "start_line": 130,
    "text_preview": "VALID, name, ioe.getMessage()));\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t} else {\\n\t\t\tentries.add(new DirEntry(f));\\n\t\t}\\n\t}\\n\\n\tpublic ClassFile find(UnresolvedType type) {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"find\", this, type);\\n\t\t}\\n\t\tString name = type.getName();\\n\t\tif (notFound.contains(name)) {\\n\t\t\treturn null;\\n\t\t}\\n\t\tfor (Iterator"
  },
  {
    "method_id": "M1843",
    "name": "if",
    "return_type": "",
    "signature": "if(file == null)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1844",
    "name": "if",
    "return_type": "",
    "signature": "if(idx == -1)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1845",
    "name": "if",
    "return_type": "",
    "signature": "if(idx !=-1)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1846",
    "name": "if",
    "return_type": "",
    "signature": "if(packageStart != null)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1847",
    "name": "if",
    "return_type": "",
    "signature": "if(file == null)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1848",
    "name": "getPackageCache",
    "return_type": "Path>",
    "signature": "getPackageCache()",
    "file_id": "F30",
    "start_line": 487,
    "text_preview": "iles.readAllBytes(file);\\n\t\t\tClassFile cf = new ByteBasedClassFile(bs, fileName);\\n\t\t\treturn cf;\\n\t\t}\\n\\n\t\tMap<String, Path> getPackageCache() {\\n\t\t\treturn state.packageCache;\\n\t\t}\\n\\n\t\tMap<String, Path> getFileCache() {\\n\t\t\treturn state.fileCache;\\n\t\t}\\n\\n\t}\\n\\n\tclass ZipFileEntry extends Entry {\\n\t\tprivate File file;\\n\t\tprivate ZipFi"
  },
  {
    "method_id": "M1849",
    "name": "getFileCache",
    "return_type": "Path>",
    "signature": "getFileCache()",
    "file_id": "F30",
    "start_line": 491,
    "text_preview": "ame);\\n\t\t\treturn cf;\\n\t\t}\\n\\n\t\tMap<String, Path> getPackageCache() {\\n\t\t\treturn state.packageCache;\\n\t\t}\\n\\n\t\tMap<String, Path> getFileCache() {\\n\t\t\treturn state.fileCache;\\n\t\t}\\n\\n\t}\\n\\n\tclass ZipFileEntry extends Entry {\\n\t\tprivate File file;\\n\t\tprivate ZipFile zipFile;\\n\\n\t\tpublic ZipFileEntry(File file) throws IOException {\\n\t\t\tthis."
  },
  {
    "method_id": "M1850",
    "name": "ZipFileEntry",
    "return_type": "",
    "signature": "ZipFileEntry(File file)",
    "file_id": "F30",
    "start_line": 118,
    "text_preview": "ase().endsWith(LangUtil.JRT_FS)) { // Java9+\\n\t\t\t\t\tentries.add(new JImageEntry(name));\\n\t\t\t\t} else {\\n\t\t\t\t\tentries.add(new ZipFileEntry(f));\\n\t\t\t\t}\\n\t\t\t} catch (IOException ioe) {\\n\t\t\t\tMessageUtil.warn(handler,\\n\t\t\t\t\t\tWeaverMessages.format(WeaverMessages.ZIPFILE_ENTRY_INVALID, name, ioe.getMessage()));\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t} el"
  },
  {
    "method_id": "M1851",
    "name": "ZipFileEntry",
    "return_type": "",
    "signature": "ZipFileEntry(ZipFile zipFile)",
    "file_id": "F30",
    "start_line": 118,
    "text_preview": "ase().endsWith(LangUtil.JRT_FS)) { // Java9+\\n\t\t\t\t\tentries.add(new JImageEntry(name));\\n\t\t\t\t} else {\\n\t\t\t\t\tentries.add(new ZipFileEntry(f));\\n\t\t\t\t}\\n\t\t\t} catch (IOException ioe) {\\n\t\t\t\tMessageUtil.warn(handler,\\n\t\t\t\t\t\tWeaverMessages.format(WeaverMessages.ZIPFILE_ENTRY_INVALID, name, ioe.getMessage()));\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t} el"
  },
  {
    "method_id": "M1852",
    "name": "getZipFile",
    "return_type": "ZipFile",
    "signature": "getZipFile()",
    "file_id": "F30",
    "start_line": 296,
    "text_preview": "ile;\\n\t\t\tthis.entry = entry;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic InputStream getInputStream() throws IOException {\\n\t\t\tis = zipFile.getZipFile().getInputStream(entry);\\n\t\t\treturn is;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void close() {\\n\t\t\ttry {\\n\t\t\t\tif (is != null)\\n\t\t\t\t\tis.close();\\n\t\t\t} catch (IOException e) {\\n\t\t\t\te.printStackTrace();\\n\t\t\t} fina"
  },
  {
    "method_id": "M1853",
    "name": "find",
    "return_type": "ClassFile",
    "signature": "find(String name)",
    "file_id": "F30",
    "start_line": 130,
    "text_preview": "VALID, name, ioe.getMessage()));\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t} else {\\n\t\t\tentries.add(new DirEntry(f));\\n\t\t}\\n\t}\\n\\n\tpublic ClassFile find(UnresolvedType type) {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"find\", this, type);\\n\t\t}\\n\t\tString name = type.getName();\\n\t\tif (notFound.contains(name)) {\\n\t\t\treturn null;\\n\t\t}\\n\t\tfor (Iterator"
  },
  {
    "method_id": "M1854",
    "name": "getAllClassFiles",
    "return_type": "List<ZipEntryClassFile>",
    "signature": "getAllClassFiles()",
    "file_id": "F30",
    "start_line": 524,
    "text_preview": "is, entry);\\n\t\t\telse\\n\t\t\t\treturn null; // This zip will be closed when necessary...\\n\t\t}\\n\\n\t\tpublic List<ZipEntryClassFile> getAllClassFiles() throws IOException {\\n\t\t\tensureOpen();\\n\t\t\tList<ZipEntryClassFile> ret = new ArrayList<>();\\n\t\t\tfor (Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) {\\n\t\t\t\t"
  },
  {
    "method_id": "M1855",
    "name": "ensureOpen",
    "return_type": "void",
    "signature": "ensureOpen()",
    "file_id": "F30",
    "start_line": 515,
    "text_preview": "ZipFile getZipFile() {\\n\t\t\treturn zipFile;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic ClassFile find(String name) throws IOException {\\n\t\t\tensureOpen();\\n\t\t\tString key = name.replace('.', '/') + \".class\";\\n\t\t\tZipEntry entry = zipFile.getEntry(key);\\n\t\t\tif (entry != null)\\n\t\t\t\treturn new ZipEntryClassFile(this, entry);\\n\t\t\telse\\n\t\t\t\treturn null"
  },
  {
    "method_id": "M1856",
    "name": "isReallyOpen",
    "return_type": "boolean",
    "signature": "isReallyOpen()",
    "file_id": "F30",
    "start_line": 539,
    "text_preview": "}\\n\\n\t\tprivate void ensureOpen() throws IOException {\\n\t\t\tif (zipFile != null && openArchives.contains(zipFile)) {\\n\t\t\t\tif (isReallyOpen())\\n\t\t\t\t\treturn;\\n\t\t\t}\\n\t\t\tif (openArchives.size() >= maxOpenArchives) {\\n\t\t\t\tcloseSomeArchives(openArchives.size() / 10); // Close 10% of\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// those open\\n\t\t\t}\\n\t\t\tzipFile = new "
  },
  {
    "method_id": "M1857",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IllegalStateException ex)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1858",
    "name": "closeSomeArchives",
    "return_type": "void",
    "signature": "closeSomeArchives(int n)",
    "file_id": "F30",
    "start_line": 543,
    "text_preview": "ves.contains(zipFile)) {\\n\t\t\t\tif (isReallyOpen())\\n\t\t\t\t\treturn;\\n\t\t\t}\\n\t\t\tif (openArchives.size() >= maxOpenArchives) {\\n\t\t\t\tcloseSomeArchives(openArchives.size() / 10); // Close 10% of\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// those open\\n\t\t\t}\\n\t\t\tzipFile = new ZipFile(file);\\n\t\t\tif (!isReallyOpen()) {\\n\t\t\t\tthrow new FileNotFoundException(\"Can't ope"
  },
  {
    "method_id": "M1859",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = n - 1; i >= 0; i--)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1860",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1861",
    "name": "close",
    "return_type": "void",
    "signature": "close()",
    "file_id": "F30",
    "start_line": 184,
    "text_preview": "ic abstract InputStream getInputStream() throws IOException;\\n\t\tpublic abstract String getPath();\\n\t\tpublic abstract void close();\\n\t}\\n\\n\tabstract static class Entry {\\n\t\tpublic abstract ClassFile find(String name) throws IOException;\\n\t}\\n\\n\tstatic class ByteBasedClassFile extends ClassFile {\\n\\n\t\tprivate final byte[] bytes;\\n\t\t"
  },
  {
    "method_id": "M1862",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ioe)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1863",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F30",
    "start_line": 78,
    "text_preview": "ic {\\n\t\tString openzipsString = getSystemPropertyWithoutSecurityException(\"org.aspectj.weaver.openarchives\",\\n\t\t\t\tInteger.toString(MAXOPEN_DEFAULT));\\n\t\tmaxOpenArchives = Integer.parseInt(openzipsString);\\n\t\tif (maxOpenArchives < 20) {\\n\t\t\tmaxOpenArchives = MAXOPEN_DEFAULT;\\n\t\t}\\n\t}\\n\\n\tpublic ClassPathManager(List<String> clas"
  },
  {
    "method_id": "M1864",
    "name": "hasClassExtension",
    "return_type": "boolean",
    "signature": "hasClassExtension(String name)",
    "file_id": "F30",
    "start_line": 530,
    "text_preview": "ile.entries(); e.hasMoreElements();) {\\n\t\t\t\tZipEntry entry = e.nextElement();\\n\t\t\t\tString name = entry.getName();\\n\t\t\t\tif (hasClassExtension(name))\\n\t\t\t\t\tret.add(new ZipEntryClassFile(this, entry));\\n\t\t\t}\\n\t\t\t// if (ret.isEmpty()) close();\\n\t\t\treturn ret;\\n\t\t}\\n\\n\t\tprivate void ensureOpen() throws IOException {\\n\t\t\tif (zipFile !="
  },
  {
    "method_id": "M1865",
    "name": "closeArchives",
    "return_type": "void",
    "signature": "closeArchives()",
    "file_id": "F30",
    "start_line": 601,
    "text_preview": "vate */static boolean hasClassExtension(String name) {\\n\t\treturn name.toLowerCase().endsWith(\".class\");\\n\t}\\n\\n\tpublic void closeArchives() {\\n\t\tfor (Entry entry : entries) {\\n\t\t\tif (entry instanceof ZipFileEntry) {\\n\t\t\t\t((ZipFileEntry) entry).close();\\n\t\t\t}\\n\t\t\topenArchives.clear();\\n\t\t}\\n\t}\\n\\n\t// Copes with the security manager\\n"
  },
  {
    "method_id": "M1866",
    "name": "for",
    "return_type": "",
    "signature": "for(Entry entry : entries)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1867",
    "name": "if",
    "return_type": "",
    "signature": "if(entry instanceof ZipFileEntry)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1868",
    "name": "getSystemPropertyWithoutSecurityException",
    "return_type": "String",
    "signature": "getSystemPropertyWithoutSecurityException(String aPropertyName, String aDefaultValue)",
    "file_id": "F30",
    "start_line": 77,
    "text_preview": "it defaults to 1000\\n\tprivate final List<ZipFile> openArchives = new ArrayList<>();\\n\\n\tstatic {\\n\t\tString openzipsString = getSystemPropertyWithoutSecurityException(\"org.aspectj.weaver.openarchives\",\\n\t\t\t\tInteger.toString(MAXOPEN_DEFAULT));\\n\t\tmaxOpenArchives = Integer.parseInt(openzipsString);\\n\t\tif (maxOpenArchives < 20) {"
  },
  {
    "method_id": "M1869",
    "name": "catch",
    "return_type": "",
    "signature": "catch(SecurityException ex)",
    "file_id": "F30",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1870",
    "name": "getEntries",
    "return_type": "List<Entry>",
    "signature": "getEntries()",
    "file_id": "F30",
    "start_line": 620,
    "text_preview": "\\n\t\t} catch (SecurityException ex) {\\n\t\t\treturn aDefaultValue;\\n\t\t}\\n\t}\\n\\n\t// Mainly exposed for testing\\n\tpublic List<Entry> getEntries() {\\n\t\treturn entries;\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M1871",
    "name": "ExceptionRange",
    "return_type": "",
    "signature": "ExceptionRange(InstructionList body, UnresolvedType exceptionType, int priority)",
    "file_id": "F31",
    "start_line": 47,
    "text_preview": "e is not well situated unless {@link #associateWithTargets} is called\\n\t *\\n\t * XXX priority should be fixed\\n\t */\\n\tpublic ExceptionRange(InstructionList body, UnresolvedType exceptionType, int priority) {\\n\t\tsuper(body);\\n\t\tthis.exceptionType = exceptionType;\\n\t\tthis.priority = priority;\\n\t}\\n\\n\t/**\\n\t * @param insideExisting\\n\t"
  },
  {
    "method_id": "M1872",
    "name": "ExceptionRange",
    "return_type": "",
    "signature": "ExceptionRange(InstructionList body, UnresolvedType exceptionType, boolean insideExisting)",
    "file_id": "F31",
    "start_line": 47,
    "text_preview": "e is not well situated unless {@link #associateWithTargets} is called\\n\t *\\n\t * XXX priority should be fixed\\n\t */\\n\tpublic ExceptionRange(InstructionList body, UnresolvedType exceptionType, int priority) {\\n\t\tsuper(body);\\n\t\tthis.exceptionType = exceptionType;\\n\t\tthis.priority = priority;\\n\t}\\n\\n\t/**\\n\t * @param insideExisting\\n\t"
  },
  {
    "method_id": "M1873",
    "name": "associateWithTargets",
    "return_type": "void",
    "signature": "associateWithTargets(InstructionHandle start, InstructionHandle end, InstructionHandle handler)",
    "file_id": "F31",
    "start_line": 60,
    "text_preview": "nType, boolean insideExisting) {\\n\t\tthis(body, exceptionType, insideExisting ? Integer.MAX_VALUE : -1);\\n\t}\\n\\n\tpublic void associateWithTargets(InstructionHandle start, InstructionHandle end, InstructionHandle handler) {\\n\t\t// assert body.contains(start) && body.contains(end) && body.contains(handler)\\n\t\tthis.start = start;"
  },
  {
    "method_id": "M1874",
    "name": "getHandler",
    "return_type": "InstructionHandle",
    "signature": "getHandler()",
    "file_id": "F31",
    "start_line": 72,
    "text_preview": "\tstart.addTargeter(this);\\n\t\tend.addTargeter(this);\\n\t\thandler.addTargeter(this);\\n\t}\\n\\n\t// ----\\n\\n\tpublic InstructionHandle getHandler() {\\n\t\treturn handler;\\n\t}\\n\\n\tpublic UnresolvedType getCatchType() {\\n\t\treturn exceptionType;\\n\t}\\n\\n\tpublic int getPriority() {\\n\t\treturn priority;\\n\t}\\n\\n\t// ---- from object\\n\\n\tpublic String toStrin"
  },
  {
    "method_id": "M1875",
    "name": "getCatchType",
    "return_type": "UnresolvedType",
    "signature": "getCatchType()",
    "file_id": "F31",
    "start_line": 76,
    "text_preview": ".addTargeter(this);\\n\t}\\n\\n\t// ----\\n\\n\tpublic InstructionHandle getHandler() {\\n\t\treturn handler;\\n\t}\\n\\n\tpublic UnresolvedType getCatchType() {\\n\t\treturn exceptionType;\\n\t}\\n\\n\tpublic int getPriority() {\\n\t\treturn priority;\\n\t}\\n\\n\t// ---- from object\\n\\n\tpublic String toString() {\\n\t\tString str;\\n\t\tif (exceptionType == null) {\\n\t\t\tstr = "
  },
  {
    "method_id": "M1876",
    "name": "getPriority",
    "return_type": "int",
    "signature": "getPriority()",
    "file_id": "F31",
    "start_line": 80,
    "text_preview": "le getHandler() {\\n\t\treturn handler;\\n\t}\\n\\n\tpublic UnresolvedType getCatchType() {\\n\t\treturn exceptionType;\\n\t}\\n\\n\tpublic int getPriority() {\\n\t\treturn priority;\\n\t}\\n\\n\t// ---- from object\\n\\n\tpublic String toString() {\\n\t\tString str;\\n\t\tif (exceptionType == null) {\\n\t\t\tstr = \"finally\";\\n\t\t} else {\\n\t\t\tstr = \"catch \" + exceptionType;\\n"
  },
  {
    "method_id": "M1877",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F31",
    "start_line": 86,
    "text_preview": ") {\\n\t\treturn exceptionType;\\n\t}\\n\\n\tpublic int getPriority() {\\n\t\treturn priority;\\n\t}\\n\\n\t// ---- from object\\n\\n\tpublic String toString() {\\n\t\tString str;\\n\t\tif (exceptionType == null) {\\n\t\t\tstr = \"finally\";\\n\t\t} else {\\n\t\t\tstr = \"catch \" + exceptionType;\\n\t\t}\\n\t\t// if (priority >= 0 && priority < Integer.MAX_VALUE) {\\n\t\t// str += \" "
  },
  {
    "method_id": "M1878",
    "name": "if",
    "return_type": "",
    "signature": "if(exceptionType == null)",
    "file_id": "F31",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1879",
    "name": "if",
    "return_type": "",
    "signature": "if(priority >= 0 && priority < Integer.MAX_VALUE)",
    "file_id": "F31",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1880",
    "name": "equals",
    "return_type": "boolean",
    "signature": "equals(Object other)",
    "file_id": "F31",
    "start_line": 99,
    "text_preview": "&& priority < Integer.MAX_VALUE) {\\n\t\t// str += \" (priority \" + priority + \")\";\\n\t\t// }\\n\t\treturn str;\\n\t}\\n\\n\tpublic boolean equals(Object other) {\\n\t\tif (!(other instanceof ExceptionRange))\\n\t\t\treturn false;\\n\t\tExceptionRange o = (ExceptionRange) other;\\n\t\treturn o.getStart() == getStart() && o.getEnd() == getEnd() && o.handle"
  },
  {
    "method_id": "M1881",
    "name": "hashCode",
    "return_type": "int",
    "signature": "hashCode()",
    "file_id": "F31",
    "start_line": 110,
    "text_preview": "xceptionType.equals(exceptionType))\\n\t\t\t\t&& o.priority == priority;\\n\t}\\n\\n\tprivate volatile int hashCode = 0;\\n\\n\tpublic int hashCode() {\\n\t\tif (hashCode == 0) {\\n\t\t\tint ret = 17;\\n\t\t\tret = 37 * ret + getStart().hashCode();\\n\t\t\tret = 37 * ret + getEnd().hashCode();\\n\t\t\tret = 37 * ret + handler.hashCode();\\n\t\t\tret = 37 * ret + ((e"
  },
  {
    "method_id": "M1882",
    "name": "if",
    "return_type": "",
    "signature": "if(hashCode == 0)",
    "file_id": "F31",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1883",
    "name": "updateTarget",
    "return_type": "void",
    "signature": "updateTarget(InstructionHandle oldIh, InstructionHandle newIh, InstructionList newBody)",
    "file_id": "F31",
    "start_line": 123,
    "text_preview": "0 : exceptionType.hashCode());\\n\t\t\tret = 37 * ret + priority;\\n\t\t\thashCode = ret;\\n\t\t}\\n\t\treturn hashCode;\\n\t}\\n\\n\tpublic void updateTarget(InstructionHandle oldIh, InstructionHandle newIh, InstructionList newBody) {\\n\t\tsuper.updateTarget(oldIh, newIh, newBody);\\n\t\t// we're guaranteed that start, end, and handler are distinct i"
  },
  {
    "method_id": "M1884",
    "name": "if",
    "return_type": "",
    "signature": "if(oldIh == handler)",
    "file_id": "F31",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1885",
    "name": "isExceptionStart",
    "return_type": "boolean",
    "signature": "isExceptionStart(InstructionHandle ih)",
    "file_id": "F31",
    "start_line": 131,
    "text_preview": " handler are distinct instruction handles.\\n\t\tif (oldIh == handler) {\\n\t\t\thandler = newIh;\\n\t\t}\\n\t}\\n\\n\tpublic static boolean isExceptionStart(InstructionHandle ih) {\\n\t\tif (!isRangeHandle(ih))\\n\t\t\treturn false;\\n\t\tRange r = getRange(ih);\\n\t\tif (!(r instanceof ExceptionRange))\\n\t\t\treturn false;\\n\t\tExceptionRange er = (ExceptionRan"
  },
  {
    "method_id": "M1886",
    "name": "isExceptionEnd",
    "return_type": "boolean",
    "signature": "isExceptionEnd(InstructionHandle ih)",
    "file_id": "F31",
    "start_line": 141,
    "text_preview": "e))\\n\t\t\treturn false;\\n\t\tExceptionRange er = (ExceptionRange) r;\\n\t\treturn er.getStart() == ih;\\n\t}\\n\\n\tpublic static boolean isExceptionEnd(InstructionHandle ih) {\\n\t\tif (!isRangeHandle(ih))\\n\t\t\treturn false;\\n\t\tRange r = getRange(ih);\\n\t\tif (!(r instanceof ExceptionRange))\\n\t\t\treturn false;\\n\t\tExceptionRange er = (ExceptionRange"
  },
  {
    "method_id": "M1887",
    "name": "ExtensibleURLClassLoader",
    "return_type": "",
    "signature": "ExtensibleURLClassLoader(URL[] urls, ClassLoader parent)",
    "file_id": "F32",
    "start_line": 31,
    "text_preview": "\\npublic abstract class ExtensibleURLClassLoader extends URLClassLoader {\\n\\n\tprivate ClassPathManager classPath;\\n\\n\tpublic ExtensibleURLClassLoader(URL[] urls, ClassLoader parent) {\\n\t\tsuper(urls, parent);\\n\\n\t\t// System.err.println(\"? ExtensibleURLClassLoader.<init>() path=\" + WeavingAdaptor.makeClasspath(urls));\\n\t\ttry {\\n\t\t"
  },
  {
    "method_id": "M1888",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ExceptionInInitializerError ex)",
    "file_id": "F32",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1889",
    "name": "addURL",
    "return_type": "void",
    "signature": "addURL(URL url)",
    "file_id": "F32",
    "start_line": 43,
    "text_preview": ");\\n\t\t} catch (ExceptionInInitializerError ex) {\\n\t\t\tex.printStackTrace(System.out);\\n\t\t\tthrow ex;\\n\t\t}\\n\t}\\n\\n\tprotected void addURL(URL url) {\\n\t\tsuper.addURL(url); // amc - this call was missing and is needed in\\n\t\t// WeavingURLClassLoader chains\\n\t\tclassPath.addPath(url.getPath(), null);\\n\t}\\n\\n\tprotected Class findClass(String"
  },
  {
    "method_id": "M1890",
    "name": "findClass",
    "return_type": "Class",
    "signature": "findClass(String name)",
    "file_id": "F32",
    "start_line": 49,
    "text_preview": "ssing and is needed in\\n\t\t// WeavingURLClassLoader chains\\n\t\tclassPath.addPath(url.getPath(), null);\\n\t}\\n\\n\tprotected Class findClass(String name) throws ClassNotFoundException {\\n\t\t// System.err.println(\"? ExtensibleURLClassLoader.findClass(\" + name + \")\");\\n\t\ttry {\\n\t\t\tbyte[] bytes = getBytes(name);\\n\t\t\tif (bytes != null) {\\n"
  },
  {
    "method_id": "M1891",
    "name": "if",
    "return_type": "",
    "signature": "if(bytes != null)",
    "file_id": "F32",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1892",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ex)",
    "file_id": "F32",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1893",
    "name": "defineClass",
    "return_type": "Class",
    "signature": "defineClass(String name, byte[] b, CodeSource cs)",
    "file_id": "F32",
    "start_line": 54,
    "text_preview": "eURLClassLoader.findClass(\" + name + \")\");\\n\t\ttry {\\n\t\t\tbyte[] bytes = getBytes(name);\\n\t\t\tif (bytes != null) {\\n\t\t\t\treturn defineClass(name, bytes);\\n\t\t\t} else {\\n\t\t\t\tthrow new ClassNotFoundException(name);\\n\t\t\t}\\n\t\t} catch (IOException ex) {\\n\t\t\tthrow new ClassNotFoundException(name, ex);\\n\t\t}\\n\t}\\n\\n\tprotected Class defineClass("
  },
  {
    "method_id": "M1894",
    "name": "getBytes",
    "return_type": "byte[]",
    "signature": "getBytes(String name)",
    "file_id": "F32",
    "start_line": 52,
    "text_preview": "undException {\\n\t\t// System.err.println(\"? ExtensibleURLClassLoader.findClass(\" + name + \")\");\\n\t\ttry {\\n\t\t\tbyte[] bytes = getBytes(name);\\n\t\t\tif (bytes != null) {\\n\t\t\t\treturn defineClass(name, bytes);\\n\t\t\t} else {\\n\t\t\t\tthrow new ClassNotFoundException(name);\\n\t\t\t}\\n\t\t} catch (IOException ex) {\\n\t\t\tthrow new ClassNotFoundExcepti"
  },
  {
    "method_id": "M1895",
    "name": "catch",
    "return_type": "",
    "signature": "catch(BCException bce)",
    "file_id": "F32",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1896",
    "name": "if",
    "return_type": "",
    "signature": "if(classFile != null)",
    "file_id": "F32",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1897",
    "name": "defineClass",
    "return_type": ">",
    "signature": "defineClass(String name, byte[] bytes /* ClassPathManager.ClassFile classFile */)",
    "file_id": "F32",
    "start_line": 54,
    "text_preview": "eURLClassLoader.findClass(\" + name + \")\");\\n\t\ttry {\\n\t\t\tbyte[] bytes = getBytes(name);\\n\t\t\tif (bytes != null) {\\n\t\t\t\treturn defineClass(name, bytes);\\n\t\t\t} else {\\n\t\t\t\tthrow new ClassNotFoundException(name);\\n\t\t\t}\\n\t\t} catch (IOException ex) {\\n\t\t\tthrow new ClassNotFoundException(name, ex);\\n\t\t}\\n\t}\\n\\n\tprotected Class defineClass("
  },
  {
    "method_id": "M1898",
    "name": "if",
    "return_type": "",
    "signature": "if(packageName != null)",
    "file_id": "F32",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1899",
    "name": "if",
    "return_type": "",
    "signature": "if(pakkage == null)",
    "file_id": "F32",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1900",
    "name": "getPackageName",
    "return_type": "String",
    "signature": "getPackageName(String className)",
    "file_id": "F32",
    "start_line": 91,
    "text_preview": "Class(String name, byte[] bytes /* ClassPathManager.ClassFile classFile */) throws IOException {\\n\t\tString packageName = getPackageName(name);\\n\t\tif (packageName != null) {\\n\t\t\tPackage pakkage = getPackage(packageName);\\n\t\t\tif (pakkage == null) {\\n\t\t\t\tdefinePackage(packageName, null, null, null, null, null, null, null);\\n\t\t\t"
  },
  {
    "method_id": "M1901",
    "name": "close",
    "return_type": "void",
    "signature": "close()",
    "file_id": "F32",
    "start_line": 84,
    "text_preview": "lassFile != null) {\\n\t\t\ttry {\\n\t\t\t\tb = FileUtil.readAsByteArray(classFile.getInputStream());\\n\t\t\t} finally {\\n\t\t\t\tclassFile.close();\\n\t\t\t}\\n\t\t}\\n\t\treturn b;\\n\t}\\n\\n\tprivate Class<?> defineClass(String name, byte[] bytes /* ClassPathManager.ClassFile classFile */) throws IOException {\\n\t\tString packageName = getPackageName(name);\\n"
  },
  {
    "method_id": "M1902",
    "name": "FakeAnnotation",
    "return_type": "",
    "signature": "FakeAnnotation(String name, String sig, boolean isRuntimeVisible)",
    "file_id": "F33",
    "start_line": 35,
    "text_preview": "otation extends AnnotationGen {\\n\\n\tprivate String name;\\n\tprivate String sig;\\n\tprivate boolean isRuntimeVisible;\\n\\n\tpublic FakeAnnotation(String name, String sig, boolean isRuntimeVisible) {\\n\t\tsuper(null, null, true, null);\\n\t\tthis.name = name;\\n\t\tthis.sig = sig;\\n\t\tthis.isRuntimeVisible = isRuntimeVisible;\\n\t}\\n\\n\tpublic Strin"
  },
  {
    "method_id": "M1903",
    "name": "getTypeName",
    "return_type": "String",
    "signature": "getTypeName()",
    "file_id": "F33",
    "start_line": 42,
    "text_preview": "null, true, null);\\n\t\tthis.name = name;\\n\t\tthis.sig = sig;\\n\t\tthis.isRuntimeVisible = isRuntimeVisible;\\n\t}\\n\\n\tpublic String getTypeName() {\\n\t\treturn name;\\n\t}\\n\\n\tpublic String getTypeSignature() {\\n\t\treturn sig;\\n\t}\\n\\n\tpublic void addElementNameValuePair(NameValuePair evp) {\\n\t\t// doesnt need to know about name/value pairs\\n\t}\\n\\n\t"
  },
  {
    "method_id": "M1904",
    "name": "getTypeSignature",
    "return_type": "String",
    "signature": "getTypeSignature()",
    "file_id": "F33",
    "start_line": 46,
    "text_preview": "= sig;\\n\t\tthis.isRuntimeVisible = isRuntimeVisible;\\n\t}\\n\\n\tpublic String getTypeName() {\\n\t\treturn name;\\n\t}\\n\\n\tpublic String getTypeSignature() {\\n\t\treturn sig;\\n\t}\\n\\n\tpublic void addElementNameValuePair(NameValuePair evp) {\\n\t\t// doesnt need to know about name/value pairs\\n\t}\\n\\n\tpublic void dump(DataOutputStream dos) throws IOEx"
  },
  {
    "method_id": "M1905",
    "name": "addElementNameValuePair",
    "return_type": "void",
    "signature": "addElementNameValuePair(NameValuePair evp)",
    "file_id": "F33",
    "start_line": 50,
    "text_preview": "}\\n\\n\tpublic String getTypeName() {\\n\t\treturn name;\\n\t}\\n\\n\tpublic String getTypeSignature() {\\n\t\treturn sig;\\n\t}\\n\\n\tpublic void addElementNameValuePair(NameValuePair evp) {\\n\t\t// doesnt need to know about name/value pairs\\n\t}\\n\\n\tpublic void dump(DataOutputStream dos) throws IOException {\\n\t\t// should be serialized\\n\t}\\n\\n\tpublic int "
  },
  {
    "method_id": "M1906",
    "name": "dump",
    "return_type": "void",
    "signature": "dump(DataOutputStream dos)",
    "file_id": "F33",
    "start_line": 54,
    "text_preview": "blic void addElementNameValuePair(NameValuePair evp) {\\n\t\t// doesnt need to know about name/value pairs\\n\t}\\n\\n\tpublic void dump(DataOutputStream dos) throws IOException {\\n\t\t// should be serialized\\n\t}\\n\\n\tpublic int getTypeIndex() {\\n\t\treturn 0;\\n\t}\\n\\n\tpublic List getValues() {\\n\t\treturn null;\\n\t}\\n\\n\tpublic boolean isRuntimeVisibl"
  },
  {
    "method_id": "M1907",
    "name": "getTypeIndex",
    "return_type": "int",
    "signature": "getTypeIndex()",
    "file_id": "F33",
    "start_line": 58,
    "text_preview": "/value pairs\\n\t}\\n\\n\tpublic void dump(DataOutputStream dos) throws IOException {\\n\t\t// should be serialized\\n\t}\\n\\n\tpublic int getTypeIndex() {\\n\t\treturn 0;\\n\t}\\n\\n\tpublic List getValues() {\\n\t\treturn null;\\n\t}\\n\\n\tpublic boolean isRuntimeVisible() {\\n\t\treturn isRuntimeVisible;\\n\t}\\n\\n\tprotected void setIsRuntimeVisible(boolean b) {\\n\t}\\n\\n"
  },
  {
    "method_id": "M1908",
    "name": "getValues",
    "return_type": "List",
    "signature": "getValues()",
    "file_id": "F33",
    "start_line": 62,
    "text_preview": "tream dos) throws IOException {\\n\t\t// should be serialized\\n\t}\\n\\n\tpublic int getTypeIndex() {\\n\t\treturn 0;\\n\t}\\n\\n\tpublic List getValues() {\\n\t\treturn null;\\n\t}\\n\\n\tpublic boolean isRuntimeVisible() {\\n\t\treturn isRuntimeVisible;\\n\t}\\n\\n\tprotected void setIsRuntimeVisible(boolean b) {\\n\t}\\n\\n\tpublic String toShortString() {\\n\t\treturn \"@\" "
  },
  {
    "method_id": "M1909",
    "name": "isRuntimeVisible",
    "return_type": "boolean",
    "signature": "isRuntimeVisible()",
    "file_id": "F33",
    "start_line": 66,
    "text_preview": "rialized\\n\t}\\n\\n\tpublic int getTypeIndex() {\\n\t\treturn 0;\\n\t}\\n\\n\tpublic List getValues() {\\n\t\treturn null;\\n\t}\\n\\n\tpublic boolean isRuntimeVisible() {\\n\t\treturn isRuntimeVisible;\\n\t}\\n\\n\tprotected void setIsRuntimeVisible(boolean b) {\\n\t}\\n\\n\tpublic String toShortString() {\\n\t\treturn \"@\" + this.name;\\n\t}\\n\\n\tpublic String toString() {\\n\t\tre"
  },
  {
    "method_id": "M1910",
    "name": "setIsRuntimeVisible",
    "return_type": "void",
    "signature": "setIsRuntimeVisible(boolean b)",
    "file_id": "F33",
    "start_line": 70,
    "text_preview": "st getValues() {\\n\t\treturn null;\\n\t}\\n\\n\tpublic boolean isRuntimeVisible() {\\n\t\treturn isRuntimeVisible;\\n\t}\\n\\n\tprotected void setIsRuntimeVisible(boolean b) {\\n\t}\\n\\n\tpublic String toShortString() {\\n\t\treturn \"@\" + this.name;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn this.name;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M1911",
    "name": "toShortString",
    "return_type": "String",
    "signature": "toShortString()",
    "file_id": "F33",
    "start_line": 73,
    "text_preview": "isRuntimeVisible() {\\n\t\treturn isRuntimeVisible;\\n\t}\\n\\n\tprotected void setIsRuntimeVisible(boolean b) {\\n\t}\\n\\n\tpublic String toShortString() {\\n\t\treturn \"@\" + this.name;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn this.name;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M1912",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F33",
    "start_line": 77,
    "text_preview": "void setIsRuntimeVisible(boolean b) {\\n\t}\\n\\n\tpublic String toShortString() {\\n\t\treturn \"@\" + this.name;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn this.name;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M1913",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(IfPointcut node, Object data)",
    "file_id": "F34",
    "start_line": 26,
    "text_preview": "ok for an if() pointcut\\n */\\nclass IfFinder extends AbstractPatternNodeVisitor {\\n\tboolean hasIf = false;\\n\\n\tpublic Object visit(IfPointcut node, Object data) {\\n\t\tif (node.alwaysFalse() || node.alwaysTrue()) {\\n\t\t\t// IfFalse / IfTrue\\n\t\t} else {\\n\t\t\thasIf = true;\\n\t\t}\\n\t\treturn node;\\n\t}\\n\\n\tpublic Object visit(AndPointcut node, "
  },
  {
    "method_id": "M1914",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(AndPointcut node, Object data)",
    "file_id": "F34",
    "start_line": 26,
    "text_preview": "ok for an if() pointcut\\n */\\nclass IfFinder extends AbstractPatternNodeVisitor {\\n\tboolean hasIf = false;\\n\\n\tpublic Object visit(IfPointcut node, Object data) {\\n\t\tif (node.alwaysFalse() || node.alwaysTrue()) {\\n\t\t\t// IfFalse / IfTrue\\n\t\t} else {\\n\t\t\thasIf = true;\\n\t\t}\\n\t\treturn node;\\n\t}\\n\\n\tpublic Object visit(AndPointcut node, "
  },
  {
    "method_id": "M1915",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(NotPointcut node, Object data)",
    "file_id": "F34",
    "start_line": 26,
    "text_preview": "ok for an if() pointcut\\n */\\nclass IfFinder extends AbstractPatternNodeVisitor {\\n\tboolean hasIf = false;\\n\\n\tpublic Object visit(IfPointcut node, Object data) {\\n\t\tif (node.alwaysFalse() || node.alwaysTrue()) {\\n\t\t\t// IfFalse / IfTrue\\n\t\t} else {\\n\t\t\thasIf = true;\\n\t\t}\\n\t\treturn node;\\n\t}\\n\\n\tpublic Object visit(AndPointcut node, "
  },
  {
    "method_id": "M1916",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(OrPointcut node, Object data)",
    "file_id": "F34",
    "start_line": 26,
    "text_preview": "ok for an if() pointcut\\n */\\nclass IfFinder extends AbstractPatternNodeVisitor {\\n\tboolean hasIf = false;\\n\\n\tpublic Object visit(IfPointcut node, Object data) {\\n\t\tif (node.alwaysFalse() || node.alwaysTrue()) {\\n\t\t\t// IfFalse / IfTrue\\n\t\t} else {\\n\t\t\thasIf = true;\\n\t\t}\\n\t\treturn node;\\n\t}\\n\\n\tpublic Object visit(AndPointcut node, "
  },
  {
    "method_id": "M1917",
    "name": "InlinedSourceFileInfo",
    "return_type": "calculated",
    "signature": "InlinedSourceFileInfo(int highestLineNumber)",
    "file_id": "F35",
    "start_line": 162,
    "text_preview": "erclass = null;\\n\\n\t// ---\\n\\n\tstatic class InlinedSourceFileInfo {\\n\t\tint highestLineNumber;\\n\t\tint offset; // calculated\\n\\n\t\tInlinedSourceFileInfo(int highestLineNumber) {\\n\t\t\tthis.highestLineNumber = highestLineNumber;\\n\t\t}\\n\t}\\n\\n\tvoid addInlinedSourceFileInfo(String fullpath, int highestLineNumber) {\\n\t\tInlinedSourceFileInfo i"
  },
  {
    "method_id": "M1918",
    "name": "addInlinedSourceFileInfo",
    "return_type": "void",
    "signature": "addInlinedSourceFileInfo(String fullpath, int highestLineNumber)",
    "file_id": "F35",
    "start_line": 167,
    "text_preview": "lculated\\n\\n\t\tInlinedSourceFileInfo(int highestLineNumber) {\\n\t\t\tthis.highestLineNumber = highestLineNumber;\\n\t\t}\\n\t}\\n\\n\tvoid addInlinedSourceFileInfo(String fullpath, int highestLineNumber) {\\n\t\tInlinedSourceFileInfo info = inlinedFiles.get(fullpath);\\n\t\tif (info != null) {\\n\t\t\tif (info.highestLineNumber < highestLineNumber) {"
  },
  {
    "method_id": "M1919",
    "name": "if",
    "return_type": "",
    "signature": "if(info != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1920",
    "name": "if",
    "return_type": "",
    "signature": "if(info.highestLineNumber < highestLineNumber)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1921",
    "name": "calculateSourceDebugExtensionOffsets",
    "return_type": "void",
    "signature": "calculateSourceDebugExtensionOffsets()",
    "file_id": "F35",
    "start_line": 178,
    "text_preview": "tLineNumber;\\n\t\t\t}\\n\t\t} else {\\n\t\t\tinlinedFiles.put(fullpath, new InlinedSourceFileInfo(highestLineNumber));\\n\t\t}\\n\t}\\n\\n\tvoid calculateSourceDebugExtensionOffsets() {\\n\t\tint i = roundUpToHundreds(highestLineNumber);\\n\t\tfor (InlinedSourceFileInfo element : inlinedFiles.values()) {\\n\t\t\telement.offset = i;\\n\t\t\ti = roundUpToHundreds"
  },
  {
    "method_id": "M1922",
    "name": "roundUpToHundreds",
    "return_type": "int",
    "signature": "roundUpToHundreds(int i)",
    "file_id": "F35",
    "start_line": 179,
    "text_preview": "llpath, new InlinedSourceFileInfo(highestLineNumber));\\n\t\t}\\n\t}\\n\\n\tvoid calculateSourceDebugExtensionOffsets() {\\n\t\tint i = roundUpToHundreds(highestLineNumber);\\n\t\tfor (InlinedSourceFileInfo element : inlinedFiles.values()) {\\n\t\t\telement.offset = i;\\n\t\t\ti = roundUpToHundreds(i + element.highestLineNumber);\\n\t\t}\\n\t}\\n\\n\tprivate s"
  },
  {
    "method_id": "M1923",
    "name": "getSourceDebugExtensionOffset",
    "return_type": "int",
    "signature": "getSourceDebugExtensionOffset(String fullpath)",
    "file_id": "F35",
    "start_line": 190,
    "text_preview": "ent.highestLineNumber);\\n\t\t}\\n\t}\\n\\n\tprivate static int roundUpToHundreds(int i) {\\n\t\treturn ((i / 100) + 1) * 100;\\n\t}\\n\\n\tint getSourceDebugExtensionOffset(String fullpath) {\\n\t\treturn inlinedFiles.get(fullpath).offset;\\n\t}\\n\\n\t// private Unknown getSourceDebugExtensionAttribute() {\\n\t// int nameIndex = cp.addUtf8(\"SourceDebugExt"
  },
  {
    "method_id": "M1924",
    "name": "getSourceDebugExtensionAttribute",
    "return_type": "Unknown",
    "signature": "getSourceDebugExtensionAttribute()",
    "file_id": "F35",
    "start_line": 194,
    "text_preview": "nt getSourceDebugExtensionOffset(String fullpath) {\\n\t\treturn inlinedFiles.get(fullpath).offset;\\n\t}\\n\\n\t// private Unknown getSourceDebugExtensionAttribute() {\\n\t// int nameIndex = cp.addUtf8(\"SourceDebugExtension\");\\n\t// String data = getSourceDebugExtensionString();\\n\t// //System.err.println(data);\\n\t// byte[] bytes = Utili"
  },
  {
    "method_id": "M1925",
    "name": "LazyClassGen",
    "return_type": "",
    "signature": "LazyClassGen()",
    "file_id": "F35",
    "start_line": 204,
    "text_preview": "oUTF(data);\\n\t// int length = bytes.length;\\n\t//\\n\t// return new Unknown(nameIndex, length, bytes, cp);\\n\t// }\\n\\n\t// private LazyClassGen() {}\\n\t// public static void main(String[] args) {\\n\t// LazyClassGen m = new LazyClassGen();\\n\t// m.highestLineNumber = 37;\\n\t// m.inlinedFiles.put(\"boo/baz/foo.java\", new InlinedSourceFileIn"
  },
  {
    "method_id": "M1926",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] args)",
    "file_id": "F35",
    "start_line": 205,
    "text_preview": ";\\n\t//\\n\t// return new Unknown(nameIndex, length, bytes, cp);\\n\t// }\\n\\n\t// private LazyClassGen() {}\\n\t// public static void main(String[] args) {\\n\t// LazyClassGen m = new LazyClassGen();\\n\t// m.highestLineNumber = 37;\\n\t// m.inlinedFiles.put(\"boo/baz/foo.java\", new InlinedSourceFileInfo( 83));\\n\t// m.inlinedFiles.put(\"boo/bar"
  },
  {
    "method_id": "M1927",
    "name": "getSourceDebugExtensionString",
    "return_type": "String",
    "signature": "getSourceDebugExtensionString()",
    "file_id": "F35",
    "start_line": 196,
    "text_preview": " Unknown getSourceDebugExtensionAttribute() {\\n\t// int nameIndex = cp.addUtf8(\"SourceDebugExtension\");\\n\t// String data = getSourceDebugExtensionString();\\n\t// //System.err.println(data);\\n\t// byte[] bytes = Utility.stringToUTF(data);\\n\t// int length = bytes.length;\\n\t//\\n\t// return new Unknown(nameIndex, length, bytes, cp);\\n"
  },
  {
    "method_id": "M1928",
    "name": "if",
    "return_type": "",
    "signature": "if(ii == -1)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1929",
    "name": "disassemble",
    "return_type": "void",
    "signature": "disassemble(String path, String name, PrintStream out)",
    "file_id": "F35",
    "start_line": 266,
    "text_preview": "ring();\\n\t// }\\n\\n\t// ---- end JSR45-related stuff\\n\\n\t/** Emit disassembled class and newline to out */\\n\tpublic static void disassemble(String path, String name, PrintStream out) throws IOException {\\n\t\tif (null == out) {\\n\t\t\treturn;\\n\t\t}\\n\t\t// out.println(\"classPath: \" + classPath);\\n\\n\t\tBcelWorld world = new BcelWorld(path);\\n\\n"
  },
  {
    "method_id": "M1930",
    "name": "if",
    "return_type": "",
    "signature": "if(null == out)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1931",
    "name": "getNewGeneratedNameTag",
    "return_type": "String",
    "signature": "getNewGeneratedNameTag()",
    "file_id": "F35",
    "start_line": 281,
    "text_preview": "w LazyClassGen(BcelWorld.getBcelObjectType(world.resolve(ut)));\\n\t\tclazz.print(out);\\n\t\tout.println();\\n\t}\\n\\n\tpublic String getNewGeneratedNameTag() {\\n\t\treturn Integer.toString(childCounter++);\\n\t}\\n\\n\t// ----\\n\\n\tpublic LazyClassGen(String class_name, String super_class_name, String file_name, int access_flags, String[] interf"
  },
  {
    "method_id": "M1932",
    "name": "LazyClassGen",
    "return_type": "",
    "signature": "LazyClassGen(String class_name, String super_class_name, String file_name, int access_flags, String[] interfaces,\n\t\t\tWorld world)",
    "file_id": "F35",
    "start_line": 204,
    "text_preview": "oUTF(data);\\n\t// int length = bytes.length;\\n\t//\\n\t// return new Unknown(nameIndex, length, bytes, cp);\\n\t// }\\n\\n\t// private LazyClassGen() {}\\n\t// public static void main(String[] args) {\\n\t// LazyClassGen m = new LazyClassGen();\\n\t// m.highestLineNumber = 37;\\n\t// m.inlinedFiles.put(\"boo/baz/foo.java\", new InlinedSourceFileIn"
  },
  {
    "method_id": "M1933",
    "name": "setMajorMinor",
    "return_type": "void",
    "signature": "setMajorMinor(int major, int minor)",
    "file_id": "F35",
    "start_line": 296,
    "text_preview": "new InstructionFactory(myGen, cp);\\n\t\tregenerateGenericSignatureAttribute = true;\\n\t\tthis.world = world;\\n\t}\\n\\n\tpublic void setMajorMinor(int major, int minor) {\\n\t\tmyGen.setMajor(major);\\n\t\tmyGen.setMinor(minor);\\n\t}\\n\\n\tpublic int getMajor() {\\n\t\treturn myGen.getMajor();\\n\t}\\n\\n\tpublic int getMinor() {\\n\t\treturn myGen.getMinor();\\n"
  },
  {
    "method_id": "M1934",
    "name": "getMajor",
    "return_type": "int",
    "signature": "getMajor()",
    "file_id": "F35",
    "start_line": 301,
    "text_preview": "}\\n\\n\tpublic void setMajorMinor(int major, int minor) {\\n\t\tmyGen.setMajor(major);\\n\t\tmyGen.setMinor(minor);\\n\t}\\n\\n\tpublic int getMajor() {\\n\t\treturn myGen.getMajor();\\n\t}\\n\\n\tpublic int getMinor() {\\n\t\treturn myGen.getMinor();\\n\t}\\n\\n\t// Non child type, so it comes from a real type in the world.\\n\tpublic LazyClassGen(BcelObjectType m"
  },
  {
    "method_id": "M1935",
    "name": "getMinor",
    "return_type": "int",
    "signature": "getMinor()",
    "file_id": "F35",
    "start_line": 305,
    "text_preview": "myGen.setMajor(major);\\n\t\tmyGen.setMinor(minor);\\n\t}\\n\\n\tpublic int getMajor() {\\n\t\treturn myGen.getMajor();\\n\t}\\n\\n\tpublic int getMinor() {\\n\t\treturn myGen.getMinor();\\n\t}\\n\\n\t// Non child type, so it comes from a real type in the world.\\n\tpublic LazyClassGen(BcelObjectType myType) {\\n\t\tmyGen = new ClassGen(myType.getJavaClass());\\n"
  },
  {
    "method_id": "M1936",
    "name": "LazyClassGen",
    "return_type": "",
    "signature": "LazyClassGen(BcelObjectType myType)",
    "file_id": "F35",
    "start_line": 204,
    "text_preview": "oUTF(data);\\n\t// int length = bytes.length;\\n\t//\\n\t// return new Unknown(nameIndex, length, bytes, cp);\\n\t// }\\n\\n\t// private LazyClassGen() {}\\n\t// public static void main(String[] args) {\\n\t// LazyClassGen m = new LazyClassGen();\\n\t// m.highestLineNumber = 37;\\n\t// m.inlinedFiles.put(\"boo/baz/foo.java\", new InlinedSourceFileIn"
  },
  {
    "method_id": "M1937",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < fields.length; i++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1938",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1939",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1940",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < methods.length; i++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1941",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember field : fields)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1942",
    "name": "hasSerialVersionUIDField",
    "return_type": "boolean",
    "signature": "hasSerialVersionUIDField(ResolvedType type)",
    "file_id": "F35",
    "start_line": 330,
    "text_preview": "uals(UnresolvedType.LONG))\\n\t\t\t// {\\n\t\t\t// hasSerialVersionUIDField = true;\\n\t\t\t// }\\n\t\t\t// }\\n\t\t\thasSerialVersionUIDField = hasSerialVersionUIDField(getType());\\n\\n\t\t\tResolvedMember[] methods = getType().getDeclaredMethods();\\n\t\t\tfor (ResolvedMember method : methods) {\\n\t\t\t\tif (method.getName().equals(\"<clinit>\")) {\\n\t\t\t\t\tif (m"
  },
  {
    "method_id": "M1943",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember field : fields)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1944",
    "name": "addAttribute",
    "return_type": "void",
    "signature": "addAttribute(Attribute i)",
    "file_id": "F35",
    "start_line": 387,
    "text_preview": ")\\n\t\t\t\t\t&& field.getType().equals(UnresolvedType.LONG)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\\n\t\treturn false;\\n\t}\\n\\n\t// public void addAttribute(Attribute i) {\\n\t// myGen.addAttribute(i);\\n\t// }\\n\\n\t// ----\\n\\n\tpublic String getInternalClassName() {\\n\t\treturn getConstantPool().getConstantString_CONSTANTClass(myGen.getClassNameIndex());\\n\t"
  },
  {
    "method_id": "M1945",
    "name": "getInternalClassName",
    "return_type": "String",
    "signature": "getInternalClassName()",
    "file_id": "F35",
    "start_line": 393,
    "text_preview": "eturn false;\\n\t}\\n\\n\t// public void addAttribute(Attribute i) {\\n\t// myGen.addAttribute(i);\\n\t// }\\n\\n\t// ----\\n\\n\tpublic String getInternalClassName() {\\n\t\treturn getConstantPool().getConstantString_CONSTANTClass(myGen.getClassNameIndex());\\n\t\t// getConstantPool().getConstantString(\\n\t\t// myGen.getClassNameIndex(),\\n\t\t// Constants"
  },
  {
    "method_id": "M1946",
    "name": "getInternalFileName",
    "return_type": "String",
    "signature": "getInternalFileName()",
    "file_id": "F35",
    "start_line": 401,
    "text_preview": "etConstantPool().getConstantString(\\n\t\t// myGen.getClassNameIndex(),\\n\t\t// Constants.CONSTANT_Class);\\n\\n\t}\\n\\n\tpublic String getInternalFileName() {\\n\t\tString str = getInternalClassName();\\n\t\tint index = str.lastIndexOf('/');\\n\t\tif (index == -1) {\\n\t\t\treturn getFileName();\\n\t\t} else {\\n\t\t\treturn str.substring(0, index + 1) + getF"
  },
  {
    "method_id": "M1947",
    "name": "if",
    "return_type": "",
    "signature": "if(index == -1)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1948",
    "name": "getPackageName",
    "return_type": "String",
    "signature": "getPackageName()",
    "file_id": "F35",
    "start_line": 414,
    "text_preview": "();\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * Returns the packagename - if its the default package we return an empty string\\n\t */\\n\tpublic String getPackageName() {\\n\t\tif (packageName != null) {\\n\t\t\treturn packageName;\\n\t\t}\\n\t\tString str = getInternalClassName();\\n\t\tint index = str.indexOf(\"<\");\\n\t\tif (index != -1) {\\n\t\t\tstr = str.substring(0, index);"
  },
  {
    "method_id": "M1949",
    "name": "if",
    "return_type": "",
    "signature": "if(packageName != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1950",
    "name": "if",
    "return_type": "",
    "signature": "if(index != -1)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1951",
    "name": "if",
    "return_type": "",
    "signature": "if(index == -1)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1952",
    "name": "addMethodGen",
    "return_type": "void",
    "signature": "addMethodGen(LazyMethodGen gen)",
    "file_id": "F35",
    "start_line": 360,
    "text_preview": "\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\tResolvedMember[] methods = myType.getDeclaredMethods();\\n\t\tfor (ResolvedMember method : methods) {\\n\t\t\taddMethodGen(new LazyMethodGen((BcelMethod) method, this));\\n\t\t}\\n\\n\t\t// Method[] methods = myGen.getMethods();\\n\t\t// for (int i = 0; i < methods.length; i++) {\\n\t\t// addMethodGen(new LazyMethodGen(methods"
  },
  {
    "method_id": "M1953",
    "name": "if",
    "return_type": "",
    "signature": "if(highestLineNumber < gen.highestLineNumber)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1954",
    "name": "removeMethodGen",
    "return_type": "boolean",
    "signature": "removeMethodGen(LazyMethodGen gen)",
    "file_id": "F35",
    "start_line": 438,
    "text_preview": "\tif (highestLineNumber < gen.highestLineNumber) {\\n\t\t\thighestLineNumber = gen.highestLineNumber;\\n\t\t}\\n\t}\\n\\n\tpublic boolean removeMethodGen(LazyMethodGen gen) {\\n\t\treturn methodGens.remove(gen);\\n\t}\\n\\n\tpublic void addMethodGen(LazyMethodGen gen, ISourceLocation sourceLocation) {\\n\t\taddMethodGen(gen);\\n\t\tif (!gen.getMethod().isP"
  },
  {
    "method_id": "M1955",
    "name": "addMethodGen",
    "return_type": "void",
    "signature": "addMethodGen(LazyMethodGen gen, ISourceLocation sourceLocation)",
    "file_id": "F35",
    "start_line": 360,
    "text_preview": "\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\tResolvedMember[] methods = myType.getDeclaredMethods();\\n\t\tfor (ResolvedMember method : methods) {\\n\t\t\taddMethodGen(new LazyMethodGen((BcelMethod) method, this));\\n\t\t}\\n\\n\t\t// Method[] methods = myGen.getMethods();\\n\t\t// for (int i = 0; i < methods.length; i++) {\\n\t\t// addMethodGen(new LazyMethodGen(methods"
  },
  {
    "method_id": "M1956",
    "name": "errorOnAddedField",
    "return_type": "void",
    "signature": "errorOnAddedField(FieldGen field, ISourceLocation sourceLocation)",
    "file_id": "F35",
    "start_line": 449,
    "text_preview": "gen);\\n\t\tif (!gen.getMethod().isPrivate()) {\\n\t\t\twarnOnAddedMethod(gen.getMethod(), sourceLocation);\\n\t\t}\\n\t}\\n\\n\tpublic void errorOnAddedField(FieldGen field, ISourceLocation sourceLocation) {\\n\t\tif (isSerializable && !hasSerialVersionUIDField) {\\n\t\t\tgetWorld().getLint().serialVersionUIDBroken.signal(\\n\t\t\t\t\tnew String[] { myTy"
  },
  {
    "method_id": "M1957",
    "name": "if",
    "return_type": "",
    "signature": "if(isSerializable && !hasSerialVersionUIDField)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1958",
    "name": "warnOnAddedInterface",
    "return_type": "void",
    "signature": "warnOnAddedInterface(String name, ISourceLocation sourceLocation)",
    "file_id": "F35",
    "start_line": 456,
    "text_preview": "\t\t\t\t\tnew String[] { myType.getResolvedTypeX().getName(), field.getName() }, sourceLocation, null);\\n\t\t}\\n\t}\\n\\n\tpublic void warnOnAddedInterface(String name, ISourceLocation sourceLocation) {\\n\t\twarnOnModifiedSerialVersionUID(sourceLocation, \"added interface \" + name);\\n\t}\\n\\n\tpublic void warnOnAddedMethod(Method method, ISour"
  },
  {
    "method_id": "M1959",
    "name": "warnOnAddedMethod",
    "return_type": "void",
    "signature": "warnOnAddedMethod(Method method, ISourceLocation sourceLocation)",
    "file_id": "F35",
    "start_line": 445,
    "text_preview": "dGen(LazyMethodGen gen, ISourceLocation sourceLocation) {\\n\t\taddMethodGen(gen);\\n\t\tif (!gen.getMethod().isPrivate()) {\\n\t\t\twarnOnAddedMethod(gen.getMethod(), sourceLocation);\\n\t\t}\\n\t}\\n\\n\tpublic void errorOnAddedField(FieldGen field, ISourceLocation sourceLocation) {\\n\t\tif (isSerializable && !hasSerialVersionUIDField) {\\n\t\t\tget"
  },
  {
    "method_id": "M1960",
    "name": "warnOnAddedStaticInitializer",
    "return_type": "void",
    "signature": "warnOnAddedStaticInitializer(Shadow shadow, ISourceLocation sourceLocation)",
    "file_id": "F35",
    "start_line": 464,
    "text_preview": "n) {\\n\t\twarnOnModifiedSerialVersionUID(sourceLocation, \"added non-private method \" + method.getName());\\n\t}\\n\\n\tpublic void warnOnAddedStaticInitializer(Shadow shadow, ISourceLocation sourceLocation) {\\n\t\tif (!hasClinit) {\\n\t\t\twarnOnModifiedSerialVersionUID(sourceLocation, \"added static initializer\");\\n\t\t}\\n\t}\\n\\n\tpublic void wa"
  },
  {
    "method_id": "M1961",
    "name": "if",
    "return_type": "",
    "signature": "if(!hasClinit)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1962",
    "name": "warnOnModifiedSerialVersionUID",
    "return_type": "void",
    "signature": "warnOnModifiedSerialVersionUID(ISourceLocation sourceLocation, String reason)",
    "file_id": "F35",
    "start_line": 457,
    "text_preview": "() }, sourceLocation, null);\\n\t\t}\\n\t}\\n\\n\tpublic void warnOnAddedInterface(String name, ISourceLocation sourceLocation) {\\n\t\twarnOnModifiedSerialVersionUID(sourceLocation, \"added interface \" + name);\\n\t}\\n\\n\tpublic void warnOnAddedMethod(Method method, ISourceLocation sourceLocation) {\\n\t\twarnOnModifiedSerialVersionUID(sourceLo"
  },
  {
    "method_id": "M1963",
    "name": "if",
    "return_type": "",
    "signature": "if(isSerializable && !hasSerialVersionUIDField)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1964",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F35",
    "start_line": 315,
    "text_preview": "ConstantPool();\\n\t\tfact = new InstructionFactory(myGen, cp);\\n\t\tthis.myType = myType;\\n\t\tworld = myType.getResolvedTypeX().getWorld();\\n\\n\t\t/* Does this class support serialization */\\n\t\tif (implementsSerializable(getType())) {\\n\t\t\tisSerializable = true;\\n\\n\t\t\t// ResolvedMember[] fields = getType().getDeclaredFields();\\n\t\t\t// fo"
  },
  {
    "method_id": "M1965",
    "name": "getMethodGens",
    "return_type": "List<LazyMethodGen>",
    "signature": "getMethodGens()",
    "file_id": "F35",
    "start_line": 481,
    "text_preview": "\t\t\t\treason }, sourceLocation, null);\\n\t\t}\\n\t}\\n\\n\tpublic World getWorld() {\\n\t\treturn world;\\n\t}\\n\\n\tpublic List<LazyMethodGen> getMethodGens() {\\n\t\treturn methodGens; // ???Collections.unmodifiableList(methodGens);\\n\t}\\n\\n\tpublic List<BcelField> getFieldGens() {\\n\t\treturn fields;\\n\t}\\n\\n\tpublic boolean fieldExists(String name) {\\n\t\t//"
  },
  {
    "method_id": "M1966",
    "name": "getFieldGens",
    "return_type": "List<BcelField>",
    "signature": "getFieldGens()",
    "file_id": "F35",
    "start_line": 485,
    "text_preview": "Gen> getMethodGens() {\\n\t\treturn methodGens; // ???Collections.unmodifiableList(methodGens);\\n\t}\\n\\n\tpublic List<BcelField> getFieldGens() {\\n\t\treturn fields;\\n\t}\\n\\n\tpublic boolean fieldExists(String name) {\\n\t\t//\t\tField[] allFields = myGen.getFields();\\n\t\t//\t\tif (allFields!=null) {\\n\t\t//\t\t\tfor (int i=0;i<allFields.length;i++) {"
  },
  {
    "method_id": "M1967",
    "name": "fieldExists",
    "return_type": "boolean",
    "signature": "fieldExists(String name)",
    "file_id": "F35",
    "start_line": 489,
    "text_preview": "ections.unmodifiableList(methodGens);\\n\t}\\n\\n\tpublic List<BcelField> getFieldGens() {\\n\t\treturn fields;\\n\t}\\n\\n\tpublic boolean fieldExists(String name) {\\n\t\t//\t\tField[] allFields = myGen.getFields();\\n\t\t//\t\tif (allFields!=null) {\\n\t\t//\t\t\tfor (int i=0;i<allFields.length;i++) {\\n\t\t//\t\t\t\tField f = allFields[i];\\n\t\t//\t\t\t\tif (f.getName"
  },
  {
    "method_id": "M1968",
    "name": "if",
    "return_type": "",
    "signature": "if(allFields!=null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1969",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0;i<allFields.length;i++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1970",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelField f: fields)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1971",
    "name": "writeBack",
    "return_type": "void",
    "signature": "writeBack(BcelWorld world)",
    "file_id": "F35",
    "start_line": 507,
    "text_preview": " (BcelField f: fields) {\\n\t\t\tif (f.getName().equals(name)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\tprivate void writeBack(BcelWorld world) {\\n\t\tif (getConstantPool().getSize() > Short.MAX_VALUE) {\\n\t\t\treportClassTooBigProblem();\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (annotations.size() > 0) {\\n\t\t\tfor (AnnotationGen element : annot"
  },
  {
    "method_id": "M1972",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationGen element : annotations)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1973",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < annAttributes.length; i++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1974",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceDebugExtensionSupportSwitchedOn)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1975",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen gen : methodGens)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1976",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < len; i++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1977",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceDebugExtensionSupportSwitchedOn)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1978",
    "name": "fixupGenericSignatureAttribute",
    "return_type": "void",
    "signature": "fixupGenericSignatureAttribute()",
    "file_id": "F35",
    "start_line": 591,
    "text_preview": "5, getFileName()), null,\\n\t\t\t\t\t\t\tnull);\\n\t\t\t\t}\\n\t\t\t\t// myGen.addAttribute(getSourceDebugExtensionAttribute());\\n\t\t\t}\\n\t\t}\\n\\n\t\tfixupGenericSignatureAttribute();\\n\t}\\n\\n\t/**\\n\t * When working with Java generics, a signature attribute is attached to the type which indicates how it was declared. This\\n\t * routine ensures the signatur"
  },
  {
    "method_id": "M1979",
    "name": "if",
    "return_type": "",
    "signature": "if(myType == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1980",
    "name": "if",
    "return_type": "",
    "signature": "if(!regenerateGenericSignatureAttribute)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1981",
    "name": "if",
    "return_type": "",
    "signature": "if(myType != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1982",
    "name": "if",
    "return_type": "hierarchy",
    "signature": "if(sigAttr != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1983",
    "name": "if",
    "return_type": "interfaces",
    "signature": "if(!needAttribute)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1984",
    "name": "if",
    "return_type": "",
    "signature": "if(myType != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1985",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType typeX : interfaceRTXs)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1986",
    "name": "if",
    "return_type": "",
    "signature": "if(extraSuperInterfaces != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1987",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType interfaceType : extraSuperInterfaces)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1988",
    "name": "if",
    "return_type": "",
    "signature": "if(myType == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1989",
    "name": "if",
    "return_type": "",
    "signature": "if(superclassRTX != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1990",
    "name": "if",
    "return_type": "",
    "signature": "if(needAttribute)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1991",
    "name": "if",
    "return_type": "",
    "signature": "if(myType != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1992",
    "name": "if",
    "return_type": "",
    "signature": "if(tVars.length > 0)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1993",
    "name": "for",
    "return_type": "",
    "signature": "for(TypeVariable variable : tVars)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1994",
    "name": "if",
    "return_type": "",
    "signature": "if(myType != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1995",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType interfaceRTX : interfaceRTXs)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1996",
    "name": "if",
    "return_type": "",
    "signature": "if(extraSuperInterfaces != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1997",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType extraSuperInterface : extraSuperInterfaces)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1998",
    "name": "if",
    "return_type": "",
    "signature": "if(sigAttr != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M1999",
    "name": "createSignatureAttribute",
    "return_type": "Signature",
    "signature": "createSignatureAttribute(String signature)",
    "file_id": "F35",
    "start_line": 708,
    "text_preview": "e.append(s);\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tif (sigAttr != null) {\\n\t\t\t\tmyGen.removeAttribute(sigAttr);\\n\t\t\t}\\n\t\t\tmyGen.addAttribute(createSignatureAttribute(signature.toString()));\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * Helper method to create a signature attribute based on a string signature: e.g. \"Ljava/lang/Object;LI<Ljava/lang/Double;>;\"\\n\t */\\n\tpriv"
  },
  {
    "method_id": "M2000",
    "name": "reportClassTooBigProblem",
    "return_type": "void",
    "signature": "reportClassTooBigProblem()",
    "file_id": "F35",
    "start_line": 509,
    "text_preview": "\treturn false;\\n\t}\\n\\n\tprivate void writeBack(BcelWorld world) {\\n\t\tif (getConstantPool().getSize() > Short.MAX_VALUE) {\\n\t\t\treportClassTooBigProblem();\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (annotations.size() > 0) {\\n\t\t\tfor (AnnotationGen element : annotations) {\\n\t\t\t\tmyGen.addAnnotation(element);\\n\t\t\t}\\n\t\t\t// Attribute[] annAttributes =\\n\t\t\t/"
  },
  {
    "method_id": "M2001",
    "name": "hasSourceDebugExtensionAttribute",
    "return_type": "boolean",
    "signature": "hasSourceDebugExtensionAttribute(ClassGen gen)",
    "file_id": "F35",
    "start_line": 583,
    "text_preview": "Field(gen.getField(cp));\\n\t\t}\\n\\n\t\tif (sourceDebugExtensionSupportSwitchedOn) {\\n\t\t\tif (inlinedFiles.size() != 0) {\\n\t\t\t\tif (hasSourceDebugExtensionAttribute(myGen)) {\\n\t\t\t\t\tworld.showMessage(IMessage.WARNING, WeaverMessages.format(WeaverMessages.OVERWRITE_JSR45, getFileName()), null,\\n\t\t\t\t\t\t\tnull);\\n\t\t\t\t}\\n\t\t\t\t// myGen.addAttr"
  },
  {
    "method_id": "M2002",
    "name": "getJavaClass",
    "return_type": "JavaClass",
    "signature": "getJavaClass(BcelWorld world)",
    "file_id": "F35",
    "start_line": 311,
    "text_preview": " so it comes from a real type in the world.\\n\tpublic LazyClassGen(BcelObjectType myType) {\\n\t\tmyGen = new ClassGen(myType.getJavaClass());\\n\t\tcp = myGen.getConstantPool();\\n\t\tfact = new InstructionFactory(myGen, cp);\\n\t\tthis.myType = myType;\\n\t\tworld = myType.getResolvedTypeX().getWorld();\\n\\n\t\t/* Does this class support seria"
  },
  {
    "method_id": "M2003",
    "name": "getJavaClassBytesIncludingReweavable",
    "return_type": "byte[]",
    "signature": "getJavaClassBytesIncludingReweavable(BcelWorld world)",
    "file_id": "F35",
    "start_line": 749,
    "text_preview": "\tpublic JavaClass getJavaClass(BcelWorld world) {\\n\t\twriteBack(world);\\n\t\treturn myGen.getJavaClass();\\n\t}\\n\\n\tpublic byte[] getJavaClassBytesIncludingReweavable(BcelWorld world) {\\n\t\twriteBack(world);\\n\t\tbyte[] wovenClassFileData = myGen.getJavaClass().getBytes();\\n\t\t// At 1.6 stackmaps are optional, whilst at 1.7 and later t"
  },
  {
    "method_id": "M2004",
    "name": "if",
    "return_type": "",
    "signature": "if(!AsmDetector.isAsmAround)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2005",
    "name": "if",
    "return_type": "",
    "signature": "if(AsmDetector.rootCause instanceof ClassNotFoundException ||\n\t\t\t\t\t\tAsmDetector.rootCause instanceof NoClassDefFoundError)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2006",
    "name": "addGeneratedInner",
    "return_type": "void",
    "signature": "addGeneratedInner(LazyClassGen newClass)",
    "file_id": "F35",
    "start_line": 783,
    "text_preview": "ue;\\n\t\t\treturn wsi.replaceKeyWithDiff(wovenClassFileData);\\n\t\t} else {\\n\t\t\treturn wovenClassFileData;\\n\t\t}\\n\t}\\n\\n\tpublic void addGeneratedInner(LazyClassGen newClass) {\\n\t\tclassGens.add(newClass);\\n\t}\\n\\n\tpublic void addInterface(ResolvedType newInterface, ISourceLocation sourceLocation) {\\n\t\tregenerateGenericSignatureAttribute ="
  },
  {
    "method_id": "M2007",
    "name": "addInterface",
    "return_type": "void",
    "signature": "addInterface(ResolvedType newInterface, ISourceLocation sourceLocation)",
    "file_id": "F35",
    "start_line": 787,
    "text_preview": "ssFileData;\\n\t\t}\\n\t}\\n\\n\tpublic void addGeneratedInner(LazyClassGen newClass) {\\n\t\tclassGens.add(newClass);\\n\t}\\n\\n\tpublic void addInterface(ResolvedType newInterface, ISourceLocation sourceLocation) {\\n\t\tregenerateGenericSignatureAttribute = true;\\n\\n\t\tif (extraSuperInterfaces == null) {\\n\t\t\textraSuperInterfaces = new ResolvedTyp"
  },
  {
    "method_id": "M2008",
    "name": "if",
    "return_type": "",
    "signature": "if(extraSuperInterfaces == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2009",
    "name": "setSuperClass",
    "return_type": "void",
    "signature": "setSuperClass(ResolvedType newSuperclass)",
    "file_id": "F35",
    "start_line": 805,
    "text_preview": "s(UnresolvedType.SERIALIZABLE)) {\\n\t\t\twarnOnAddedInterface(newInterface.getName(), sourceLocation);\\n\t\t}\\n\t}\\n\\n\tpublic void setSuperClass(ResolvedType newSuperclass) {\\n\t\tregenerateGenericSignatureAttribute = true;\\n\t\tsuperclass = newSuperclass;\\n\t\t// myType.addParent(typeX); // used for the attribute\\n\t\tif (newSuperclass.getG"
  },
  {
    "method_id": "M2010",
    "name": "getSuperClassname",
    "return_type": "String",
    "signature": "getSuperClassname()",
    "file_id": "F35",
    "start_line": 816,
    "text_preview": "pe();\\n\t\t}\\n\t\tmyGen.setSuperclassName(newSuperclass.getName()); // used in the real\\n\t\t// class data\\n\t}\\n\\n\t// public String getSuperClassname() {\\n\t// return myGen.getSuperclassName();\\n\t// }\\n\\n\tpublic ResolvedType getSuperClass() {\\n\t\tif (superclass != null) {\\n\t\t\treturn superclass;\\n\t\t}\\n\t\treturn myType.getSuperclass();\\n\t}\\n\\n\tpu"
  },
  {
    "method_id": "M2011",
    "name": "getSuperClass",
    "return_type": "ResolvedType",
    "signature": "getSuperClass()",
    "file_id": "F35",
    "start_line": 669,
    "text_preview": "e()) {\\n\t\t\t\t\t\tneedAttribute = true;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t} else {\\n\t\t\t\t// check the supertype\\n\t\t\t\tResolvedType superclassRTX = getSuperClass();\\n\t\t\t\tif (superclassRTX.isGenericType() || superclassRTX.isParameterizedType()) {\\n\t\t\t\t\tneedAttribute = true;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\tif (needAttribute) {\\n\t\t\tStringBuilder signature = new Stri"
  },
  {
    "method_id": "M2012",
    "name": "if",
    "return_type": "",
    "signature": "if(superclass != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2013",
    "name": "getInterfaceNames",
    "return_type": "String[]",
    "signature": "getInterfaceNames()",
    "file_id": "F35",
    "start_line": 734,
    "text_preview": "en = new ClassGen(myGen.getClassName(), myGen.getSuperclassName(), myGen.getFileName(), myGen.getModifiers(),\\n\t\t\t\tmyGen.getInterfaceNames());\\n\t\t// raise an error against this compilation unit.\\n\t\tgetWorld().showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.CLASS_TOO_BIG, this.getClassName()),\\n\t\t\t\tnew Sour"
  },
  {
    "method_id": "M2014",
    "name": "getClassGens",
    "return_type": "List<LazyClassGen>",
    "signature": "getClassGens()",
    "file_id": "F35",
    "start_line": 832,
    "text_preview": "ceNames() {\\n\t\treturn myGen.getInterfaceNames();\\n\t}\\n\\n\t// non-recursive, may be a bug, ha ha.\\n\tprivate List<LazyClassGen> getClassGens() {\\n\t\tList<LazyClassGen> ret = new ArrayList<>();\\n\t\tret.add(this);\\n\t\tret.addAll(classGens);\\n\t\treturn ret;\\n\t}\\n\\n\tpublic List<UnwovenClassFile.ChildClass> getChildClasses(BcelWorld world) {\\n"
  },
  {
    "method_id": "M2015",
    "name": "getChildClasses",
    "return_type": "ChildClass>",
    "signature": "getChildClasses(BcelWorld world)",
    "file_id": "F35",
    "start_line": 839,
    "text_preview": "ew ArrayList<>();\\n\t\tret.add(this);\\n\t\tret.addAll(classGens);\\n\t\treturn ret;\\n\t}\\n\\n\tpublic List<UnwovenClassFile.ChildClass> getChildClasses(BcelWorld world) {\\n\t\tif (classGens.isEmpty()) {\\n\t\t\treturn Collections.emptyList();\\n\t\t}\\n\t\tList<UnwovenClassFile.ChildClass> ret = new ArrayList<>();\\n\t\tfor (LazyClassGen clazz : classGen"
  },
  {
    "method_id": "M2016",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyClassGen clazz : classGens)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2017",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F35",
    "start_line": 260,
    "text_preview": "ffset + 1); out.append(\",1\\n\");\\n\t// }\\n\t// // end section\\n\t// out.append(\"*E\\n\");\\n\t// // and finish up...\\n\t// return out.toString();\\n\t// }\\n\\n\t// ---- end JSR45-related stuff\\n\\n\t/** Emit disassembled class and newline to out */\\n\tpublic static void disassemble(String path, String name, PrintStream out) throws IOException {\\n"
  },
  {
    "method_id": "M2018",
    "name": "toShortString",
    "return_type": "String",
    "signature": "toShortString()",
    "file_id": "F35",
    "start_line": 857,
    "text_preview": "dd(new UnwovenClassFile.ChildClass(name, bytes));\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn toShortString();\\n\t}\\n\\n\tpublic String toShortString() {\\n\t\tString s = org.aspectj.apache.bcel.classfile.Utility.accessToString(myGen.getModifiers(), true);\\n\t\tif (!s.equals(\"\")) {\\n\t\t\ts += \" \";\\n\t\t}\\n\t\ts += "
  },
  {
    "method_id": "M2019",
    "name": "toLongString",
    "return_type": "String",
    "signature": "toLongString()",
    "file_id": "F35",
    "start_line": 871,
    "text_preview": "Utility.classOrInterface(myGen.getModifiers());\\n\t\ts += \" \";\\n\t\ts += myGen.getClassName();\\n\t\treturn s;\\n\t}\\n\\n\tpublic String toLongString() {\\n\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\\n\t\tprint(new PrintStream(s));\\n\t\treturn new String(s.toByteArray());\\n\t}\\n\\n\tpublic void print() {\\n\t\tprint(System.out);\\n\t}\\n\\n\tpublic"
  },
  {
    "method_id": "M2020",
    "name": "print",
    "return_type": "void",
    "signature": "print()",
    "file_id": "F35",
    "start_line": 277,
    "text_preview": "ifiableDelegate(true);\\n\t\tLazyClassGen clazz = new LazyClassGen(BcelWorld.getBcelObjectType(world.resolve(ut)));\\n\t\tclazz.print(out);\\n\t\tout.println();\\n\t}\\n\\n\tpublic String getNewGeneratedNameTag() {\\n\t\treturn Integer.toString(childCounter++);\\n\t}\\n\\n\t// ----\\n\\n\tpublic LazyClassGen(String class_name, String super_class_name, Str"
  },
  {
    "method_id": "M2021",
    "name": "print",
    "return_type": "void",
    "signature": "print(PrintStream out)",
    "file_id": "F35",
    "start_line": 277,
    "text_preview": "ifiableDelegate(true);\\n\t\tLazyClassGen clazz = new LazyClassGen(BcelWorld.getBcelObjectType(world.resolve(ut)));\\n\t\tclazz.print(out);\\n\t\tout.println();\\n\t}\\n\\n\tpublic String getNewGeneratedNameTag() {\\n\t\treturn Integer.toString(childCounter++);\\n\t}\\n\\n\t// ----\\n\\n\tpublic LazyClassGen(String class_name, String super_class_name, Str"
  },
  {
    "method_id": "M2022",
    "name": "printOne",
    "return_type": "void",
    "signature": "printOne(PrintStream out)",
    "file_id": "F35",
    "start_line": 885,
    "text_preview": "terator<LazyClassGen> iter = classGens.iterator(); iter.hasNext();) {\\n\t\t\tLazyClassGen element = iter.next();\\n\t\t\telement.printOne(out);\\n\t\t\tif (iter.hasNext()) {\\n\t\t\t\tout.println();\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate void printOne(PrintStream out) {\\n\t\tout.print(toShortString());\\n\t\tout.print(\" extends \");\\n\t\tout.print(org.aspectj.apache"
  },
  {
    "method_id": "M2023",
    "name": "if",
    "return_type": "",
    "signature": "if(size > 0)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2024",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < size; i++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2025",
    "name": "if",
    "return_type": "",
    "signature": "if(i < size - 1)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2026",
    "name": "if",
    "return_type": "",
    "signature": "if(myType != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2027",
    "name": "for",
    "return_type": "",
    "signature": "for(Field field : fields)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2028",
    "name": "isEmptyClinit",
    "return_type": "boolean",
    "signature": "isEmptyClinit(LazyMethodGen gen)",
    "file_id": "F35",
    "start_line": 568,
    "text_preview": "e();\\n\t\tmyGen.setMethods(Method.NoMethods);\\n\\n\t\tfor (LazyMethodGen gen : methodGens) {\\n\t\t\t// we skip empty clinits\\n\t\t\tif (isEmptyClinit(gen)) {\\n\t\t\t\tcontinue;\\n\t\t\t}\\n\t\t\tmyGen.addMethod(gen.getMethod());\\n\t\t}\\n\\n\t\tlen = fields.size();\\n\t\tmyGen.setFields(Field.NoFields);\\n\t\tfor (int i = 0; i < len; i++) {\\n\t\t\tBcelField gen = fields"
  },
  {
    "method_id": "M2029",
    "name": "while",
    "return_type": "",
    "signature": "while(start != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2030",
    "name": "getConstantPool",
    "return_type": "ConstantPool",
    "signature": "getConstantPool()",
    "file_id": "F35",
    "start_line": 290,
    "text_preview": "\tWorld world) {\\n\t\tmyGen = new ClassGen(class_name, super_class_name, file_name, access_flags, interfaces);\\n\t\tcp = myGen.getConstantPool();\\n\t\tfact = new InstructionFactory(myGen, cp);\\n\t\tregenerateGenericSignatureAttribute = true;\\n\t\tthis.world = world;\\n\t}\\n\\n\tpublic void setMajorMinor(int major, int minor) {\\n\t\tmyGen.setMaj"
  },
  {
    "method_id": "M2031",
    "name": "getName",
    "return_type": "String",
    "signature": "getName()",
    "file_id": "F35",
    "start_line": 324,
    "text_preview": "claredFields();\\n\t\t\t// for (int i = 0; i < fields.length; i++) {\\n\t\t\t// ResolvedMember field = fields[i];\\n\t\t\t// if (field.getName().equals(\"serialVersionUID\")\\n\t\t\t// && field.isStatic() && field.getType().equals(UnresolvedType.LONG))\\n\t\t\t// {\\n\t\t\t// hasSerialVersionUIDField = true;\\n\t\t\t// }\\n\t\t\t// }\\n\t\t\thasSerialVersionUIDFiel"
  },
  {
    "method_id": "M2032",
    "name": "isWoven",
    "return_type": "boolean",
    "signature": "isWoven()",
    "file_id": "F35",
    "start_line": 962,
    "text_preview": "Pool getConstantPool() {\\n\t\treturn cp;\\n\t}\\n\\n\tpublic String getName() {\\n\t\treturn myGen.getClassName();\\n\t}\\n\\n\tpublic boolean isWoven() {\\n\t\treturn myType.getWeaverState() != null;\\n\t}\\n\\n\tpublic boolean isReweavable() {\\n\t\tif (myType.getWeaverState() == null) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn myType.getWeaverState().isReweavable();"
  },
  {
    "method_id": "M2033",
    "name": "isReweavable",
    "return_type": "boolean",
    "signature": "isReweavable()",
    "file_id": "F35",
    "start_line": 775,
    "text_preview": "leData);\\n\t\t}\\n\\n\t\tWeaverStateInfo wsi = myType.getWeaverState();// getOrCreateWeaverStateInfo();\\n\t\tif (wsi != null && wsi.isReweavable() && !world.isOverWeaving()) { // && !reweavableDataInserted\\n\t\t\t// reweavableDataInserted = true;\\n\t\t\treturn wsi.replaceKeyWithDiff(wovenClassFileData);\\n\t\t} else {\\n\t\t\treturn wovenClassFile"
  },
  {
    "method_id": "M2034",
    "name": "getAspectsAffectingType",
    "return_type": "Set<String>",
    "signature": "getAspectsAffectingType()",
    "file_id": "F35",
    "start_line": 973,
    "text_preview": "etWeaverState() == null) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn myType.getWeaverState().isReweavable();\\n\t}\\n\\n\tpublic Set<String> getAspectsAffectingType() {\\n\t\tif (myType.getWeaverState() == null) {\\n\t\t\treturn null;\\n\t\t}\\n\t\treturn myType.getWeaverState().getAspectsAffectingType();\\n\t}\\n\\n\tpublic WeaverStateInfo getOrCreateWeaverStateI"
  },
  {
    "method_id": "M2035",
    "name": "getOrCreateWeaverStateInfo",
    "return_type": "WeaverStateInfo",
    "signature": "getOrCreateWeaverStateInfo(boolean inReweavableMode)",
    "file_id": "F35",
    "start_line": 774,
    "text_preview": ".addStackMaps(world, myGen.getClassName(), wovenClassFileData);\\n\t\t}\\n\\n\t\tWeaverStateInfo wsi = myType.getWeaverState();// getOrCreateWeaverStateInfo();\\n\t\tif (wsi != null && wsi.isReweavable() && !world.isOverWeaving()) { // && !reweavableDataInserted\\n\t\t\t// reweavableDataInserted = true;\\n\t\t\treturn wsi.replaceKeyWithDiff(w"
  },
  {
    "method_id": "M2036",
    "name": "if",
    "return_type": "",
    "signature": "if(ret != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2037",
    "name": "getFactory",
    "return_type": "InstructionFactory",
    "signature": "getFactory()",
    "file_id": "F35",
    "start_line": 990,
    "text_preview": "ret = new WeaverStateInfo(inReweavableMode);\\n\t\tmyType.setWeaverState(ret);\\n\t\treturn ret;\\n\t}\\n\\n\tpublic InstructionFactory getFactory() {\\n\t\treturn fact;\\n\t}\\n\\n\tpublic LazyMethodGen getStaticInitializer() {\\n\t\tfor (LazyMethodGen gen : methodGens) {\\n\t\t\t// OPTIMIZE persist kind of member into the gen object? for clinit\\n\t\t\tif (g"
  },
  {
    "method_id": "M2038",
    "name": "getStaticInitializer",
    "return_type": "LazyMethodGen",
    "signature": "getStaticInitializer()",
    "file_id": "F35",
    "start_line": 994,
    "text_preview": "tWeaverState(ret);\\n\t\treturn ret;\\n\t}\\n\\n\tpublic InstructionFactory getFactory() {\\n\t\treturn fact;\\n\t}\\n\\n\tpublic LazyMethodGen getStaticInitializer() {\\n\t\tfor (LazyMethodGen gen : methodGens) {\\n\t\t\t// OPTIMIZE persist kind of member into the gen object? for clinit\\n\t\t\tif (gen.getName().equals(\"<clinit>\")) {\\n\t\t\t\treturn gen;\\n\t\t\t}\\n"
  },
  {
    "method_id": "M2039",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen gen : methodGens)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2040",
    "name": "getAjcPreClinit",
    "return_type": "LazyMethodGen",
    "signature": "getAjcPreClinit()",
    "file_id": "F35",
    "start_line": 1015,
    "text_preview": "t of the static initializer).\\n\t *\\n\t * @return the LazyMethodGen representing the ajc$ clinit\\n\t */\\n\tpublic LazyMethodGen getAjcPreClinit() {\\n\t\tif (this.isInterface()) {\\n\t\t\tthrow new IllegalStateException();\\n\t\t}\\n\t\tfor (LazyMethodGen methodGen : methodGens) {\\n\t\t\tif (methodGen.getName().equals(NameMangler.AJC_PRE_CLINIT_NA"
  },
  {
    "method_id": "M2041",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen methodGen : methodGens)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2042",
    "name": "if",
    "return_type": "",
    "signature": "if(serialVersionUIDRequiresInitialization)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2043",
    "name": "createExtendedAjcPreClinit",
    "return_type": "LazyMethodGen",
    "signature": "createExtendedAjcPreClinit(LazyMethodGen previousPreClinit, int i)",
    "file_id": "F35",
    "start_line": 1047,
    "text_preview": "eturns it. The index is used as a name suffix.\\n\t *\\n\t * @param previousPreClinit\\n\t * @param i\\n\t */\\n\tpublic LazyMethodGen createExtendedAjcPreClinit(LazyMethodGen previousPreClinit, int i) {\\n\t\tLazyMethodGen ajcPreClinit = new LazyMethodGen(Modifier.PRIVATE | Modifier.STATIC, Type.VOID,\\n\t\t\t\tNameMangler.AJC_PRE_CLINIT_NAME"
  },
  {
    "method_id": "M2044",
    "name": "getTjpField",
    "return_type": "Field",
    "signature": "getTjpField(BcelShadow shadow, final boolean isEnclosingJp)",
    "file_id": "F35",
    "start_line": 1074,
    "text_preview": "ntime.reflect.Factory\");\\n\tprivate static final ObjectType classType = new ObjectType(\"java.lang.Class\");\\n\\n\tpublic Field getTjpField(BcelShadow shadow, final boolean isEnclosingJp) {\\n\t\tField tjpField = tjpFields.get(shadow);\\n\t\tif (tjpField != null) {\\n\t\t\treturn tjpField;\\n\t\t}\\n\\n\t\tint modifiers = Modifier.STATIC;\\n\\n\t\t// J9: "
  },
  {
    "method_id": "M2045",
    "name": "if",
    "return_type": "",
    "signature": "if(tjpField != null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2046",
    "name": "if",
    "return_type": "",
    "signature": "if(tjpFieldsCounter == -1)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2047",
    "name": "if",
    "return_type": "",
    "signature": "if(existingFields == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2048",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelField field : existingFields)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2049",
    "name": "if",
    "return_type": "",
    "signature": "if(lastField == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2050",
    "name": "getAnnotationCachingField",
    "return_type": "Field",
    "signature": "getAnnotationCachingField(BcelShadow shadow, ResolvedType toType, boolean isWithin)",
    "file_id": "F35",
    "start_line": 1156,
    "text_preview": "\t *\\n\t * @param shadow the shadow at which the @annotation result is being cached\\n\t * @return a field\\n\t */\\n\tpublic Field getAnnotationCachingField(BcelShadow shadow, ResolvedType toType, boolean isWithin) {\\n\t\t// Multiple annotation types at a shadow. A different field would be required for each\\n\t\tCacheKey cacheKey = new"
  },
  {
    "method_id": "M2051",
    "name": "if",
    "return_type": "",
    "signature": "if(field == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2052",
    "name": "CacheKey",
    "return_type": "",
    "signature": "CacheKey(BcelShadow shadow, ResolvedType annotationType, boolean isWithin)",
    "file_id": "F35",
    "start_line": 1158,
    "text_preview": "n) {\\n\t\t// Multiple annotation types at a shadow. A different field would be required for each\\n\t\tCacheKey cacheKey = new CacheKey(shadow, toType, isWithin);\\n\t\tField field = annotationCachingFieldCache.get(cacheKey);\\n\t\t// System.out.println(field + \" for shadow \" + shadow);\\n\t\tif (field == null) {\\n\t\t\t// private static Ann"
  },
  {
    "method_id": "M2053",
    "name": "hashCode",
    "return_type": "int",
    "signature": "hashCode()",
    "file_id": "F35",
    "start_line": 1187,
    "text_preview": "his.key = isWithin ? shadow : shadow.toString();\\n\t\t\tthis.annotationType = annotationType;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic int hashCode() {\\n\t\t\treturn key.hashCode() * 37 + annotationType.hashCode();\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean equals(Object other) {\\n\t\t\tif (!(other instanceof CacheKey)) {\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t\tCacheK"
  },
  {
    "method_id": "M2054",
    "name": "equals",
    "return_type": "boolean",
    "signature": "equals(Object other)",
    "file_id": "F35",
    "start_line": 324,
    "text_preview": "ds();\\n\t\t\t// for (int i = 0; i < fields.length; i++) {\\n\t\t\t// ResolvedMember field = fields[i];\\n\t\t\t// if (field.getName().equals(\"serialVersionUID\")\\n\t\t\t// && field.isStatic() && field.getType().equals(UnresolvedType.LONG))\\n\t\t\t// {\\n\t\t\t// hasSerialVersionUIDField = true;\\n\t\t\t// }\\n\t\t\t// }\\n\t\t\thasSerialVersionUIDField = hasSer"
  },
  {
    "method_id": "M2055",
    "name": "addAjClassField",
    "return_type": "void",
    "signature": "addAjClassField()",
    "file_id": "F35",
    "start_line": 549,
    "text_preview": " the test compare weaved class file\\n\t\t// based on some test data as text files...\\n\t\t// if (!myGen.isInterface()) {\\n\t\t// addAjClassField();\\n\t\t// }\\n\\n\t\taddAjcInitializers();\\n\\n\t\t// 17Feb05 - ASC - Skip this for now - it crashes IBM 1.4.2 jvms\\n\t\t// (pr80430). Will be revisited when contents\\n\t\t// of attribute are confirmed t"
  },
  {
    "method_id": "M2056",
    "name": "addAjcInitializers",
    "return_type": "void",
    "signature": "addAjcInitializers()",
    "file_id": "F35",
    "start_line": 552,
    "text_preview": "s file\\n\t\t// based on some test data as text files...\\n\t\t// if (!myGen.isInterface()) {\\n\t\t// addAjClassField();\\n\t\t// }\\n\\n\t\taddAjcInitializers();\\n\\n\t\t// 17Feb05 - ASC - Skip this for now - it crashes IBM 1.4.2 jvms\\n\t\t// (pr80430). Will be revisited when contents\\n\t\t// of attribute are confirmed to be correct.\\n\t\tboolean sourc"
  },
  {
    "method_id": "M2057",
    "name": "for",
    "return_type": "",
    "signature": "for(int counter = 1; counter <= il.length; counter++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2058",
    "name": "if",
    "return_type": "",
    "signature": "if(il.length > counter)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2059",
    "name": "initInstructionList",
    "return_type": "InstructionList",
    "signature": "initInstructionList()",
    "file_id": "F35",
    "start_line": 1244,
    "text_preview": "er);\\n\t\t\t}\\n\t\t\tprevMethod.getBody().insert(il[counter - 1]);\\n\t\t\tprevMethod = nextMethod;\\n\t\t}\\n\t}\\n\\n\tprivate InstructionList initInstructionList() {\\n\t\tInstructionList list = new InstructionList();\\n\t\tInstructionFactory fact = getFactory();\\n\\n\t\t// make a new factory\\n\t\tlist.append(fact.createNew(factoryType));\\n\t\tlist.append(Ins"
  },
  {
    "method_id": "M2060",
    "name": "initializeAllTjps",
    "return_type": "InstructionList[]",
    "signature": "initializeAllTjps()",
    "file_id": "F35",
    "start_line": 1226,
    "text_preview": "() {\\n\t\tif (tjpFields.size() == 0 && !serialVersionUIDRequiresInitialization) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tInstructionList[] il = initializeAllTjps();\\n\\n\t\tLazyMethodGen prevMethod;\\n\t\tLazyMethodGen nextMethod = null;\\n\t\tif (this.isInterface()) { // Cannot sneak stuff into another static method in an interface\\n\t\t\tprevMethod = getSta"
  },
  {
    "method_id": "M2061",
    "name": "sort",
    "return_type": "",
    "signature": "sort(new Comparator<Map.Entry<BcelShadow, Field>>()",
    "file_id": "F35",
    "start_line": 1275,
    "text_preview": "();\\n\t\tlists.add(list);\\n\\n\t\tList<Map.Entry<BcelShadow, Field>> entries = new ArrayList<>(tjpFields.entrySet());\\n\t\tentries.sort(new Comparator<Map.Entry<BcelShadow, Field>>() {\\n\t\t\t@Override\\n\t\t\tpublic int compare(Map.Entry<BcelShadow, Field> a, Map.Entry<BcelShadow, Field> b) {\\n\t\t\t\treturn (a.getValue()).getName().compareTo"
  },
  {
    "method_id": "M2062",
    "name": "compare",
    "return_type": "int",
    "signature": "compare(Map.Entry<BcelShadow, Field> a, Map.Entry<BcelShadow, Field> b)",
    "file_id": "F35",
    "start_line": 1277,
    "text_preview": "ist<>(tjpFields.entrySet());\\n\t\tentries.sort(new Comparator<Map.Entry<BcelShadow, Field>>() {\\n\t\t\t@Override\\n\t\t\tpublic int compare(Map.Entry<BcelShadow, Field> a, Map.Entry<BcelShadow, Field> b) {\\n\t\t\t\treturn (a.getValue()).getName().compareTo((b.getValue()).getName());\\n\t\t\t}\\n\t\t});\\n\\n\t\tlong estimatedSize = 0;\\n\t\tfor (Map.Entr"
  },
  {
    "method_id": "M2063",
    "name": "for",
    "return_type": "",
    "signature": "for(Map.Entry<BcelShadow, Field> entry : entries)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2064",
    "name": "if",
    "return_type": "",
    "signature": "if(estimatedSize > Constants.MAX_CODE_SIZE)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2065",
    "name": "initializeTjp",
    "return_type": "void",
    "signature": "initializeTjp(InstructionFactory fact, InstructionList list, Field field, BcelShadow shadow)",
    "file_id": "F35",
    "start_line": 1290,
    "text_preview": "tInstructionList();\\n\t\t\t\tlists.add(list);\\n\t\t\t}\\n\t\t\testimatedSize += entry.getValue().getSignature().getBytes().length;\\n\t\t\tinitializeTjp(fact, list, entry.getValue(), entry.getKey());\\n\t\t}\\n\t\tInstructionList listArrayModel[] = new InstructionList[1];\\n\t\treturn lists.toArray(listArrayModel);\\n\t}\\n\\n\tprivate void initializeTjp(In"
  },
  {
    "method_id": "M2066",
    "name": "if",
    "return_type": "",
    "signature": "if(isFastSJPAvailable && exceptionTypes.length == 0)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2067",
    "name": "if",
    "return_type": "strings",
    "signature": "if(isFastSJPAvailable)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2068",
    "name": "if",
    "return_type": "",
    "signature": "if(fastSJP)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2069",
    "name": "if",
    "return_type": "",
    "signature": "if(exceptionTypes != null && exceptionTypes.length != 0)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2070",
    "name": "getFactoryMethod",
    "return_type": "String",
    "signature": "getFactoryMethod(Field field, BcelShadow shadow)",
    "file_id": "F35",
    "start_line": 1462,
    "text_preview": "(fact.createFieldAccess(getClassName(), field.getName(), field.getType(), Constants.PUTSTATIC));\\n\t\t}\\n\t}\\n\\n\tpublic String getFactoryMethod(Field field, BcelShadow shadow) {\\n\t\tStringBuilder b = new StringBuilder();\\n\t\tb.append(\"make\");\\n\t\tMemberKind kind = shadow.getSignature().getKind();\\n\t\tif (kind.equals(Member.METHOD)) {"
  },
  {
    "method_id": "M2071",
    "name": "initializeTjpOptimal",
    "return_type": "void",
    "signature": "initializeTjpOptimal(InstructionFactory fact, InstructionList list, Field field, BcelShadow shadow)",
    "file_id": "F35",
    "start_line": 1298,
    "text_preview": "ionList list, Field field, BcelShadow shadow) {\\n\t\tif (world.getTargetAspectjRuntimeLevel() == RuntimeVersion.V1_9) {\\n\t\t\tinitializeTjpOptimal(fact, list, field, shadow);\\n\t\t\treturn;\\n\t\t}\\n\t\tboolean fastSJP = false;\\n\t\t// avoid fast SJP if it is for an enclosing joinpoint\\n\t\tboolean isFastSJPAvailable = shadow.getWorld().isTa"
  },
  {
    "method_id": "M2072",
    "name": "if",
    "return_type": "",
    "signature": "if(pnames != null && pnames.length>0)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2073",
    "name": "pushStrings",
    "return_type": "void",
    "signature": "pushStrings(InstructionList list, String[] strings)",
    "file_id": "F35",
    "start_line": 1513,
    "text_preview": "ing(list, sig.getName());\\n\t\t\tpushClass(list, sig.getDeclaringType());\\n\t\t\tpushClasses(list, sig.getParameterTypes());\\n\t\t\tpushStrings(list, sig.getParameterNames(w));\\n\t\t\tpushClasses(list, sig.getExceptions(w));\\n\t\t\tpushClass(list, sig.getReturnType());\\n\t\t\tpushInt(list, shadow.getSourceLine());\\n\t\t\tlist.append(fact.createIn"
  },
  {
    "method_id": "M2074",
    "name": "if",
    "return_type": "strings",
    "signature": "if(strings == null || strings.length == 0)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2075",
    "name": "for",
    "return_type": "",
    "signature": "for(int s=0;s<strings.length;s++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2076",
    "name": "pushClass",
    "return_type": "void",
    "signature": "pushClass(InstructionList list, UnresolvedType type)",
    "file_id": "F35",
    "start_line": 1511,
    "text_preview": "f (sig.getKind().equals(Member.METHOD)) {\\n\t\t\tpushInt(list, sig.getModifiers(w));\\n\t\t\tpushString(list, sig.getName());\\n\t\t\tpushClass(list, sig.getDeclaringType());\\n\t\t\tpushClasses(list, sig.getParameterTypes());\\n\t\t\tpushStrings(list, sig.getParameterNames(w));\\n\t\t\tpushClasses(list, sig.getExceptions(w));\\n\t\t\tpushClass(list, s"
  },
  {
    "method_id": "M2077",
    "name": "if",
    "return_type": "",
    "signature": "if(classString == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2078",
    "name": "pushClasses",
    "return_type": "void",
    "signature": "pushClasses(InstructionList list, UnresolvedType[] types)",
    "file_id": "F35",
    "start_line": 1512,
    "text_preview": "\tpushInt(list, sig.getModifiers(w));\\n\t\t\tpushString(list, sig.getName());\\n\t\t\tpushClass(list, sig.getDeclaringType());\\n\t\t\tpushClasses(list, sig.getParameterTypes());\\n\t\t\tpushStrings(list, sig.getParameterNames(w));\\n\t\t\tpushClasses(list, sig.getExceptions(w));\\n\t\t\tpushClass(list, sig.getReturnType());\\n\t\t\tpushInt(list, shadow"
  },
  {
    "method_id": "M2079",
    "name": "if",
    "return_type": "objects",
    "signature": "if(types == null || types.length == 0)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2080",
    "name": "for",
    "return_type": "",
    "signature": "for(int t=0;t<types.length;t++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2081",
    "name": "pushString",
    "return_type": "void",
    "signature": "pushString(InstructionList list, String string)",
    "file_id": "F35",
    "start_line": 1503,
    "text_preview": "InstructionList list, Field field, BcelShadow shadow) {\\n\t\tlist.append(InstructionFactory.createLoad(factoryType, 0));\\n\t\tpushString(list, shadow.getKind().getName());\\n\t\tString factoryMethod = getFactoryMethod(field, shadow);\\n\t\tMember sig = shadow.getSignature();\\n\t\tBcelWorld w = shadow.getWorld();\\n\\n\t\tif (sig.getKind().eq"
  },
  {
    "method_id": "M2082",
    "name": "pushInt",
    "return_type": "void",
    "signature": "pushInt(InstructionList list, int value)",
    "file_id": "F35",
    "start_line": 1509,
    "text_preview": "Member sig = shadow.getSignature();\\n\t\tBcelWorld w = shadow.getWorld();\\n\\n\t\tif (sig.getKind().equals(Member.METHOD)) {\\n\t\t\tpushInt(list, sig.getModifiers(w));\\n\t\t\tpushString(list, sig.getName());\\n\t\t\tpushClass(list, sig.getDeclaringType());\\n\t\t\tpushClasses(list, sig.getParameterTypes());\\n\t\t\tpushStrings(list, sig.getParameter"
  },
  {
    "method_id": "M2083",
    "name": "makeString",
    "return_type": "String",
    "signature": "makeString(int i)",
    "file_id": "F35",
    "start_line": 1330,
    "text_preview": "= shadow.getWorld();\\n\\n\t\t\t// For methods, push the parts of the signature on.\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getModifiers(w))));\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, sig.getName()));\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\\n\t\t\tlist.append(Instructi"
  },
  {
    "method_id": "M2084",
    "name": "makeString",
    "return_type": "String",
    "signature": "makeString(UnresolvedType t)",
    "file_id": "F35",
    "start_line": 1330,
    "text_preview": "= shadow.getWorld();\\n\\n\t\t\t// For methods, push the parts of the signature on.\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getModifiers(w))));\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, sig.getName()));\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\\n\t\t\tlist.append(Instructi"
  },
  {
    "method_id": "M2085",
    "name": "makeLdcClassString",
    "return_type": "String",
    "signature": "makeLdcClassString(UnresolvedType type)",
    "file_id": "F35",
    "start_line": 1633,
    "text_preview": "tSignature().equals(\"V\")) {\\n\t\t\t\tlist.append(InstructionFactory.ACONST_NULL);\\n\t\t\t}\\n\t\t\treturn;\\n\t\t}\\n\t\tString classString = makeLdcClassString(type);\\n\t\tif (classString == null) {\\n\t\t\tlist.append(InstructionFactory.ACONST_NULL);\\n\t\t} else {\\n\t\t\tlist.append(fact.PUSHCLASS(cp, classString));\\n\t\t}\\n\t}\\n\\n\tprivate void pushClasses(Ins"
  },
  {
    "method_id": "M2086",
    "name": "makeString",
    "return_type": "String",
    "signature": "makeString(UnresolvedType[] types)",
    "file_id": "F35",
    "start_line": 1330,
    "text_preview": "= shadow.getWorld();\\n\\n\t\t\t// For methods, push the parts of the signature on.\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getModifiers(w))));\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, sig.getName()));\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\\n\t\t\tlist.append(Instructi"
  },
  {
    "method_id": "M2087",
    "name": "if",
    "return_type": "",
    "signature": "if(types == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2088",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = types.length; i < len; i++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2089",
    "name": "if",
    "return_type": "",
    "signature": "if(i > 0)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2090",
    "name": "makeString",
    "return_type": "String",
    "signature": "makeString(String[] names)",
    "file_id": "F35",
    "start_line": 1330,
    "text_preview": "= shadow.getWorld();\\n\\n\t\t\t// For methods, push the parts of the signature on.\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getModifiers(w))));\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, sig.getName()));\\n\t\t\tlist.append(InstructionFactory.PUSH(cp, makeString(sig.getDeclaringType())));\\n\t\t\tlist.append(Instructi"
  },
  {
    "method_id": "M2091",
    "name": "if",
    "return_type": "",
    "signature": "if(names == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2092",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = names.length; i < len; i++)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2093",
    "name": "if",
    "return_type": "",
    "signature": "if(i > 0)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2094",
    "name": "getType",
    "return_type": "ResolvedType",
    "signature": "getType()",
    "file_id": "F35",
    "start_line": 318,
    "text_preview": "rld = myType.getResolvedTypeX().getWorld();\\n\\n\t\t/* Does this class support serialization */\\n\t\tif (implementsSerializable(getType())) {\\n\t\t\tisSerializable = true;\\n\\n\t\t\t// ResolvedMember[] fields = getType().getDeclaredFields();\\n\t\t\t// for (int i = 0; i < fields.length; i++) {\\n\t\t\t// ResolvedMember field = fields[i];\\n\t\t\t// if"
  },
  {
    "method_id": "M2095",
    "name": "if",
    "return_type": "",
    "signature": "if(myType == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2096",
    "name": "getBcelObjectType",
    "return_type": "BcelObjectType",
    "signature": "getBcelObjectType()",
    "file_id": "F35",
    "start_line": 276,
    "text_preview": " UnresolvedType.forName(name);\\n\t\tut.setNeedsModifiableDelegate(true);\\n\t\tLazyClassGen clazz = new LazyClassGen(BcelWorld.getBcelObjectType(world.resolve(ut)));\\n\t\tclazz.print(out);\\n\t\tout.println();\\n\t}\\n\\n\tpublic String getNewGeneratedNameTag() {\\n\t\treturn Integer.toString(childCounter++);\\n\t}\\n\\n\t// ----\\n\\n\tpublic LazyClassGen("
  },
  {
    "method_id": "M2097",
    "name": "getFileName",
    "return_type": "String",
    "signature": "getFileName()",
    "file_id": "F35",
    "start_line": 219,
    "text_preview": "\t// private String getSourceDebugExtensionString() {\\n\t// StringBuffer out = new StringBuffer();\\n\t// String myFileName = getFileName();\\n\t// // header section\\n\t// out.append(\"SMAP\\n\");\\n\t// out.append(myFileName);\\n\t// out.append(\"\\nAspectJ\\n\");\\n\t// // stratum section\\n\t// out.append(\"*S AspectJ\\n\");\\n\t// // file section\\n\t//"
  },
  {
    "method_id": "M2098",
    "name": "addField",
    "return_type": "void",
    "signature": "addField(FieldGen field)",
    "file_id": "F35",
    "start_line": 347,
    "text_preview": "PRIVATE | Constants.ACC_FINAL | Constants.ACC_STATIC, BasicType.LONG,\\n\t\t\t\t\t\t\"serialVersionUID\", getConstantPool());\\n\t\t\t\taddField(fg);\\n\t\t\t\thasSerialVersionUIDField = true;\\n\t\t\t\tserialVersionUIDRequiresInitialization = true;\\n\t\t\t\t// warn about what we've done?\\n\t\t\t\tif (world.getLint().calculatingSerialVersionUID.isEnabled()"
  },
  {
    "method_id": "M2099",
    "name": "makeSyntheticAndTransientIfNeeded",
    "return_type": "void",
    "signature": "makeSyntheticAndTransientIfNeeded(FieldGen field)",
    "file_id": "F35",
    "start_line": 1747,
    "text_preview": "tring getFileName() {\\n\t\treturn myGen.getFileName();\\n\t}\\n\\n\t// for *new* fields\\n\tprivate void addField(FieldGen field) {\\n\t\tmakeSyntheticAndTransientIfNeeded(field);\\n\t\tBcelField bcelField = null;\\n\t\tif (getBcelObjectType() != null) {\\n\t\t\tbcelField = new BcelField(getBcelObjectType(), field.getField());\\n\t\t} else {\\n\t\t\tbcelFiel"
  },
  {
    "method_id": "M2100",
    "name": "hasSyntheticAttribute",
    "return_type": "boolean",
    "signature": "hasSyntheticAttribute(List<Attribute> attributes)",
    "file_id": "F35",
    "start_line": 1771,
    "text_preview": "()) {\\n\t\t\t\t// add the synthetic modifier flag\\n\t\t\t\tfield.setModifiers(field.getModifiers() | ACC_SYNTHETIC);\\n\t\t\t}\\n\t\t\tif (!hasSyntheticAttribute(field.getAttributes())) {\\n\t\t\t\t// belt and braces, do the attribute even on Java 5 in addition\\n\t\t\t\t// to the modifier flag\\n\t\t\t\t// Attribute[] oldAttrs = field.getAttributes();\\n\t\t\t"
  },
  {
    "method_id": "M2101",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute attribute : attributes)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2102",
    "name": "addField",
    "return_type": "void",
    "signature": "addField(FieldGen field, ISourceLocation sourceLocation)",
    "file_id": "F35",
    "start_line": 347,
    "text_preview": "PRIVATE | Constants.ACC_FINAL | Constants.ACC_STATIC, BasicType.LONG,\\n\t\t\t\t\t\t\"serialVersionUID\", getConstantPool());\\n\t\t\t\taddField(fg);\\n\t\t\t\thasSerialVersionUIDField = true;\\n\t\t\t\tserialVersionUIDRequiresInitialization = true;\\n\t\t\t\t// warn about what we've done?\\n\t\t\t\tif (world.getLint().calculatingSerialVersionUID.isEnabled()"
  },
  {
    "method_id": "M2103",
    "name": "getClassName",
    "return_type": "String",
    "signature": "getClassName()",
    "file_id": "F35",
    "start_line": 353,
    "text_preview": "lculatingSerialVersionUID.isEnabled()) {\\n\t\t\t\t\tworld.getLint().calculatingSerialVersionUID.signal(\\n\t\t\t\t\t\t\tnew String[] { getClassName(), Long.toString(calculatedSerialVersionUID) + \"L\" }, null, null);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\tResolvedMember[] methods = myType.getDeclaredMethods();\\n\t\tfor (ResolvedMember method : methods) {\\n\t\t\ta"
  },
  {
    "method_id": "M2104",
    "name": "isInterface",
    "return_type": "boolean",
    "signature": "isInterface()",
    "file_id": "F35",
    "start_line": 343,
    "text_preview": "(\"qui?\");\\n\t\t\t\t\t}\\n\t\t\t\t\thasClinit = true;\\n\t\t\t\t}\\n\t\t\t}\\n\\n\t\t\t// Do we need to calculate an SUID and add it?\\n\t\t\tif (!getType().isInterface() && !hasSerialVersionUIDField && world.isAddSerialVerUID()) {\\n\t\t\t\tcalculatedSerialVersionUID = myGen.getSUID();\\n\t\t\t\tFieldGen fg = new FieldGen(Constants.ACC_PRIVATE | Constants.ACC_FINAL "
  },
  {
    "method_id": "M2105",
    "name": "isAbstract",
    "return_type": "boolean",
    "signature": "isAbstract()",
    "file_id": "F35",
    "start_line": 1811,
    "text_preview": " {\\n\t\treturn myGen.getClassName();\\n\t}\\n\\n\tpublic boolean isInterface() {\\n\t\treturn myGen.isInterface();\\n\t}\\n\\n\tpublic boolean isAbstract() {\\n\t\treturn myGen.isAbstract();\\n\t}\\n\\n\tpublic LazyMethodGen getLazyMethodGen(Member m) {\\n\t\treturn getLazyMethodGen(m.getName(), m.getSignature(), false);\\n\t}\\n\\n\tpublic LazyMethodGen getLazyMet"
  },
  {
    "method_id": "M2106",
    "name": "getLazyMethodGen",
    "return_type": "LazyMethodGen",
    "signature": "getLazyMethodGen(Member m)",
    "file_id": "F35",
    "start_line": 1815,
    "text_preview": "\t\treturn myGen.isInterface();\\n\t}\\n\\n\tpublic boolean isAbstract() {\\n\t\treturn myGen.isAbstract();\\n\t}\\n\\n\tpublic LazyMethodGen getLazyMethodGen(Member m) {\\n\t\treturn getLazyMethodGen(m.getName(), m.getSignature(), false);\\n\t}\\n\\n\tpublic LazyMethodGen getLazyMethodGen(String name, String signature) {\\n\t\treturn getLazyMethodGen(name"
  },
  {
    "method_id": "M2107",
    "name": "getLazyMethodGen",
    "return_type": "LazyMethodGen",
    "signature": "getLazyMethodGen(String name, String signature)",
    "file_id": "F35",
    "start_line": 1815,
    "text_preview": "\t\treturn myGen.isInterface();\\n\t}\\n\\n\tpublic boolean isAbstract() {\\n\t\treturn myGen.isAbstract();\\n\t}\\n\\n\tpublic LazyMethodGen getLazyMethodGen(Member m) {\\n\t\treturn getLazyMethodGen(m.getName(), m.getSignature(), false);\\n\t}\\n\\n\tpublic LazyMethodGen getLazyMethodGen(String name, String signature) {\\n\t\treturn getLazyMethodGen(name"
  },
  {
    "method_id": "M2108",
    "name": "getLazyMethodGen",
    "return_type": "LazyMethodGen",
    "signature": "getLazyMethodGen(String name, String signature, boolean allowMissing)",
    "file_id": "F35",
    "start_line": 1815,
    "text_preview": "\t\treturn myGen.isInterface();\\n\t}\\n\\n\tpublic boolean isAbstract() {\\n\t\treturn myGen.isAbstract();\\n\t}\\n\\n\tpublic LazyMethodGen getLazyMethodGen(Member m) {\\n\t\treturn getLazyMethodGen(m.getName(), m.getSignature(), false);\\n\t}\\n\\n\tpublic LazyMethodGen getLazyMethodGen(String name, String signature) {\\n\t\treturn getLazyMethodGen(name"
  },
  {
    "method_id": "M2109",
    "name": "for",
    "return_type": "",
    "signature": "for(LazyMethodGen gen : methodGens)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2110",
    "name": "if",
    "return_type": "",
    "signature": "if(!allowMissing)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2111",
    "name": "forcePublic",
    "return_type": "void",
    "signature": "forcePublic()",
    "file_id": "F35",
    "start_line": 1837,
    "text_preview": "s.getName() + \" does not have a method \" + name + \" with signature \" + signature);\\n\t\t}\\n\\n\t\treturn null;\\n\t}\\n\\n\tpublic void forcePublic() {\\n\t\tmyGen.setModifiers(Utility.makePublic(myGen.getModifiers()));\\n\t}\\n\\n\tpublic boolean hasAnnotation(UnresolvedType t) {\\n\\n\t\t// annotations on the real thing\\n\t\tAnnotationGen agens[] = myGe"
  },
  {
    "method_id": "M2112",
    "name": "hasAnnotation",
    "return_type": "boolean",
    "signature": "hasAnnotation(UnresolvedType t)",
    "file_id": "F35",
    "start_line": 1841,
    "text_preview": "l;\\n\t}\\n\\n\tpublic void forcePublic() {\\n\t\tmyGen.setModifiers(Utility.makePublic(myGen.getModifiers()));\\n\t}\\n\\n\tpublic boolean hasAnnotation(UnresolvedType t) {\\n\\n\t\t// annotations on the real thing\\n\t\tAnnotationGen agens[] = myGen.getAnnotations();\\n\t\tif (agens == null) {\\n\t\t\treturn false;\\n\t\t}\\n\t\tfor (AnnotationGen gen : agens) {\\n"
  },
  {
    "method_id": "M2113",
    "name": "if",
    "return_type": "",
    "signature": "if(agens == null)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2114",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationGen gen : agens)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2115",
    "name": "addAnnotation",
    "return_type": "void",
    "signature": "addAnnotation(AnnotationGen a)",
    "file_id": "F35",
    "start_line": 515,
    "text_preview": "oBigProblem();\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (annotations.size() > 0) {\\n\t\t\tfor (AnnotationGen element : annotations) {\\n\t\t\t\tmyGen.addAnnotation(element);\\n\t\t\t}\\n\t\t\t// Attribute[] annAttributes =\\n\t\t\t// org.aspectj.apache.bcel.classfile.Utility.getAnnotationAttributes(\\n\t\t\t// getConstantPool(),annotations);\\n\t\t\t// for (int i = 0; i < "
  },
  {
    "method_id": "M2116",
    "name": "addAttribute",
    "return_type": "void",
    "signature": "addAttribute(AjAttribute attribute)",
    "file_id": "F35",
    "start_line": 387,
    "text_preview": ")\\n\t\t\t\t\t&& field.getType().equals(UnresolvedType.LONG)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\\n\t\treturn false;\\n\t}\\n\\n\t// public void addAttribute(Attribute i) {\\n\t// myGen.addAttribute(i);\\n\t// }\\n\\n\t// ----\\n\\n\tpublic String getInternalClassName() {\\n\t\treturn getConstantPool().getConstantString_CONSTANTClass(myGen.getClassNameIndex());\\n\t"
  },
  {
    "method_id": "M2117",
    "name": "addAttribute",
    "return_type": "void",
    "signature": "addAttribute(Attribute attribute)",
    "file_id": "F35",
    "start_line": 387,
    "text_preview": ")\\n\t\t\t\t\t&& field.getType().equals(UnresolvedType.LONG)) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t}\\n\\n\t\treturn false;\\n\t}\\n\\n\t// public void addAttribute(Attribute i) {\\n\t// myGen.addAttribute(i);\\n\t// }\\n\\n\t// ----\\n\\n\tpublic String getInternalClassName() {\\n\t\treturn getConstantPool().getConstantString_CONSTANTClass(myGen.getClassNameIndex());\\n\t"
  },
  {
    "method_id": "M2118",
    "name": "getAttributes",
    "return_type": "Collection<Attribute>",
    "signature": "getAttributes()",
    "file_id": "F35",
    "start_line": 931,
    "text_preview": "fo.UNKNOWN));\\n\t\t\tif (iter.hasNext()) {\\n\t\t\t\tout.println();\\n\t\t\t}\\n\t\t}\\n\t\t// out.println(\"  ATTRIBS: \" + Arrays.asList(myGen.getAttributes()));\\n\\n\t\tout.println(\"end \" + toShortString());\\n\t}\\n\\n\tprivate boolean isEmptyClinit(LazyMethodGen gen) {\\n\\n\t\tif (!gen.getName().equals(\"<clinit>\")) {\\n\t\t\treturn false;\\n\t\t}\\n\t\t// System.err.pr"
  },
  {
    "method_id": "M2119",
    "name": "implementsSerializable",
    "return_type": "boolean",
    "signature": "implementsSerializable(ResolvedType aType)",
    "file_id": "F35",
    "start_line": 318,
    "text_preview": "s.myType = myType;\\n\t\tworld = myType.getResolvedTypeX().getWorld();\\n\\n\t\t/* Does this class support serialization */\\n\t\tif (implementsSerializable(getType())) {\\n\t\t\tisSerializable = true;\\n\\n\t\t\t// ResolvedMember[] fields = getType().getDeclaredFields();\\n\t\t\t// for (int i = 0; i < fields.length; i++) {\\n\t\t\t// ResolvedMember fiel"
  },
  {
    "method_id": "M2120",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType anInterface : interfaces)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2121",
    "name": "isAtLeastJava5",
    "return_type": "boolean",
    "signature": "isAtLeastJava5()",
    "file_id": "F35",
    "start_line": 1907,
    "text_preview": " null && !superType.isMissing()) {\\n\t\t\treturn implementsSerializable(superType);\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\tpublic boolean isAtLeastJava5() {\\n\t\treturn (myGen.getMajor() >= Constants.MAJOR_1_5);\\n\t}\\n\\n\t/**\\n\t * Return the next available field name with the specified 'prefix', e.g. for prefix 'class$' where class$0, class$1 ex"
  },
  {
    "method_id": "M2122",
    "name": "allocateField",
    "return_type": "String",
    "signature": "allocateField(String prefix)",
    "file_id": "F35",
    "start_line": 1915,
    "text_preview": "e specified 'prefix', e.g. for prefix 'class$' where class$0, class$1 exist then\\n\t * return class$2\\n\t */\\n\tpublic String allocateField(String prefix) {\\n\t\tint highestAllocated = -1;\\n\t\tList<BcelField> fs = getFieldGens();\\n\t\tfor (BcelField field : fs) {\\n\t\t\tif (field.getName().startsWith(prefix)) {\\n\t\t\t\ttry {\\n\t\t\t\t\tint num = "
  },
  {
    "method_id": "M2123",
    "name": "for",
    "return_type": "",
    "signature": "for(BcelField field : fs)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2124",
    "name": "if",
    "return_type": "",
    "signature": "if(num > highestAllocated)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2125",
    "name": "catch",
    "return_type": "",
    "signature": "catch(NumberFormatException nfe)",
    "file_id": "F35",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2126",
    "name": "LightweightBcelMethod",
    "return_type": "",
    "signature": "LightweightBcelMethod(BcelObjectType declaringType, Method method)",
    "file_id": "F36",
    "start_line": 133,
    "text_preview": "s technically on\\n\tpublic ResolvedType definingType = null;\\n\\n\tstatic class LightweightBcelMethod extends BcelMethod {\\n\\n\t\tLightweightBcelMethod(BcelObjectType declaringType, Method method) {\\n\t\t\tsuper(declaringType, method);\\n\t\t\t// TODO Auto-generated constructor stub\\n\t\t}\\n\\n\t}\\n\\n\tpublic LazyMethodGen(int modifiers, Type retu"
  },
  {
    "method_id": "M2127",
    "name": "LazyMethodGen",
    "return_type": "",
    "signature": "LazyMethodGen(int modifiers, Type returnType, String name, Type[] paramTypes, String[] declaredExceptions,\n\t\t\tLazyClassGen enclosingClass)",
    "file_id": "F36",
    "start_line": 140,
    "text_preview": "ringType, Method method) {\\n\t\t\tsuper(declaringType, method);\\n\t\t\t// TODO Auto-generated constructor stub\\n\t\t}\\n\\n\t}\\n\\n\tpublic LazyMethodGen(int modifiers, Type returnType, String name, Type[] paramTypes, String[] declaredExceptions,\\n\t\t\tLazyClassGen enclosingClass) {\\n\t\t// enclosingClass.getName() + \", \" + returnType);\\n\t\tthis."
  },
  {
    "method_id": "M2128",
    "name": "calculateMaxLocals",
    "return_type": "int",
    "signature": "calculateMaxLocals()",
    "file_id": "F36",
    "start_line": 152,
    "text_preview": "eptions = declaredExceptions;\\n\t\tif (!Modifier.isAbstract(modifiers)) {\\n\t\t\tbody = new InstructionList();\\n\t\t\tsetMaxLocals(calculateMaxLocals());\\n\t\t} else {\\n\t\t\tbody = null;\\n\t\t}\\n\t\tthis.attributes = new ArrayList<>();\\n\t\tthis.enclosingClass = enclosingClass;\\n\t\tassertGoodBody();\\n\t\tthis.originalMethodHasLocalVariableTable = tr"
  },
  {
    "method_id": "M2129",
    "name": "for",
    "return_type": "",
    "signature": "for(Type type : argumentTypes)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2130",
    "name": "LazyMethodGen",
    "return_type": "",
    "signature": "LazyMethodGen(Method m, LazyClassGen enclosingClass)",
    "file_id": "F36",
    "start_line": 140,
    "text_preview": "ringType, Method method) {\\n\t\t\tsuper(declaringType, method);\\n\t\t\t// TODO Auto-generated constructor stub\\n\t\t}\\n\\n\t}\\n\\n\tpublic LazyMethodGen(int modifiers, Type returnType, String name, Type[] paramTypes, String[] declaredExceptions,\\n\t\t\tLazyClassGen enclosingClass) {\\n\t\t// enclosingClass.getName() + \", \" + returnType);\\n\t\tthis."
  },
  {
    "method_id": "M2131",
    "name": "isAbstractOrNative",
    "return_type": "boolean",
    "signature": "isAbstractOrNative(int modifiers)",
    "file_id": "F36",
    "start_line": 213,
    "text_preview": "ct()) {\\n\t\t\t\t// TODO we could check for @Around advice as well\\n\t\t\t\tthis.canInline = false;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate boolean isAbstractOrNative(int modifiers) {\\n\t\treturn Modifier.isAbstract(modifiers) || Modifier.isNative(modifiers);\\n\t}\\n\\n\tpublic LazyMethodGen(BcelMethod m, LazyClassGen enclosingClass) {\\n\t\tsavedMethod = m.ge"
  },
  {
    "method_id": "M2132",
    "name": "LazyMethodGen",
    "return_type": "",
    "signature": "LazyMethodGen(BcelMethod m, LazyClassGen enclosingClass)",
    "file_id": "F36",
    "start_line": 140,
    "text_preview": "ringType, Method method) {\\n\t\t\tsuper(declaringType, method);\\n\t\t\t// TODO Auto-generated constructor stub\\n\t\t}\\n\\n\t}\\n\\n\tpublic LazyMethodGen(int modifiers, Type returnType, String name, Type[] paramTypes, String[] declaredExceptions,\\n\t\t\tLazyClassGen enclosingClass) {\\n\t\t// enclosingClass.getName() + \", \" + returnType);\\n\t\tthis."
  },
  {
    "method_id": "M2133",
    "name": "hasDeclaredLineNumberInfo",
    "return_type": "boolean",
    "signature": "hasDeclaredLineNumberInfo()",
    "file_id": "F36",
    "start_line": 248,
    "text_preview": "ct()) {\\n\t\t\t\t// TODO we could check for @Around advice as well\\n\t\t\t\tthis.canInline = false;\\n\t\t\t}\\n\t\t}\\n\\n\t}\\n\\n\tpublic boolean hasDeclaredLineNumberInfo() {\\n\t\treturn (memberView != null && memberView.hasDeclarationLineNumberInfo());\\n\t}\\n\\n\tpublic int getDeclarationLineNumber() {\\n\t\tif (hasDeclaredLineNumberInfo()) {\\n\t\t\treturn me"
  },
  {
    "method_id": "M2134",
    "name": "getDeclarationLineNumber",
    "return_type": "int",
    "signature": "getDeclarationLineNumber()",
    "file_id": "F36",
    "start_line": 252,
    "text_preview": "sDeclaredLineNumberInfo() {\\n\t\treturn (memberView != null && memberView.hasDeclarationLineNumberInfo());\\n\t}\\n\\n\tpublic int getDeclarationLineNumber() {\\n\t\tif (hasDeclaredLineNumberInfo()) {\\n\t\t\treturn memberView.getDeclarationLineNumber();\\n\t\t} else {\\n\t\t\treturn -1;\\n\t\t}\\n\t}\\n\\n\tpublic int getDeclarationOffset() {\\n\t\tif (hasDeclar"
  },
  {
    "method_id": "M2135",
    "name": "getDeclarationOffset",
    "return_type": "int",
    "signature": "getDeclarationOffset()",
    "file_id": "F36",
    "start_line": 260,
    "text_preview": "claredLineNumberInfo()) {\\n\t\t\treturn memberView.getDeclarationLineNumber();\\n\t\t} else {\\n\t\t\treturn -1;\\n\t\t}\\n\t}\\n\\n\tpublic int getDeclarationOffset() {\\n\t\tif (hasDeclaredLineNumberInfo()) {\\n\t\t\treturn memberView.getDeclarationOffset();\\n\t\t} else {\\n\t\t\treturn 0;\\n\t\t}\\n\t}\\n\\n\tpublic void addAnnotation(AnnotationAJ ax) {\\n\t\tinitialize();"
  },
  {
    "method_id": "M2136",
    "name": "addAnnotation",
    "return_type": "void",
    "signature": "addAnnotation(AnnotationAJ ax)",
    "file_id": "F36",
    "start_line": 268,
    "text_preview": "asDeclaredLineNumberInfo()) {\\n\t\t\treturn memberView.getDeclarationOffset();\\n\t\t} else {\\n\t\t\treturn 0;\\n\t\t}\\n\t}\\n\\n\tpublic void addAnnotation(AnnotationAJ ax) {\\n\t\tinitialize();\\n\t\tif (memberView == null) {\\n\t\t\t// If member view is null, we manage them in newAnnotations\\n\t\t\tif (newAnnotations == null) {\\n\t\t\t\tnewAnnotations = new Ar"
  },
  {
    "method_id": "M2137",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2138",
    "name": "if",
    "return_type": "newAnnotations",
    "signature": "if(newAnnotations == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2139",
    "name": "removeAnnotation",
    "return_type": "void",
    "signature": "removeAnnotation(ResolvedType annotationType)",
    "file_id": "F36",
    "start_line": 281,
    "text_preview": "s = new ArrayList<>();\\n\t\t\t}\\n\t\t\tnewAnnotations.add(ax);\\n\t\t} else {\\n\t\t\tmemberView.addAnnotation(ax);\\n\t\t}\\n\t}\\n\\n\tpublic void removeAnnotation(ResolvedType annotationType) {\\n\t\tinitialize();\\n\t\tif (memberView == null) {\\n\t\t\t// If member view is null, we manage them in newAnnotations\\n\t\t\tif (annotationsForRemoval == null) {\\n\t\t\t\ta"
  },
  {
    "method_id": "M2140",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2141",
    "name": "if",
    "return_type": "newAnnotations",
    "signature": "if(annotationsForRemoval == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2142",
    "name": "addParameterAnnotation",
    "return_type": "void",
    "signature": "addParameterAnnotation(int parameterNumber, AnnotationAJ anno)",
    "file_id": "F36",
    "start_line": 294,
    "text_preview": "otationsForRemoval.add(annotationType);\\n\t\t} else {\\n\t\t\tmemberView.removeAnnotation(annotationType);\\n\t\t}\\n\t}\\n\\n\tpublic void addParameterAnnotation(int parameterNumber, AnnotationAJ anno) {\\n\t\tinitialize();\\n\t\tif (memberView == null) {\\n\t\t\tif (newParameterAnnotations == null) {\\n\t\t\t\t// time to create it\\n\t\t\t\tint pcount = getArgu"
  },
  {
    "method_id": "M2143",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2144",
    "name": "if",
    "return_type": "",
    "signature": "if(newParameterAnnotations == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2145",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < pcount; i++)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2146",
    "name": "if",
    "return_type": "",
    "signature": "if(i == parameterNumber)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2147",
    "name": "getAnnotationTypes",
    "return_type": "ResolvedType[]",
    "signature": "getAnnotationTypes()",
    "file_id": "F36",
    "start_line": 321,
    "text_preview": "wAnnoArray;\\n\t\t\t}\\n\t\t} else {\\n\t\t\tmemberView.addParameterAnnotation(parameterNumber, anno);\\n\t\t}\\n\t}\\n\\n\tpublic ResolvedType[] getAnnotationTypes() {\\n\t\tinitialize();\\n\t\tif (memberView == null && newAnnotations!=null && newAnnotations.size()!=0) {\\n\t\t\t// TODO Ignoring removed annotations for now\\n\t\t\tResolvedType[] annotationTypes"
  },
  {
    "method_id": "M2148",
    "name": "getAnnotations",
    "return_type": "AnnotationAJ[]",
    "signature": "getAnnotations()",
    "file_id": "F36",
    "start_line": 334,
    "text_preview": "pes[a] = newAnnotations.get(a).getType();\\n\t\t\t}\\n\t\t\treturn annotationTypes;\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tpublic AnnotationAJ[] getAnnotations() {\\n\t\tinitialize();\\n\t\tif (memberView == null && newAnnotations!=null && newAnnotations.size()!=0) {\\n\t\t\treturn newAnnotations.toArray(AnnotationAJ.EMPTY_ARRAY);\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tp"
  },
  {
    "method_id": "M2149",
    "name": "hasAnnotation",
    "return_type": "boolean",
    "signature": "hasAnnotation(UnresolvedType annotationType)",
    "file_id": "F36",
    "start_line": 342,
    "text_preview": "tations.size()!=0) {\\n\t\t\treturn newAnnotations.toArray(AnnotationAJ.EMPTY_ARRAY);\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tpublic boolean hasAnnotation(UnresolvedType annotationType) {\\n\t\tinitialize();\\n\t\tif (memberView == null) {\\n\t\t\tif (annotationsForRemoval != null) {\\n\t\t\t\tfor (ResolvedType at : annotationsForRemoval) {\\n\t\t\t\t\tif (at.equal"
  },
  {
    "method_id": "M2150",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2151",
    "name": "if",
    "return_type": "",
    "signature": "if(annotationsForRemoval != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2152",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType at : annotationsForRemoval)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2153",
    "name": "if",
    "return_type": "first",
    "signature": "if(newAnnotations != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2154",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ annotation : newAnnotations)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2155",
    "name": "initialize",
    "return_type": "void",
    "signature": "initialize()",
    "file_id": "F36",
    "start_line": 269,
    "text_preview": "turn memberView.getDeclarationOffset();\\n\t\t} else {\\n\t\t\treturn 0;\\n\t\t}\\n\t}\\n\\n\tpublic void addAnnotation(AnnotationAJ ax) {\\n\t\tinitialize();\\n\t\tif (memberView == null) {\\n\t\t\t// If member view is null, we manage them in newAnnotations\\n\t\t\tif (newAnnotations == null) {\\n\t\t\t\tnewAnnotations = new ArrayList<>();\\n\t\t\t}\\n\t\t\tnewAnnotations"
  },
  {
    "method_id": "M2156",
    "name": "if",
    "return_type": "",
    "signature": "if(returnType != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2157",
    "name": "unpackHandlers",
    "return_type": "void",
    "signature": "unpackHandlers(MethodGen gen)",
    "file_id": "F36",
    "start_line": 394,
    "text_preview": "l;\\n\t\t} else {\\n\t\t\t// body = new InstructionList(savedMethod.getCode().getCode());\\n\t\t\tbody = gen.getInstructionList();\\n\t\t\tunpackHandlers(gen);\\n\t\t\tensureAllLineNumberSetup();\\n\t\t\thighestLineNumber = gen.getHighestlinenumber();\\n\t\t}\\n\t\tassertGoodBody();\\n\t}\\n\\n\t// XXX we're relying on the javac promise I've just made up that we "
  },
  {
    "method_id": "M2158",
    "name": "if",
    "return_type": "",
    "signature": "if(exns != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2159",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < len; i++, priority--)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2160",
    "name": "getOutermostExceptionStart",
    "return_type": "InstructionHandle",
    "signature": "getOutermostExceptionStart(InstructionHandle ih)",
    "file_id": "F36",
    "start_line": 420,
    "text_preview": " 0; i < len; i++, priority--) {\\n\t\t\t\tCodeExceptionGen exn = exns[i];\\n\\n\t\t\t\tInstructionHandle start = Range.genStart(body, getOutermostExceptionStart(exn.getStartPC()));\\n\t\t\t\tInstructionHandle end = Range.genEnd(body, getOutermostExceptionEnd(exn.getEndPC()));\\n\t\t\t\t// this doesn't necessarily handle overlapping correctly!!!"
  },
  {
    "method_id": "M2161",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2162",
    "name": "getOutermostExceptionEnd",
    "return_type": "InstructionHandle",
    "signature": "getOutermostExceptionEnd(InstructionHandle ih)",
    "file_id": "F36",
    "start_line": 421,
    "text_preview": "rt = Range.genStart(body, getOutermostExceptionStart(exn.getStartPC()));\\n\t\t\t\tInstructionHandle end = Range.genEnd(body, getOutermostExceptionEnd(exn.getEndPC()));\\n\t\t\t\t// this doesn't necessarily handle overlapping correctly!!!\\n\t\t\t\tExceptionRange er = new ExceptionRange(body, exn.getCatchType() == null ? null : BcelWorl"
  },
  {
    "method_id": "M2163",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2164",
    "name": "ensureAllLineNumberSetup",
    "return_type": "void",
    "signature": "ensureAllLineNumberSetup()",
    "file_id": "F36",
    "start_line": 111,
    "text_preview": " ctor() in such a way that it creates\\n\t * Tags - removing the need for unpackLocals/unpackLineNumbers - HOWEVER see the ensureAllLineNumberSetup() method for some\\n\t * other relevant info.\\n\t *\\n\t * Whats the difference between a Tag and a Gen? A Tag is more lightweight, it doesn't know which instructions it targets, it\\n\t"
  },
  {
    "method_id": "M2165",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof LineNumberTag)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2166",
    "name": "if",
    "return_type": "",
    "signature": "if(lastKnownLineNumberTag != null && !skip)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2167",
    "name": "allocateLocal",
    "return_type": "int",
    "signature": "allocateLocal(Type type)",
    "file_id": "F36",
    "start_line": 478,
    "text_preview": "NumberTag != null && !skip) {\\n\t\t\t\tih.addTargeter(lastKnownLineNumberTag);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t// ===============\\n\\n\tpublic int allocateLocal(Type type) {\\n\t\treturn allocateLocal(type.getSize());\\n\t}\\n\\n\tpublic int allocateLocal(int slots) {\\n\t\tint max = getMaxLocals();\\n\t\tsetMaxLocals(max + slots);\\n\t\treturn max;\\n\t}\\n\\n\tpublic Method "
  },
  {
    "method_id": "M2168",
    "name": "allocateLocal",
    "return_type": "int",
    "signature": "allocateLocal(int slots)",
    "file_id": "F36",
    "start_line": 478,
    "text_preview": "NumberTag != null && !skip) {\\n\t\t\t\tih.addTargeter(lastKnownLineNumberTag);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\t// ===============\\n\\n\tpublic int allocateLocal(Type type) {\\n\t\treturn allocateLocal(type.getSize());\\n\t}\\n\\n\tpublic int allocateLocal(int slots) {\\n\t\tint max = getMaxLocals();\\n\t\tsetMaxLocals(max + slots);\\n\t\treturn max;\\n\t}\\n\\n\tpublic Method "
  },
  {
    "method_id": "M2169",
    "name": "getMethod",
    "return_type": "Method",
    "signature": "getMethod()",
    "file_id": "F36",
    "start_line": 218,
    "text_preview": " Modifier.isNative(modifiers);\\n\t}\\n\\n\tpublic LazyMethodGen(BcelMethod m, LazyClassGen enclosingClass) {\\n\t\tsavedMethod = m.getMethod();\\n\t\tthis.enclosingClass = enclosingClass;\\n\t\tif (!isAbstractOrNative(m.getModifiers()) && savedMethod.getCode() == null) {\\n\t\t\tthrow new RuntimeException(\"bad non-abstract method with no code"
  },
  {
    "method_id": "M2170",
    "name": "if",
    "return_type": "",
    "signature": "if(savedMethod != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2171",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassGenException e)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2172",
    "name": "catch",
    "return_type": "",
    "signature": "catch(RuntimeException re)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2173",
    "name": "markAsChanged",
    "return_type": "void",
    "signature": "markAsChanged()",
    "file_id": "F36",
    "start_line": 534,
    "text_preview": "ashing.\\n\t\t\t\tbody = null;\\n\t\t\t\tMethodGen gen = pack();\\n\t\t\t\treturn gen.getMethod();\\n\t\t\t}\\n\t\t\tthrow re;\\n\t\t}\\n\t}\\n\\n\tpublic void markAsChanged() {\\n\t\tif (wasPackedOptimally) {\\n\t\t\tthrow new RuntimeException(\"Already packed method is being re-modified: \" + getClassName() + \" \" + toShortString());\\n\t\t}\\n\t\tinitialize();\\n\t\tsavedMethod "
  },
  {
    "method_id": "M2174",
    "name": "if",
    "return_type": "",
    "signature": "if(wasPackedOptimally)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2175",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F36",
    "start_line": 545,
    "text_preview": "rtString());\\n\t\t}\\n\t\tinitialize();\\n\t\tsavedMethod = null;\\n\t}\\n\\n\t// =============================\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\tBcelObjectType bot = enclosingClass.getBcelObjectType();\\n\t\tWeaverVersionInfo weaverVersion = (bot == null ? WeaverVersionInfo.CURRENT : bot.getWeaverVersionAttribute());\\n\t\treturn toLong"
  },
  {
    "method_id": "M2176",
    "name": "toShortString",
    "return_type": "String",
    "signature": "toShortString()",
    "file_id": "F36",
    "start_line": 536,
    "text_preview": "ackedOptimally) {\\n\t\t\tthrow new RuntimeException(\"Already packed method is being re-modified: \" + getClassName() + \" \" + toShortString());\\n\t\t}\\n\t\tinitialize();\\n\t\tsavedMethod = null;\\n\t}\\n\\n\t// =============================\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\tBcelObjectType bot = enclosingClass.getBcelObjectType();\\n\t\tW"
  },
  {
    "method_id": "M2177",
    "name": "if",
    "return_type": "",
    "signature": "if(len > 0)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2178",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 1; i < argumentTypes.length; i++)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2179",
    "name": "if",
    "return_type": "",
    "signature": "if(len > 0)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2180",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 1; i < declaredExceptions.length; i++)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2181",
    "name": "toLongString",
    "return_type": "String",
    "signature": "toLongString(WeaverVersionInfo weaverVersion)",
    "file_id": "F36",
    "start_line": 548,
    "text_preview": "WeaverVersionInfo weaverVersion = (bot == null ? WeaverVersionInfo.CURRENT : bot.getWeaverVersionAttribute());\\n\t\treturn toLongString(weaverVersion);\\n\t}\\n\\n\tpublic String toShortString() {\\n\t\tString access = org.aspectj.apache.bcel.classfile.Utility.accessToString(getAccessFlags());\\n\\n\t\tStringBuilder buf = new StringBuilder"
  },
  {
    "method_id": "M2182",
    "name": "print",
    "return_type": "void",
    "signature": "print(WeaverVersionInfo weaverVersion)",
    "file_id": "F36",
    "start_line": 592,
    "text_preview": "ublic String toLongString(WeaverVersionInfo weaverVersion) {\\n\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\\n\t\tprint(new PrintStream(s), weaverVersion);\\n\t\treturn new String(s.toByteArray());\\n\t}\\n\\n\tpublic void print(WeaverVersionInfo weaverVersion) {\\n\t\tprint(System.out, weaverVersion);\\n\t}\\n\\n\tpublic void print(Pri"
  },
  {
    "method_id": "M2183",
    "name": "print",
    "return_type": "void",
    "signature": "print(PrintStream out, WeaverVersionInfo weaverVersion)",
    "file_id": "F36",
    "start_line": 592,
    "text_preview": "ublic String toLongString(WeaverVersionInfo weaverVersion) {\\n\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\\n\t\tprint(new PrintStream(s), weaverVersion);\\n\t\treturn new String(s.toByteArray());\\n\t}\\n\\n\tpublic void print(WeaverVersionInfo weaverVersion) {\\n\t\tprint(System.out, weaverVersion);\\n\t}\\n\\n\tpublic void print(Pri"
  },
  {
    "method_id": "M2184",
    "name": "if",
    "return_type": "",
    "signature": "if(body == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2185",
    "name": "printAspectAttributes",
    "return_type": "void",
    "signature": "printAspectAttributes(PrintStream out, WeaverVersionInfo weaverVersion)",
    "file_id": "F36",
    "start_line": 602,
    "text_preview": "ion);\\n\t}\\n\\n\tpublic void print(PrintStream out, WeaverVersionInfo weaverVersion) {\\n\t\tout.print(\"  \" + toShortString());\\n\t\tprintAspectAttributes(out, weaverVersion);\\n\\n\t\tInstructionList body = getBody();\\n\t\tif (body == null) {\\n\t\t\tout.println(\";\");\\n\t\t\treturn;\\n\t\t}\\n\t\tout.println(\":\");\\n\t\tnew BodyPrinter(out).run();\\n\t\tout.printl"
  },
  {
    "method_id": "M2186",
    "name": "BodyPrinter",
    "return_type": "",
    "signature": "BodyPrinter(PrintStream out)",
    "file_id": "F36",
    "start_line": 610,
    "text_preview": "\t\tInstructionList body = getBody();\\n\t\tif (body == null) {\\n\t\t\tout.println(\";\");\\n\t\t\treturn;\\n\t\t}\\n\t\tout.println(\":\");\\n\t\tnew BodyPrinter(out).run();\\n\t\tout.println(\"  end \" + toShortString());\\n\t}\\n\\n\tprivate void printAspectAttributes(PrintStream out, WeaverVersionInfo weaverVersion) {\\n\t\tISourceContext context = null;\\n\t\tif (en"
  },
  {
    "method_id": "M2187",
    "name": "BodyPrinter",
    "return_type": "",
    "signature": "BodyPrinter(PrintStream out, InstructionList il)",
    "file_id": "F36",
    "start_line": 610,
    "text_preview": "\t\tInstructionList body = getBody();\\n\t\tif (body == null) {\\n\t\t\tout.println(\";\");\\n\t\t\treturn;\\n\t\t}\\n\t\tout.println(\":\");\\n\t\tnew BodyPrinter(out).run();\\n\t\tout.println(\"  end \" + toShortString());\\n\t}\\n\\n\tprivate void printAspectAttributes(PrintStream out, WeaverVersionInfo weaverVersion) {\\n\t\tISourceContext context = null;\\n\t\tif (en"
  },
  {
    "method_id": "M2188",
    "name": "run",
    "return_type": "void",
    "signature": "run()",
    "file_id": "F36",
    "start_line": 610,
    "text_preview": " body = getBody();\\n\t\tif (body == null) {\\n\t\t\tout.println(\";\");\\n\t\t\treturn;\\n\t\t}\\n\t\tout.println(\":\");\\n\t\tnew BodyPrinter(out).run();\\n\t\tout.println(\"  end \" + toShortString());\\n\t}\\n\\n\tprivate void printAspectAttributes(PrintStream out, WeaverVersionInfo weaverVersion) {\\n\t\tISourceContext context = null;\\n\t\tif (enclosingClass != n"
  },
  {
    "method_id": "M2189",
    "name": "assignLabels",
    "return_type": "void",
    "signature": "assignLabels()",
    "file_id": "F36",
    "start_line": 648,
    "text_preview": "pool = enclosingClass.getConstantPool();\\n\t\t\tthis.body = il;\\n\t\t\tthis.out = out;\\n\t\t}\\n\\n\t\tvoid run() {\\n\t\t\t// killNops();\\n\t\t\tassignLabels();\\n\t\t\tprint();\\n\t\t}\\n\\n\t\t// label assignment\\n\t\tvoid assignLabels() {\\n\t\t\tLinkedList<ExceptionRange> exnTable = new LinkedList<>();\\n\t\t\tString pendingLabel = null;\\n\t\t\t// boolean hasPendingTarge"
  },
  {
    "method_id": "M2190",
    "name": "if",
    "return_type": "",
    "signature": "if(t instanceof ExceptionRange)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2191",
    "name": "if",
    "return_type": "else",
    "signature": "if(t instanceof InstructionBranch)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2192",
    "name": "if",
    "return_type": "",
    "signature": "if(pendingLabel == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2193",
    "name": "if",
    "return_type": "",
    "signature": "if(pendingLabel != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2194",
    "name": "for",
    "return_type": "",
    "signature": "for(ExceptionRange er: exnTable)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2195",
    "name": "print",
    "return_type": "void",
    "signature": "print()",
    "file_id": "F36",
    "start_line": 592,
    "text_preview": "ublic String toLongString(WeaverVersionInfo weaverVersion) {\\n\t\tByteArrayOutputStream s = new ByteArrayOutputStream();\\n\t\tprint(new PrintStream(s), weaverVersion);\\n\t\treturn new String(s.toByteArray());\\n\t}\\n\\n\tpublic void print(WeaverVersionInfo weaverVersion) {\\n\t\tprint(System.out, weaverVersion);\\n\t}\\n\\n\tpublic void print(Pri"
  },
  {
    "method_id": "M2196",
    "name": "if",
    "return_type": "",
    "signature": "if(line != currLine)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2197",
    "name": "printRangeString",
    "return_type": "void",
    "signature": "printRangeString(Range r, int depth)",
    "file_id": "F36",
    "start_line": 713,
    "text_preview": "doesn't handle nested: if (r.getStart().getNext() ==\\n\t\t\t\t\t// r.getEnd()) continue;\\n\t\t\t\t\tif (r.getStart() == ih) {\\n\t\t\t\t\t\tprintRangeString(r, depth++);\\n\t\t\t\t\t} else {\\n\t\t\t\t\t\tif (r.getEnd() != ih) {\\n\t\t\t\t\t\t\tthrow new RuntimeException(\"bad\");\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\tprintRangeString(r, --depth);\\n\t\t\t\t\t}\\n\t\t\t\t} else {\\n\t\t\t\t\tprintInstructio"
  },
  {
    "method_id": "M2198",
    "name": "getRangeString",
    "return_type": "String",
    "signature": "getRangeString(Range r, Map<InstructionHandle, String> labelMap)",
    "file_id": "F36",
    "start_line": 735,
    "text_preview": "ut.println();\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\tvoid printRangeString(Range r, int depth) {\\n\t\t\tprintDepth(depth);\\n\t\t\tout.println(getRangeString(r, labelMap));\\n\t\t}\\n\\n\t\tString getRangeString(Range r, Map<InstructionHandle, String> labelMap) {\\n\t\t\tif (r instanceof ExceptionRange) {\\n\t\t\t\tExceptionRange er = (ExceptionRange) r;\\n\t\t\t\tret"
  },
  {
    "method_id": "M2199",
    "name": "if",
    "return_type": "",
    "signature": "if(r instanceof ExceptionRange)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2200",
    "name": "printDepth",
    "return_type": "void",
    "signature": "printDepth(int depth)",
    "file_id": "F36",
    "start_line": 734,
    "text_preview": "line + \")\");\\n\t\t\t\t\t} else {\\n\t\t\t\t\t\tout.println();\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\tvoid printRangeString(Range r, int depth) {\\n\t\t\tprintDepth(depth);\\n\t\t\tout.println(getRangeString(r, labelMap));\\n\t\t}\\n\\n\t\tString getRangeString(Range r, Map<InstructionHandle, String> labelMap) {\\n\t\t\tif (r instanceof ExceptionRange) {\\n\t\t\t\tExceptionRang"
  },
  {
    "method_id": "M2201",
    "name": "while",
    "return_type": "",
    "signature": "while(depth > 0)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2202",
    "name": "printLabel",
    "return_type": "void",
    "signature": "printLabel(String s, int depth)",
    "file_id": "F36",
    "start_line": 757,
    "text_preview": " printDepth(int depth) {\\n\t\t\tpad(BODY_INDENT);\\n\t\t\twhile (depth > 0) {\\n\t\t\t\tout.print(\"| \");\\n\t\t\t\tdepth--;\\n\t\t\t}\\n\t\t}\\n\\n\t\tvoid printLabel(String s, int depth) {\\n\t\t\tint space = Math.max(CODE_INDENT - depth * 2, 0);\\n\t\t\tif (s == null) {\\n\t\t\t\tpad(space);\\n\t\t\t} else {\\n\t\t\t\tspace = Math.max(space - (s.length() + 2), 0);\\n\t\t\t\tpad(space)"
  },
  {
    "method_id": "M2203",
    "name": "if",
    "return_type": "",
    "signature": "if(s == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2204",
    "name": "printInstruction",
    "return_type": "void",
    "signature": "printInstruction(InstructionHandle h, int depth)",
    "file_id": "F36",
    "start_line": 721,
    "text_preview": "!= ih) {\\n\t\t\t\t\t\t\tthrow new RuntimeException(\"bad\");\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\tprintRangeString(r, --depth);\\n\t\t\t\t\t}\\n\t\t\t\t} else {\\n\t\t\t\t\tprintInstruction(ih, depth);\\n\t\t\t\t\tint line = getLineNumber(ih, currLine);\\n\t\t\t\t\tif (line != currLine) {\\n\t\t\t\t\t\tcurrLine = line;\\n\t\t\t\t\t\tout.println(\"   (line \" + line + \")\");\\n\t\t\t\t\t} else {\\n\t\t\t\t\t\tout.print"
  },
  {
    "method_id": "M2205",
    "name": "if",
    "return_type": "else",
    "signature": "if(inst instanceof InstructionSelect)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2206",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = matches.length; i < len; i++)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2207",
    "name": "if",
    "return_type": "else",
    "signature": "if(inst instanceof InstructionBranch)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2208",
    "name": "if",
    "return_type": "",
    "signature": "if(tag != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2209",
    "name": "pad",
    "return_type": "void",
    "signature": "pad(int size)",
    "file_id": "F36",
    "start_line": 750,
    "text_preview": "/\\n\t\t\t\t// + \" PRI \" + er.getPriority();\\n\t\t\t} else {\\n\t\t\t\treturn r.toString();\\n\t\t\t}\\n\t\t}\\n\\n\t\tvoid printDepth(int depth) {\\n\t\t\tpad(BODY_INDENT);\\n\t\t\twhile (depth > 0) {\\n\t\t\t\tout.print(\"| \");\\n\t\t\t\tdepth--;\\n\t\t\t}\\n\t\t}\\n\\n\t\tvoid printLabel(String s, int depth) {\\n\t\t\tint space = Math.max(CODE_INDENT - depth * 2, 0);\\n\t\t\tif (s == null) {\\n\t"
  },
  {
    "method_id": "M2210",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < size; i++)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2211",
    "name": "getLocalVariableTag",
    "return_type": "LocalVariableTag",
    "signature": "getLocalVariableTag(InstructionHandle ih, int index)",
    "file_id": "F36",
    "start_line": 807,
    "text_preview": "// inst;\\n\t\t\t\tout.print(inst.toString(false).toUpperCase());\\n\t\t\t\tint index = inst.getIndex();\\n\t\t\t\tLocalVariableTag tag = getLocalVariableTag(h, index);\\n\t\t\t\tif (tag != null) {\\n\t\t\t\t\tout.print(\"     // \");\\n\t\t\t\t\tout.print(tag.getType());\\n\t\t\t\t\tout.print(\" \");\\n\t\t\t\t\tout.print(tag.getName());\\n\t\t\t\t}\\n\t\t\t} else {\\n\t\t\t\tout.print(ins"
  },
  {
    "method_id": "M2212",
    "name": "if",
    "return_type": "",
    "signature": "if(t instanceof LocalVariableTag)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2213",
    "name": "getLineNumber",
    "return_type": "int",
    "signature": "getLineNumber(InstructionHandle ih, int prevLine)",
    "file_id": "F36",
    "start_line": 722,
    "text_preview": "ad\");\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\tprintRangeString(r, --depth);\\n\t\t\t\t\t}\\n\t\t\t\t} else {\\n\t\t\t\t\tprintInstruction(ih, depth);\\n\t\t\t\t\tint line = getLineNumber(ih, currLine);\\n\t\t\t\t\tif (line != currLine) {\\n\t\t\t\t\t\tcurrLine = line;\\n\t\t\t\t\t\tout.println(\"   (line \" + line + \")\");\\n\t\t\t\t\t} else {\\n\t\t\t\t\t\tout.println();\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\\n\t\tvoid printRang"
  },
  {
    "method_id": "M2214",
    "name": "if",
    "return_type": "",
    "signature": "if(t instanceof LineNumberTag)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2215",
    "name": "isStatic",
    "return_type": "boolean",
    "signature": "isStatic()",
    "file_id": "F36",
    "start_line": 174,
    "text_preview": "Around advice as well\\n\t\t\t\tthis.canInline = false;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate int calculateMaxLocals() {\\n\t\tint ret = Modifier.isStatic(modifiers) ? 0 : 1; // will there be a 'this'?\\n\t\tfor (Type type : argumentTypes) {\\n\t\t\tret += type.getSize();\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\t// build from an existing method, lazy build saves most wor"
  },
  {
    "method_id": "M2216",
    "name": "isAbstract",
    "return_type": "boolean",
    "signature": "isAbstract()",
    "file_id": "F36",
    "start_line": 150,
    "text_preview": "rgumentNames = Utility.makeArgNames(paramTypes.length);\\n\t\tthis.declaredExceptions = declaredExceptions;\\n\t\tif (!Modifier.isAbstract(modifiers)) {\\n\t\t\tbody = new InstructionList();\\n\t\t\tsetMaxLocals(calculateMaxLocals());\\n\t\t} else {\\n\t\t\tbody = null;\\n\t\t}\\n\t\tthis.attributes = new ArrayList<>();\\n\t\tthis.enclosingClass = enclosing"
  },
  {
    "method_id": "M2217",
    "name": "isBridgeMethod",
    "return_type": "boolean",
    "signature": "isBridgeMethod()",
    "file_id": "F36",
    "start_line": 858,
    "text_preview": "tAccessFlags());\\n\t}\\n\\n\tpublic boolean isAbstract() {\\n\t\treturn Modifier.isAbstract(getAccessFlags());\\n\t}\\n\\n\tpublic boolean isBridgeMethod() {\\n\t\treturn (getAccessFlags() & Constants.ACC_BRIDGE) != 0;\\n\t}\\n\\n\tpublic void addExceptionHandler(InstructionHandle start, InstructionHandle end, InstructionHandle handlerStart,\\n\t\t\tObje"
  },
  {
    "method_id": "M2218",
    "name": "addExceptionHandler",
    "return_type": "void",
    "signature": "addExceptionHandler(InstructionHandle start, InstructionHandle end, InstructionHandle handlerStart,\n\t\t\tObjectType catchType, boolean highPriority)",
    "file_id": "F36",
    "start_line": 862,
    "text_preview": "gs());\\n\t}\\n\\n\tpublic boolean isBridgeMethod() {\\n\t\treturn (getAccessFlags() & Constants.ACC_BRIDGE) != 0;\\n\t}\\n\\n\tpublic void addExceptionHandler(InstructionHandle start, InstructionHandle end, InstructionHandle handlerStart,\\n\t\t\tObjectType catchType, boolean highPriority) {\\n\\n\t\tInstructionHandle start1 = Range.genStart(body, "
  },
  {
    "method_id": "M2219",
    "name": "getAccessFlags",
    "return_type": "int",
    "signature": "getAccessFlags()",
    "file_id": "F36",
    "start_line": 552,
    "text_preview": "rsion);\\n\t}\\n\\n\tpublic String toShortString() {\\n\t\tString access = org.aspectj.apache.bcel.classfile.Utility.accessToString(getAccessFlags());\\n\\n\t\tStringBuilder buf = new StringBuilder();\\n\\n\t\tif (!access.equals(\"\")) {\\n\t\t\tbuf.append(access);\\n\t\t\tbuf.append(\" \");\\n\t\t}\\n\t\tbuf.append(org.aspectj.apache.bcel.classfile.Utility.signat"
  },
  {
    "method_id": "M2220",
    "name": "getAccessFlagsWithoutSynchronized",
    "return_type": "int",
    "signature": "getAccessFlagsWithoutSynchronized()",
    "file_id": "F36",
    "start_line": 876,
    "text_preview": "ssociateWithTargets(start1, end1, handlerStart);\\n\t}\\n\\n\tpublic int getAccessFlags() {\\n\t\treturn modifiers;\\n\t}\\n\\n\tpublic int getAccessFlagsWithoutSynchronized() {\\n\t\tif (isSynchronized()) {\\n\t\t\treturn modifiers - Modifier.SYNCHRONIZED;\\n\t\t}\\n\t\treturn modifiers;\\n\t}\\n\\n\tpublic boolean isSynchronized() {\\n\t\treturn (modifiers & Modifi"
  },
  {
    "method_id": "M2221",
    "name": "isSynchronized",
    "return_type": "boolean",
    "signature": "isSynchronized()",
    "file_id": "F36",
    "start_line": 877,
    "text_preview": "rt);\\n\t}\\n\\n\tpublic int getAccessFlags() {\\n\t\treturn modifiers;\\n\t}\\n\\n\tpublic int getAccessFlagsWithoutSynchronized() {\\n\t\tif (isSynchronized()) {\\n\t\t\treturn modifiers - Modifier.SYNCHRONIZED;\\n\t\t}\\n\t\treturn modifiers;\\n\t}\\n\\n\tpublic boolean isSynchronized() {\\n\t\treturn (modifiers & Modifier.SYNCHRONIZED) != 0;\\n\t}\\n\\n\tpublic void setA"
  },
  {
    "method_id": "M2222",
    "name": "setAccessFlags",
    "return_type": "void",
    "signature": "setAccessFlags(int newFlags)",
    "file_id": "F36",
    "start_line": 887,
    "text_preview": "n modifiers;\\n\t}\\n\\n\tpublic boolean isSynchronized() {\\n\t\treturn (modifiers & Modifier.SYNCHRONIZED) != 0;\\n\t}\\n\\n\tpublic void setAccessFlags(int newFlags) {\\n\t\tthis.modifiers = newFlags;\\n\t}\\n\\n\tpublic Type[] getArgumentTypes() {\\n\t\tinitialize();\\n\t\treturn argumentTypes;\\n\t}\\n\\n\tpublic LazyClassGen getEnclosingClass() {\\n\t\treturn encl"
  },
  {
    "method_id": "M2223",
    "name": "getArgumentTypes",
    "return_type": "Type[]",
    "signature": "getArgumentTypes()",
    "file_id": "F36",
    "start_line": 299,
    "text_preview": "lize();\\n\t\tif (memberView == null) {\\n\t\t\tif (newParameterAnnotations == null) {\\n\t\t\t\t// time to create it\\n\t\t\t\tint pcount = getArgumentTypes().length;\\n\t\t\t\tnewParameterAnnotations = new AnnotationAJ[pcount][];\\n\t\t\t\tfor (int i = 0; i < pcount; i++) {\\n\t\t\t\t\tif (i == parameterNumber) {\\n\t\t\t\t\t\tnewParameterAnnotations[i] = new Anno"
  },
  {
    "method_id": "M2224",
    "name": "getEnclosingClass",
    "return_type": "LazyClassGen",
    "signature": "getEnclosingClass()",
    "file_id": "F36",
    "start_line": 360,
    "text_preview": "ignature().equals(annotationType.getSignature())) {\\n\t\t\t\t\t\treturn true;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tmemberView = new BcelMethod(getEnclosingClass().getBcelObjectType(), getMethod());\\n\t\t\treturn memberView.hasAnnotation(annotationType);\\n\t\t}\\n\t\treturn memberView.hasAnnotation(annotationType);\\n\t}\\n\\n\tprivate void initialize() {\\n\t\tif "
  },
  {
    "method_id": "M2225",
    "name": "getMaxLocals",
    "return_type": "int",
    "signature": "getMaxLocals()",
    "file_id": "F36",
    "start_line": 377,
    "text_preview": "ptions();\\n\t\tthis.attributes = gen.getAttributes();\\n\t\t// this.annotations = gen.getAnnotations();\\n\t\tthis.maxLocals = gen.getMaxLocals();\\n\\n\t\t// this.returnType = BcelWorld.makeBcelType(memberView.getReturnType());\\n\t\t// this.argumentTypes =\\n\t\t// BcelWorld.makeBcelTypes(memberView.getParameterTypes());\\n\t\t//\\n\t\t// this.decla"
  },
  {
    "method_id": "M2226",
    "name": "getName",
    "return_type": "String",
    "signature": "getName()",
    "file_id": "F36",
    "start_line": 142,
    "text_preview": "ype, String name, Type[] paramTypes, String[] declaredExceptions,\\n\t\t\tLazyClassGen enclosingClass) {\\n\t\t// enclosingClass.getName() + \", \" + returnType);\\n\t\tthis.memberView = null; // should be okay, since constructed ones aren't woven into\\n\t\tthis.modifiers = modifiers;\\n\t\tthis.returnType = returnType;\\n\t\tthis.name = name;\\n"
  },
  {
    "method_id": "M2227",
    "name": "getGenericReturnTypeSignature",
    "return_type": "String",
    "signature": "getGenericReturnTypeSignature()",
    "file_id": "F36",
    "start_line": 908,
    "text_preview": ";\\n\t}\\n\\n\tpublic int getMaxLocals() {\\n\t\treturn maxLocals;\\n\t}\\n\\n\tpublic String getName() {\\n\t\treturn name;\\n\t}\\n\\n\tpublic String getGenericReturnTypeSignature() {\\n\t\tif (memberView == null) {\\n\t\t\treturn getReturnType().getSignature();\\n\t\t} else {\\n\t\t\treturn memberView.getGenericReturnType().getSignature();\\n\t\t}\\n\t}\\n\\n\tpublic Type getR"
  },
  {
    "method_id": "M2228",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2229",
    "name": "getReturnType",
    "return_type": "Type",
    "signature": "getReturnType()",
    "file_id": "F36",
    "start_line": 372,
    "text_preview": " new MethodGen(savedMethod, enclosingClass.getName(), enclosingClass.getConstantPool(), true);\\n\\n\t\tthis.returnType = gen.getReturnType();\\n\t\tthis.argumentTypes = gen.getArgumentTypes();\\n\t\tthis.declaredExceptions = gen.getExceptions();\\n\t\tthis.attributes = gen.getAttributes();\\n\t\t// this.annotations = gen.getAnnotations();\\n"
  },
  {
    "method_id": "M2230",
    "name": "setMaxLocals",
    "return_type": "void",
    "signature": "setMaxLocals(int maxLocals)",
    "file_id": "F36",
    "start_line": 152,
    "text_preview": "s.declaredExceptions = declaredExceptions;\\n\t\tif (!Modifier.isAbstract(modifiers)) {\\n\t\t\tbody = new InstructionList();\\n\t\t\tsetMaxLocals(calculateMaxLocals());\\n\t\t} else {\\n\t\t\tbody = null;\\n\t\t}\\n\t\tthis.attributes = new ArrayList<>();\\n\t\tthis.enclosingClass = enclosingClass;\\n\t\tassertGoodBody();\\n\t\tthis.originalMethodHasLocalVaria"
  },
  {
    "method_id": "M2231",
    "name": "getBody",
    "return_type": "InstructionList",
    "signature": "getBody()",
    "file_id": "F36",
    "start_line": 604,
    "text_preview": "rVersion) {\\n\t\tout.print(\"  \" + toShortString());\\n\t\tprintAspectAttributes(out, weaverVersion);\\n\\n\t\tInstructionList body = getBody();\\n\t\tif (body == null) {\\n\t\t\tout.println(\";\");\\n\t\t\treturn;\\n\t\t}\\n\t\tout.println(\":\");\\n\t\tnew BodyPrinter(out).run();\\n\t\tout.println(\"  end \" + toShortString());\\n\t}\\n\\n\tprivate void printAspectAttribute"
  },
  {
    "method_id": "M2232",
    "name": "getBodyForPrint",
    "return_type": "InstructionList",
    "signature": "getBodyForPrint()",
    "file_id": "F36",
    "start_line": 636,
    "text_preview": "\\n\t\tConstantPool pool;\\n\\n\t\tBodyPrinter(PrintStream out) {\\n\t\t\tthis.pool = enclosingClass.getConstantPool();\\n\t\t\tthis.body = getBodyForPrint();\\n\t\t\tthis.out = out;\\n\t\t}\\n\\n\t\tBodyPrinter(PrintStream out, InstructionList il) {\\n\t\t\tthis.pool = enclosingClass.getConstantPool();\\n\t\t\tthis.body = il;\\n\t\t\tthis.out = out;\\n\t\t}\\n\\n\t\tvoid run()"
  },
  {
    "method_id": "M2233",
    "name": "hasBody",
    "return_type": "boolean",
    "signature": "hasBody()",
    "file_id": "F36",
    "start_line": 934,
    "text_preview": " {\\n\t\tmarkAsChanged();\\n\t\treturn body;\\n\t}\\n\\n\tpublic InstructionList getBodyForPrint() {\\n\t\treturn body;\\n\t}\\n\\n\tpublic boolean hasBody() {\\n\t\tif (savedMethod != null) {\\n\t\t\treturn savedMethod.getCode() != null;\\n\t\t}\\n\t\treturn body != null;\\n\t}\\n\\n\tpublic List<Attribute> getAttributes() {\\n\t\treturn attributes;\\n\t}\\n\\n\tpublic String[] get"
  },
  {
    "method_id": "M2234",
    "name": "if",
    "return_type": "",
    "signature": "if(savedMethod != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2235",
    "name": "getAttributes",
    "return_type": "List<Attribute>",
    "signature": "getAttributes()",
    "file_id": "F36",
    "start_line": 375,
    "text_preview": "\t\tthis.argumentTypes = gen.getArgumentTypes();\\n\t\tthis.declaredExceptions = gen.getExceptions();\\n\t\tthis.attributes = gen.getAttributes();\\n\t\t// this.annotations = gen.getAnnotations();\\n\t\tthis.maxLocals = gen.getMaxLocals();\\n\\n\t\t// this.returnType = BcelWorld.makeBcelType(memberView.getReturnType());\\n\t\t// this.argumentType"
  },
  {
    "method_id": "M2236",
    "name": "getDeclaredExceptions",
    "return_type": "String[]",
    "signature": "getDeclaredExceptions()",
    "file_id": "F36",
    "start_line": 945,
    "text_preview": "ull;\\n\t\t}\\n\t\treturn body != null;\\n\t}\\n\\n\tpublic List<Attribute> getAttributes() {\\n\t\treturn attributes;\\n\t}\\n\\n\tpublic String[] getDeclaredExceptions() {\\n\t\treturn declaredExceptions;\\n\t}\\n\\n\tpublic String getClassName() {\\n\t\treturn enclosingClass.getName();\\n\t}\\n\\n\t// ---- packing!\\n\\n\tpublic MethodGen pack() {\\n\t\tforceSyntheticForAjcMa"
  },
  {
    "method_id": "M2237",
    "name": "getClassName",
    "return_type": "String",
    "signature": "getClassName()",
    "file_id": "F36",
    "start_line": 505,
    "text_preview": ")\\n\t\t\t\t\t.showMessage(\\n\t\t\t\t\t\t\tIMessage.ERROR,\\n\t\t\t\t\t\t\tWeaverMessages.format(WeaverMessages.PROBLEM_GENERATING_METHOD, this.getClassName(), this.getName(),\\n\t\t\t\t\t\t\t\t\te.getMessage()),\\n\t\t\t\t\t\t\tthis.getMemberView() == null ? null : this.getMemberView().getSourceLocation(), null);\\n\t\t\t// throw e; PR 70201.... let the normal probl"
  },
  {
    "method_id": "M2238",
    "name": "pack",
    "return_type": "MethodGen",
    "signature": "pack()",
    "file_id": "F36",
    "start_line": 495,
    "text_preview": " {\\n\t\t\treturn savedMethod; // ??? this relies on gentle treatment of\\n\t\t\t// constant pool\\n\t\t}\\n\\n\t\ttry {\\n\t\t\tMethodGen gen = pack();\\n\t\t\tsavedMethod = gen.getMethod();\\n\t\t\treturn savedMethod;\\n\t\t} catch (ClassGenException e) {\\n\t\t\tenclosingClass\\n\t\t\t\t\t.getBcelObjectType()\\n\t\t\t\t\t.getResolvedTypeX()\\n\t\t\t\t\t.getWorld()\\n\t\t\t\t\t.showMessa"
  },
  {
    "method_id": "M2239",
    "name": "for",
    "return_type": "",
    "signature": "for(String declaredException : declaredExceptions)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2240",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute attr : attributes)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2241",
    "name": "if",
    "return_type": "",
    "signature": "if(newAnnotations != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2242",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ element : newAnnotations)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2243",
    "name": "if",
    "return_type": "",
    "signature": "if(newParameterAnnotations != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2244",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < newParameterAnnotations.length; i++)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2245",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ anno : annos)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2246",
    "name": "for",
    "return_type": "",
    "signature": "for(AnnotationAJ an : ans)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2247",
    "name": "if",
    "return_type": "",
    "signature": "if(isSynthetic)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2248",
    "name": "hasAttribute",
    "return_type": "boolean",
    "signature": "hasAttribute(String attributeName)",
    "file_id": "F36",
    "start_line": 1002,
    "text_preview": "ingClass.getWorld().isInJava5Mode()) {\\n\t\t\t\tgen.setModifiers(gen.getModifiers() | Constants.ACC_SYNTHETIC);\\n\t\t\t}\\n\t\t\tif (!hasAttribute(\"Synthetic\")) {\\n\t\t\t\t// belt and braces, do the attribute even on Java 5 in addition to the modifier flag\\n\t\t\t\tConstantPool cpg = gen.getConstantPool();\\n\t\t\t\tint index = cpg.addUtf8(\"Synthet"
  },
  {
    "method_id": "M2249",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute attr: attributes)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2250",
    "name": "forceSyntheticForAjcMagicMembers",
    "return_type": "void",
    "signature": "forceSyntheticForAjcMagicMembers()",
    "file_id": "F36",
    "start_line": 956,
    "text_preview": "\\n\tpublic String getClassName() {\\n\t\treturn enclosingClass.getName();\\n\t}\\n\\n\t// ---- packing!\\n\\n\tpublic MethodGen pack() {\\n\t\tforceSyntheticForAjcMagicMembers();\\n\\n\t\t// killNops();\\n\t\tint flags = getAccessFlags();\\n\t\tif (enclosingClass.getWorld().isJoinpointSynchronizationEnabled()\\n\t\t\t\t&& enclosingClass.getWorld().areSynchroniz"
  },
  {
    "method_id": "M2251",
    "name": "inAspect",
    "return_type": "boolean",
    "signature": "inAspect()",
    "file_id": "F36",
    "start_line": 1039,
    "text_preview": "}\\n\t\treturn false;\\n\t}\\n\\n\tprivate void forceSyntheticForAjcMagicMembers() {\\n\t\tif (NameMangler.isSyntheticMethod(getName(), inAspect())) {\\n\t\t\tmakeSynthetic();\\n\t\t}\\n\t}\\n\\n\tprivate boolean inAspect() {\\n\t\tBcelObjectType objectType = enclosingClass.getBcelObjectType();\\n\t\treturn (objectType == null ? false : objectType.isAspect())"
  },
  {
    "method_id": "M2252",
    "name": "makeSynthetic",
    "return_type": "void",
    "signature": "makeSynthetic()",
    "file_id": "F36",
    "start_line": 1040,
    "text_preview": "\t}\\n\\n\tprivate void forceSyntheticForAjcMagicMembers() {\\n\t\tif (NameMangler.isSyntheticMethod(getName(), inAspect())) {\\n\t\t\tmakeSynthetic();\\n\t\t}\\n\t}\\n\\n\tprivate boolean inAspect() {\\n\t\tBcelObjectType objectType = enclosingClass.getBcelObjectType();\\n\t\treturn (objectType == null ? false : objectType.isAspect());\\n\t}\\n\\n\tpublic void"
  },
  {
    "method_id": "M2253",
    "name": "packBody",
    "return_type": "void",
    "signature": "packBody(MethodGen gen)",
    "file_id": "F36",
    "start_line": 1013,
    "text_preview": "s.enclosingClass.getWorld().shouldFastPackMethods()) {\\n\t\t\t\tif (isAdviceMethod() || getName().equals(\"<clinit>\")) {\\n\t\t\t\t\tpackBody(gen);\\n\t\t\t\t} else {\\n\t\t\t\t\toptimizedPackBody(gen);\\n\t\t\t\t}\\n\t\t\t} else {\\n\t\t\t\tpackBody(gen);\\n\t\t\t}\\n\\n\t\t\tgen.setMaxLocals(true);\\n\t\t\tgen.setMaxStack();\\n\t\t} else {\\n\t\t\tgen.setInstructionList(null);\\n\t\t}\\n\t\tr"
  },
  {
    "method_id": "M2254",
    "name": "while",
    "return_type": "",
    "signature": "while(oldInstructionHandle != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2255",
    "name": "if",
    "return_type": "",
    "signature": "if(oldInstruction instanceof InstructionBranch)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2256",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof LineNumberTag)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2257",
    "name": "if",
    "return_type": "",
    "signature": "if(line != currLine)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2258",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof LocalVariableTag)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2259",
    "name": "if",
    "return_type": "position",
    "signature": "if(p == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2260",
    "name": "createNewLocalVariables",
    "return_type": "void",
    "signature": "createNewLocalVariables(MethodGen gen)",
    "file_id": "F36",
    "start_line": 1137,
    "text_preview": "we\\n\t\t\t\t// are left with no local variables, not even the ones for 'this' and\\n\t\t\t\t// parameters passed to the method\\n\t\t\t\tcreateNewLocalVariables(gen);\\n\t\t\t} else {\\n\t\t\t\taddLocalVariables(gen, localVariables);\\n\t\t\t}\\n\t\t}\\n\\n\t\t// JAVAC adds line number tables (with just one entry) to generated\\n\t\t// accessor methods - this\\n\t\t// "
  },
  {
    "method_id": "M2261",
    "name": "if",
    "return_type": "",
    "signature": "if(cname == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2262",
    "name": "if",
    "return_type": "",
    "signature": "if(paramNames != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2263",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < argumentTypes.length; i++)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2264",
    "name": "if",
    "return_type": "",
    "signature": "if(pname == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2265",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F36",
    "start_line": 502,
    "text_preview": "vedMethod;\\n\t\t} catch (ClassGenException e) {\\n\t\t\tenclosingClass\\n\t\t\t\t\t.getBcelObjectType()\\n\t\t\t\t\t.getResolvedTypeX()\\n\t\t\t\t\t.getWorld()\\n\t\t\t\t\t.showMessage(\\n\t\t\t\t\t\t\tIMessage.ERROR,\\n\t\t\t\t\t\t\tWeaverMessages.format(WeaverMessages.PROBLEM_GENERATING_METHOD, this.getClassName(), this.getName(),\\n\t\t\t\t\t\t\t\t\te.getMessage()),\\n\t\t\t\t\t\t\tthis.g"
  },
  {
    "method_id": "M2266",
    "name": "optimizedPackBody",
    "return_type": "void",
    "signature": "optimizedPackBody(MethodGen gen)",
    "file_id": "F36",
    "start_line": 1015,
    "text_preview": "dFastPackMethods()) {\\n\t\t\t\tif (isAdviceMethod() || getName().equals(\"<clinit>\")) {\\n\t\t\t\t\tpackBody(gen);\\n\t\t\t\t} else {\\n\t\t\t\t\toptimizedPackBody(gen);\\n\t\t\t\t}\\n\t\t\t} else {\\n\t\t\t\tpackBody(gen);\\n\t\t\t}\\n\\n\t\t\tgen.setMaxLocals(true);\\n\t\t\tgen.setMaxStack();\\n\t\t} else {\\n\t\t\tgen.setInstructionList(null);\\n\t\t}\\n\t\treturn gen;\\n\t}\\n\\n\tprivate boolean h"
  },
  {
    "method_id": "M2267",
    "name": "while",
    "return_type": "exceptionList",
    "signature": "while(iHandle != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2268",
    "name": "if",
    "return_type": "",
    "signature": "if(inst == Range.RANGEINSTRUCTION)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2269",
    "name": "if",
    "return_type": "",
    "signature": "if(r instanceof ExceptionRange)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2270",
    "name": "if",
    "return_type": "",
    "signature": "if(inst instanceof InstructionBranch)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2271",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof LineNumberTag)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2272",
    "name": "if",
    "return_type": "",
    "signature": "if(line != currLine)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2273",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof LocalVariableTag)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2274",
    "name": "if",
    "return_type": "position",
    "signature": "if(p == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2275",
    "name": "for",
    "return_type": "",
    "signature": "for(BranchHandle branchHandle : branchInstructions)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2276",
    "name": "for",
    "return_type": "handlers",
    "signature": "for(ExceptionRange r : exceptionList)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2277",
    "name": "for",
    "return_type": "",
    "signature": "for(InstructionHandle handle : forDeletion)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2278",
    "name": "catch",
    "return_type": "",
    "signature": "catch(TargetLostException e)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2279",
    "name": "addLocalVariables",
    "return_type": "void",
    "signature": "addLocalVariables(MethodGen gen, Map<LocalVariableTag, LVPosition> localVariables)",
    "file_id": "F36",
    "start_line": 1139,
    "text_preview": "t even the ones for 'this' and\\n\t\t\t\t// parameters passed to the method\\n\t\t\t\tcreateNewLocalVariables(gen);\\n\t\t\t} else {\\n\t\t\t\taddLocalVariables(gen, localVariables);\\n\t\t\t}\\n\t\t}\\n\\n\t\t// JAVAC adds line number tables (with just one entry) to generated\\n\t\t// accessor methods - this\\n\t\t// keeps some tools that rely on finding at least"
  },
  {
    "method_id": "M2280",
    "name": "if",
    "return_type": "",
    "signature": "if(argTypes != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2281",
    "name": "for",
    "return_type": "",
    "signature": "for(Type argType : argTypes)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2282",
    "name": "if",
    "return_type": "",
    "signature": "if(slots == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2283",
    "name": "if",
    "return_type": "",
    "signature": "if(t == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2284",
    "name": "addExceptionHandlers",
    "return_type": "void",
    "signature": "addExceptionHandlers(MethodGen gen, Map<InstructionHandle, InstructionHandle> map,\n\t\t\tIterable<ExceptionRange> exnList)",
    "file_id": "F36",
    "start_line": 1127,
    "text_preview": "tructionHandle = oldInstructionHandle.getNext();\\n\t\t\t\tnewInstructionHandle = newInstructionHandle.getNext();\\n\t\t\t}\\n\t\t}\\n\\n\t\taddExceptionHandlers(gen, map, exceptionList);\\n\t\tif (originalMethodHasLocalVariableTable || enclosingClass\\n\t\t\t\t.getBcelObjectType()\\n\t\t\t\t.getResolvedTypeX()\\n\t\t\t\t.getWorld().generateNewLvts) {\\n\t\t\tif (lo"
  },
  {
    "method_id": "M2285",
    "name": "for",
    "return_type": "handlers",
    "signature": "for(ExceptionRange r : exnList)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2286",
    "name": "handleBranchInstruction",
    "return_type": "void",
    "signature": "handleBranchInstruction(Map<InstructionHandle, InstructionHandle> map, Instruction oldInstruction,\n\t\t\tInstruction newInstruction)",
    "file_id": "F36",
    "start_line": 1093,
    "text_preview": "on newInstruction = newInstructionHandle.getInstruction();\\n\\n\t\t\t\tif (oldInstruction instanceof InstructionBranch) {\\n\t\t\t\t\thandleBranchInstruction(map, oldInstruction, newInstruction);\\n\t\t\t\t}\\n\\n\t\t\t\t// now deal with line numbers\\n\t\t\t\t// and store up info for local variables\\n\t\t\t\tfor (InstructionTargeter targeter : oldInstructi"
  },
  {
    "method_id": "M2287",
    "name": "if",
    "return_type": "",
    "signature": "if(oldBranchInstruction instanceof InstructionSelect)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2288",
    "name": "for",
    "return_type": "",
    "signature": "for(int k = oldTargets.length - 1; k >= 0; k--)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2289",
    "name": "jumpForward",
    "return_type": "InstructionHandle",
    "signature": "jumpForward(InstructionHandle t, Set<InstructionHandle> handlesForDeletion)",
    "file_id": "F36",
    "start_line": 1260,
    "text_preview": "handlers\\n\t\tfor (ExceptionRange r : exceptionList) {\\n\t\t\tif (r.isEmpty()) {\\n\t\t\t\tcontinue;\\n\t\t\t}\\n\t\t\tgen.addExceptionHandler(jumpForward(r.getRealStart(), forDeletion), jumpForward(r.getRealEnd(), forDeletion),\\n\t\t\t\t\tjumpForward(r.getHandler(), forDeletion),\\n\t\t\t\t\t(r.getCatchType() == null) ? null : (ObjectType) BcelWorld.mak"
  },
  {
    "method_id": "M2290",
    "name": "handleBranchInstruction",
    "return_type": "void",
    "signature": "handleBranchInstruction(BranchHandle branchHandle, Set<InstructionHandle> handlesForDeletion)",
    "file_id": "F36",
    "start_line": 1093,
    "text_preview": "on newInstruction = newInstructionHandle.getInstruction();\\n\\n\t\t\t\tif (oldInstruction instanceof InstructionBranch) {\\n\t\t\t\t\thandleBranchInstruction(map, oldInstruction, newInstruction);\\n\t\t\t\t}\\n\\n\t\t\t\t// now deal with line numbers\\n\t\t\t\t// and store up info for local variables\\n\t\t\t\tfor (InstructionTargeter targeter : oldInstructi"
  },
  {
    "method_id": "M2291",
    "name": "if",
    "return_type": "",
    "signature": "if(branchInstruction instanceof InstructionSelect)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2292",
    "name": "for",
    "return_type": "",
    "signature": "for(int k = targets.length - 1; k >= 0; k--)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2293",
    "name": "handleRangeInstruction",
    "return_type": "void",
    "signature": "handleRangeInstruction(InstructionHandle ih, LinkedList<ExceptionRange> exnList)",
    "file_id": "F36",
    "start_line": 1084,
    "text_preview": "ionHandle) == null) {\\n\t\t\t\t// must be a range instruction since they're the only things we\\n\t\t\t\t// didn't copy across\\n\t\t\t\thandleRangeInstruction(oldInstructionHandle, exceptionList);\\n\t\t\t\t// just increment ih.\\n\t\t\t\toldInstructionHandle = oldInstructionHandle.getNext();\\n\t\t\t} else {\\n\t\t\t\t// assert map.get(ih) == jh\\n\t\t\t\tInstru"
  },
  {
    "method_id": "M2294",
    "name": "if",
    "return_type": "",
    "signature": "if(r instanceof ExceptionRange)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2295",
    "name": "copyAllInstructionsExceptRangeInstructionsInto",
    "return_type": "InstructionHandle>",
    "signature": "copyAllInstructionsExceptRangeInstructionsInto(InstructionList intoList)",
    "file_id": "F36",
    "start_line": 1063,
    "text_preview": "(MethodGen gen) {\\n\t\tInstructionList fresh = gen.getInstructionList();\\n\t\tMap<InstructionHandle, InstructionHandle> map = copyAllInstructionsExceptRangeInstructionsInto(fresh);\\n\\n\t\t// at this point, no rangeHandles are in fresh. Let's use that...\\n\\n\t\t/*\\n\t\t * Update branch targets and insert various attributes. Insert our e"
  },
  {
    "method_id": "M2296",
    "name": "if",
    "return_type": "",
    "signature": "if(copy instanceof InstructionBranch)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2297",
    "name": "killNops",
    "return_type": "void",
    "signature": "killNops()",
    "file_id": "F36",
    "start_line": 647,
    "text_preview": " il) {\\n\t\t\tthis.pool = enclosingClass.getConstantPool();\\n\t\t\tthis.body = il;\\n\t\t\tthis.out = out;\\n\t\t}\\n\\n\t\tvoid run() {\\n\t\t\t// killNops();\\n\t\t\tassignLabels();\\n\t\t\tprint();\\n\t\t}\\n\\n\t\t// label assignment\\n\t\tvoid assignLabels() {\\n\t\t\tLinkedList<ExceptionRange> exnTable = new LinkedList<>();\\n\t\t\tString pendingLabel = null;\\n\t\t\t// boolean "
  },
  {
    "method_id": "M2298",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2299",
    "name": "if",
    "return_type": "",
    "signature": "if(targeters != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2300",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = targeters.length; i < len; i++)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2301",
    "name": "catch",
    "return_type": "",
    "signature": "catch(TargetLostException e)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2302",
    "name": "fNext",
    "return_type": "InstructionHandle",
    "signature": "fNext(InstructionHandle ih)",
    "file_id": "F36",
    "start_line": 1503,
    "text_preview": "r);\\n\t// } catch (TargetLostException e) {\\n\t// }\\n\t// }\\n\t// curr = next;\\n\t// }\\n\t// }\\n\t// private static InstructionHandle fNext(InstructionHandle ih) {\\n\t// while (true) {\\n\t// if (ih.getInstruction()==Range.RANGEINSTRUCTION) ih = ih.getNext();\\n\t// else return ih;\\n\t// }\\n\t// }\\n\tprivate static InstructionHandle remap(Instruc"
  },
  {
    "method_id": "M2303",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2304",
    "name": "remap",
    "return_type": "InstructionHandle",
    "signature": "remap(InstructionHandle handle, Map<InstructionHandle, InstructionHandle> map)",
    "file_id": "F36",
    "start_line": 1366,
    "text_preview": "dlers\\n\t\tfor (ExceptionRange r : exnList) {\\n\t\t\tif (r.isEmpty()) {\\n\t\t\t\tcontinue;\\n\t\t\t}\\n\t\t\tInstructionHandle rMappedStart = remap(r.getRealStart(), map);\\n\t\t\tInstructionHandle rMappedEnd = remap(r.getRealEnd(), map);\\n\t\t\tInstructionHandle rMappedHandler = remap(r.getHandler(), map);\\n\t\t\tgen.addExceptionHandler(rMappedStart, r"
  },
  {
    "method_id": "M2305",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2306",
    "name": "if",
    "return_type": "",
    "signature": "if(ret == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2307",
    "name": "insertHandler",
    "return_type": "void",
    "signature": "insertHandler(ExceptionRange fresh, List<ExceptionRange> l)",
    "file_id": "F36",
    "start_line": 669,
    "text_preview": "{\\n\t\t\t\t\t\t// assert isRangeHandle(h);\\n\t\t\t\t\t\tExceptionRange r = (ExceptionRange) t;\\n\t\t\t\t\t\tif (r.getStart() == ih) {\\n\t\t\t\t\t\t\tinsertHandler(r, exnTable);\\n\t\t\t\t\t\t}\\n\t\t\t\t\t} else if (t instanceof InstructionBranch) {\\n\t\t\t\t\t\tif (pendingLabel == null) {\\n\t\t\t\t\t\t\tpendingLabel = \"L\" + lcounter++;\\n\t\t\t\t\t\t}\\n\t\t\t\t\t} else {\\n\t\t\t\t\t\t// assert is"
  },
  {
    "method_id": "M2308",
    "name": "isPrivate",
    "return_type": "boolean",
    "signature": "isPrivate()",
    "file_id": "F36",
    "start_line": 1565,
    "text_preview": "previous();\\n\t\t\t\titer.add(fresh);\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t}\\n\\n\t\t// we have reached the end\\n\t\tl.add(fresh);\\n\t}\\n\\n\tpublic boolean isPrivate() {\\n\t\treturn Modifier.isPrivate(getAccessFlags());\\n\t}\\n\\n\tpublic boolean isProtected() {\\n\t\treturn Modifier.isProtected(getAccessFlags());\\n\t}\\n\\n\tpublic boolean isDefault() {\\n\t\treturn !(isProtect"
  },
  {
    "method_id": "M2309",
    "name": "isProtected",
    "return_type": "boolean",
    "signature": "isProtected()",
    "file_id": "F36",
    "start_line": 1569,
    "text_preview": "nd\\n\t\tl.add(fresh);\\n\t}\\n\\n\tpublic boolean isPrivate() {\\n\t\treturn Modifier.isPrivate(getAccessFlags());\\n\t}\\n\\n\tpublic boolean isProtected() {\\n\t\treturn Modifier.isProtected(getAccessFlags());\\n\t}\\n\\n\tpublic boolean isDefault() {\\n\t\treturn !(isProtected() || isPrivate() || isPublic());\\n\t}\\n\\n\tpublic boolean isPublic() {\\n\t\treturn Mod"
  },
  {
    "method_id": "M2310",
    "name": "isDefault",
    "return_type": "boolean",
    "signature": "isDefault()",
    "file_id": "F36",
    "start_line": 1573,
    "text_preview": "ccessFlags());\\n\t}\\n\\n\tpublic boolean isProtected() {\\n\t\treturn Modifier.isProtected(getAccessFlags());\\n\t}\\n\\n\tpublic boolean isDefault() {\\n\t\treturn !(isProtected() || isPrivate() || isPublic());\\n\t}\\n\\n\tpublic boolean isPublic() {\\n\t\treturn Modifier.isPublic(getAccessFlags());\\n\t}\\n\\n\t// ----\\n\\n\t/**\\n\t * A good body is a body with t"
  },
  {
    "method_id": "M2311",
    "name": "isPublic",
    "return_type": "boolean",
    "signature": "isPublic()",
    "file_id": "F36",
    "start_line": 1574,
    "text_preview": "rn Modifier.isProtected(getAccessFlags());\\n\t}\\n\\n\tpublic boolean isDefault() {\\n\t\treturn !(isProtected() || isPrivate() || isPublic());\\n\t}\\n\\n\tpublic boolean isPublic() {\\n\t\treturn Modifier.isPublic(getAccessFlags());\\n\t}\\n\\n\t// ----\\n\\n\t/**\\n\t * A good body is a body with the following properties:\\n\t *\\n\t * <ul>\\n\t * <li>For each br"
  },
  {
    "method_id": "M2312",
    "name": "assertGoodBody",
    "return_type": "void",
    "signature": "assertGoodBody()",
    "file_id": "F36",
    "start_line": 158,
    "text_preview": "als());\\n\t\t} else {\\n\t\t\tbody = null;\\n\t\t}\\n\t\tthis.attributes = new ArrayList<>();\\n\t\tthis.enclosingClass = enclosingClass;\\n\t\tassertGoodBody();\\n\t\tthis.originalMethodHasLocalVariableTable = true; // it is a new method, we want an lvar table\\n\\n\t\t// @AJ advice are not inlined by default since requires further analysis and weavin"
  },
  {
    "method_id": "M2313",
    "name": "if",
    "return_type": "",
    "signature": "if(true)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2314",
    "name": "assertGoodBody",
    "return_type": "void",
    "signature": "assertGoodBody(InstructionList il, String from)",
    "file_id": "F36",
    "start_line": 158,
    "text_preview": "als());\\n\t\t} else {\\n\t\t\tbody = null;\\n\t\t}\\n\t\tthis.attributes = new ArrayList<>();\\n\t\tthis.enclosingClass = enclosingClass;\\n\t\tassertGoodBody();\\n\t\tthis.originalMethodHasLocalVariableTable = true; // it is a new method, we want an lvar table\\n\\n\t\t// @AJ advice are not inlined by default since requires further analysis and weavin"
  },
  {
    "method_id": "M2315",
    "name": "if",
    "return_type": "",
    "signature": "if(true)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2316",
    "name": "if",
    "return_type": "",
    "signature": "if(il == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2317",
    "name": "assertGoodHandle",
    "return_type": "void",
    "signature": "assertGoodHandle(InstructionHandle ih, Set body, Stack<Range> ranges, String from)",
    "file_id": "F36",
    "start_line": 1627,
    "text_preview": "getInstruction());\\n//\t\t\t}\\n//\t\t}\\n//\\n//\t\tfor (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {\\n//\t\t\tassertGoodHandle(ih, body, ranges, from);\\n//\t\t\tIterator<InstructionTargeter> tIter = ih.getTargeters().iterator();\\n//\t\t\twhile (tIter.hasNext()) {\\n//\t\t\t\tassertGoodTargeter(tIter.next(), ih, body, from)"
  },
  {
    "method_id": "M2318",
    "name": "if",
    "return_type": "else",
    "signature": "if(inst instanceof InstructionBranch)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2319",
    "name": "assertGoodBranchInstruction",
    "return_type": "void",
    "signature": "assertGoodBranchInstruction(BranchHandle ih, InstructionBranch inst, Set body, Stack<Range> ranges,\n//\t\t\tString from)",
    "file_id": "F36",
    "start_line": 1643,
    "text_preview": "dle(ih)) {\\n//\t\t\tassertGoodRangeHandle(ih, body, ranges, from);\\n//\t\t} else if (inst instanceof InstructionBranch) {\\n//\t\t\tassertGoodBranchInstruction((BranchHandle) ih, (InstructionBranch) inst, body, ranges, from);\\n//\t\t}\\n//\t}\\n\\n//\tprivate static void assertGoodBranchInstruction(BranchHandle ih, InstructionBranch inst, Se"
  },
  {
    "method_id": "M2320",
    "name": "if",
    "return_type": "",
    "signature": "if(inst instanceof InstructionSelect)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2321",
    "name": "for",
    "return_type": "",
    "signature": "for(int k = itargets.length - 1; k >= 0; k--)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2322",
    "name": "assertInBody",
    "return_type": "void",
    "signature": "assertInBody(Object ih, Set body, String from)",
    "file_id": "F36",
    "start_line": 1653,
    "text_preview": " BCException(\"bad branch instruction/handle pair in \" + from);\\n//\t\t}\\n//\t\tInstructionHandle target = ih.getTarget();\\n//\t\tassertInBody(target, body, from);\\n//\t\tassertTargetedBy(target, inst, from);\\n//\t\tif (inst instanceof InstructionSelect) {\\n//\t\t\tInstructionSelect sel = (InstructionSelect) inst;\\n//\t\t\tInstructionHandle[]"
  },
  {
    "method_id": "M2323",
    "name": "assertGoodRangeHandle",
    "return_type": "void",
    "signature": "assertGoodRangeHandle(InstructionHandle ih, Set body, Stack ranges, String from)",
    "file_id": "F36",
    "start_line": 1641,
    "text_preview": ") {\\n//\t\t\tthrow new BCException(\"bad instruction/handle pair in \" + from);\\n//\t\t}\\n//\t\tif (Range.isRangeHandle(ih)) {\\n//\t\t\tassertGoodRangeHandle(ih, body, ranges, from);\\n//\t\t} else if (inst instanceof InstructionBranch) {\\n//\t\t\tassertGoodBranchInstruction((BranchHandle) ih, (InstructionBranch) inst, body, ranges, from);\\n//"
  },
  {
    "method_id": "M2324",
    "name": "assertGoodRange",
    "return_type": "void",
    "signature": "assertGoodRange(Range r, Set body, String from)",
    "file_id": "F36",
    "start_line": 1674,
    "text_preview": "e(InstructionHandle ih, Set body, Stack ranges, String from) {\\n//\t\tRange r = getRangeAndAssertExactlyOne(ih, from);\\n//\t\tassertGoodRange(r, body, from);\\n//\t\tif (r.getStart() == ih) {\\n//\t\t\tranges.push(r);\\n//\t\t} else if (r.getEnd() == ih) {\\n//\t\t\tif (ranges.peek() != r) {\\n//\t\t\t\tthrow new BCException(\"bad range inclusion in"
  },
  {
    "method_id": "M2325",
    "name": "if",
    "return_type": "",
    "signature": "if(r instanceof ExceptionRange)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2326",
    "name": "assertRangeHandle",
    "return_type": "void",
    "signature": "assertRangeHandle(InstructionHandle ih, String from)",
    "file_id": "F36",
    "start_line": 1687,
    "text_preview": "/\tprivate static void assertGoodRange(Range r, Set body, String from) {\\n//\t\tassertInBody(r.getStart(), body, from);\\n//\t\tassertRangeHandle(r.getStart(), from);\\n//\t\tassertTargetedBy(r.getStart(), r, from);\\n//\\n//\t\tassertInBody(r.getEnd(), body, from);\\n//\t\tassertRangeHandle(r.getEnd(), from);\\n//\t\tassertTargetedBy(r.getEnd("
  },
  {
    "method_id": "M2327",
    "name": "assertTargetedBy",
    "return_type": "void",
    "signature": "assertTargetedBy(InstructionHandle target, InstructionTargeter targeter, String from)",
    "file_id": "F36",
    "start_line": 1654,
    "text_preview": "andle pair in \" + from);\\n//\t\t}\\n//\t\tInstructionHandle target = ih.getTarget();\\n//\t\tassertInBody(target, body, from);\\n//\t\tassertTargetedBy(target, inst, from);\\n//\t\tif (inst instanceof InstructionSelect) {\\n//\t\t\tInstructionSelect sel = (InstructionSelect) inst;\\n//\t\t\tInstructionHandle[] itargets = sel.getTargets();\\n//\t\t\tfor"
  },
  {
    "method_id": "M2328",
    "name": "if",
    "return_type": "",
    "signature": "if(instructionTargeter == targeter)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2329",
    "name": "assertTargets",
    "return_type": "void",
    "signature": "assertTargets(InstructionTargeter targeter, InstructionHandle target, String from)",
    "file_id": "F36",
    "start_line": 1716,
    "text_preview": " {\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t}\\n\t\tthrow new RuntimeException(\"bad targeting relationship in \" + from);\\n\t}\\n\\n\tprivate static void assertTargets(InstructionTargeter targeter, InstructionHandle target, String from) {\\n\t\tif (targeter instanceof Range) {\\n\t\t\tRange r = (Range) targeter;\\n\t\t\tif (r.getStart() == target || r.getEnd() == ta"
  },
  {
    "method_id": "M2330",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof Range)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2331",
    "name": "if",
    "return_type": "",
    "signature": "if(r instanceof ExceptionRange)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2332",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof InstructionBranch)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2333",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof InstructionSelect)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2334",
    "name": "for",
    "return_type": "",
    "signature": "for(int k = itargets.length - 1; k >= 0; k--)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2335",
    "name": "if",
    "return_type": "",
    "signature": "if(itargets[k] == target)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2336",
    "name": "if",
    "return_type": "else",
    "signature": "if(targeter instanceof Tag)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2337",
    "name": "getRangeAndAssertExactlyOne",
    "return_type": "Range",
    "signature": "getRangeAndAssertExactlyOne(InstructionHandle ih, String from)",
    "file_id": "F36",
    "start_line": 1673,
    "text_preview": "//\tprivate static void assertGoodRangeHandle(InstructionHandle ih, Set body, Stack ranges, String from) {\\n//\t\tRange r = getRangeAndAssertExactlyOne(ih, from);\\n//\t\tassertGoodRange(r, body, from);\\n//\t\tif (r.getStart() == ih) {\\n//\t\t\tranges.push(r);\\n//\t\t} else if (r.getEnd() == ih) {\\n//\t\t\tif (ranges.peek() != r) {\\n//\t\t\t\tth"
  },
  {
    "method_id": "M2338",
    "name": "if",
    "return_type": "",
    "signature": "if(ts instanceof Range)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2339",
    "name": "if",
    "return_type": "",
    "signature": "if(ret != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2340",
    "name": "if",
    "return_type": "",
    "signature": "if(ret == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2341",
    "name": "assertGoodTargeter",
    "return_type": "void",
    "signature": "assertGoodTargeter(InstructionTargeter t, InstructionHandle ih, Set body, String from)",
    "file_id": "F36",
    "start_line": 1630,
    "text_preview": "s, from);\\n//\t\t\tIterator<InstructionTargeter> tIter = ih.getTargeters().iterator();\\n//\t\t\twhile (tIter.hasNext()) {\\n//\t\t\t\tassertGoodTargeter(tIter.next(), ih, body, from);\\n//\t\t\t}\\n//\t\t}\\n\t}\\n\\n//\tprivate static void assertGoodHandle(InstructionHandle ih, Set body, Stack<Range> ranges, String from) {\\n//\t\tInstruction inst = ih"
  },
  {
    "method_id": "M2342",
    "name": "if",
    "return_type": "",
    "signature": "if(t instanceof Range)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2343",
    "name": "if",
    "return_type": "else",
    "signature": "if(t instanceof InstructionBranch)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2344",
    "name": "isAdviceMethod",
    "return_type": "boolean",
    "signature": "isAdviceMethod()",
    "file_id": "F36",
    "start_line": 165,
    "text_preview": " an to be done annotation to keep\\n\t\t// inline state will be garbaged due to reweavable impl\\n\t\tif (memberView != null && isAdviceMethod()) {\\n\t\t\tif (enclosingClass.getType().isAnnotationStyleAspect()) {\\n\t\t\t\t// TODO we could check for @Around advice as well\\n\t\t\t\tthis.canInline = false;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate int calculateMa"
  },
  {
    "method_id": "M2345",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2346",
    "name": "isAjSynthetic",
    "return_type": "boolean",
    "signature": "isAjSynthetic()",
    "file_id": "F36",
    "start_line": 1786,
    "text_preview": "\\n\t\tif (memberView == null) {\\n\t\t\treturn false;\\n\t\t}\\n\t\treturn memberView.getAssociatedShadowMunger() != null;\\n\t}\\n\\n\tboolean isAjSynthetic() {\\n\t\tif (memberView == null) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn memberView.isAjSynthetic();\\n\t}\\n\\n\tboolean isSynthetic() {\\n\t\tif (memberView == null) {\\n\t\t\treturn false;\\n\t\t}\\n\t\treturn memberView"
  },
  {
    "method_id": "M2347",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2348",
    "name": "isSynthetic",
    "return_type": "boolean",
    "signature": "isSynthetic()",
    "file_id": "F36",
    "start_line": 1793,
    "text_preview": "ean isAjSynthetic() {\\n\t\tif (memberView == null) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn memberView.isAjSynthetic();\\n\t}\\n\\n\tboolean isSynthetic() {\\n\t\tif (memberView == null) {\\n\t\t\treturn false;\\n\t\t}\\n\t\treturn memberView.isSynthetic();\\n\t}\\n\\n\tpublic ISourceLocation getSourceLocation() {\\n\t\tif (memberView != null) {\\n\t\t\treturn memberView.g"
  },
  {
    "method_id": "M2349",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView == null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2350",
    "name": "getSourceLocation",
    "return_type": "ISourceLocation",
    "signature": "getSourceLocation()",
    "file_id": "F36",
    "start_line": 507,
    "text_preview": "lassName(), this.getName(),\\n\t\t\t\t\t\t\t\t\te.getMessage()),\\n\t\t\t\t\t\t\tthis.getMemberView() == null ? null : this.getMemberView().getSourceLocation(), null);\\n\t\t\t// throw e; PR 70201.... let the normal problem reporting\\n\t\t\t// infrastructure deal with this rather than crashing.\\n\t\t\tbody = null;\\n\t\t\tMethodGen gen = pack();\\n\t\t\treturn "
  },
  {
    "method_id": "M2351",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2352",
    "name": "getEffectiveSignature",
    "return_type": "EffectiveSignatureAttribute",
    "signature": "getEffectiveSignature()",
    "file_id": "F36",
    "start_line": 1807,
    "text_preview": "ull) {\\n\t\t\treturn memberView.getSourceLocation();\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tpublic AjAttribute.EffectiveSignatureAttribute getEffectiveSignature() {\\n\t\t// if (memberView == null) return null;\\n\t\tif (effectiveSignature != null) {\\n\t\t\treturn effectiveSignature;\\n\t\t}\\n\t\treturn memberView.getEffectiveSignature();\\n\t}\\n\\n\tpublic void "
  },
  {
    "method_id": "M2353",
    "name": "if",
    "return_type": "",
    "signature": "if(effectiveSignature != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2354",
    "name": "setEffectiveSignature",
    "return_type": "void",
    "signature": "setEffectiveSignature(ResolvedMember member, Shadow.Kind kind, boolean shouldWeave)",
    "file_id": "F36",
    "start_line": 1815,
    "text_preview": "iveSignature != null) {\\n\t\t\treturn effectiveSignature;\\n\t\t}\\n\t\treturn memberView.getEffectiveSignature();\\n\t}\\n\\n\tpublic void setEffectiveSignature(ResolvedMember member, Shadow.Kind kind, boolean shouldWeave) {\\n\t\tthis.effectiveSignature = new AjAttribute.EffectiveSignatureAttribute(member, kind, shouldWeave);\\n\t}\\n\\n\tpublic St"
  },
  {
    "method_id": "M2355",
    "name": "getSignature",
    "return_type": "String",
    "signature": "getSignature()",
    "file_id": "F36",
    "start_line": 355,
    "text_preview": "ll) {\\n\t\t\t\tfor (AnnotationAJ annotation : newAnnotations) {\\n\t\t\t\t\tif (annotation.getTypeSignature().equals(annotationType.getSignature())) {\\n\t\t\t\t\t\treturn true;\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tmemberView = new BcelMethod(getEnclosingClass().getBcelObjectType(), getMethod());\\n\t\t\treturn memberView.hasAnnotation(annotationType);\\n\t\t}\\n\t\t"
  },
  {
    "method_id": "M2356",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2357",
    "name": "getParameterSignature",
    "return_type": "String",
    "signature": "getParameterSignature()",
    "file_id": "F36",
    "start_line": 1826,
    "text_preview": "ypesToSignature(BcelWorld.fromBcel(getReturnType()), BcelWorld.fromBcel(getArgumentTypes()), false);\\n\t}\\n\\n\tpublic String getParameterSignature() {\\n\t\tif (memberView != null) {\\n\t\t\treturn memberView.getParameterSignature();\\n\t\t}\\n\t\treturn MemberImpl.typesToSignature(BcelWorld.fromBcel(getArgumentTypes()));\\n\t}\\n\\n\tpublic BcelMe"
  },
  {
    "method_id": "M2358",
    "name": "if",
    "return_type": "",
    "signature": "if(memberView != null)",
    "file_id": "F36",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2359",
    "name": "getMemberView",
    "return_type": "BcelMethod",
    "signature": "getMemberView()",
    "file_id": "F36",
    "start_line": 507,
    "text_preview": "at(WeaverMessages.PROBLEM_GENERATING_METHOD, this.getClassName(), this.getName(),\\n\t\t\t\t\t\t\t\t\te.getMessage()),\\n\t\t\t\t\t\t\tthis.getMemberView() == null ? null : this.getMemberView().getSourceLocation(), null);\\n\t\t\t// throw e; PR 70201.... let the normal problem reporting\\n\t\t\t// infrastructure deal with this rather than crashing."
  },
  {
    "method_id": "M2360",
    "name": "forcePublic",
    "return_type": "void",
    "signature": "forcePublic()",
    "file_id": "F36",
    "start_line": 1837,
    "text_preview": "BcelWorld.fromBcel(getArgumentTypes()));\\n\t}\\n\\n\tpublic BcelMethod getMemberView() {\\n\t\treturn memberView;\\n\t}\\n\\n\tpublic void forcePublic() {\\n\t\tmarkAsChanged();\\n\t\tmodifiers = Utility.makePublic(modifiers);\\n\t}\\n\\n\tpublic boolean getCanInline() {\\n\t\treturn canInline;\\n\t}\\n\\n\tpublic void setCanInline(boolean canInline) {\\n\t\tthis.canIn"
  },
  {
    "method_id": "M2361",
    "name": "getCanInline",
    "return_type": "boolean",
    "signature": "getCanInline()",
    "file_id": "F36",
    "start_line": 1842,
    "text_preview": "w;\\n\t}\\n\\n\tpublic void forcePublic() {\\n\t\tmarkAsChanged();\\n\t\tmodifiers = Utility.makePublic(modifiers);\\n\t}\\n\\n\tpublic boolean getCanInline() {\\n\t\treturn canInline;\\n\t}\\n\\n\tpublic void setCanInline(boolean canInline) {\\n\t\tthis.canInline = canInline;\\n\t}\\n\\n\tpublic void addAttribute(Attribute attribute) {\\n\t\tattributes.add(attribute);\\n"
  },
  {
    "method_id": "M2362",
    "name": "setCanInline",
    "return_type": "void",
    "signature": "setCanInline(boolean canInline)",
    "file_id": "F36",
    "start_line": 1846,
    "text_preview": "\\n\t\tmodifiers = Utility.makePublic(modifiers);\\n\t}\\n\\n\tpublic boolean getCanInline() {\\n\t\treturn canInline;\\n\t}\\n\\n\tpublic void setCanInline(boolean canInline) {\\n\t\tthis.canInline = canInline;\\n\t}\\n\\n\tpublic void addAttribute(Attribute attribute) {\\n\t\tattributes.add(attribute);\\n\t}\\n\\n\tpublic String toTraceString() {\\n\t\treturn toShortS"
  },
  {
    "method_id": "M2363",
    "name": "addAttribute",
    "return_type": "void",
    "signature": "addAttribute(Attribute attribute)",
    "file_id": "F36",
    "start_line": 971,
    "text_preview": "ption : declaredExceptions) {\\n\t\t\tgen.addException(declaredException);\\n\t\t}\\n\\n\t\tfor (Attribute attr : attributes) {\\n\t\t\tgen.addAttribute(attr);\\n\t\t}\\n\\n\t\tif (newAnnotations != null) {\\n\t\t\tfor (AnnotationAJ element : newAnnotations) {\\n\t\t\t\tgen.addAnnotation(new AnnotationGen(((BcelAnnotation) element).getBcelAnnotation(), gen.ge"
  },
  {
    "method_id": "M2364",
    "name": "toTraceString",
    "return_type": "String",
    "signature": "toTraceString()",
    "file_id": "F36",
    "start_line": 1854,
    "text_preview": "nline = canInline;\\n\t}\\n\\n\tpublic void addAttribute(Attribute attribute) {\\n\t\tattributes.add(attribute);\\n\t}\\n\\n\tpublic String toTraceString() {\\n\t\treturn toShortString();\\n\t}\\n\\n\tpublic ConstantPool getConstantPool() {\\n\t\treturn enclosingClass.getConstantPool();\\n\t}\\n\\n\tpublic static boolean isConstructor(LazyMethodGen aMethod) {\\n\t\t"
  },
  {
    "method_id": "M2365",
    "name": "getConstantPool",
    "return_type": "ConstantPool",
    "signature": "getConstantPool()",
    "file_id": "F36",
    "start_line": 370,
    "text_preview": "urnType != null) {\\n\t\t\treturn;\\n\t\t}\\n\t\tMethodGen gen = new MethodGen(savedMethod, enclosingClass.getName(), enclosingClass.getConstantPool(), true);\\n\\n\t\tthis.returnType = gen.getReturnType();\\n\t\tthis.argumentTypes = gen.getArgumentTypes();\\n\t\tthis.declaredExceptions = gen.getExceptions();\\n\t\tthis.attributes = gen.getAttribute"
  },
  {
    "method_id": "M2366",
    "name": "isConstructor",
    "return_type": "boolean",
    "signature": "isConstructor(LazyMethodGen aMethod)",
    "file_id": "F36",
    "start_line": 1862,
    "text_preview": "g();\\n\t}\\n\\n\tpublic ConstantPool getConstantPool() {\\n\t\treturn enclosingClass.getConstantPool();\\n\t}\\n\\n\tpublic static boolean isConstructor(LazyMethodGen aMethod) {\\n\t\treturn aMethod.getName().equals(\"<init>\");\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M2367",
    "name": "Range",
    "return_type": "",
    "signature": "Range(InstructionList il)",
    "file_id": "F37",
    "start_line": 30,
    "text_preview": "onList body;\\n\tprotected InstructionHandle start;\\n\tprotected InstructionHandle end;\\n\\n\t// ---- initialization\\n\\n\tprotected Range(InstructionList il) {\\n\t\tthis.body = il;\\n\t}\\n\\n\t// ----\\n\\n\tfinal InstructionList getBody() {\\n\t\treturn body;\\n\t}\\n\\n\tfinal InstructionHandle getStart() {\\n\t\treturn start;\\n\t}\\n\\n\tfinal InstructionHandle get"
  },
  {
    "method_id": "M2368",
    "name": "getBody",
    "return_type": "InstructionList",
    "signature": "getBody()",
    "file_id": "F37",
    "start_line": 36,
    "text_preview": "\\n\t// ---- initialization\\n\\n\tprotected Range(InstructionList il) {\\n\t\tthis.body = il;\\n\t}\\n\\n\t// ----\\n\\n\tfinal InstructionList getBody() {\\n\t\treturn body;\\n\t}\\n\\n\tfinal InstructionHandle getStart() {\\n\t\treturn start;\\n\t}\\n\\n\tfinal InstructionHandle getEnd() {\\n\t\treturn end;\\n\t}\\n\\n\t// ----\\n\\n\tboolean isEmpty() {\\n\t\tInstructionHandle ih = s"
  },
  {
    "method_id": "M2369",
    "name": "getStart",
    "return_type": "InstructionHandle",
    "signature": "getStart()",
    "file_id": "F37",
    "start_line": 40,
    "text_preview": "st il) {\\n\t\tthis.body = il;\\n\t}\\n\\n\t// ----\\n\\n\tfinal InstructionList getBody() {\\n\t\treturn body;\\n\t}\\n\\n\tfinal InstructionHandle getStart() {\\n\t\treturn start;\\n\t}\\n\\n\tfinal InstructionHandle getEnd() {\\n\t\treturn end;\\n\t}\\n\\n\t// ----\\n\\n\tboolean isEmpty() {\\n\t\tInstructionHandle ih = start;\\n\t\t// System.err.println(\"  looking for \" + end);\\n\t"
  },
  {
    "method_id": "M2370",
    "name": "getEnd",
    "return_type": "InstructionHandle",
    "signature": "getEnd()",
    "file_id": "F37",
    "start_line": 44,
    "text_preview": "nList getBody() {\\n\t\treturn body;\\n\t}\\n\\n\tfinal InstructionHandle getStart() {\\n\t\treturn start;\\n\t}\\n\\n\tfinal InstructionHandle getEnd() {\\n\t\treturn end;\\n\t}\\n\\n\t// ----\\n\\n\tboolean isEmpty() {\\n\t\tInstructionHandle ih = start;\\n\t\t// System.err.println(\"  looking for \" + end);\\n\t\twhile (ih != end) {\\n\t\t\t// System.err.println(\"    ih \" + "
  },
  {
    "method_id": "M2371",
    "name": "isEmpty",
    "return_type": "boolean",
    "signature": "isEmpty()",
    "file_id": "F37",
    "start_line": 50,
    "text_preview": "ructionHandle getStart() {\\n\t\treturn start;\\n\t}\\n\\n\tfinal InstructionHandle getEnd() {\\n\t\treturn end;\\n\t}\\n\\n\t// ----\\n\\n\tboolean isEmpty() {\\n\t\tInstructionHandle ih = start;\\n\t\t// System.err.println(\"  looking for \" + end);\\n\t\twhile (ih != end) {\\n\t\t\t// System.err.println(\"    ih \" + ih);\\n\t\t\tif (!Range.isRangeHandle(ih)) {\\n\t\t\t\tretu"
  },
  {
    "method_id": "M2372",
    "name": "while",
    "return_type": "",
    "signature": "while(ih != end)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2373",
    "name": "getRealStart",
    "return_type": "InstructionHandle",
    "signature": "getRealStart(InstructionHandle ih)",
    "file_id": "F37",
    "start_line": 63,
    "text_preview": "ange.isRangeHandle(ih)) {\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t\tih = ih.getNext();\\n\t\t}\\n\t\treturn true;\\n\t}\\n\\n\tstatic InstructionHandle getRealStart(InstructionHandle ih) {\\n\t\twhile (Range.isRangeHandle(ih)) {\\n\t\t\tih = ih.getNext();\\n\t\t}\\n\t\treturn ih;\\n\t}\\n\\n\tInstructionHandle getRealStart() {\\n\t\treturn getRealStart(start);\\n\t}\\n\\n\tstatic Instru"
  },
  {
    "method_id": "M2374",
    "name": "getRealStart",
    "return_type": "InstructionHandle",
    "signature": "getRealStart()",
    "file_id": "F37",
    "start_line": 63,
    "text_preview": "ange.isRangeHandle(ih)) {\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t\tih = ih.getNext();\\n\t\t}\\n\t\treturn true;\\n\t}\\n\\n\tstatic InstructionHandle getRealStart(InstructionHandle ih) {\\n\t\twhile (Range.isRangeHandle(ih)) {\\n\t\t\tih = ih.getNext();\\n\t\t}\\n\t\treturn ih;\\n\t}\\n\\n\tInstructionHandle getRealStart() {\\n\t\treturn getRealStart(start);\\n\t}\\n\\n\tstatic Instru"
  },
  {
    "method_id": "M2375",
    "name": "getRealEnd",
    "return_type": "InstructionHandle",
    "signature": "getRealEnd(InstructionHandle ih)",
    "file_id": "F37",
    "start_line": 74,
    "text_preview": ");\\n\t\t}\\n\t\treturn ih;\\n\t}\\n\\n\tInstructionHandle getRealStart() {\\n\t\treturn getRealStart(start);\\n\t}\\n\\n\tstatic InstructionHandle getRealEnd(InstructionHandle ih) {\\n\t\twhile (Range.isRangeHandle(ih)) {\\n\t\t\tih = ih.getPrev();\\n\t\t}\\n\t\treturn ih;\\n\t}\\n\\n\tInstructionHandle getRealEnd() {\\n\t\treturn getRealEnd(end);\\n\t}\\n\\n\tInstructionHandle get"
  },
  {
    "method_id": "M2376",
    "name": "getRealEnd",
    "return_type": "InstructionHandle",
    "signature": "getRealEnd()",
    "file_id": "F37",
    "start_line": 74,
    "text_preview": ");\\n\t\t}\\n\t\treturn ih;\\n\t}\\n\\n\tInstructionHandle getRealStart() {\\n\t\treturn getRealStart(start);\\n\t}\\n\\n\tstatic InstructionHandle getRealEnd(InstructionHandle ih) {\\n\t\twhile (Range.isRangeHandle(ih)) {\\n\t\t\tih = ih.getPrev();\\n\t\t}\\n\t\treturn ih;\\n\t}\\n\\n\tInstructionHandle getRealEnd() {\\n\t\treturn getRealEnd(end);\\n\t}\\n\\n\tInstructionHandle get"
  },
  {
    "method_id": "M2377",
    "name": "getRealNext",
    "return_type": "InstructionHandle",
    "signature": "getRealNext()",
    "file_id": "F37",
    "start_line": 85,
    "text_preview": "= ih.getPrev();\\n\t\t}\\n\t\treturn ih;\\n\t}\\n\\n\tInstructionHandle getRealEnd() {\\n\t\treturn getRealEnd(end);\\n\t}\\n\\n\tInstructionHandle getRealNext() {\\n\t\treturn getRealStart(end);\\n\t}\\n\\n\t// ----\\n\\n\tInstructionHandle insert(Instruction i, Where where) {\\n\t\tInstructionList il = new InstructionList();\\n\t\tInstructionHandle ret = il.insert(i);\\n"
  },
  {
    "method_id": "M2378",
    "name": "insert",
    "return_type": "InstructionHandle",
    "signature": "insert(Instruction i, Where where)",
    "file_id": "F37",
    "start_line": 91,
    "text_preview": "rn getRealEnd(end);\\n\t}\\n\\n\tInstructionHandle getRealNext() {\\n\t\treturn getRealStart(end);\\n\t}\\n\\n\t// ----\\n\\n\tInstructionHandle insert(Instruction i, Where where) {\\n\t\tInstructionList il = new InstructionList();\\n\t\tInstructionHandle ret = il.insert(i);\\n\t\tinsert(il, where);\\n\t\treturn ret;\\n\t}\\n\\n\tvoid insert(InstructionList freshIl, "
  },
  {
    "method_id": "M2379",
    "name": "insert",
    "return_type": "void",
    "signature": "insert(InstructionList freshIl, Where where)",
    "file_id": "F37",
    "start_line": 91,
    "text_preview": "rn getRealEnd(end);\\n\t}\\n\\n\tInstructionHandle getRealNext() {\\n\t\treturn getRealStart(end);\\n\t}\\n\\n\t// ----\\n\\n\tInstructionHandle insert(Instruction i, Where where) {\\n\t\tInstructionList il = new InstructionList();\\n\t\tInstructionHandle ret = il.insert(i);\\n\t\tinsert(il, where);\\n\t\treturn ret;\\n\t}\\n\\n\tvoid insert(InstructionList freshIl, "
  },
  {
    "method_id": "M2380",
    "name": "if",
    "return_type": "",
    "signature": "if(where == InsideBefore || where == OutsideBefore)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2381",
    "name": "if",
    "return_type": "",
    "signature": "if(where == InsideBefore || where == OutsideAfter)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2382",
    "name": "if",
    "return_type": "",
    "signature": "if(where == OutsideBefore)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2383",
    "name": "append",
    "return_type": "InstructionHandle",
    "signature": "append(Instruction i)",
    "file_id": "F37",
    "start_line": 106,
    "text_preview": "e) {\\n\t\t\th = getStart();\\n\t\t} else {\\n\t\t\th = getEnd();\\n\t\t}\\n\t\tif (where == InsideBefore || where == OutsideAfter) {\\n\t\t\tbody.append(h, freshIl);\\n\t\t} else {\\n\t\t\tInstructionHandle newStart = body.insert(h, freshIl);\\n\t\t\tif (where == OutsideBefore) {\\n\t\t\t\t// XXX this is slow. There's a better design than this. We should\\n\t\t\t\t// ne"
  },
  {
    "method_id": "M2384",
    "name": "append",
    "return_type": "void",
    "signature": "append(InstructionList i)",
    "file_id": "F37",
    "start_line": 106,
    "text_preview": "e) {\\n\t\t\th = getStart();\\n\t\t} else {\\n\t\t\th = getEnd();\\n\t\t}\\n\t\tif (where == InsideBefore || where == OutsideAfter) {\\n\t\t\tbody.append(h, freshIl);\\n\t\t} else {\\n\t\t\tInstructionHandle newStart = body.insert(h, freshIl);\\n\t\t\tif (where == OutsideBefore) {\\n\t\t\t\t// XXX this is slow. There's a better design than this. We should\\n\t\t\t\t// ne"
  },
  {
    "method_id": "M2385",
    "name": "setLineNumberFromNext",
    "return_type": "void",
    "signature": "setLineNumberFromNext(InstructionHandle ih)",
    "file_id": "F37",
    "start_line": 127,
    "text_preview": "return insert(i, InsideAfter);\\n\t}\\n\\n\tvoid append(InstructionList i) {\\n\t\tinsert(i, InsideAfter);\\n\t}\\n\\n\tprivate static void setLineNumberFromNext(InstructionHandle ih) {\\n\t\tint lineNumber = Utility.getSourceLine(ih.getNext());\\n\t\tif (lineNumber != -1) {\\n\t\t\tUtility.setSourceLine(ih, lineNumber);\\n\t\t}\\n\t}\\n\\n\tstatic InstructionHan"
  },
  {
    "method_id": "M2386",
    "name": "if",
    "return_type": "",
    "signature": "if(lineNumber != -1)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2387",
    "name": "genStart",
    "return_type": "InstructionHandle",
    "signature": "genStart(InstructionList body)",
    "file_id": "F37",
    "start_line": 134,
    "text_preview": "ne(ih.getNext());\\n\t\tif (lineNumber != -1) {\\n\t\t\tUtility.setSourceLine(ih, lineNumber);\\n\t\t}\\n\t}\\n\\n\tstatic InstructionHandle genStart(InstructionList body) {\\n\t\tInstructionHandle ih = body.insert(Range.RANGEINSTRUCTION);\\n\t\tsetLineNumberFromNext(ih);\\n\t\treturn ih;\\n\t}\\n\\n\tstatic InstructionHandle genEnd(InstructionList body) {\\n\t\t"
  },
  {
    "method_id": "M2388",
    "name": "genEnd",
    "return_type": "InstructionHandle",
    "signature": "genEnd(InstructionList body)",
    "file_id": "F37",
    "start_line": 140,
    "text_preview": "andle ih = body.insert(Range.RANGEINSTRUCTION);\\n\t\tsetLineNumberFromNext(ih);\\n\t\treturn ih;\\n\t}\\n\\n\tstatic InstructionHandle genEnd(InstructionList body) {\\n\t\treturn body.append(Range.RANGEINSTRUCTION);\\n\t}\\n\\n\tstatic InstructionHandle genStart(InstructionList body, InstructionHandle ih) {\\n\t\tif (ih == null) {\\n\t\t\treturn genStart"
  },
  {
    "method_id": "M2389",
    "name": "genStart",
    "return_type": "InstructionHandle",
    "signature": "genStart(InstructionList body, InstructionHandle ih)",
    "file_id": "F37",
    "start_line": 134,
    "text_preview": "ne(ih.getNext());\\n\t\tif (lineNumber != -1) {\\n\t\t\tUtility.setSourceLine(ih, lineNumber);\\n\t\t}\\n\t}\\n\\n\tstatic InstructionHandle genStart(InstructionList body) {\\n\t\tInstructionHandle ih = body.insert(Range.RANGEINSTRUCTION);\\n\t\tsetLineNumberFromNext(ih);\\n\t\treturn ih;\\n\t}\\n\\n\tstatic InstructionHandle genEnd(InstructionList body) {\\n\t\t"
  },
  {
    "method_id": "M2390",
    "name": "if",
    "return_type": "",
    "signature": "if(ih == null)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2391",
    "name": "genEnd",
    "return_type": "InstructionHandle",
    "signature": "genEnd(InstructionList body, InstructionHandle ih)",
    "file_id": "F37",
    "start_line": 140,
    "text_preview": "andle ih = body.insert(Range.RANGEINSTRUCTION);\\n\t\tsetLineNumberFromNext(ih);\\n\t\treturn ih;\\n\t}\\n\\n\tstatic InstructionHandle genEnd(InstructionList body) {\\n\t\treturn body.append(Range.RANGEINSTRUCTION);\\n\t}\\n\\n\tstatic InstructionHandle genStart(InstructionList body, InstructionHandle ih) {\\n\t\tif (ih == null) {\\n\t\t\treturn genStart"
  },
  {
    "method_id": "M2392",
    "name": "if",
    "return_type": "",
    "signature": "if(ih == null)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2393",
    "name": "containsTarget",
    "return_type": "boolean",
    "signature": "containsTarget(InstructionHandle ih)",
    "file_id": "F37",
    "start_line": 162,
    "text_preview": "== null) {\\n\t\t\treturn genEnd(body);\\n\t\t}\\n\t\treturn body.append(ih, Range.RANGEINSTRUCTION);\\n\t}\\n\\n\t// -----\\n\\n\tpublic boolean containsTarget(InstructionHandle ih) {\\n\t\treturn false;\\n\t}\\n\\n\tpublic final void updateTarget(InstructionHandle old_ih, InstructionHandle new_ih) {\\n\t\tthrow new RuntimeException(\"Ranges must be updated wi"
  },
  {
    "method_id": "M2394",
    "name": "updateTarget",
    "return_type": "void",
    "signature": "updateTarget(InstructionHandle old_ih, InstructionHandle new_ih)",
    "file_id": "F37",
    "start_line": 166,
    "text_preview": "TRUCTION);\\n\t}\\n\\n\t// -----\\n\\n\tpublic boolean containsTarget(InstructionHandle ih) {\\n\t\treturn false;\\n\t}\\n\\n\tpublic final void updateTarget(InstructionHandle old_ih, InstructionHandle new_ih) {\\n\t\tthrow new RuntimeException(\"Ranges must be updated with an enclosing instructionList\");\\n\t}\\n\\n\tprotected void updateTarget(Instructio"
  },
  {
    "method_id": "M2395",
    "name": "updateTarget",
    "return_type": "void",
    "signature": "updateTarget(InstructionHandle old_ih, InstructionHandle new_ih, InstructionList new_il)",
    "file_id": "F37",
    "start_line": 166,
    "text_preview": "TRUCTION);\\n\t}\\n\\n\t// -----\\n\\n\tpublic boolean containsTarget(InstructionHandle ih) {\\n\t\treturn false;\\n\t}\\n\\n\tpublic final void updateTarget(InstructionHandle old_ih, InstructionHandle new_ih) {\\n\t\tthrow new RuntimeException(\"Ranges must be updated with an enclosing instructionList\");\\n\t}\\n\\n\tprotected void updateTarget(Instructio"
  },
  {
    "method_id": "M2396",
    "name": "if",
    "return_type": "",
    "signature": "if(new_ih != null)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2397",
    "name": "if",
    "return_type": "",
    "signature": "if(old_ih == start)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2398",
    "name": "if",
    "return_type": "",
    "signature": "if(old_ih == end)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2399",
    "name": "isRangeHandle",
    "return_type": "boolean",
    "signature": "isRangeHandle(InstructionHandle ih)",
    "file_id": "F37",
    "start_line": 55,
    "text_preview": "stem.err.println(\"  looking for \" + end);\\n\t\twhile (ih != end) {\\n\t\t\t// System.err.println(\"    ih \" + ih);\\n\t\t\tif (!Range.isRangeHandle(ih)) {\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t\tih = ih.getNext();\\n\t\t}\\n\t\treturn true;\\n\t}\\n\\n\tstatic InstructionHandle getRealStart(InstructionHandle ih) {\\n\t\twhile (Range.isRangeHandle(ih)) {\\n\t\t\tih = ih.g"
  },
  {
    "method_id": "M2400",
    "name": "if",
    "return_type": "",
    "signature": "if(ih == null)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2401",
    "name": "getRange",
    "return_type": "Range",
    "signature": "getRange(InstructionHandle ih)",
    "file_id": "F37",
    "start_line": 192,
    "text_preview": " null) {\\n\t\t\treturn false;\\n\t\t}\\n\t\treturn ih.getInstruction() == Range.RANGEINSTRUCTION;\\n\t}\\n\\n\tprotected static final Range getRange(InstructionHandle ih) {\\n\t\t// assert isRangeHandle(ih)\\n\t\tRange ret = null;\\n\t\tfor (InstructionTargeter targeter : ih.getTargeters()) {\\n\t\t\tif (targeter instanceof Range) {\\n\t\t\t\tRange r = (Range) "
  },
  {
    "method_id": "M2402",
    "name": "if",
    "return_type": "",
    "signature": "if(targeter instanceof Range)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2403",
    "name": "if",
    "return_type": "",
    "signature": "if(ret != null)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2404",
    "name": "if",
    "return_type": "",
    "signature": "if(ret == null)",
    "file_id": "F37",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2405",
    "name": "Where",
    "return_type": "",
    "signature": "Where(String name)",
    "file_id": "F37",
    "start_line": 215,
    "text_preview": " {\\n\t\t\tthrow new BCException(\"shouldn't happen\");\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\t// ----\\n\\n\tstatic final Where InsideBefore = new Where(\"insideBefore\");\\n\tstatic final Where InsideAfter = new Where(\"insideAfter\");\\n\tstatic final Where OutsideBefore = new Where(\"outsideBefore\");\\n\tstatic final Where OutsideAfter = new Where(\"outside"
  },
  {
    "method_id": "M2406",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F37",
    "start_line": 235,
    "text_preview": "\\n\\n\tstatic class Where {\\n\t\tprivate String name;\\n\\n\t\tpublic Where(String name) {\\n\t\t\tthis.name = name;\\n\t\t}\\n\\n\t\tpublic String toString() {\\n\t\t\treturn name;\\n\t\t}\\n\t}\\n}\\n"
  },
  {
    "method_id": "M2407",
    "name": "ShadowRange",
    "return_type": "",
    "signature": "ShadowRange(InstructionList body)",
    "file_id": "F38",
    "start_line": 40,
    "text_preview": "t well situated unless both {@link #associateWithTargets} and\\n\t * {@link #associateWithShadow} are called.\\n\t */\\n\tpublic ShadowRange(InstructionList body) {\\n\t\tsuper(body);\\n\t}\\n\\n\tprotected void associateWithTargets(InstructionHandle start, InstructionHandle end) {\\n\t\t// assert body.contains(start) && body.contains(end);\\n\t\t"
  },
  {
    "method_id": "M2408",
    "name": "associateWithTargets",
    "return_type": "void",
    "signature": "associateWithTargets(InstructionHandle start, InstructionHandle end)",
    "file_id": "F38",
    "start_line": 44,
    "text_preview": "k #associateWithShadow} are called.\\n\t */\\n\tpublic ShadowRange(InstructionList body) {\\n\t\tsuper(body);\\n\t}\\n\\n\tprotected void associateWithTargets(InstructionHandle start, InstructionHandle end) {\\n\t\t// assert body.contains(start) && body.contains(end);\\n\t\tthis.start = start;\\n\t\tthis.end = end;\\n\t\tstart.addTargeter(this);\\n\t\tend."
  },
  {
    "method_id": "M2409",
    "name": "associateWithShadow",
    "return_type": "void",
    "signature": "associateWithShadow(BcelShadow shadow)",
    "file_id": "F38",
    "start_line": 52,
    "text_preview": "ains(end);\\n\t\tthis.start = start;\\n\t\tthis.end = end;\\n\t\tstart.addTargeter(this);\\n\t\tend.addTargeter(this);\\n\t}\\n\\n\tpublic void associateWithShadow(BcelShadow shadow) {\\n\t\tthis.shadow = shadow;\\n\t\tshadow.setRange(this);\\n\t}\\n\\n\t// ----\\n\\n\tpublic Shadow.Kind getKind() {\\n\t\treturn shadow.getKind();\\n\t}\\n\\n\t@Override\\n\tpublic String toStrin"
  },
  {
    "method_id": "M2410",
    "name": "getKind",
    "return_type": "Kind",
    "signature": "getKind()",
    "file_id": "F38",
    "start_line": 59,
    "text_preview": "ciateWithShadow(BcelShadow shadow) {\\n\t\tthis.shadow = shadow;\\n\t\tshadow.setRange(this);\\n\t}\\n\\n\t// ----\\n\\n\tpublic Shadow.Kind getKind() {\\n\t\treturn shadow.getKind();\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn shadow.toString();\\n\t}\\n\\n\tvoid extractInstructionsInto(LazyMethodGen freshMethod, IntMap remap, boolean addRetu"
  },
  {
    "method_id": "M2411",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F38",
    "start_line": 64,
    "text_preview": ".setRange(this);\\n\t}\\n\\n\t// ----\\n\\n\tpublic Shadow.Kind getKind() {\\n\t\treturn shadow.getKind();\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn shadow.toString();\\n\t}\\n\\n\tvoid extractInstructionsInto(LazyMethodGen freshMethod, IntMap remap, boolean addReturn) {\\n\t\tLazyMethodGen.assertGoodBody(getBody(), toString());\\n\t\tfreshM"
  },
  {
    "method_id": "M2412",
    "name": "extractInstructionsInto",
    "return_type": "void",
    "signature": "extractInstructionsInto(LazyMethodGen freshMethod, IntMap remap, boolean addReturn)",
    "file_id": "F38",
    "start_line": 68,
    "text_preview": "getKind() {\\n\t\treturn shadow.getKind();\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn shadow.toString();\\n\t}\\n\\n\tvoid extractInstructionsInto(LazyMethodGen freshMethod, IntMap remap, boolean addReturn) {\\n\t\tLazyMethodGen.assertGoodBody(getBody(), toString());\\n\t\tfreshMethod.assertGoodBody();\\n\t\tInstructionList freshBody"
  },
  {
    "method_id": "M2413",
    "name": "if",
    "return_type": "",
    "signature": "if(freshI instanceof InstructionBranch)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2414",
    "name": "if",
    "return_type": "",
    "signature": "if(freshBranch instanceof InstructionSelect)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2415",
    "name": "for",
    "return_type": "",
    "signature": "for(int k = oldTargets.length - 1; k >= 0; k--)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2416",
    "name": "if",
    "return_type": "",
    "signature": "if(source instanceof LocalVariableTag)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2417",
    "name": "if",
    "return_type": "",
    "signature": "if(kind == Shadow.AdviceExecution || kind == Shadow.ConstructorExecution || kind == Shadow.MethodExecution\n\t\t\t\t\t\t\t|| kind == Shadow.PreInitialization || kind == Shadow.Initialization\n\t\t\t\t\t\t\t|| kind == Shadow.StaticInitialization)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2418",
    "name": "if",
    "return_type": "else",
    "signature": "if(source instanceof Range)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2419",
    "name": "if",
    "return_type": "",
    "signature": "if(freshI instanceof RET)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2420",
    "name": "if",
    "return_type": "",
    "signature": "if(source instanceof LocalVariableTag)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2421",
    "name": "catch",
    "return_type": "",
    "signature": "catch(TargetLostException e)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2422",
    "name": "if",
    "return_type": "",
    "signature": "if(addReturn)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2423",
    "name": "if",
    "return_type": "",
    "signature": "if(t == this)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2424",
    "name": "if",
    "return_type": "",
    "signature": "if(!addReturn)",
    "file_id": "F38",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2425",
    "name": "getShadow",
    "return_type": "BcelShadow",
    "signature": "getShadow()",
    "file_id": "F38",
    "start_line": 236,
    "text_preview": "\t\t\t}\\n\t\t}\\n\\n\t\tLazyMethodGen.assertGoodBody(getBody(), toString());\\n\t\tfreshMethod.assertGoodBody();\\n\t}\\n\\n\tpublic BcelShadow getShadow() {\\n\t\treturn shadow;\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M2426",
    "name": "TypeAnnotationAccessVar",
    "return_type": "",
    "signature": "TypeAnnotationAccessVar(ResolvedType type, BcelVar theAnnotatedTargetIsStoredHere)",
    "file_id": "F39",
    "start_line": 32,
    "text_preview": " createLoadInstructions()\\n */\\npublic class TypeAnnotationAccessVar extends BcelVar {\\n\\n\tprivate BcelVar target;\\n\\n\tpublic TypeAnnotationAccessVar(ResolvedType type, BcelVar theAnnotatedTargetIsStoredHere) {\\n\t\tsuper(type, 0);\\n\t\ttarget = theAnnotatedTargetIsStoredHere;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"TypeAnnotati"
  },
  {
    "method_id": "M2427",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F39",
    "start_line": 37,
    "text_preview": "elVar theAnnotatedTargetIsStoredHere) {\\n\t\tsuper(type, 0);\\n\t\ttarget = theAnnotatedTargetIsStoredHere;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"TypeAnnotationAccessVar(\" + getType() + \")\";\\n\t}\\n\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Instruction"
  },
  {
    "method_id": "M2428",
    "name": "createLoad",
    "return_type": "Instruction",
    "signature": "createLoad(InstructionFactory fact)",
    "file_id": "F39",
    "start_line": 41,
    "text_preview": "redHere;\\n\t}\\n\\n\tpublic String toString() {\\n\t\treturn \"TypeAnnotationAccessVar(\" + getType() + \")\";\\n\t}\\n\\n\tpublic Instruction createLoad(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Instruction createStore(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t"
  },
  {
    "method_id": "M2429",
    "name": "createStore",
    "return_type": "Instruction",
    "signature": "createStore(InstructionFactory fact)",
    "file_id": "F39",
    "start_line": 45,
    "text_preview": "nstruction createLoad(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Instruction createStore(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tthrow new RuntimeException(\"u"
  },
  {
    "method_id": "M2430",
    "name": "createCopyFrom",
    "return_type": "InstructionList",
    "signature": "createCopyFrom(InstructionFactory fact, int oldSlot)",
    "file_id": "F39",
    "start_line": 49,
    "text_preview": "ction createStore(InstructionFactory fact) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic InstructionList createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createLoadI"
  },
  {
    "method_id": "M2431",
    "name": "appendLoad",
    "return_type": "void",
    "signature": "appendLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F39",
    "start_line": 53,
    "text_preview": " createCopyFrom(InstructionFactory fact, int oldSlot) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic void appendLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.append(createLoadInstructions(getType(), fact));\\n\t}\\n\\n\tpublic InstructionList createLoadInstructions(ResolvedType toType, InstructionFacto"
  },
  {
    "method_id": "M2432",
    "name": "createLoadInstructions",
    "return_type": "InstructionList",
    "signature": "createLoadInstructions(ResolvedType toType, InstructionFactory fact)",
    "file_id": "F39",
    "start_line": 26,
    "text_preview": "ing an annotated 'thing'. Main use is to create the instructions that\\n * retrieve the annotation from the 'thing' - see createLoadInstructions()\\n */\\npublic class TypeAnnotationAccessVar extends BcelVar {\\n\\n\tprivate BcelVar target;\\n\\n\tpublic TypeAnnotationAccessVar(ResolvedType type, BcelVar theAnnotatedTargetIsStoredHere"
  },
  {
    "method_id": "M2433",
    "name": "appendLoadAndConvert",
    "return_type": "void",
    "signature": "appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType)",
    "file_id": "F39",
    "start_line": 71,
    "text_preview": "l.append(Utility.createConversion(fact, jlaAnnotation, BcelWorld.makeBcelType(toType)));\\n\t\treturn il;\\n\\n\t}\\n\\n\tpublic void appendLoadAndConvert(InstructionList il, InstructionFactory fact, ResolvedType toType) {\\n\t\til.append(createLoadInstructions(toType, fact));\\n\\n\t}\\n\\n\tpublic void insertLoad(InstructionList il, Instruction"
  },
  {
    "method_id": "M2434",
    "name": "insertLoad",
    "return_type": "void",
    "signature": "insertLoad(InstructionList il, InstructionFactory fact)",
    "file_id": "F39",
    "start_line": 76,
    "text_preview": "l, InstructionFactory fact, ResolvedType toType) {\\n\t\til.append(createLoadInstructions(toType, fact));\\n\\n\t}\\n\\n\tpublic void insertLoad(InstructionList il, InstructionFactory fact) {\\n\t\til.insert(createLoadInstructions(getType(), fact));\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M2435",
    "name": "UnwovenClassFile",
    "return_type": "",
    "signature": "UnwovenClassFile(String filename, byte[] bytes)",
    "file_id": "F41",
    "start_line": 35,
    "text_preview": "ildClasses = Collections.emptyList();\\n\tprotected String className = null;\\n\tprotected boolean isModule = false;\\n\\n\tpublic UnwovenClassFile(String filename, byte[] bytes) {\\n\t\tthis.filename = filename;\\n\t\tthis.isModule = filename.toLowerCase().endsWith(\"module-info.java\");\\n\t\tthis.bytes = bytes;\\n\t}\\n\\n\t/** Use if the classname"
  },
  {
    "method_id": "M2436",
    "name": "UnwovenClassFile",
    "return_type": "",
    "signature": "UnwovenClassFile(String filename, String classname, byte[] bytes)",
    "file_id": "F41",
    "start_line": 35,
    "text_preview": "ildClasses = Collections.emptyList();\\n\tprotected String className = null;\\n\tprotected boolean isModule = false;\\n\\n\tpublic UnwovenClassFile(String filename, byte[] bytes) {\\n\t\tthis.filename = filename;\\n\t\tthis.isModule = filename.toLowerCase().endsWith(\"module-info.java\");\\n\t\tthis.bytes = bytes;\\n\t}\\n\\n\t/** Use if the classname"
  },
  {
    "method_id": "M2437",
    "name": "shouldBeWoven",
    "return_type": "boolean",
    "signature": "shouldBeWoven()",
    "file_id": "F41",
    "start_line": 49,
    "text_preview": "me.toLowerCase().endsWith(\"module-info.class\");\\n\t\tthis.className = classname;\\n\t\tthis.bytes = bytes;\\n\t}\\n\\n\tpublic boolean shouldBeWoven() {\\n\t\t// Skip module-info files for now, they aren't really types\\n\t\treturn !isModule;\\n\t}\\n\\n\tpublic String getFilename() {\\n\t\treturn filename;\\n\t}\\n\\n\tpublic String makeInnerFileName(String in"
  },
  {
    "method_id": "M2438",
    "name": "getFilename",
    "return_type": "String",
    "signature": "getFilename()",
    "file_id": "F41",
    "start_line": 54,
    "text_preview": " shouldBeWoven() {\\n\t\t// Skip module-info files for now, they aren't really types\\n\t\treturn !isModule;\\n\t}\\n\\n\tpublic String getFilename() {\\n\t\treturn filename;\\n\t}\\n\\n\tpublic String makeInnerFileName(String innerName) {\\n\t\tString prefix = filename.substring(0, filename.length() - 6); // strip the .class\\n\t\treturn prefix + \"$\" + "
  },
  {
    "method_id": "M2439",
    "name": "makeInnerFileName",
    "return_type": "String",
    "signature": "makeInnerFileName(String innerName)",
    "file_id": "F41",
    "start_line": 58,
    "text_preview": ", they aren't really types\\n\t\treturn !isModule;\\n\t}\\n\\n\tpublic String getFilename() {\\n\t\treturn filename;\\n\t}\\n\\n\tpublic String makeInnerFileName(String innerName) {\\n\t\tString prefix = filename.substring(0, filename.length() - 6); // strip the .class\\n\t\treturn prefix + \"$\" + innerName + \".class\";\\n\t}\\n\\n\tpublic byte[] getBytes() {\\n"
  },
  {
    "method_id": "M2440",
    "name": "getBytes",
    "return_type": "byte[]",
    "signature": "getBytes()",
    "file_id": "F41",
    "start_line": 63,
    "text_preview": "bstring(0, filename.length() - 6); // strip the .class\\n\t\treturn prefix + \"$\" + innerName + \".class\";\\n\t}\\n\\n\tpublic byte[] getBytes() {\\n\t\t// if (bytes == null) bytes = javaClass.getBytes();\\n\t\treturn bytes;\\n\t}\\n\\n\tpublic JavaClass getJavaClass() {\\n\t\t// XXX need to know when to make a new class and when not to\\n\t\t// XXX this i"
  },
  {
    "method_id": "M2441",
    "name": "getJavaClass",
    "return_type": "JavaClass",
    "signature": "getJavaClass()",
    "file_id": "F41",
    "start_line": 68,
    "text_preview": "\tpublic byte[] getBytes() {\\n\t\t// if (bytes == null) bytes = javaClass.getBytes();\\n\t\treturn bytes;\\n\t}\\n\\n\tpublic JavaClass getJavaClass() {\\n\t\t// XXX need to know when to make a new class and when not to\\n\t\t// XXX this is an important optimization\\n\t\tif (getBytes() == null) {\\n\t\t\tSystem.out.println(\"no bytes for: \" + getFilen"
  },
  {
    "method_id": "M2442",
    "name": "writeUnchangedBytes",
    "return_type": "void",
    "signature": "writeUnchangedBytes()",
    "file_id": "F41",
    "start_line": 81,
    "text_preview": "if (javaClass == null) javaClass = Utility.makeJavaClass(filename, getBytes());\\n\t\t// return javaClass;\\n\t}\\n\\n\tpublic void writeUnchangedBytes() throws IOException {\\n\t\twriteWovenBytes(getBytes(), Collections.<ChildClass>emptyList());\\n\t}\\n\\n\tpublic void writeWovenBytes(byte[] bytes, List<ChildClass> childClasses) throws IOEx"
  },
  {
    "method_id": "M2443",
    "name": "writeWovenBytes",
    "return_type": "void",
    "signature": "writeWovenBytes(byte[] bytes, List<ChildClass> childClasses)",
    "file_id": "F41",
    "start_line": 82,
    "text_preview": "keJavaClass(filename, getBytes());\\n\t\t// return javaClass;\\n\t}\\n\\n\tpublic void writeUnchangedBytes() throws IOException {\\n\t\twriteWovenBytes(getBytes(), Collections.<ChildClass>emptyList());\\n\t}\\n\\n\tpublic void writeWovenBytes(byte[] bytes, List<ChildClass> childClasses) throws IOException {\\n\t\twriteChildClasses(childClasses);\\n"
  },
  {
    "method_id": "M2444",
    "name": "writeChildClasses",
    "return_type": "void",
    "signature": "writeChildClasses(List<ChildClass> childClasses)",
    "file_id": "F41",
    "start_line": 86,
    "text_preview": "lass>emptyList());\\n\t}\\n\\n\tpublic void writeWovenBytes(byte[] bytes, List<ChildClass> childClasses) throws IOException {\\n\t\twriteChildClasses(childClasses);\\n\\n\t\t// System.err.println(\"should write: \" + getClassName());\\n\\n\t\t// System.err.println(\"about to write: \" + this + \", \" + writtenBytes + \", \");\\n\t\t// + writtenBytes != n"
  },
  {
    "method_id": "M2445",
    "name": "for",
    "return_type": "right",
    "signature": "for(ChildClass childClass : childClasses)",
    "file_id": "F41",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2446",
    "name": "writeChildClassFile",
    "return_type": "void",
    "signature": "writeChildClassFile(String innerName, byte[] bytes)",
    "file_id": "F41",
    "start_line": 113,
    "text_preview": "\\n\t\tchildClasses.removeAll(writtenChildClasses); // XXX is this right\\n\\n\t\tfor (ChildClass childClass : childClasses) {\\n\t\t\twriteChildClassFile(childClass.name, childClass.bytes);\\n\t\t}\\n\\n\t\twrittenChildClasses = childClasses;\\n\\n\t}\\n\\n\tprivate void writeChildClassFile(String innerName, byte[] bytes) throws IOException {\\n\t\tBuffere"
  },
  {
    "method_id": "M2447",
    "name": "deleteAllChildClasses",
    "return_type": "void",
    "signature": "deleteAllChildClasses()",
    "file_id": "F41",
    "start_line": 108,
    "text_preview": "ses whose\\n\t\t// ??? names aren't in childClasses; however, it's unclear\\n\t\t// ??? how much that will affect performance\\n\t\tdeleteAllChildClasses();\\n\\n\t\tchildClasses.removeAll(writtenChildClasses); // XXX is this right\\n\\n\t\tfor (ChildClass childClass : childClasses) {\\n\t\t\twriteChildClassFile(childClass.name, childClass.bytes);"
  },
  {
    "method_id": "M2448",
    "name": "for",
    "return_type": "",
    "signature": "for(ChildClass childClass : writtenChildClasses)",
    "file_id": "F41",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2449",
    "name": "deleteChildClassFile",
    "return_type": "void",
    "signature": "deleteChildClassFile(String innerName)",
    "file_id": "F41",
    "start_line": 128,
    "text_preview": ");\\n\t\tos.close();\\n\t}\\n\\n\tprotected void deleteAllChildClasses() {\\n\t\tfor (ChildClass childClass : writtenChildClasses) {\\n\t\t\tdeleteChildClassFile(childClass.name);\\n\t\t}\\n\t}\\n\\n\tprotected void deleteChildClassFile(String innerName) {\\n\t\tFile childClassFile = new File(makeInnerFileName(innerName));\\n\t\tchildClassFile.delete();\\n\t}\\n\\n\t"
  },
  {
    "method_id": "M2450",
    "name": "unchanged",
    "return_type": "boolean",
    "signature": "unchanged(byte[] b1, byte[] b2)",
    "file_id": "F41",
    "start_line": 91,
    "text_preview": "\t\t// System.err.println(\"about to write: \" + this + \", \" + writtenBytes + \", \");\\n\t\t// + writtenBytes != null + \" && \" + unchanged(bytes, writtenBytes) );\\n\\n\t\t// if (writtenBytes != null && unchanged(bytes, writtenBytes)) return;\\n\\n\t\t// System.err.println(\"    actually wrote it\");\\n\\n\t\tBufferedOutputStream os = FileUtil.mak"
  },
  {
    "method_id": "M2451",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < len; i++)",
    "file_id": "F41",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2452",
    "name": "getClassNameAsChars",
    "return_type": "char[]",
    "signature": "getClassNameAsChars()",
    "file_id": "F41",
    "start_line": 148,
    "text_preview": "false;\\n\t\tfor (int i = 0; i < len; i++) {\\n\t\t\tif (b1[i] != b2[i])\\n\t\t\t\treturn false;\\n\t\t}\\n\t\treturn true;\\n\t}\\n\\n\tpublic char[] getClassNameAsChars() {\\n\t\tif (charfilename == null) {\\n\t\t\tcharfilename = getClassName().replace('.', '/').toCharArray();\\n\t\t}\\n\t\treturn charfilename;\\n\t}\\n\\n\tpublic String getClassName() {\\n\t\tif (className ="
  },
  {
    "method_id": "M2453",
    "name": "if",
    "return_type": "",
    "signature": "if(charfilename == null)",
    "file_id": "F41",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2454",
    "name": "getClassName",
    "return_type": "String",
    "signature": "getClassName()",
    "file_id": "F41",
    "start_line": 88,
    "text_preview": "lass> childClasses) throws IOException {\\n\t\twriteChildClasses(childClasses);\\n\\n\t\t// System.err.println(\"should write: \" + getClassName());\\n\\n\t\t// System.err.println(\"about to write: \" + this + \", \" + writtenBytes + \", \");\\n\t\t// + writtenBytes != null + \" && \" + unchanged(bytes, writtenBytes) );\\n\\n\t\t// if (writtenBytes != nu"
  },
  {
    "method_id": "M2455",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F41",
    "start_line": 162,
    "text_preview": ".getClassName(); // OPTIMIZE quicker way to determine name??? surely?\\n\t\treturn className;\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn \"UnwovenClassFile(\" + filename + \", \" + getClassName() + \")\";\\n\t}\\n\\n\t// record\\n\t// OPTIMIZE why is the 'short name' used here (the bit after the dollar) - seems we mess about a lot"
  },
  {
    "method_id": "M2456",
    "name": "ChildClass",
    "return_type": "",
    "signature": "ChildClass(String name, byte[] bytes)",
    "file_id": "F41",
    "start_line": 173,
    "text_preview": "ly to put\\n\t// it back on!\\n\tpublic static class ChildClass {\\n\t\tpublic final String name;\\n\t\tpublic final byte[] bytes;\\n\\n\t\tChildClass(String name, byte[] bytes) {\\n\t\t\tthis.name = name;\\n\t\t\tthis.bytes = bytes;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean equals(Object other) {\\n\t\t\tif (!(other instanceof ChildClass))\\n\t\t\t\treturn false;\\n\t\t"
  },
  {
    "method_id": "M2457",
    "name": "equals",
    "return_type": "boolean",
    "signature": "equals(Object other)",
    "file_id": "F41",
    "start_line": 179,
    "text_preview": "\t\tChildClass(String name, byte[] bytes) {\\n\t\t\tthis.name = name;\\n\t\t\tthis.bytes = bytes;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean equals(Object other) {\\n\t\t\tif (!(other instanceof ChildClass))\\n\t\t\t\treturn false;\\n\t\t\tChildClass o = (ChildClass) other;\\n\t\t\treturn o.name.equals(name) && unchanged(o.bytes, bytes);\\n\t\t}\\n\\n\t\t@Override\\n\t\tpub"
  },
  {
    "method_id": "M2458",
    "name": "hashCode",
    "return_type": "int",
    "signature": "hashCode()",
    "file_id": "F41",
    "start_line": 187,
    "text_preview": "Class o = (ChildClass) other;\\n\t\t\treturn o.name.equals(name) && unchanged(o.bytes, bytes);\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic int hashCode() {\\n\t\t\treturn name.hashCode();\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic String toString() {\\n\t\t\treturn \"(ChildClass \" + name + \")\";\\n\t\t}\\n\t}\\n\\n\tpublic void setClassNameAsChars(char[] classNameAsChars) {\\n\t\tthis."
  },
  {
    "method_id": "M2459",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F41",
    "start_line": 162,
    "text_preview": ".getClassName(); // OPTIMIZE quicker way to determine name??? surely?\\n\t\treturn className;\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn \"UnwovenClassFile(\" + filename + \", \" + getClassName() + \")\";\\n\t}\\n\\n\t// record\\n\t// OPTIMIZE why is the 'short name' used here (the bit after the dollar) - seems we mess about a lot"
  },
  {
    "method_id": "M2460",
    "name": "setClassNameAsChars",
    "return_type": "void",
    "signature": "setClassNameAsChars(char[] classNameAsChars)",
    "file_id": "F41",
    "start_line": 197,
    "text_preview": "e.hashCode();\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic String toString() {\\n\t\t\treturn \"(ChildClass \" + name + \")\";\\n\t\t}\\n\t}\\n\\n\tpublic void setClassNameAsChars(char[] classNameAsChars) {\\n\t\tthis.charfilename = classNameAsChars;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M2461",
    "name": "UnwovenClassFileWithThirdPartyManagedBytecode",
    "return_type": "",
    "signature": "UnwovenClassFileWithThirdPartyManagedBytecode(String filename, String classname, IByteCodeProvider provider)",
    "file_id": "F42",
    "start_line": 28,
    "text_preview": "er;\\n\\n\tpublic interface IByteCodeProvider {\\n\t\tbyte[] getBytes();\\n\t}\\n\\n\t// OPTIMIZE make classname an input char[]\\n\tpublic UnwovenClassFileWithThirdPartyManagedBytecode(String filename, String classname, IByteCodeProvider provider) {\\n\t\tsuper(filename, classname, null);\\n\t\tthis.provider = provider;\\n\t}\\n\\n\tpublic byte[] getByt"
  },
  {
    "method_id": "M2462",
    "name": "getBytes",
    "return_type": "byte[]",
    "signature": "getBytes()",
    "file_id": "F42",
    "start_line": 24,
    "text_preview": "anagedBytecode extends UnwovenClassFile {\\n\\n\tIByteCodeProvider provider;\\n\\n\tpublic interface IByteCodeProvider {\\n\t\tbyte[] getBytes();\\n\t}\\n\\n\t// OPTIMIZE make classname an input char[]\\n\tpublic UnwovenClassFileWithThirdPartyManagedBytecode(String filename, String classname, IByteCodeProvider provider) {\\n\t\tsuper(filename, cla"
  },
  {
    "method_id": "M2463",
    "name": "readAjAttributes",
    "return_type": "List<AjAttribute>",
    "signature": "readAjAttributes(String classname, Attribute[] as, ISourceContext context, World w,\n\t\t\tAjAttribute.WeaverVersionInfo version, ConstantPoolReader dataDecompressor)",
    "file_id": "F43",
    "start_line": 69,
    "text_preview": "ivate final static char PACKAGE_INITIAL_CHAR = AjAttribute.AttributePrefix.charAt(0);\\n\\n\tpublic static List<AjAttribute> readAjAttributes(String classname, Attribute[] as, ISourceContext context, World w,\\n\t\t\tAjAttribute.WeaverVersionInfo version, ConstantPoolReader dataDecompressor) {\\n\t\tList<AjAttribute> attributes = ne"
  },
  {
    "method_id": "M2464",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = as.length - 1; i >= 0; i--)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2465",
    "name": "if",
    "return_type": "",
    "signature": "if(a instanceof Unknown)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2466",
    "name": "if",
    "return_type": "",
    "signature": "if(attr != null)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2467",
    "name": "beautifyLocation",
    "return_type": "String",
    "signature": "beautifyLocation(ISourceLocation isl)",
    "file_id": "F43",
    "start_line": 113,
    "text_preview": "ce source location - particular in the case where the source info is missing (binary weave).\\n\t */\\n\tpublic static String beautifyLocation(ISourceLocation isl) {\\n\t\tStringBuilder nice = new StringBuilder();\\n\t\tif (isl == null || isl.getSourceFile() == null || isl.getSourceFile().getName().contains(\"no debug info available\""
  },
  {
    "method_id": "M2468",
    "name": "if",
    "return_type": "",
    "signature": "if(takeFrom == -1)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2469",
    "name": "createSuperInvoke",
    "return_type": "Instruction",
    "signature": "createSuperInvoke(InstructionFactory fact, BcelWorld world, Member signature)",
    "file_id": "F43",
    "start_line": 132,
    "text_preview": ") != 0) {\\n\t\t\t\tnice.append(\":\").append(isl.getLine());\\n\t\t\t}\\n\t\t}\\n\t\treturn nice.toString();\\n\t}\\n\\n\tpublic static Instruction createSuperInvoke(InstructionFactory fact, BcelWorld world, Member signature) {\\n\t\tshort kind;\\n\t\tif (Modifier.isInterface(signature.getModifiers())) {\\n\t\t\tthrow new RuntimeException(\"bad\");\\n\t\t} else if "
  },
  {
    "method_id": "M2470",
    "name": "createInvoke",
    "return_type": "Instruction",
    "signature": "createInvoke(InstructionFactory fact, BcelWorld world, Member signature)",
    "file_id": "F43",
    "start_line": 144,
    "text_preview": "tModifiers())) {\\n\t\t\tthrow new RuntimeException(\"bad\");\\n\t\t} else {\\n\t\t\tkind = Constants.INVOKESPECIAL;\\n\t\t}\\n\\n\t\treturn fact.createInvoke(signature.getDeclaringType().getName(), signature.getName(),\\n\t\t\t\tBcelWorld.makeBcelType(signature.getReturnType()), BcelWorld.makeBcelTypes(signature.getParameterTypes()), kind);\\n\t}\\n\\n\tpub"
  },
  {
    "method_id": "M2471",
    "name": "createGet",
    "return_type": "Instruction",
    "signature": "createGet(InstructionFactory fact, Member signature)",
    "file_id": "F43",
    "start_line": 169,
    "text_preview": "ure.getReturnType()),\\n\t\t\t\tBcelWorld.makeBcelTypes(signature.getParameterTypes()), kind);\\n\t}\\n\\n\tpublic static Instruction createGet(InstructionFactory fact, Member signature) {\\n\t\tshort kind;\\n\t\tif (Modifier.isStatic(signature.getModifiers())) {\\n\t\t\tkind = Constants.GETSTATIC;\\n\t\t} else {\\n\t\t\tkind = Constants.GETFIELD;\\n\t\t}\\n\\n\t"
  },
  {
    "method_id": "M2472",
    "name": "createSet",
    "return_type": "Instruction",
    "signature": "createSet(InstructionFactory fact, Member signature)",
    "file_id": "F43",
    "start_line": 181,
    "text_preview": "me(), signature.getName(),\\n\t\t\t\tBcelWorld.makeBcelType(signature.getReturnType()), kind);\\n\t}\\n\\n\tpublic static Instruction createSet(InstructionFactory fact, Member signature) {\\n\t\tshort kind;\\n\t\tif (Modifier.isStatic(signature.getModifiers())) {\\n\t\t\tkind = Constants.PUTSTATIC;\\n\t\t} else {\\n\t\t\tkind = Constants.PUTFIELD;\\n\t\t}\\n\\n\t"
  },
  {
    "method_id": "M2473",
    "name": "createInstanceof",
    "return_type": "Instruction",
    "signature": "createInstanceof(InstructionFactory fact, ReferenceType t)",
    "file_id": "F43",
    "start_line": 193,
    "text_preview": "me(), signature.getName(),\\n\t\t\t\tBcelWorld.makeBcelType(signature.getReturnType()), kind);\\n\t}\\n\\n\tpublic static Instruction createInstanceof(InstructionFactory fact, ReferenceType t) {\\n\t\tint cpoolEntry = (t instanceof ArrayType) ? fact.getConstantPool().addArrayClass((ArrayType) t) : fact.getConstantPool()\\n\t\t\t\t.addClass((O"
  },
  {
    "method_id": "M2474",
    "name": "createInvoke",
    "return_type": "Instruction",
    "signature": "createInvoke(InstructionFactory fact, LazyMethodGen m)",
    "file_id": "F43",
    "start_line": 144,
    "text_preview": "tModifiers())) {\\n\t\t\tthrow new RuntimeException(\"bad\");\\n\t\t} else {\\n\t\t\tkind = Constants.INVOKESPECIAL;\\n\t\t}\\n\\n\t\treturn fact.createInvoke(signature.getDeclaringType().getName(), signature.getName(),\\n\t\t\t\tBcelWorld.makeBcelType(signature.getReturnType()), BcelWorld.makeBcelTypes(signature.getParameterTypes()), kind);\\n\t}\\n\\n\tpub"
  },
  {
    "method_id": "M2475",
    "name": "createInvoke",
    "return_type": "Instruction",
    "signature": "createInvoke(InstructionFactory fact, short kind, Member member)",
    "file_id": "F43",
    "start_line": 144,
    "text_preview": "tModifiers())) {\\n\t\t\tthrow new RuntimeException(\"bad\");\\n\t\t} else {\\n\t\t\tkind = Constants.INVOKESPECIAL;\\n\t\t}\\n\\n\t\treturn fact.createInvoke(signature.getDeclaringType().getName(), signature.getName(),\\n\t\t\t\tBcelWorld.makeBcelType(signature.getReturnType()), BcelWorld.makeBcelTypes(signature.getParameterTypes()), kind);\\n\t}\\n\\n\tpub"
  },
  {
    "method_id": "M2476",
    "name": "makeArgNames",
    "return_type": "String[]",
    "signature": "makeArgNames(int n)",
    "file_id": "F43",
    "start_line": 236,
    "text_preview": "\\n\t// ??? these should perhaps be cached. Remember to profile this to see if\\n\t// it's a problem.\\n\tpublic static String[] makeArgNames(int n) {\\n\t\tString[] ret = new String[n];\\n\t\tfor (int i = 0; i < n; i++) {\\n\t\t\tif (i < 5) {\\n\t\t\t\tret[i] = argNames[i];\\n\t\t\t} else {\\n\t\t\t\tret[i] = \"arg\" + i;\\n\t\t\t}\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\t// Looku"
  },
  {
    "method_id": "M2477",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < n; i++)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2478",
    "name": "if",
    "return_type": "",
    "signature": "if(i < 5)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2479",
    "name": "appendConversion",
    "return_type": "void",
    "signature": "appendConversion(InstructionList il, InstructionFactory fact, ResolvedType fromType, ResolvedType toType)",
    "file_id": "F43",
    "start_line": 271,
    "text_preview": "\"SLjava/lang/Short;\", \"shortValue\");\\n\t\tvalidBoxing.put(\"ZLjava/lang/Boolean;\", \"booleanValue\");\\n\t}\\n\\n\tpublic static void appendConversion(InstructionList il, InstructionFactory fact, ResolvedType fromType, ResolvedType toType) {\\n\t\tif (!toType.isConvertableFrom(fromType) && !fromType.isConvertableFrom(toType)) {\\n\t\t\tthrow"
  },
  {
    "method_id": "M2480",
    "name": "if",
    "return_type": "",
    "signature": "if(w == null)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2481",
    "name": "if",
    "return_type": "",
    "signature": "if(i != null)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2482",
    "name": "catch",
    "return_type": "",
    "signature": "catch(RuntimeException e)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2483",
    "name": "createConversion",
    "return_type": "InstructionList",
    "signature": "createConversion(InstructionFactory factory, Type fromType, Type toType)",
    "file_id": "F43",
    "start_line": 349,
    "text_preview": "& ! toType.isPrimitive()\\n\t\t\til.append(fact.createCheckCast((ReferenceType) to));\\n\t\t}\\n\t}\\n\\n\tpublic static InstructionList createConversion(InstructionFactory factory, Type fromType, Type toType) {\\n\t\treturn createConversion(factory, fromType, toType, false);\\n\t}\\n\\n\tpublic static InstructionList createConversion(InstructionF"
  },
  {
    "method_id": "M2484",
    "name": "createConversion",
    "return_type": "InstructionList",
    "signature": "createConversion(InstructionFactory fact, Type fromType, Type toType, boolean allowAutoboxing)",
    "file_id": "F43",
    "start_line": 349,
    "text_preview": "& ! toType.isPrimitive()\\n\t\t\til.append(fact.createCheckCast((ReferenceType) to));\\n\t\t}\\n\t}\\n\\n\tpublic static InstructionList createConversion(InstructionFactory factory, Type fromType, Type toType) {\\n\t\treturn createConversion(factory, fromType, toType, false);\\n\t}\\n\\n\tpublic static InstructionList createConversion(InstructionF"
  },
  {
    "method_id": "M2485",
    "name": "if",
    "return_type": "",
    "signature": "if(toType instanceof BasicType)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2486",
    "name": "if",
    "return_type": "",
    "signature": "if(toType instanceof BasicType)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2487",
    "name": "if",
    "return_type": "",
    "signature": "if(fromType instanceof BasicType)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2488",
    "name": "if",
    "return_type": "else",
    "signature": "if(fromType instanceof ReferenceType)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2489",
    "name": "if",
    "return_type": "",
    "signature": "if(allowAutoboxing)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2490",
    "name": "if",
    "return_type": "",
    "signature": "if(toType instanceof BasicType && fromType instanceof ReferenceType)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2491",
    "name": "if",
    "return_type": "",
    "signature": "if(fromType instanceof BasicType && toType instanceof ReferenceType)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2492",
    "name": "createConstant",
    "return_type": "Instruction",
    "signature": "createConstant(InstructionFactory fact, int value)",
    "file_id": "F43",
    "start_line": 428,
    "text_preview": ");\\n\t\t\t\treturn il;\\n\t\t\t}\\n\t\t}\\n\\n\t\til.append(fact.createCast(fromType, toType));\\n\t\treturn il;\\n\t}\\n\\n\tpublic static Instruction createConstant(InstructionFactory fact, int value) {\\n\t\tInstruction inst;\\n\t\tswitch (value) {\\n\t\tcase -1:\\n\t\t\tinst = InstructionConstants.ICONST_M1;\\n\t\t\tbreak;\\n\t\tcase 0:\\n\t\t\tinst = InstructionConstants.ICON"
  },
  {
    "method_id": "M2493",
    "name": "switch",
    "return_type": "",
    "signature": "switch(value)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2494",
    "name": "if",
    "return_type": "",
    "signature": "if(value <= Byte.MAX_VALUE && value >= Byte.MIN_VALUE)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2495",
    "name": "if",
    "return_type": "else",
    "signature": "if(value <= Short.MAX_VALUE && value >= Short.MIN_VALUE)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2496",
    "name": "makeJavaClass",
    "return_type": "JavaClass",
    "signature": "makeJavaClass(String filename, byte[] bytes)",
    "file_id": "F43",
    "start_line": 469,
    "text_preview": "For testing purposes: bit clunky but does work */\\n\tpublic static int testingParseCounter = 0;\\n\\n\tpublic static JavaClass makeJavaClass(String filename, byte[] bytes) {\\n\t\ttry {\\n\t\t\ttestingParseCounter++;\\n\t\t\tClassParser parser = new ClassParser(new ByteArrayInputStream(bytes), filename);\\n\t\t\treturn parser.parse();\\n\t\t} catch"
  },
  {
    "method_id": "M2497",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2498",
    "name": "replaceInstruction",
    "return_type": "void",
    "signature": "replaceInstruction(InstructionHandle ih, InstructionList replacementInstructions,\n\t\t\tLazyMethodGen enclosingMethod)",
    "file_id": "F43",
    "start_line": 486,
    "text_preview": "instruction to replace ih with\\n\t * @param enclosingMethod where to find ih's instruction list.\\n\t */\\n\tpublic static void replaceInstruction(InstructionHandle ih, InstructionList replacementInstructions,\\n\t\t\tLazyMethodGen enclosingMethod) {\\n\t\tInstructionList il = enclosingMethod.getBody();\\n\t\tInstructionHandle fresh = il.a"
  },
  {
    "method_id": "M2499",
    "name": "deleteInstruction",
    "return_type": "void",
    "signature": "deleteInstruction(InstructionHandle ih, LazyMethodGen enclosingMethod)",
    "file_id": "F43",
    "start_line": 490,
    "text_preview": "\t\tInstructionList il = enclosingMethod.getBody();\\n\t\tInstructionHandle fresh = il.append(ih, replacementInstructions);\\n\t\tdeleteInstruction(ih, fresh, enclosingMethod);\\n\t}\\n\\n\t/**\\n\t * delete an instruction handle and retarget all targeters of the deleted instruction to the next instruction. Obviously, this\\n\t * should not b"
  },
  {
    "method_id": "M2500",
    "name": "deleteInstruction",
    "return_type": "void",
    "signature": "deleteInstruction(InstructionHandle ih, InstructionHandle retargetTo, LazyMethodGen enclosingMethod)",
    "file_id": "F43",
    "start_line": 490,
    "text_preview": "\t\tInstructionList il = enclosingMethod.getBody();\\n\t\tInstructionHandle fresh = il.append(ih, replacementInstructions);\\n\t\tdeleteInstruction(ih, fresh, enclosingMethod);\\n\t}\\n\\n\t/**\\n\t * delete an instruction handle and retarget all targeters of the deleted instruction to the next instruction. Obviously, this\\n\t * should not b"
  },
  {
    "method_id": "M2501",
    "name": "catch",
    "return_type": "",
    "signature": "catch(TargetLostException e)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2502",
    "name": "copyInstruction",
    "return_type": "Instruction",
    "signature": "copyInstruction(Instruction i)",
    "file_id": "F43",
    "start_line": 534,
    "text_preview": "or:\\n\t *     call(* Instruction.copy()) &amp;&amp; within(org.aspectj.weaver)\\n\t *       &amp;&amp; !withincode(* Utility.copyInstruction(Instruction)):\\n\t *     &quot;use Utility.copyInstruction to work-around bug in Select.copy()&quot;;\\n\t * </pre>\\n\t */\\n\tpublic static Instruction copyInstruction(Instruction i) {\\n\t\tif (i "
  },
  {
    "method_id": "M2503",
    "name": "if",
    "return_type": "",
    "signature": "if(i instanceof InstructionSelect)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2504",
    "name": "for",
    "return_type": "",
    "signature": "for(int ii = 0; ii < targets.length; ii++)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2505",
    "name": "getSourceLine",
    "return_type": "int",
    "signature": "getSourceLine(InstructionHandle ih)",
    "file_id": "F43",
    "start_line": 559,
    "text_preview": "\t// this naive version overruns the JVM stack size, if only Java understood\\n\t// tail recursion...\\n\t// public static int getSourceLine(InstructionHandle ih) {\\n\t// if (ih == null) return -1;\\n\t//\\n\t// InstructionTargeter[] ts = ih.getTargeters();\\n\t// if (ts != null) {\\n\t// for (int j = ts.length - 1; j >= 0; j--) {\\n\t// Inst"
  },
  {
    "method_id": "M2506",
    "name": "if",
    "return_type": "",
    "signature": "if(ts != null)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2507",
    "name": "for",
    "return_type": "",
    "signature": "for(int j = ts.length - 1; j >= 0; j--)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2508",
    "name": "if",
    "return_type": "",
    "signature": "if(t instanceof LineNumberTag)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2509",
    "name": "getSourceLine",
    "return_type": "int",
    "signature": "getSourceLine(InstructionHandle ih)",
    "file_id": "F43",
    "start_line": 559,
    "text_preview": "\t// this naive version overruns the JVM stack size, if only Java understood\\n\t// tail recursion...\\n\t// public static int getSourceLine(InstructionHandle ih) {\\n\t// if (ih == null) return -1;\\n\t//\\n\t// InstructionTargeter[] ts = ih.getTargeters();\\n\t// if (ts != null) {\\n\t// for (int j = ts.length - 1; j >= 0; j--) {\\n\t// Inst"
  },
  {
    "method_id": "M2510",
    "name": "while",
    "return_type": "",
    "signature": "while(lookahead++ < 100)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2511",
    "name": "if",
    "return_type": "",
    "signature": "if(ih == null)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2512",
    "name": "if",
    "return_type": "",
    "signature": "if(t instanceof LineNumberTag)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2513",
    "name": "getSourceLine",
    "return_type": "int",
    "signature": "getSourceLine(InstructionHandle ih)",
    "file_id": "F43",
    "start_line": 559,
    "text_preview": "\t// this naive version overruns the JVM stack size, if only Java understood\\n\t// tail recursion...\\n\t// public static int getSourceLine(InstructionHandle ih) {\\n\t// if (ih == null) return -1;\\n\t//\\n\t// InstructionTargeter[] ts = ih.getTargeters();\\n\t// if (ts != null) {\\n\t// for (int j = ts.length - 1; j >= 0; j--) {\\n\t// Inst"
  },
  {
    "method_id": "M2514",
    "name": "setSourceLine",
    "return_type": "void",
    "signature": "setSourceLine(InstructionHandle ih, int lineNumber)",
    "file_id": "F43",
    "start_line": 600,
    "text_preview": "\t// assumes that there is no already extant source line tag. Otherwise we'll\\n\t// have to be better.\\n\tpublic static void setSourceLine(InstructionHandle ih, int lineNumber) {\\n\t\t// OPTIMIZE LineNumberTag instances for the same line could be shared\\n\t\t// throughout a method...\\n\t\tih.addTargeter(new LineNumberTag(lineNumber)"
  },
  {
    "method_id": "M2515",
    "name": "makePublic",
    "return_type": "int",
    "signature": "makePublic(int i)",
    "file_id": "F43",
    "start_line": 606,
    "text_preview": "ine could be shared\\n\t\t// throughout a method...\\n\t\tih.addTargeter(new LineNumberTag(lineNumber));\\n\t}\\n\\n\tpublic static int makePublic(int i) {\\n\t\treturn i & ~(Modifier.PROTECTED | Modifier.PRIVATE) | Modifier.PUBLIC;\\n\t}\\n\\n\tpublic static BcelVar[] pushAndReturnArrayOfVars(ResolvedType[] proceedParamTypes, InstructionList il,"
  },
  {
    "method_id": "M2516",
    "name": "pushAndReturnArrayOfVars",
    "return_type": "BcelVar[]",
    "signature": "pushAndReturnArrayOfVars(ResolvedType[] proceedParamTypes, InstructionList il, InstructionFactory fact,\n\t\t\tLazyMethodGen enclosingMethod)",
    "file_id": "F43",
    "start_line": 610,
    "text_preview": "kePublic(int i) {\\n\t\treturn i & ~(Modifier.PROTECTED | Modifier.PRIVATE) | Modifier.PUBLIC;\\n\t}\\n\\n\tpublic static BcelVar[] pushAndReturnArrayOfVars(ResolvedType[] proceedParamTypes, InstructionList il, InstructionFactory fact,\\n\t\t\tLazyMethodGen enclosingMethod) {\\n\t\tint len = proceedParamTypes.length;\\n\t\tBcelVar[] ret = new "
  },
  {
    "method_id": "M2517",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = len - 1; i >= 0; i--)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2518",
    "name": "isConstantPushInstruction",
    "return_type": "boolean",
    "signature": "isConstantPushInstruction(Instruction i)",
    "file_id": "F43",
    "start_line": 626,
    "text_preview": "nFactory.createStore(type, local));\\n\t\t\tret[i] = new BcelVar(typeX, local);\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic static boolean isConstantPushInstruction(Instruction i) {\\n\t\tlong ii = Constants.instFlags[i.opcode];\\n\t\treturn ((ii & Constants.PUSH_INST) != 0 && (ii & Constants.CONSTANT_INST) != 0);\\n\t}\\n\\n\t/**\\n\t * Checks for suppres"
  },
  {
    "method_id": "M2519",
    "name": "isSuppressing",
    "return_type": "boolean",
    "signature": "isSuppressing(Member member, String lintkey)",
    "file_id": "F43",
    "start_line": 634,
    "text_preview": "\\n\t * Checks for suppression specified on the member or on the declaring type of that member\\n\t */\\n\tpublic static boolean isSuppressing(Member member, String lintkey) {\\n\t\tboolean isSuppressing = Utils.isSuppressing(member.getAnnotations(), lintkey);\\n\t\tif (isSuppressing) {\\n\t\t\treturn true;\\n\t\t}\\n\t\tUnresolvedType type = membe"
  },
  {
    "method_id": "M2520",
    "name": "if",
    "return_type": "",
    "signature": "if(isSuppressing)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2521",
    "name": "if",
    "return_type": "",
    "signature": "if(type instanceof ResolvedType)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2522",
    "name": "getSuppressedWarnings",
    "return_type": "Kind>",
    "signature": "getSuppressedWarnings(AnnotationAJ[] anns, Lint lint)",
    "file_id": "F43",
    "start_line": 646,
    "text_preview": ".isSuppressing(((ResolvedType) type).getAnnotations(), lintkey);\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\tpublic static List<Lint.Kind> getSuppressedWarnings(AnnotationAJ[] anns, Lint lint) {\\n\t\tif (anns == null) {\\n\t\t\treturn Collections.emptyList();\\n\t\t}\\n\t\t// Go through the annotation types\\n\t\tList<Lint.Kind> suppressedWarnings = new Arr"
  },
  {
    "method_id": "M2523",
    "name": "if",
    "return_type": "",
    "signature": "if(anns == null)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2524",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; !found && i < anns.length; i++)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2525",
    "name": "for",
    "return_type": "",
    "signature": "for(ElementValue elementValue : values)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2526",
    "name": "if",
    "return_type": "",
    "signature": "if(lintKind != null)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2527",
    "name": "isSimple",
    "return_type": "boolean",
    "signature": "isSimple(Method method)",
    "file_id": "F43",
    "start_line": 684,
    "text_preview": "lintKind);\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\treturn suppressedWarnings;\\n\t}\\n\\n\t// not yet used...\\n\t// public static boolean isSimple(Method method) {\\n\t// if (method.getCode()==null) return true;\\n\t// if (method.getCode().getCode().length>10) return false;\\n\t// InstructionList instrucs = new\\n\t// InstructionList(method.getCode"
  },
  {
    "method_id": "M2528",
    "name": "while",
    "return_type": "",
    "signature": "while(InstrHandle != null)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2529",
    "name": "if",
    "return_type": "",
    "signature": "if(Instr instanceof InstructionBranch)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2530",
    "name": "if",
    "return_type": "else",
    "signature": "if(Instr instanceof InvokeInstruction)",
    "file_id": "F43",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2531",
    "name": "bcelAttribute",
    "return_type": "Attribute",
    "signature": "bcelAttribute(AjAttribute a, ConstantPool pool)",
    "file_id": "F43",
    "start_line": 709,
    "text_preview": "\t// return false;\\n\t// }\\n\t// InstrHandle = InstrHandle.getNext();\\n\t// }\\n\t// return true;\\n\t// }\\n\\n\tpublic static Attribute bcelAttribute(AjAttribute a, ConstantPool pool) {\\n\t\tint nameIndex = pool.addUtf8(a.getNameString());\\n\t\tbyte[] bytes = a.getBytes(new BcelConstantPoolWriter(pool));\\n\t\tint length = bytes.length;\\n\\n\t\tretu"
  },
  {
    "method_id": "M2532",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F44",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2533",
    "name": "addStackMaps",
    "return_type": "byte[]",
    "signature": "addStackMaps(World world, String classname, byte[] data)",
    "file_id": "F45",
    "start_line": 40,
    "text_preview": "e use our own minimal MethodVisitor.\\n *\\n * @author Andy Clement\\n */\\npublic class StackMapAdder {\\n\\n\tpublic static byte[] addStackMaps(World world, String classname, byte[] data) {\\n\t\ttry {\\n\t\t\tClassReader cr = new ClassReader(data);\\n\t\t\tClassWriter cw = new AspectJConnectClassWriter(cr, world);\\n\t\t\tClassVisitor cv = new Asp"
  },
  {
    "method_id": "M2534",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F45",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2535",
    "name": "AspectJClassVisitor",
    "return_type": "",
    "signature": "AspectJClassVisitor(ClassVisitor classwriter)",
    "file_id": "F45",
    "start_line": 44,
    "text_preview": "ader cr = new ClassReader(data);\\n\t\t\tClassWriter cw = new AspectJConnectClassWriter(cr, world);\\n\t\t\tClassVisitor cv = new AspectJClassVisitor(cw);\\n\t\t\tcr.accept(cv, 0);\\n\t\t\treturn cw.toByteArray();\\n\t\t} catch (Throwable t) {\\n\t\t\t// If in here fixing an error about version, change the ASMX in class above!\\n\t\t\tSystem.err.printl"
  },
  {
    "method_id": "M2536",
    "name": "visitMethod",
    "return_type": "MethodVisitor",
    "signature": "visitMethod(int access, String name, String desc, String signature, String[] exceptions)",
    "file_id": "F45",
    "start_line": 64,
    "text_preview": "tJClassVisitor(ClassVisitor classwriter) {\\n\t\t\tsuper(Opcodes.ASM9, classwriter);\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\\n\t\t\tMethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\\n\t\t\treturn new AJMethodVis"
  },
  {
    "method_id": "M2537",
    "name": "AJMethodVisitor",
    "return_type": "",
    "signature": "AJMethodVisitor(MethodVisitor mv)",
    "file_id": "F45",
    "start_line": 66,
    "text_preview": "tring[] exceptions) {\\n\t\t\tMethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\\n\t\t\treturn new AJMethodVisitor(mv);\\n\t\t}\\n\\n\t\t// Minimal pass through MethodVisitor just so that the ClassReader doesn't see one that has been directly\\n\t\t// created by a ClassWriter (see top level class comment)\\n\t\tstat"
  },
  {
    "method_id": "M2538",
    "name": "AspectJConnectClassWriter",
    "return_type": "",
    "signature": "AspectJConnectClassWriter(ClassReader cr, World w)",
    "file_id": "F45",
    "start_line": 43,
    "text_preview": "orld world, String classname, byte[] data) {\\n\t\ttry {\\n\t\t\tClassReader cr = new ClassReader(data);\\n\t\t\tClassWriter cw = new AspectJConnectClassWriter(cr, world);\\n\t\t\tClassVisitor cv = new AspectJClassVisitor(cw);\\n\t\t\tcr.accept(cv, 0);\\n\t\t\treturn cw.toByteArray();\\n\t\t} catch (Throwable t) {\\n\t\t\t// If in here fixing an error abou"
  },
  {
    "method_id": "M2539",
    "name": "getCommonSuperClass",
    "return_type": "String",
    "signature": "getCommonSuperClass(final String type1, final String type2)",
    "file_id": "F45",
    "start_line": 26,
    "text_preview": " byte data and then a reader/writer\\n * process it. The writer is wired into the world so that types can be resolved and getCommonSuperClass() can be implemented without\\n * class loading using the context class loader.\\n *\\n * It is important that the constant pool is preserved here and asm does not try to remove unused e"
  },
  {
    "method_id": "M2540",
    "name": "if",
    "return_type": "",
    "signature": "if(resolvedType1 == null)",
    "file_id": "F45",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2541",
    "name": "Definition",
    "return_type": "",
    "signature": "Definition()",
    "file_id": "F47",
    "start_line": 47,
    "text_preview": " must be around for them to function properly\\n\t */\\n\tprivate final Map<String, String> requiredTypesForAspects;\\n\\n\tpublic Definition() {\\n\t\tweaverOptions = new StringBuffer();\\n\t\tdumpBefore = false;\\n\t\tperClassloaderDumpDir = false;\\n\t\tdumpPatterns = new ArrayList<>();\\n\t\tincludePatterns = new ArrayList<>();\\n\t\texcludePatterns"
  },
  {
    "method_id": "M2542",
    "name": "getWeaverOptions",
    "return_type": "String",
    "signature": "getWeaverOptions()",
    "file_id": "F47",
    "start_line": 62,
    "text_preview": "= new ArrayList<>();\\n\t\tscopedAspects = new HashMap<>();\\n\t\trequiredTypesForAspects = new HashMap<>();\\n\t}\\n\\n\tpublic String getWeaverOptions() {\\n\t\treturn weaverOptions.toString();\\n\t}\\n\\n\tpublic List<String> getDumpPatterns() {\\n\t\treturn dumpPatterns;\\n\t}\\n\\n\tpublic void setDumpBefore(boolean b) {\\n\t\tdumpBefore = b;\\n\t}\\n\\n\tpublic bo"
  },
  {
    "method_id": "M2543",
    "name": "getDumpPatterns",
    "return_type": "List<String>",
    "signature": "getDumpPatterns()",
    "file_id": "F47",
    "start_line": 66,
    "text_preview": " = new HashMap<>();\\n\t}\\n\\n\tpublic String getWeaverOptions() {\\n\t\treturn weaverOptions.toString();\\n\t}\\n\\n\tpublic List<String> getDumpPatterns() {\\n\t\treturn dumpPatterns;\\n\t}\\n\\n\tpublic void setDumpBefore(boolean b) {\\n\t\tdumpBefore = b;\\n\t}\\n\\n\tpublic boolean shouldDumpBefore() {\\n\t\treturn dumpBefore;\\n\t}\\n\\n\tpublic void setCreateDumpDir"
  },
  {
    "method_id": "M2544",
    "name": "setDumpBefore",
    "return_type": "void",
    "signature": "setDumpBefore(boolean b)",
    "file_id": "F47",
    "start_line": 70,
    "text_preview": "\t\treturn weaverOptions.toString();\\n\t}\\n\\n\tpublic List<String> getDumpPatterns() {\\n\t\treturn dumpPatterns;\\n\t}\\n\\n\tpublic void setDumpBefore(boolean b) {\\n\t\tdumpBefore = b;\\n\t}\\n\\n\tpublic boolean shouldDumpBefore() {\\n\t\treturn dumpBefore;\\n\t}\\n\\n\tpublic void setCreateDumpDirPerClassloader(boolean b) {\\n\t\tperClassloaderDumpDir = b;\\n\t}\\n"
  },
  {
    "method_id": "M2545",
    "name": "shouldDumpBefore",
    "return_type": "boolean",
    "signature": "shouldDumpBefore()",
    "file_id": "F47",
    "start_line": 74,
    "text_preview": "mpPatterns() {\\n\t\treturn dumpPatterns;\\n\t}\\n\\n\tpublic void setDumpBefore(boolean b) {\\n\t\tdumpBefore = b;\\n\t}\\n\\n\tpublic boolean shouldDumpBefore() {\\n\t\treturn dumpBefore;\\n\t}\\n\\n\tpublic void setCreateDumpDirPerClassloader(boolean b) {\\n\t\tperClassloaderDumpDir = b;\\n\t}\\n\\n\tpublic boolean createDumpDirPerClassloader() {\\n\t\treturn perClas"
  },
  {
    "method_id": "M2546",
    "name": "setCreateDumpDirPerClassloader",
    "return_type": "void",
    "signature": "setCreateDumpDirPerClassloader(boolean b)",
    "file_id": "F47",
    "start_line": 78,
    "text_preview": "umpBefore(boolean b) {\\n\t\tdumpBefore = b;\\n\t}\\n\\n\tpublic boolean shouldDumpBefore() {\\n\t\treturn dumpBefore;\\n\t}\\n\\n\tpublic void setCreateDumpDirPerClassloader(boolean b) {\\n\t\tperClassloaderDumpDir = b;\\n\t}\\n\\n\tpublic boolean createDumpDirPerClassloader() {\\n\t\treturn perClassloaderDumpDir;\\n\t}\\n\\n\tpublic List<String> getIncludePatterns"
  },
  {
    "method_id": "M2547",
    "name": "createDumpDirPerClassloader",
    "return_type": "boolean",
    "signature": "createDumpDirPerClassloader()",
    "file_id": "F47",
    "start_line": 82,
    "text_preview": "mpBefore;\\n\t}\\n\\n\tpublic void setCreateDumpDirPerClassloader(boolean b) {\\n\t\tperClassloaderDumpDir = b;\\n\t}\\n\\n\tpublic boolean createDumpDirPerClassloader() {\\n\t\treturn perClassloaderDumpDir;\\n\t}\\n\\n\tpublic List<String> getIncludePatterns() {\\n\t\treturn includePatterns;\\n\t}\\n\\n\tpublic List<String> getExcludePatterns() {\\n\t\treturn exclu"
  },
  {
    "method_id": "M2548",
    "name": "getIncludePatterns",
    "return_type": "List<String>",
    "signature": "getIncludePatterns()",
    "file_id": "F47",
    "start_line": 86,
    "text_preview": "mpDir = b;\\n\t}\\n\\n\tpublic boolean createDumpDirPerClassloader() {\\n\t\treturn perClassloaderDumpDir;\\n\t}\\n\\n\tpublic List<String> getIncludePatterns() {\\n\t\treturn includePatterns;\\n\t}\\n\\n\tpublic List<String> getExcludePatterns() {\\n\t\treturn excludePatterns;\\n\t}\\n\\n\tpublic List<String> getAspectClassNames() {\\n\t\treturn aspectClassNames;\\n\t"
  },
  {
    "method_id": "M2549",
    "name": "getExcludePatterns",
    "return_type": "List<String>",
    "signature": "getExcludePatterns()",
    "file_id": "F47",
    "start_line": 90,
    "text_preview": "rClassloaderDumpDir;\\n\t}\\n\\n\tpublic List<String> getIncludePatterns() {\\n\t\treturn includePatterns;\\n\t}\\n\\n\tpublic List<String> getExcludePatterns() {\\n\t\treturn excludePatterns;\\n\t}\\n\\n\tpublic List<String> getAspectClassNames() {\\n\t\treturn aspectClassNames;\\n\t}\\n\\n\tpublic List<String> getAspectExcludePatterns() {\\n\t\treturn aspectExclud"
  },
  {
    "method_id": "M2550",
    "name": "getAspectClassNames",
    "return_type": "List<String>",
    "signature": "getAspectClassNames()",
    "file_id": "F47",
    "start_line": 94,
    "text_preview": "urn includePatterns;\\n\t}\\n\\n\tpublic List<String> getExcludePatterns() {\\n\t\treturn excludePatterns;\\n\t}\\n\\n\tpublic List<String> getAspectClassNames() {\\n\t\treturn aspectClassNames;\\n\t}\\n\\n\tpublic List<String> getAspectExcludePatterns() {\\n\t\treturn aspectExcludePatterns;\\n\t}\\n\\n\tpublic List<String> getAspectIncludePatterns() {\\n\t\treturn "
  },
  {
    "method_id": "M2551",
    "name": "getAspectExcludePatterns",
    "return_type": "List<String>",
    "signature": "getAspectExcludePatterns()",
    "file_id": "F47",
    "start_line": 98,
    "text_preview": "n excludePatterns;\\n\t}\\n\\n\tpublic List<String> getAspectClassNames() {\\n\t\treturn aspectClassNames;\\n\t}\\n\\n\tpublic List<String> getAspectExcludePatterns() {\\n\t\treturn aspectExcludePatterns;\\n\t}\\n\\n\tpublic List<String> getAspectIncludePatterns() {\\n\t\treturn aspectIncludePatterns;\\n\t}\\n\\n\tpublic List<Definition.ConcreteAspect> getConcre"
  },
  {
    "method_id": "M2552",
    "name": "getAspectIncludePatterns",
    "return_type": "List<String>",
    "signature": "getAspectIncludePatterns()",
    "file_id": "F47",
    "start_line": 102,
    "text_preview": "ssNames;\\n\t}\\n\\n\tpublic List<String> getAspectExcludePatterns() {\\n\t\treturn aspectExcludePatterns;\\n\t}\\n\\n\tpublic List<String> getAspectIncludePatterns() {\\n\t\treturn aspectIncludePatterns;\\n\t}\\n\\n\tpublic List<Definition.ConcreteAspect> getConcreteAspects() {\\n\t\treturn concreteAspects;\\n\t}\\n\\n\tpublic static class ConcreteAspect {\\n\t\tpu"
  },
  {
    "method_id": "M2553",
    "name": "getConcreteAspects",
    "return_type": "ConcreteAspect>",
    "signature": "getConcreteAspects()",
    "file_id": "F47",
    "start_line": 106,
    "text_preview": "c List<String> getAspectIncludePatterns() {\\n\t\treturn aspectIncludePatterns;\\n\t}\\n\\n\tpublic List<Definition.ConcreteAspect> getConcreteAspects() {\\n\t\treturn concreteAspects;\\n\t}\\n\\n\tpublic static class ConcreteAspect {\\n\t\tpublic final String name;\\n\t\tpublic final String extend;\\n\t\tpublic final String precedence;\\n\t\tpublic final Li"
  },
  {
    "method_id": "M2554",
    "name": "ConcreteAspect",
    "return_type": "",
    "signature": "ConcreteAspect(String name, String extend)",
    "file_id": "F47",
    "start_line": 120,
    "text_preview": "> pointcutsAndAdvice;\\n\t\tpublic final String perclause;\\n\t\tpublic List<Definition.DeclareErrorOrWarning> deows;\\n\\n\t\tpublic ConcreteAspect(String name, String extend) {\\n\t\t\tthis(name, extend, null, null);\\n\t\t}\\n\\n\t\tpublic ConcreteAspect(String name, String extend, String precedence, String perclause) {\\n\t\t\tthis.name = name;\\n\t\t\t"
  },
  {
    "method_id": "M2555",
    "name": "ConcreteAspect",
    "return_type": "",
    "signature": "ConcreteAspect(String name, String extend, String precedence, String perclause)",
    "file_id": "F47",
    "start_line": 120,
    "text_preview": "> pointcutsAndAdvice;\\n\t\tpublic final String perclause;\\n\t\tpublic List<Definition.DeclareErrorOrWarning> deows;\\n\\n\t\tpublic ConcreteAspect(String name, String extend) {\\n\t\t\tthis(name, extend, null, null);\\n\t\t}\\n\\n\t\tpublic ConcreteAspect(String name, String extend, String precedence, String perclause) {\\n\t\t\tthis.name = name;\\n\t\t\t"
  },
  {
    "method_id": "M2556",
    "name": "Pointcut",
    "return_type": "",
    "signature": "Pointcut(String name, String expression)",
    "file_id": "F47",
    "start_line": 150,
    "text_preview": "clause;\\n\t\t}\\n\t}\\n\\n\tpublic static class Pointcut {\\n\t\tpublic final String name;\\n\t\tpublic final String expression;\\n\\n\t\tpublic Pointcut(String name, String expression) {\\n\t\t\tthis.name = name;\\n\t\t\tthis.expression = expression;\\n\t\t}\\n\t}\\n\\n\tpublic enum AdviceKind {\\n\t\tBefore, After, AfterReturning, AfterThrowing, Around;\\n\t}\\n\\n\tpublic e"
  },
  {
    "method_id": "M2557",
    "name": "DeclareAnnotation",
    "return_type": "",
    "signature": "DeclareAnnotation(DeclareAnnotationKind kind, String pattern, String annotation)",
    "file_id": "F47",
    "start_line": 169,
    "text_preview": "DeclareAnnotationKind declareAnnotationKind;\\n\t\tpublic final String pattern;\\n\t\tpublic final String annotation;\\n\\n\t\tpublic DeclareAnnotation(DeclareAnnotationKind kind, String pattern, String annotation) {\\n\t\t\tthis.declareAnnotationKind = kind;\\n\t\t\tthis.pattern = pattern;\\n\t\t\tthis.annotation = annotation;\\n\t\t}\\n\t}\\n\\n\tpublic sta"
  },
  {
    "method_id": "M2558",
    "name": "PointcutAndAdvice",
    "return_type": "",
    "signature": "PointcutAndAdvice(AdviceKind adviceKind, String pointcut, String adviceClass, String adviceMethod)",
    "file_id": "F47",
    "start_line": 182,
    "text_preview": "Class; // com.foo.Bar\\n\t\tpublic final String adviceMethod; // foo(java.lang.String,org.aspectj.lang.JoinPoint)\\n\\n\t\tpublic PointcutAndAdvice(AdviceKind adviceKind, String pointcut, String adviceClass, String adviceMethod) {\\n\t\t\tthis.adviceKind = adviceKind;\\n\t\t\tthis.pointcut = pointcut;\\n\t\t\tthis.adviceClass = adviceClass;\\n\t\t"
  },
  {
    "method_id": "M2559",
    "name": "DeclareErrorOrWarning",
    "return_type": "",
    "signature": "DeclareErrorOrWarning(boolean isError, String pointcut, String message)",
    "file_id": "F47",
    "start_line": 195,
    "text_preview": "rorOrWarning {\\n\t\tpublic final boolean isError;\\n\t\tpublic final String pointcut;\\n\t\tpublic final String message;\\n\\n\t\tpublic DeclareErrorOrWarning(boolean isError, String pointcut, String message) {\\n\t\t\tthis.isError = isError;\\n\t\t\tthis.pointcut = pointcut;\\n\t\t\tthis.message = message;\\n\t\t}\\n\t}\\n\\n\tpublic void appendWeaverOptions(St"
  },
  {
    "method_id": "M2560",
    "name": "appendWeaverOptions",
    "return_type": "void",
    "signature": "appendWeaverOptions(String option)",
    "file_id": "F47",
    "start_line": 202,
    "text_preview": "ring message) {\\n\t\t\tthis.isError = isError;\\n\t\t\tthis.pointcut = pointcut;\\n\t\t\tthis.message = message;\\n\t\t}\\n\t}\\n\\n\tpublic void appendWeaverOptions(String option) {\\n\t\tweaverOptions.append(option.trim()).append(' ');\\n\t}\\n\\n\tpublic void addScopedAspect(String name, String scopePattern) {\\n\t\tscopedAspects.put(name, scopePattern);\\n\t}"
  },
  {
    "method_id": "M2561",
    "name": "addScopedAspect",
    "return_type": "void",
    "signature": "addScopedAspect(String name, String scopePattern)",
    "file_id": "F47",
    "start_line": 206,
    "text_preview": "\\n\\n\tpublic void appendWeaverOptions(String option) {\\n\t\tweaverOptions.append(option.trim()).append(' ');\\n\t}\\n\\n\tpublic void addScopedAspect(String name, String scopePattern) {\\n\t\tscopedAspects.put(name, scopePattern);\\n\t}\\n\\n\tpublic String getScopeForAspect(String name) {\\n\t\treturn scopedAspects.get(name);\\n\t}\\n\\n\tpublic void setA"
  },
  {
    "method_id": "M2562",
    "name": "getScopeForAspect",
    "return_type": "String",
    "signature": "getScopeForAspect(String name)",
    "file_id": "F47",
    "start_line": 210,
    "text_preview": "ic void addScopedAspect(String name, String scopePattern) {\\n\t\tscopedAspects.put(name, scopePattern);\\n\t}\\n\\n\tpublic String getScopeForAspect(String name) {\\n\t\treturn scopedAspects.get(name);\\n\t}\\n\\n\tpublic void setAspectRequires(String name, String requiredType) {\\n\t\trequiredTypesForAspects.put(name, requiredType);\\n\t}\\n\\n\tpublic"
  },
  {
    "method_id": "M2563",
    "name": "setAspectRequires",
    "return_type": "void",
    "signature": "setAspectRequires(String name, String requiredType)",
    "file_id": "F47",
    "start_line": 214,
    "text_preview": ", scopePattern);\\n\t}\\n\\n\tpublic String getScopeForAspect(String name) {\\n\t\treturn scopedAspects.get(name);\\n\t}\\n\\n\tpublic void setAspectRequires(String name, String requiredType) {\\n\t\trequiredTypesForAspects.put(name, requiredType);\\n\t}\\n\\n\tpublic String getAspectRequires(String name) {\\n\t\treturn requiredTypesForAspects.get(name);"
  },
  {
    "method_id": "M2564",
    "name": "getAspectRequires",
    "return_type": "String",
    "signature": "getAspectRequires(String name)",
    "file_id": "F47",
    "start_line": 218,
    "text_preview": "spectRequires(String name, String requiredType) {\\n\t\trequiredTypesForAspects.put(name, requiredType);\\n\t}\\n\\n\tpublic String getAspectRequires(String name) {\\n\t\treturn requiredTypesForAspects.get(name);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M2565",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2566",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2567",
    "name": "DocumentParser",
    "return_type": "",
    "signature": "DocumentParser()",
    "file_id": "F48",
    "start_line": 109,
    "text_preview": "\t\t\t.equalsIgnoreCase(\"true\");\\n\t\t} catch (Throwable t) {\\n\t\t\tt.printStackTrace();\\n\t\t}\\n\t\tLIGHTPARSER = value;\\n\t}\\n\\n\tprivate DocumentParser() {\\n\t\tdefinition = new Definition();\\n\t}\\n\\n\tpublic static Definition parse(final URL url) throws Exception {\\n\t\tif (CACHE && parsedFiles.containsKey(url.toString())) {\\n\t\t\treturn parsedFile"
  },
  {
    "method_id": "M2568",
    "name": "parse",
    "return_type": "Definition",
    "signature": "parse(final URL url)",
    "file_id": "F48",
    "start_line": 113,
    "text_preview": "}\\n\t\tLIGHTPARSER = value;\\n\t}\\n\\n\tprivate DocumentParser() {\\n\t\tdefinition = new Definition();\\n\t}\\n\\n\tpublic static Definition parse(final URL url) throws Exception {\\n\t\tif (CACHE && parsedFiles.containsKey(url.toString())) {\\n\t\t\treturn parsedFiles.get(url.toString());\\n\t\t}\\n\t\tDefinition def = null;\\n\\n\t\tif (LIGHTPARSER) {\\n\t\t\tdef ="
  },
  {
    "method_id": "M2569",
    "name": "if",
    "return_type": "",
    "signature": "if(LIGHTPARSER)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2570",
    "name": "saxParsing",
    "return_type": "Definition",
    "signature": "saxParsing(URL url)",
    "file_id": "F48",
    "start_line": 122,
    "text_preview": "oString());\\n\t\t}\\n\t\tDefinition def = null;\\n\\n\t\tif (LIGHTPARSER) {\\n\t\t\tdef = SimpleAOPParser.parse(url);\\n\t\t} else {\\n\t\t\tdef = saxParsing(url);\\n\t\t}\\n\\n\t\tif (CACHE && def.getAspectClassNames().size() > 0) {\\n\t\t\tparsedFiles.put(url.toString(), def);\\n\t\t}\\n\\n\t\treturn def;\\n\t}\\n\\n\tprivate static Definition saxParsing(URL url) throws SAXEx"
  },
  {
    "method_id": "M2571",
    "name": "catch",
    "return_type": "",
    "signature": "catch(SAXException e)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2572",
    "name": "catch",
    "return_type": "",
    "signature": "catch(SAXException e)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2573",
    "name": "catch",
    "return_type": "",
    "signature": "catch(SAXException e)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2574",
    "name": "getXMLReader",
    "return_type": "XMLReader",
    "signature": "getXMLReader()",
    "file_id": "F48",
    "start_line": 135,
    "text_preview": "n, ParserConfigurationException, IOException {\\n\t\tDocumentParser parser = new DocumentParser();\\n\\n\t\tXMLReader xmlReader = getXMLReader();\\n\t\txmlReader.setContentHandler(parser);\\n\t\txmlReader.setErrorHandler(parser);\\n\\n\t\ttry {\\n\t\t\txmlReader.setFeature(\"https://xml.org/sax/features/validation\", false);\\n\t\t} catch (SAXException "
  },
  {
    "method_id": "M2575",
    "name": "catch",
    "return_type": "",
    "signature": "catch(SAXException ex)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2576",
    "name": "resolveEntity",
    "return_type": "InputSource",
    "signature": "resolveEntity(String publicId, String systemId)",
    "file_id": "F48",
    "start_line": 175,
    "text_preview": "lReader = SAXParserFactory.newInstance().newSAXParser().getXMLReader();\\n\t\t}\\n\t\treturn xmlReader;\\n\t}\\n\\n\tpublic InputSource resolveEntity(String publicId, String systemId) throws SAXException {\\n\t\tif (publicId.equals(DTD_PUBLIC_ID) || publicId.equals(DTD_PUBLIC_ID_ALIAS)) {\\n\t\t\tInputStream in = DocumentParser.class.getResour"
  },
  {
    "method_id": "M2577",
    "name": "if",
    "return_type": "",
    "signature": "if(in == null)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2578",
    "name": "startElement",
    "return_type": "void",
    "signature": "startElement(String uri, String localName, String qName, Attributes attributes)",
    "file_id": "F48",
    "start_line": 190,
    "text_preview": "AspectJ - WARN - unknown DTD \" + publicId + \" - consider using \" + DTD_PUBLIC_ID);\\n\t\t\treturn null;\\n\t\t}\\n\t}\\n\\n\tpublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\\n\t\tif (ASPECT_ELEMENT.equals(qName)) {\\n\t\t\tString name = attributes.getValue(NAME_ATTRIBUTE);\\n\t\t\tStr"
  },
  {
    "method_id": "M2579",
    "name": "if",
    "return_type": "",
    "signature": "if(scopePattern != null)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2580",
    "name": "if",
    "return_type": "",
    "signature": "if(requiredType != null)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2581",
    "name": "if",
    "return_type": "",
    "signature": "if(inAspectJ)",
    "file_id": "F48",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2582",
    "name": "getWithinAttribute",
    "return_type": "String",
    "signature": "getWithinAttribute(Attributes attributes)",
    "file_id": "F48",
    "start_line": 293,
    "text_preview": "equals(qName)) {\\n\t\t\tinAspects = true;\\n\t\t} else if (INCLUDE_ELEMENT.equals(qName) && inWeaver) {\\n\t\t\tString typePattern = getWithinAttribute(attributes);\\n\t\t\tif (!isNull(typePattern)) {\\n\t\t\t\tdefinition.getIncludePatterns().add(typePattern);\\n\t\t\t}\\n\t\t} else if (EXCLUDE_ELEMENT.equals(qName) && inWeaver) {\\n\t\t\tString typePatter"
  },
  {
    "method_id": "M2583",
    "name": "endElement",
    "return_type": "void",
    "signature": "endElement(String uri, String localName, String qName)",
    "file_id": "F48",
    "start_line": 335,
    "text_preview": "ithinAttribute(Attributes attributes) {\\n\t\treturn replaceXmlAnd(attributes.getValue(WITHIN_ATTRIBUTE));\\n\t}\\n\\n\tpublic void endElement(String uri, String localName, String qName) throws SAXException {\\n\t\tif (CONCRETE_ASPECT_ELEMENT.equals(qName)) {\\n\t\t\tactiveConcreteAspectDefinition = null;\\n\t\t} else if (ASPECTJ_ELEMENT.equal"
  },
  {
    "method_id": "M2584",
    "name": "warning",
    "return_type": "void",
    "signature": "warning(SAXParseException e)",
    "file_id": "F48",
    "start_line": 349,
    "text_preview": "lement(uri, localName, qName);\\n\t}\\n\\n\t// TODO AV - define what we want for XML parser error - for now stderr\\n\tpublic void warning(SAXParseException e) throws SAXException {\\n\t\tsuper.warning(e);\\n\t}\\n\\n\tpublic void error(SAXParseException e) throws SAXException {\\n\t\tsuper.error(e);\\n\t}\\n\\n\tpublic void fatalError(SAXParseException"
  },
  {
    "method_id": "M2585",
    "name": "error",
    "return_type": "void",
    "signature": "error(SAXParseException e)",
    "file_id": "F48",
    "start_line": 353,
    "text_preview": "r - for now stderr\\n\tpublic void warning(SAXParseException e) throws SAXException {\\n\t\tsuper.warning(e);\\n\t}\\n\\n\tpublic void error(SAXParseException e) throws SAXException {\\n\t\tsuper.error(e);\\n\t}\\n\\n\tpublic void fatalError(SAXParseException e) throws SAXException {\\n\t\tsuper.fatalError(e);\\n\t}\\n\\n\tprivate static String replaceXmlAn"
  },
  {
    "method_id": "M2586",
    "name": "fatalError",
    "return_type": "void",
    "signature": "fatalError(SAXParseException e)",
    "file_id": "F48",
    "start_line": 357,
    "text_preview": "\tsuper.warning(e);\\n\t}\\n\\n\tpublic void error(SAXParseException e) throws SAXException {\\n\t\tsuper.error(e);\\n\t}\\n\\n\tpublic void fatalError(SAXParseException e) throws SAXException {\\n\t\tsuper.fatalError(e);\\n\t}\\n\\n\tprivate static String replaceXmlAnd(String expression) {\\n\t\t// TODO AV do we need to handle \"..)AND\" or \"AND(..\" ?\\n\t\tre"
  },
  {
    "method_id": "M2587",
    "name": "replaceXmlAnd",
    "return_type": "String",
    "signature": "replaceXmlAnd(String expression)",
    "file_id": "F48",
    "start_line": 193,
    "text_preview": " {\\n\t\tif (ASPECT_ELEMENT.equals(qName)) {\\n\t\t\tString name = attributes.getValue(NAME_ATTRIBUTE);\\n\t\t\tString scopePattern = replaceXmlAnd(attributes.getValue(SCOPE_ATTRIBUTE));\\n\t\t\tString requiredType = attributes.getValue(REQUIRES_ATTRIBUTE);\\n\t\t\tif (!isNull(name)) {\\n\t\t\t\tdefinition.getAspectClassNames().add(name);\\n\t\t\t\tif (s"
  },
  {
    "method_id": "M2588",
    "name": "isNull",
    "return_type": "boolean",
    "signature": "isNull(String s)",
    "file_id": "F48",
    "start_line": 195,
    "text_preview": "XmlAnd(attributes.getValue(SCOPE_ATTRIBUTE));\\n\t\t\tString requiredType = attributes.getValue(REQUIRES_ATTRIBUTE);\\n\t\t\tif (!isNull(name)) {\\n\t\t\t\tdefinition.getAspectClassNames().add(name);\\n\t\t\t\tif (scopePattern != null) {\\n\t\t\t\t\tdefinition.addScopedAspect(name, scopePattern);\\n\t\t\t\t}\\n\t\t\t\tif (requiredType != null) {\\n\t\t\t\t\tdefiniti"
  },
  {
    "method_id": "M2589",
    "name": "isTrue",
    "return_type": "boolean",
    "signature": "isTrue(String s)",
    "file_id": "F48",
    "start_line": 308,
    "text_preview": "Patterns().add(typePattern);\\n\t\t\t}\\n\t\t\tString beforeAndAfter = attributes.getValue(DUMP_BEFOREANDAFTER_ATTRIBUTE);\\n\t\t\tif (isTrue(beforeAndAfter)) {\\n\t\t\t\tdefinition.setDumpBefore(true);\\n\t\t\t}\\n\t\t\tString perWeaverDumpDir = attributes.getValue(DUMP_PERCLASSLOADERDIR_ATTRIBUTE);\\n\t\t\tif (isTrue(perWeaverDumpDir)) {\\n\t\t\t\tdefinition"
  },
  {
    "method_id": "M2590",
    "name": "deactivateCaching",
    "return_type": "void",
    "signature": "deactivateCaching()",
    "file_id": "F48",
    "start_line": 377,
    "text_preview": "ean isTrue(String s) {\\n\t\treturn (s != null && s.equals(\"true\"));\\n\t}\\n\\n\t/**\\n\t * Turn off caching\\n\t */\\n\tpublic static void deactivateCaching() {\\n\t\tCACHE = false;\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M2591",
    "name": "LightXMLParser",
    "return_type": "",
    "signature": "LightXMLParser()",
    "file_id": "F49",
    "start_line": 38,
    "text_preview": ", new char[] { '\\'' });\\n\t\tentities.put(\"lt\", new char[] { '<' });\\n\t\tentities.put(\"gt\", new char[] { '>' });\\n\t}\\n\\n\tpublic LightXMLParser() {\\n\t\tthis.name = null;\\n\t\tthis.attributes = new HashMap<>();\\n\t\tthis.children = new ArrayList<>();\\n\t}\\n\\n\tpublic ArrayList getChildrens() {\\n\t\treturn this.children;\\n\t}\\n\\n\tpublic String getNa"
  },
  {
    "method_id": "M2592",
    "name": "getChildrens",
    "return_type": "ArrayList",
    "signature": "getChildrens()",
    "file_id": "F49",
    "start_line": 44,
    "text_preview": ") {\\n\t\tthis.name = null;\\n\t\tthis.attributes = new HashMap<>();\\n\t\tthis.children = new ArrayList<>();\\n\t}\\n\\n\tpublic ArrayList getChildrens() {\\n\t\treturn this.children;\\n\t}\\n\\n\tpublic String getName() {\\n\t\treturn this.name;\\n\t}\\n\\n\tpublic void parseFromReader(Reader reader) throws Exception {\\n\t\tthis.pushedBackChar = NULL_CHAR;\\n\t\tthis"
  },
  {
    "method_id": "M2593",
    "name": "getName",
    "return_type": "String",
    "signature": "getName()",
    "file_id": "F49",
    "start_line": 48,
    "text_preview": "\\n\t\tthis.children = new ArrayList<>();\\n\t}\\n\\n\tpublic ArrayList getChildrens() {\\n\t\treturn this.children;\\n\t}\\n\\n\tpublic String getName() {\\n\t\treturn this.name;\\n\t}\\n\\n\tpublic void parseFromReader(Reader reader) throws Exception {\\n\t\tthis.pushedBackChar = NULL_CHAR;\\n\t\tthis.attributes = new HashMap<>();\\n\t\tthis.name = null;\\n\t\tthis.ch"
  },
  {
    "method_id": "M2594",
    "name": "parseFromReader",
    "return_type": "void",
    "signature": "parseFromReader(Reader reader)",
    "file_id": "F49",
    "start_line": 52,
    "text_preview": " ArrayList getChildrens() {\\n\t\treturn this.children;\\n\t}\\n\\n\tpublic String getName() {\\n\t\treturn this.name;\\n\t}\\n\\n\tpublic void parseFromReader(Reader reader) throws Exception {\\n\t\tthis.pushedBackChar = NULL_CHAR;\\n\t\tthis.attributes = new HashMap<>();\\n\t\tthis.name = null;\\n\t\tthis.children = new ArrayList<>();\\n\t\tthis.reader = reade"
  },
  {
    "method_id": "M2595",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2596",
    "name": "if",
    "return_type": "exception",
    "signature": "if(c != '<')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2597",
    "name": "skipBlanks",
    "return_type": "char",
    "signature": "skipBlanks()",
    "file_id": "F49",
    "start_line": 61,
    "text_preview": "= new ArrayList<>();\\n\t\tthis.reader = reader;\\n\\n\t\twhile (true) {\\n\t\t\t// Skips whiteSpaces, blanks, \\r\\n..\\n\t\t\tchar c = this.skipBlanks();\\n\\n\t\t\t// All xml should start by <xml, a <!-- or <nodeName, if not throw\\n\t\t\t// exception\\n\t\t\tif (c != '<') {\\n\t\t\t\tthrow new Exception(\"LightParser Exception: Expected < but got: \" + c);\\n\t\t\t}"
  },
  {
    "method_id": "M2598",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2599",
    "name": "switch",
    "return_type": "",
    "signature": "switch(c)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2600",
    "name": "getWhitespaces",
    "return_type": "char",
    "signature": "getWhitespaces(StringBuffer result)",
    "file_id": "F49",
    "start_line": 101,
    "text_preview": "\\n\t\t\tcase '\\n':\\n\t\t\tcase '\\r':\\n\t\t\tcase ' ':\\n\t\t\tcase '\\t':\\n\t\t\t\tbreak;\\n\t\t\tdefault:\\n\t\t\t\treturn c;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate char getWhitespaces(StringBuffer result) throws Exception {\\n\t\twhile (true) {\\n\t\t\tchar c = this.getNextChar();\\n\t\t\tswitch (c) {\\n\t\t\tcase ' ':\\n\t\t\tcase '\\t':\\n\t\t\tcase '\\n':\\n\t\t\t\tresult.append(c);\\n\t\t\tcase '\\r':\\n\t\t\t"
  },
  {
    "method_id": "M2601",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2602",
    "name": "switch",
    "return_type": "",
    "signature": "switch(c)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2603",
    "name": "getNodeName",
    "return_type": "void",
    "signature": "getNodeName(StringBuffer result)",
    "file_id": "F49",
    "start_line": 117,
    "text_preview": "'\\t':\\n\t\t\tcase '\\n':\\n\t\t\t\tresult.append(c);\\n\t\t\tcase '\\r':\\n\t\t\t\tbreak;\\n\t\t\tdefault:\\n\t\t\t\treturn c;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate void getNodeName(StringBuffer result) throws Exception {\\n\t\tchar c;\\n\t\twhile (true) {\\n\t\t\t// Iterate while next character is not [a-z] [A-Z] [0-9] [ .:_-] not\\n\t\t\t// null\\n\t\t\tc = this.getNextChar();\\n\t\t\tif (((c "
  },
  {
    "method_id": "M2604",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2605",
    "name": "getString",
    "return_type": "void",
    "signature": "getString(StringBuffer string)",
    "file_id": "F49",
    "start_line": 132,
    "text_preview": "\t\t\t&& (c != '.') && (c != ':')) {\\n\t\t\t\tthis.pushBackChar(c);\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t\tresult.append(c);\\n\t\t}\\n\t}\\n\\n\tprivate void getString(StringBuffer string) throws Exception {\\n\t\tchar delimiter = this.getNextChar();\\n\t\tif ((delimiter != '\\'') && (delimiter != '\"')) {\\n\t\t\tthrow new Exception(\"Parsing error. Expected ' or \\\"  but"
  },
  {
    "method_id": "M2606",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2607",
    "name": "if",
    "return_type": "",
    "signature": "if(c == delimiter)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2608",
    "name": "if",
    "return_type": "else",
    "signature": "if(c == '&')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2609",
    "name": "getPCData",
    "return_type": "void",
    "signature": "getPCData(StringBuffer data)",
    "file_id": "F49",
    "start_line": 151,
    "text_preview": "urn;\\n\t\t\t} else if (c == '&') {\\n\t\t\t\tthis.mapEntity(string);\\n\t\t\t} else {\\n\t\t\t\tstring.append(c);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate void getPCData(StringBuffer data) throws Exception {\\n\t\twhile (true) {\\n\t\t\tchar c = this.getNextChar();\\n\t\t\tif (c == '<') {\\n\t\t\t\tc = this.getNextChar();\\n\t\t\t\tif (c == '!') {\\n\t\t\t\t\tthis.checkCDATA(data);\\n\t\t\t\t} el"
  },
  {
    "method_id": "M2610",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2611",
    "name": "if",
    "return_type": "",
    "signature": "if(c == '<')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2612",
    "name": "if",
    "return_type": "",
    "signature": "if(c == '!')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2613",
    "name": "checkCDATA",
    "return_type": "boolean",
    "signature": "checkCDATA(StringBuffer buf)",
    "file_id": "F49",
    "start_line": 157,
    "text_preview": "e (true) {\\n\t\t\tchar c = this.getNextChar();\\n\t\t\tif (c == '<') {\\n\t\t\t\tc = this.getNextChar();\\n\t\t\t\tif (c == '!') {\\n\t\t\t\t\tthis.checkCDATA(data);\\n\t\t\t\t} else {\\n\t\t\t\t\tthis.pushBackChar(c);\\n\t\t\t\t\treturn;\\n\t\t\t\t}\\n\t\t\t} else {\\n\t\t\t\tdata.append(c);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate boolean checkCDATA(StringBuffer buf) throws Exception {\\n\t\tchar c = th"
  },
  {
    "method_id": "M2614",
    "name": "if",
    "return_type": "",
    "signature": "if(c != '[')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2615",
    "name": "while",
    "return_type": "",
    "signature": "while(delimiterCharsSkipped < 3)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2616",
    "name": "switch",
    "return_type": "",
    "signature": "switch(c)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2617",
    "name": "if",
    "return_type": "",
    "signature": "if(delimiterCharsSkipped < 2)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2618",
    "name": "if",
    "return_type": "",
    "signature": "if(delimiterCharsSkipped < 2)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2619",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < delimiterCharsSkipped; i++)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2620",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < delimiterCharsSkipped; i++)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2621",
    "name": "skipCommentOrXmlTag",
    "return_type": "void",
    "signature": "skipCommentOrXmlTag(int bracketLevel)",
    "file_id": "F49",
    "start_line": 74,
    "text_preview": ".getNextChar();\\n\\n\t\t\t// if starts with ! or ? it is <?xml or a comment: skip\\n\t\t\tif ((c == '!') || (c == '?')) {\\n\t\t\t\tthis.skipCommentOrXmlTag(0);\\n\t\t\t} else {\\n\t\t\t\t// it is a node, pusch character back\\n\t\t\t\tthis.pushBackChar(c);\\n\t\t\t\t// parse node\\n\t\t\t\tthis.parseNode(this);\\n\t\t\t\t// Only one root node, so finsh.\\n\t\t\t\treturn;\\n\t\t\t"
  },
  {
    "method_id": "M2622",
    "name": "if",
    "return_type": "",
    "signature": "if(bracketLevel == 0)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2623",
    "name": "if",
    "return_type": "",
    "signature": "if(c == '-')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2624",
    "name": "if",
    "return_type": "",
    "signature": "if(c == ']')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2625",
    "name": "if",
    "return_type": "else",
    "signature": "if(c == '[')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2626",
    "name": "if",
    "return_type": "else",
    "signature": "if(c == '-')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2627",
    "name": "if",
    "return_type": "else",
    "signature": "if(c == '[')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2628",
    "name": "while",
    "return_type": "",
    "signature": "while(level > 0)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2629",
    "name": "if",
    "return_type": "",
    "signature": "if(delim == NULL_CHAR)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2630",
    "name": "if",
    "return_type": "else",
    "signature": "if(bracketLevel <= 0)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2631",
    "name": "if",
    "return_type": "",
    "signature": "if(c == '<')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2632",
    "name": "if",
    "return_type": "else",
    "signature": "if(c == '>')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2633",
    "name": "if",
    "return_type": "",
    "signature": "if(c == '[')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2634",
    "name": "if",
    "return_type": "else",
    "signature": "if(c == ']')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2635",
    "name": "if",
    "return_type": "",
    "signature": "if(c == delim)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2636",
    "name": "parseNode",
    "return_type": "void",
    "signature": "parseNode(LightXMLParser elt)",
    "file_id": "F49",
    "start_line": 79,
    "text_preview": "OrXmlTag(0);\\n\t\t\t} else {\\n\t\t\t\t// it is a node, pusch character back\\n\t\t\t\tthis.pushBackChar(c);\\n\t\t\t\t// parse node\\n\t\t\t\tthis.parseNode(this);\\n\t\t\t\t// Only one root node, so finsh.\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate char skipBlanks() throws Exception {\\n\t\twhile (true) {\\n\t\t\tchar c = this.getNextChar();\\n\t\t\tswitch (c) {\\n\t\t\tcase '\\"
  },
  {
    "method_id": "M2637",
    "name": "if",
    "return_type": "",
    "signature": "if(c != '=')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2638",
    "name": "if",
    "return_type": "",
    "signature": "if(c == '/')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2639",
    "name": "if",
    "return_type": "",
    "signature": "if(c != '>')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2640",
    "name": "if",
    "return_type": "",
    "signature": "if(c != '<')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2641",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2642",
    "name": "if",
    "return_type": "",
    "signature": "if(c == '!')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2643",
    "name": "if",
    "return_type": "",
    "signature": "if(c != '<')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2644",
    "name": "if",
    "return_type": "",
    "signature": "if(c != '/')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2645",
    "name": "if",
    "return_type": "",
    "signature": "if(c == '/')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2646",
    "name": "while",
    "return_type": "comment",
    "signature": "while(c != '/')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2647",
    "name": "if",
    "return_type": "",
    "signature": "if(c == '!')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2648",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < 2; i++)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2649",
    "name": "if",
    "return_type": "",
    "signature": "if(c != '-')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2650",
    "name": "if",
    "return_type": "",
    "signature": "if(c != '<')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2651",
    "name": "if",
    "return_type": "",
    "signature": "if(c != '/')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2652",
    "name": "skipComment",
    "return_type": "void",
    "signature": "skipComment()",
    "file_id": "F49",
    "start_line": 227,
    "text_preview": " (c == ']') {\\n\t\t\t\t\tbracketLevel--;\\n\t\t\t\t} else if (c == '[') {\\n\t\t\t\t\tbracketLevel++;\\n\t\t\t\t} else if (c == '-') {\\n\t\t\t\t\tthis.skipComment();\\n\t\t\t\t\treturn;\\n\t\t\t\t}\\n\t\t\t} else if (c == '[') {\\n\t\t\t\tbracketLevel++;\\n\t\t\t}\\n\t\t}\\n\t\twhile (level > 0) {\\n\t\t\tc = this.getNextChar();\\n\t\t\tif (delim == NULL_CHAR) {\\n\t\t\t\tif ((c == '\"') || (c == '\\'')"
  },
  {
    "method_id": "M2653",
    "name": "while",
    "return_type": "",
    "signature": "while(dashes > 0)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2654",
    "name": "if",
    "return_type": "",
    "signature": "if(ch == '-')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2655",
    "name": "if",
    "return_type": "",
    "signature": "if(nextChar != '>')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2656",
    "name": "checkLiteral",
    "return_type": "boolean",
    "signature": "checkLiteral(String literal)",
    "file_id": "F49",
    "start_line": 174,
    "text_preview": "tChar();\\n\t\tif (c != '[') {\\n\t\t\tthis.pushBackChar(c);\\n\t\t\tthis.skipCommentOrXmlTag(0);\\n\t\t\treturn false;\\n\t\t} else if (!this.checkLiteral(\"CDATA[\")) {\\n\t\t\tthis.skipCommentOrXmlTag(1); // one [ has already been read\\n\t\t\treturn false;\\n\t\t} else {\\n\t\t\tint delimiterCharsSkipped = 0;\\n\t\t\twhile (delimiterCharsSkipped < 3) {\\n\t\t\t\tc = th"
  },
  {
    "method_id": "M2657",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < length; i++)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2658",
    "name": "getNextChar",
    "return_type": "char",
    "signature": "getNextChar()",
    "file_id": "F49",
    "start_line": 70,
    "text_preview": "\t\t\t\tthrow new Exception(\"LightParser Exception: Expected < but got: \" + c);\\n\t\t\t}\\n\\n\t\t\t// read next character\\n\t\t\tc = this.getNextChar();\\n\\n\t\t\t// if starts with ! or ? it is <?xml or a comment: skip\\n\t\t\tif ((c == '!') || (c == '?')) {\\n\t\t\t\tthis.skipCommentOrXmlTag(0);\\n\t\t\t} else {\\n\t\t\t\t// it is a node, pusch character back\\n\t\t\t"
  },
  {
    "method_id": "M2659",
    "name": "if",
    "return_type": "",
    "signature": "if(this.pushedBackChar != NULL_CHAR)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2660",
    "name": "if",
    "return_type": "",
    "signature": "if(i < 0)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2661",
    "name": "mapEntity",
    "return_type": "void",
    "signature": "mapEntity(StringBuffer buf)",
    "file_id": "F49",
    "start_line": 144,
    "text_preview": "\twhile (true) {\\n\t\t\tchar c = this.getNextChar();\\n\t\t\tif (c == delimiter) {\\n\t\t\t\treturn;\\n\t\t\t} else if (c == '&') {\\n\t\t\t\tthis.mapEntity(string);\\n\t\t\t} else {\\n\t\t\t\tstring.append(c);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate void getPCData(StringBuffer data) throws Exception {\\n\t\twhile (true) {\\n\t\t\tchar c = this.getNextChar();\\n\t\t\tif (c == '<') {\\n\t\t\t\t"
  },
  {
    "method_id": "M2662",
    "name": "while",
    "return_type": "",
    "signature": "while(true)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2663",
    "name": "if",
    "return_type": "",
    "signature": "if(c == ';')",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2664",
    "name": "catch",
    "return_type": "",
    "signature": "catch(NumberFormatException e)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2665",
    "name": "if",
    "return_type": "",
    "signature": "if(value == null)",
    "file_id": "F49",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2666",
    "name": "pushBackChar",
    "return_type": "void",
    "signature": "pushBackChar(char c)",
    "file_id": "F49",
    "start_line": 77,
    "text_preview": "= '!') || (c == '?')) {\\n\t\t\t\tthis.skipCommentOrXmlTag(0);\\n\t\t\t} else {\\n\t\t\t\t// it is a node, pusch character back\\n\t\t\t\tthis.pushBackChar(c);\\n\t\t\t\t// parse node\\n\t\t\t\tthis.parseNode(this);\\n\t\t\t\t// Only one root node, so finsh.\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate char skipBlanks() throws Exception {\\n\t\twhile (true) {\\n\t\t\tchar c = th"
  },
  {
    "method_id": "M2667",
    "name": "addChild",
    "return_type": "void",
    "signature": "addChild(LightXMLParser child)",
    "file_id": "F49",
    "start_line": 346,
    "text_preview": "\t\t\t\tthis.pushBackChar(c);\\n\t\t\t\t\tLightXMLParser child = this.createAnotherElement();\\n\t\t\t\t\tthis.parseNode(child);\\n\t\t\t\t\telt.addChild(child);\\n\t\t\t\t}\\n\t\t\t\tc = this.skipBlanks();\\n\t\t\t\tif (c != '<') {\\n\t\t\t\t\tthrow new Exception(\"Parsing error. Expected <, but got: \" + c);\\n\t\t\t\t}\\n\t\t\t\tc = this.getNextChar();\\n\t\t\t}\\n\t\t\tthis.pushBackChar("
  },
  {
    "method_id": "M2668",
    "name": "setAttribute",
    "return_type": "void",
    "signature": "setAttribute(String name, Object value)",
    "file_id": "F49",
    "start_line": 283,
    "text_preview": " character and push it back\\n\t\t\tthis.pushBackChar(this.skipBlanks());\\n\\n\t\t\temptyBuf(buf);\\n\t\t\tthis.getString(buf);\\n\\n\t\t\telt.setAttribute(key, buf);\\n\\n\t\t\t// Skip blanks\\n\t\t\tc = this.skipBlanks();\\n\t\t}\\n\t\tif (c == '/') {\\n\t\t\tc = this.getNextChar();\\n\t\t\tif (c != '>') {\\n\t\t\t\tthrow new Exception(\"Parsing error. Expected > but got: \" +"
  },
  {
    "method_id": "M2669",
    "name": "getAttributes",
    "return_type": "Object>",
    "signature": "getAttributes()",
    "file_id": "F49",
    "start_line": 455,
    "text_preview": "etAttribute(String name, Object value) {\\n\t\tthis.attributes.put(name, value.toString());\\n\t}\\n\\n\tpublic Map<String, Object> getAttributes() {\\n\t\treturn this.attributes;\\n\t}\\n\\n\tprivate LightXMLParser createAnotherElement() {\\n\t\treturn new LightXMLParser();\\n\t}\\n\\n\tprivate void setName(String name) {\\n\t\tthis.name = name;\\n\t}\\n\\n\tprivat"
  },
  {
    "method_id": "M2670",
    "name": "createAnotherElement",
    "return_type": "LightXMLParser",
    "signature": "createAnotherElement()",
    "file_id": "F49",
    "start_line": 344,
    "text_preview": "\t\tthis.skipComment();\\n\t\t\t\t} else {\\n\t\t\t\t\t// it is a new node\\n\t\t\t\t\tthis.pushBackChar(c);\\n\t\t\t\t\tLightXMLParser child = this.createAnotherElement();\\n\t\t\t\t\tthis.parseNode(child);\\n\t\t\t\t\telt.addChild(child);\\n\t\t\t\t}\\n\t\t\t\tc = this.skipBlanks();\\n\t\t\t\tif (c != '<') {\\n\t\t\t\t\tthrow new Exception(\"Parsing error. Expected <, but got: \" + c);"
  },
  {
    "method_id": "M2671",
    "name": "setName",
    "return_type": "void",
    "signature": "setName(String name)",
    "file_id": "F49",
    "start_line": 264,
    "text_preview": "t. Get its name\\n\t\tStringBuffer buf = new StringBuffer();\\n\t\tthis.getNodeName(buf);\\n\t\tString name = buf.toString();\\n\t\telt.setName(name);\\n\\n\t\tchar c = this.skipBlanks();\\n\t\twhile ((c != '>') && (c != '/')) {\\n\t\t\t// Get attributes\\n\t\t\temptyBuf(buf);\\n\t\t\tthis.pushBackChar(c);\\n\t\t\tthis.getNodeName(buf);\\n\t\t\tString key = buf.toStrin"
  },
  {
    "method_id": "M2672",
    "name": "emptyBuf",
    "return_type": "void",
    "signature": "emptyBuf(StringBuffer buf)",
    "file_id": "F49",
    "start_line": 269,
    "text_preview": "ing();\\n\t\telt.setName(name);\\n\\n\t\tchar c = this.skipBlanks();\\n\t\twhile ((c != '>') && (c != '/')) {\\n\t\t\t// Get attributes\\n\t\t\temptyBuf(buf);\\n\t\t\tthis.pushBackChar(c);\\n\t\t\tthis.getNodeName(buf);\\n\t\t\tString key = buf.toString();\\n\t\t\tc = this.skipBlanks();\\n\t\t\tif (c != '=') {\\n\t\t\t\tthrow new Exception(\"Parsing error. Expected = but go"
  },
  {
    "method_id": "M2673",
    "name": "SimpleAOPParser",
    "return_type": "",
    "signature": "SimpleAOPParser()",
    "file_id": "F50",
    "start_line": 69,
    "text_preview": "e boolean m_inWeaver;\\n\tprivate boolean m_inAspects;\\n\\n\tprivate Definition.ConcreteAspect m_lastConcreteAspect;\\n\\n\tprivate SimpleAOPParser() {\\n\t\tm_definition = new Definition();\\n\t}\\n\\n\tpublic static Definition parse(final URL url) throws Exception {\\n\t\t// FileReader freader = new FileReader(\"/tmp/aop.xml\");\\n\t\tInputStream in "
  },
  {
    "method_id": "M2674",
    "name": "parse",
    "return_type": "Definition",
    "signature": "parse(final URL url)",
    "file_id": "F50",
    "start_line": 73,
    "text_preview": "ct m_lastConcreteAspect;\\n\\n\tprivate SimpleAOPParser() {\\n\t\tm_definition = new Definition();\\n\t}\\n\\n\tpublic static Definition parse(final URL url) throws Exception {\\n\t\t// FileReader freader = new FileReader(\"/tmp/aop.xml\");\\n\t\tInputStream in = url.openStream();\\n\t\tLightXMLParser xml = new LightXMLParser();\\n\t\txml.parseFromReade"
  },
  {
    "method_id": "M2675",
    "name": "startElement",
    "return_type": "void",
    "signature": "startElement(String qName, Map<String, Object> attrMap)",
    "file_id": "F50",
    "start_line": 83,
    "text_preview": "in));\\n\t\tSimpleAOPParser sap = new SimpleAOPParser();\\n\t\ttraverse(sap, xml);\\n\t\treturn sap.m_definition;\\n\t}\\n\\n\tprivate void startElement(String qName, Map<String, Object> attrMap) throws Exception {\\n\t\tif (ASPECT_ELEMENT.equals(qName)) {\\n\t\t\tString name = (String) attrMap.get(NAME_ATTRIBUTE);\\n\t\t\tString scopePattern = replace"
  },
  {
    "method_id": "M2676",
    "name": "if",
    "return_type": "",
    "signature": "if(scopePattern != null)",
    "file_id": "F50",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2677",
    "name": "if",
    "return_type": "",
    "signature": "if(requiredType != null)",
    "file_id": "F50",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2678",
    "name": "if",
    "return_type": "",
    "signature": "if(m_inAspectJ)",
    "file_id": "F50",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2679",
    "name": "if",
    "return_type": "",
    "signature": "if(pattern != null)",
    "file_id": "F50",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2680",
    "name": "if",
    "return_type": "",
    "signature": "if(pattern != null)",
    "file_id": "F50",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2681",
    "name": "if",
    "return_type": "",
    "signature": "if(pattern != null)",
    "file_id": "F50",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2682",
    "name": "endElement",
    "return_type": "void",
    "signature": "endElement(String qName)",
    "file_id": "F50",
    "start_line": 224,
    "text_preview": "else {\\n\t\t\tthrow new Exception(\\n\t\t\t\t\t\"Unknown element while parsing <aspectj> element: \" + qName);\\n\t\t}\\n\t}\\n\\n\tprivate void endElement(String qName) throws Exception {\\n\t\tif (CONCRETE_ASPECT_ELEMENT.equals(qName)) {\\n\t\t\tm_lastConcreteAspect = null;\\n\t\t} else if (ASPECTJ_ELEMENT.equals(qName)) {\\n\t\t\tm_inAspectJ = false;\\n\t\t} els"
  },
  {
    "method_id": "M2683",
    "name": "getWithinAttribute",
    "return_type": "String",
    "signature": "getWithinAttribute(Map<String, Object> attributes)",
    "file_id": "F50",
    "start_line": 130,
    "text_preview": "ls(qName)) {\\n\t\t\tm_inAspects = true;\\n\t\t} else if (INCLUDE_ELEMENT.equals(qName) && m_inWeaver) {\\n\t\t\tString typePattern = getWithinAttribute(attrMap);\\n\t\t\tif (!isNull(typePattern)) {\\n\t\t\t\tm_definition.getIncludePatterns().add(typePattern);\\n\t\t\t}\\n\t\t} else if (EXCLUDE_ELEMENT.equals(qName) && m_inWeaver) {\\n\t\t\tString typePatte"
  },
  {
    "method_id": "M2684",
    "name": "replaceXmlAnd",
    "return_type": "String",
    "signature": "replaceXmlAnd(String expression)",
    "file_id": "F50",
    "start_line": 86,
    "text_preview": "{\\n\t\tif (ASPECT_ELEMENT.equals(qName)) {\\n\t\t\tString name = (String) attrMap.get(NAME_ATTRIBUTE);\\n\t\t\tString scopePattern = replaceXmlAnd((String) attrMap\\n\t\t\t\t\t.get(SCOPE_ATTRIBUTE));\\n\t\t\tString requiredType = (String) attrMap.get(REQUIRES_ATTRIBUTE);\\n\t\t\tif (!isNull(name)) {\\n\t\t\t\tm_definition.getAspectClassNames().add(name);"
  },
  {
    "method_id": "M2685",
    "name": "isNull",
    "return_type": "boolean",
    "signature": "isNull(String s)",
    "file_id": "F50",
    "start_line": 89,
    "text_preview": "String) attrMap\\n\t\t\t\t\t.get(SCOPE_ATTRIBUTE));\\n\t\t\tString requiredType = (String) attrMap.get(REQUIRES_ATTRIBUTE);\\n\t\t\tif (!isNull(name)) {\\n\t\t\t\tm_definition.getAspectClassNames().add(name);\\n\t\t\t\tif (scopePattern != null) {\\n\t\t\t\t\tm_definition.addScopedAspect(name, scopePattern);\\n\t\t\t\t}\\n\t\t\t\tif (requiredType != null) {\\n\t\t\t\t\tm_de"
  },
  {
    "method_id": "M2686",
    "name": "isTrue",
    "return_type": "boolean",
    "signature": "isTrue(String s)",
    "file_id": "F50",
    "start_line": 146,
    "text_preview": "s().add(typePattern);\\n\t\t\t}\\n\t\t\tString beforeAndAfter = (String) attrMap\\n\t\t\t\t\t.get(DUMP_BEFOREANDAFTER_ATTRIBUTE);\\n\t\t\tif (isTrue(beforeAndAfter)) {\\n\t\t\t\tm_definition.setDumpBefore(true);\\n\t\t\t}\\n\t\t\tString perWeaverDumpDir = (String) attrMap\\n\t\t\t\t\t.get(DUMP_PERCLASSLOADERDIR_ATTRIBUTE);\\n\t\t\tif (isTrue(perWeaverDumpDir)) {\\n\t\t\t\tm"
  },
  {
    "method_id": "M2687",
    "name": "traverse",
    "return_type": "void",
    "signature": "traverse(SimpleAOPParser sap, LightXMLParser xml)",
    "file_id": "F50",
    "start_line": 79,
    "text_preview": "ew LightXMLParser();\\n\t\txml.parseFromReader(new InputStreamReader(in));\\n\t\tSimpleAOPParser sap = new SimpleAOPParser();\\n\t\ttraverse(sap, xml);\\n\t\treturn sap.m_definition;\\n\t}\\n\\n\tprivate void startElement(String qName, Map<String, Object> attrMap) throws Exception {\\n\t\tif (ASPECT_ELEMENT.equals(qName)) {\\n\t\t\tString name = (Stri"
  },
  {
    "method_id": "M2688",
    "name": "for",
    "return_type": "",
    "signature": "for(LightXMLParser child : childrens)",
    "file_id": "F50",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2689",
    "name": "if",
    "return_type": "",
    "signature": "if(ShareBootstrapTypes)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2690",
    "name": "LTWWorld",
    "return_type": "",
    "signature": "LTWWorld(ClassLoader loader, IWeavingContext weavingContext, IMessageHandler handler, ICrossReferenceHandler xrefHandler)",
    "file_id": "F51",
    "start_line": 73,
    "text_preview": "\t} else {\\n\t\t\tconcurrentMapClass = null;\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * Build a World from a ClassLoader, for LTW support\\n\t */\\n\tpublic LTWWorld(ClassLoader loader, IWeavingContext weavingContext, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {\\n\t\tsuper(loader, handler, xrefHandler);\\n\t\tthis.weavingContext = weavingContex"
  },
  {
    "method_id": "M2691",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2692",
    "name": "getClassLoader",
    "return_type": "ClassLoader",
    "signature": "getClassLoader()",
    "file_id": "F51",
    "start_line": 87,
    "text_preview": "InJava5Way(true);\\n\t\tannotationFinder = ReflectionWorld.makeAnnotationFinderIfAny(loader, this);\\n\t}\\n\\n\tpublic ClassLoader getClassLoader() {\\n\t\treturn weavingContext.getClassLoader();\\n\t}\\n\\n\t// TEST\\n\t// this is probably easier: just mark anything loaded while loading aspects as not\\n\t// expendible... it also fixes a possible"
  },
  {
    "method_id": "M2693",
    "name": "isExpendable",
    "return_type": "boolean",
    "signature": "isExpendable(ResolvedType type)",
    "file_id": "F51",
    "start_line": 95,
    "text_preview": " bug whereby non-rewoven aspects are deemed expendible\\n\t// <exclude within=\"org.foo.aspects..*\"/>\\n\t// protected boolean isExpendable(ResolvedType type) {\\n\t// return ((type != null) && !loadingAspects && !type.isAspect() && (!type\\n\t// .isPrimitiveType()));\\n\t// }\\n\\n\t/**\\n\t * Override\\n\t */\\n\t@Override\\n\tprotected ReferenceTyp"
  },
  {
    "method_id": "M2694",
    "name": "resolveDelegate",
    "return_type": "ReferenceTypeDelegate",
    "signature": "resolveDelegate(ReferenceType ty)",
    "file_id": "F51",
    "start_line": 104,
    "text_preview": "sAspect() && (!type\\n\t// .isPrimitiveType()));\\n\t// }\\n\\n\t/**\\n\t * Override\\n\t */\\n\t@Override\\n\tprotected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {\\n\\n\t\t// use reflection delegates for all bootstrap types\\n\t\tReferenceTypeDelegate bootstrapLoaderDelegate = resolveIfBootstrapDelegate(ty);\\n\t\tif (bootstrapLoaderDelega"
  },
  {
    "method_id": "M2695",
    "name": "if",
    "return_type": "",
    "signature": "if(bootstrapLoaderDelegate != null)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2696",
    "name": "resolveIfBootstrapDelegate",
    "return_type": "ReferenceTypeDelegate",
    "signature": "resolveIfBootstrapDelegate(ReferenceType ty)",
    "file_id": "F51",
    "start_line": 107,
    "text_preview": "enceType ty) {\\n\\n\t\t// use reflection delegates for all bootstrap types\\n\t\tReferenceTypeDelegate bootstrapLoaderDelegate = resolveIfBootstrapDelegate(ty);\\n\t\tif (bootstrapLoaderDelegate != null) {\\n\t\t\treturn bootstrapLoaderDelegate;\\n\t\t}\\n\\n\t\treturn super.resolveDelegate(ty);\\n\t}\\n\\n\tprotected ReferenceTypeDelegate resolveIfBoots"
  },
  {
    "method_id": "M2697",
    "name": "if",
    "return_type": "",
    "signature": "if(bootRef != null)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2698",
    "name": "if",
    "return_type": "",
    "signature": "if(rtd != null)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2699",
    "name": "if",
    "return_type": "",
    "signature": "if(fc == 'j' || fc == 'c' || fc == 'o' || fc == 's')",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2700",
    "name": "if",
    "return_type": "",
    "signature": "if(bootstrapLoaderDelegate != null)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2701",
    "name": "resolveReflectionTypeDelegate",
    "return_type": "ReferenceTypeDelegate",
    "signature": "resolveReflectionTypeDelegate(ReferenceType ty, ClassLoader resolutionLoader)",
    "file_id": "F51",
    "start_line": 132,
    "text_preview": ") ||\\n\t\t// name.startsWith(\"sun.\") || name.startsWith(\"org.omg\")) {\\n\t\t// ReferenceTypeDelegate bootstrapLoaderDelegate = resolveReflectionTypeDelegate(ty, null);\\n\t\t// if (bootstrapLoaderDelegate != null) {\\n\t\t// // it's always fine to load these bytes: there's no weaving into them\\n\t\t// // and since the class isn't initia"
  },
  {
    "method_id": "M2702",
    "name": "loadedClass",
    "return_type": "void",
    "signature": "loadedClass(Class clazz)",
    "file_id": "F51",
    "start_line": 162,
    "text_preview": "der The class loader should, ideally,\\n\t * make this call on each not yet working\\n\t *\\n\t * @param clazz\\n\t */\\n\tpublic void loadedClass(Class clazz) {\\n\t}\\n\\n\tprivate static final long serialVersionUID = 1;\\n\\n\tpublic AnnotationFinder getAnnotationFinder() {\\n\t\treturn this.annotationFinder;\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see"
  },
  {
    "method_id": "M2703",
    "name": "getAnnotationFinder",
    "return_type": "AnnotationFinder",
    "signature": "getAnnotationFinder()",
    "file_id": "F51",
    "start_line": 167,
    "text_preview": "\\n\tpublic void loadedClass(Class clazz) {\\n\t}\\n\\n\tprivate static final long serialVersionUID = 1;\\n\\n\tpublic AnnotationFinder getAnnotationFinder() {\\n\t\treturn this.annotationFinder;\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weaver.reflect.IReflectionWorld#resolve(java.lang.Class)\\n\t */\\n\tpublic ResolvedType resolve(Cl"
  },
  {
    "method_id": "M2704",
    "name": "resolve",
    "return_type": "ResolvedType",
    "signature": "resolve(Class aClass)",
    "file_id": "F51",
    "start_line": 174,
    "text_preview": "() {\\n\t\treturn this.annotationFinder;\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weaver.reflect.IReflectionWorld#resolve(java.lang.Class)\\n\t */\\n\tpublic ResolvedType resolve(Class aClass) {\\n\t\treturn ReflectionWorld.resolve(this, aClass);\\n\t}\\n\\n\tprivate static Map<?, ?> makeConcurrentMap() {\\n\t\tif (concurrentMapClass "
  },
  {
    "method_id": "M2705",
    "name": "makeConcurrentMap",
    "return_type": ">",
    "signature": "makeConcurrentMap()",
    "file_id": "F51",
    "start_line": 64,
    "text_preview": "rapTypes;\\n\\n\tstatic {\\n\t\tif (ShareBootstrapTypes) {\\n\t\t\tconcurrentMapClass = makeConcurrentMapClass();\\n\t\t\tbootstrapTypes = makeConcurrentMap();\\n\t\t} else {\\n\t\t\tconcurrentMapClass = null;\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * Build a World from a ClassLoader, for LTW support\\n\t */\\n\tpublic LTWWorld(ClassLoader loader, IWeavingContext weavingContex"
  },
  {
    "method_id": "M2706",
    "name": "if",
    "return_type": "",
    "signature": "if(concurrentMapClass != null)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2707",
    "name": "catch",
    "return_type": "",
    "signature": "catch(InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ignored)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2708",
    "name": "makeConcurrentMapClass",
    "return_type": ">",
    "signature": "makeConcurrentMapClass()",
    "file_id": "F51",
    "start_line": 63,
    "text_preview": "eflectionBasedReferenceTypeDelegate>> */bootstrapTypes;\\n\\n\tstatic {\\n\t\tif (ShareBootstrapTypes) {\\n\t\t\tconcurrentMapClass = makeConcurrentMapClass();\\n\t\t\tbootstrapTypes = makeConcurrentMap();\\n\t\t} else {\\n\t\t\tconcurrentMapClass = null;\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * Build a World from a ClassLoader, for LTW support\\n\t */\\n\tpublic LTWWorld(Cla"
  },
  {
    "method_id": "M2709",
    "name": "for",
    "return_type": "",
    "signature": "for(String betterChoice : betterChoices)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2710",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException cnfe)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2711",
    "name": "catch",
    "return_type": "",
    "signature": "catch(SecurityException se)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2712",
    "name": "isRunMinimalMemory",
    "return_type": "boolean",
    "signature": "isRunMinimalMemory()",
    "file_id": "F51",
    "start_line": 208,
    "text_preview": "in a\\n\t\t\t\t// package starting with java like java.util.concurrent\\n\t\t\t}\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isRunMinimalMemory() {\\n\t\tif (isRunMinimalMemorySet()) {\\n\t\t\treturn super.isRunMinimalMemory();\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\t// One type is completed at a time, if multiple need doing then they\\n\t// are queu"
  },
  {
    "method_id": "M2713",
    "name": "completeBinaryType",
    "return_type": "void",
    "signature": "completeBinaryType(ResolvedType ret)",
    "file_id": "F51",
    "start_line": 221,
    "text_preview": "tionInProgress = false;\\n\tprivate List<ResolvedType> typesForCompletion = new ArrayList<>();\\n\\n\t@Override\\n\tprotected void completeBinaryType(ResolvedType ret) {\\n\t\tif (isLocallyDefined(ret.getName())) {\\n\t\t\tif (typeCompletionInProgress) {\\n\t\t\t\ttypesForCompletion.add(ret);\\n\t\t\t} else {\\n\t\t\t\ttry {\\n\t\t\t\t\ttypeCompletionInProgress "
  },
  {
    "method_id": "M2714",
    "name": "if",
    "return_type": "",
    "signature": "if(typeCompletionInProgress)",
    "file_id": "F51",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2715",
    "name": "completeHierarchyForType",
    "return_type": "void",
    "signature": "completeHierarchyForType(ResolvedType ret)",
    "file_id": "F51",
    "start_line": 228,
    "text_preview": "mpletionInProgress) {\\n\t\t\t\ttypesForCompletion.add(ret);\\n\t\t\t} else {\\n\t\t\t\ttry {\\n\t\t\t\t\ttypeCompletionInProgress = true;\\n\t\t\t\t\tcompleteHierarchyForType(ret);\\n\t\t\t\t} finally {\\n\t\t\t\t\ttypeCompletionInProgress = false;\\n\t\t\t\t}\\n\t\t\t\twhile (typesForCompletion.size() != 0) {\\n\t\t\t\t\tResolvedType rt = typesForCompletion.get(0);\\n\t\t\t\t\tcomplete"
  },
  {
    "method_id": "M2716",
    "name": "needsCompletion",
    "return_type": "boolean",
    "signature": "needsCompletion()",
    "file_id": "F51",
    "start_line": 251,
    "text_preview": "ue);\\n\t\tweaveInterTypeDeclarations(ret);\\n\t\tgetLint().typeNotExposedToWeaver.setSuppressed(false);\\n\t}\\n\\n\tprotected boolean needsCompletion() {\\n\t\treturn true;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isLocallyDefined(String classname) {\\n\t\treturn weavingContext.isLocallyDefined(classname);\\n\t}\\n\\n\tprotected ResolvedType completeNonLocal"
  },
  {
    "method_id": "M2717",
    "name": "isLocallyDefined",
    "return_type": "boolean",
    "signature": "isLocallyDefined(String classname)",
    "file_id": "F51",
    "start_line": 222,
    "text_preview": "dType> typesForCompletion = new ArrayList<>();\\n\\n\t@Override\\n\tprotected void completeBinaryType(ResolvedType ret) {\\n\t\tif (isLocallyDefined(ret.getName())) {\\n\t\t\tif (typeCompletionInProgress) {\\n\t\t\t\ttypesForCompletion.add(ret);\\n\t\t\t} else {\\n\t\t\t\ttry {\\n\t\t\t\t\ttypeCompletionInProgress = true;\\n\t\t\t\t\tcompleteHierarchyForType(ret);\\n\t"
  },
  {
    "method_id": "M2718",
    "name": "completeNonLocalType",
    "return_type": "ResolvedType",
    "signature": "completeNonLocalType(ResolvedType ret)",
    "file_id": "F51",
    "start_line": 240,
    "text_preview": "orType(rt);\\n\t\t\t\t\ttypesForCompletion.remove(0);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t} else {\\n\t\t\tif (!ret.needsModifiableDelegate()) {\\n\t\t\t\tret = completeNonLocalType(ret);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate void completeHierarchyForType(ResolvedType ret) {\\n\t\tgetLint().typeNotExposedToWeaver.setSuppressed(true);\\n\t\tweaveInterTypeDeclarations(ret);\\n\t\tgetLint("
  },
  {
    "method_id": "M2719",
    "name": "storeClass",
    "return_type": "void",
    "signature": "storeClass(JavaClass clazz)",
    "file_id": "F51",
    "start_line": 274,
    "text_preview": "Type) toResolve, getClassLoader());\\n\t\t((ReferenceType) ret).setDelegate(rtd);\\n\t\treturn ret;\\n\t}\\n\\n\t@Override\\n\tpublic void storeClass(JavaClass clazz) {\\n\t\tensureRepositorySetup();\\n\t\tdelegate.storeClass(clazz);\\n\t}\\n\\n\t@Override\\n\tpublic void accept(IVisitor visitor) {\\n\t\tvisitor.visitObject(\"Class loader:\");\\n\t\tvisitor.visitObj"
  },
  {
    "method_id": "M2720",
    "name": "accept",
    "return_type": "void",
    "signature": "accept(IVisitor visitor)",
    "file_id": "F51",
    "start_line": 280,
    "text_preview": "void storeClass(JavaClass clazz) {\\n\t\tensureRepositorySetup();\\n\t\tdelegate.storeClass(clazz);\\n\t}\\n\\n\t@Override\\n\tpublic void accept(IVisitor visitor) {\\n\t\tvisitor.visitObject(\"Class loader:\");\\n\t\tvisitor.visitObject(classLoaderString);\\n\t\tvisitor.visitObject(\"Class loader parent:\");\\n\t\tvisitor.visitObject(classLoaderParentStrin"
  },
  {
    "method_id": "M2721",
    "name": "isLoadtimeWeaving",
    "return_type": "boolean",
    "signature": "isLoadtimeWeaving()",
    "file_id": "F51",
    "start_line": 288,
    "text_preview": "t(\"Class loader parent:\");\\n\t\tvisitor.visitObject(classLoaderParentString);\\n\t\tsuper.accept(visitor);\\n\t}\\n\\n\tpublic boolean isLoadtimeWeaving() {\\n\t\treturn true;\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M2722",
    "name": "addDeclareErrorOrWarningRelationship",
    "return_type": "void",
    "signature": "addDeclareErrorOrWarningRelationship(AsmManager model, Shadow affectedShadow, Checker deow)",
    "file_id": "F52",
    "start_line": 76,
    "text_preview": " = \"annotated removed by\";\\n\\n\t/**\\n\t * Add a relationship for a declare error or declare warning\\n\t */\\n\tpublic static void addDeclareErrorOrWarningRelationship(AsmManager model, Shadow affectedShadow, Checker deow) {\\n\t\tif (model == null) {\\n\t\t\treturn;\\n\t\t}\\n\t\tif (affectedShadow.getSourceLocation() == null || deow.getSourceLo"
  },
  {
    "method_id": "M2723",
    "name": "if",
    "return_type": "",
    "signature": "if(model == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2724",
    "name": "if",
    "return_type": "",
    "signature": "if(World.createInjarHierarchy)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2725",
    "name": "if",
    "return_type": "",
    "signature": "if(targetNode == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2726",
    "name": "if",
    "return_type": "",
    "signature": "if(targetHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2727",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2728",
    "name": "isMixinRelated",
    "return_type": "boolean",
    "signature": "isMixinRelated(ResolvedTypeMunger typeTransformer)",
    "file_id": "F52",
    "start_line": 116,
    "text_preview": " {\\n\t\t\tmodel.addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());\\n\t\t}\\n\t}\\n\\n\tprivate static boolean isMixinRelated(ResolvedTypeMunger typeTransformer) {\\n\t\tKind kind = typeTransformer.getKind();\\n\t\treturn kind == ResolvedTypeMunger.MethodDelegate2 || kind == ResolvedTypeMunger.FieldHost\\n\t\t\t\t|| (kind ="
  },
  {
    "method_id": "M2729",
    "name": "addRelationship",
    "return_type": "void",
    "signature": "addRelationship(AsmManager model, ResolvedType onType, ResolvedTypeMunger typeTransformer,\n\t\t\tResolvedType originatingAspect)",
    "file_id": "F52",
    "start_line": 125,
    "text_preview": "pe transformation (declare parents, intertype method declaration, declare annotation on type).\\n\t */\\n\tpublic static void addRelationship(AsmManager model, ResolvedType onType, ResolvedTypeMunger typeTransformer,\\n\t\t\tResolvedType originatingAspect) {\\n\t\tif (model == null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (World.createInjarHierarchy "
  },
  {
    "method_id": "M2730",
    "name": "if",
    "return_type": "",
    "signature": "if(model == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2731",
    "name": "if",
    "return_type": "",
    "signature": "if(closer != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2732",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceNode == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2733",
    "name": "if",
    "return_type": "declaration",
    "signature": "if(World.createInjarHierarchy)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2734",
    "name": "if",
    "return_type": "",
    "signature": "if(closer2 != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2735",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2736",
    "name": "if",
    "return_type": "",
    "signature": "if(targetHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2737",
    "name": "findOrFakeUpNode",
    "return_type": "String",
    "signature": "findOrFakeUpNode(AsmManager model, ResolvedType onType)",
    "file_id": "F52",
    "start_line": 190,
    "text_preview": "Provider().createHandleIdentifier(sourceNode);\\n\t\t\tif (sourceHandle == null) {\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t\tString targetHandle = findOrFakeUpNode(model, onType);\\n\t\t\tif (targetHandle == null) {\\n\t\t\t\treturn;\\n\t\t\t}\\n\t\t\tIRelationshipMap mapper = model.getRelationshipMap();\\n\t\t\tIRelationship foreward = mapper.get(sourceHandle, IRelation"
  },
  {
    "method_id": "M2738",
    "name": "if",
    "return_type": "",
    "signature": "if(node == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2739",
    "name": "if",
    "return_type": "",
    "signature": "if(bpath == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2740",
    "name": "if",
    "return_type": "",
    "signature": "if(pos != -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2741",
    "name": "if",
    "return_type": "",
    "signature": "if(element != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2742",
    "name": "if",
    "return_type": "1",
    "signature": "if(dotClassPosition == -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2743",
    "name": "if",
    "return_type": "",
    "signature": "if(closernode == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2744",
    "name": "createFileStructureNode",
    "return_type": "IProgramElement",
    "signature": "createFileStructureNode(AsmManager asm, String sourceFilePath)",
    "file_id": "F52",
    "start_line": 220,
    "text_preview": "ing bpath = onType.getBinaryPath();\\n\t\t\tif (bpath == null) {\\n\t\t\t\treturn model.getHandleProvider().createHandleIdentifier(createFileStructureNode(model, canonicalFilePath));\\n\t\t\t} else {\\n\t\t\t\tIProgramElement programElement = model.getHierarchy().getRoot();\\n\t\t\t\t// =Foo/,<g(G.class[G\\n\t\t\t\tStringBuilder phantomHandle = new Str"
  },
  {
    "method_id": "M2745",
    "name": "if",
    "return_type": "",
    "signature": "if(lastSlash == -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2746",
    "name": "if",
    "return_type": "",
    "signature": "if(i > lastSlash && i != -1 && j != -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2747",
    "name": "isBinaryAspect",
    "return_type": "boolean",
    "signature": "isBinaryAspect(ResolvedType aspect)",
    "file_id": "F52",
    "start_line": 131,
    "text_preview": "former,\\n\t\t\tResolvedType originatingAspect) {\\n\t\tif (model == null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (World.createInjarHierarchy && isBinaryAspect(originatingAspect)) {\\n\t\t\tcreateHierarchy(model, typeTransformer, originatingAspect);\\n\t\t}\\n\\n\t\tif (originatingAspect.getSourceLocation() != null) {\\n\t\t\tString sourceHandle = \"\";\\n\t\t\tIProgram"
  },
  {
    "method_id": "M2748",
    "name": "getBinarySourceLocation",
    "return_type": "ISourceLocation",
    "signature": "getBinarySourceLocation(ResolvedType aspect, ISourceLocation sl)",
    "file_id": "F52",
    "start_line": 309,
    "text_preview": " all advice, pointcuts and deows contained within the\\n\t * resolvedDeclaringAspect.\\n\t */\\n\tprivate static ISourceLocation getBinarySourceLocation(ResolvedType aspect, ISourceLocation sl) {\\n\t\tif (sl == null) {\\n\t\t\treturn null;\\n\t\t}\\n\t\tString sourceFileName = null;\\n\t\tif (aspect instanceof ReferenceType) {\\n\t\t\tString s = ((Refe"
  },
  {
    "method_id": "M2749",
    "name": "if",
    "return_type": "",
    "signature": "if(sl == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2750",
    "name": "if",
    "return_type": "",
    "signature": "if(aspect instanceof ReferenceType)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2751",
    "name": "if",
    "return_type": "",
    "signature": "if(i != -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2752",
    "name": "createSourceLocation",
    "return_type": "ISourceLocation",
    "signature": "createSourceLocation(String sourcefilename, ResolvedType aspect, ISourceLocation sl)",
    "file_id": "F52",
    "start_line": 328,
    "text_preview": "ation.NO_COLUMN : sl.getColumn()), sl.getContext(), sourceFileName);\\n\t\treturn sLoc;\\n\t}\\n\\n\tprivate static ISourceLocation createSourceLocation(String sourcefilename, ResolvedType aspect, ISourceLocation sl) {\\n\t\tISourceLocation sLoc = new SourceLocation(getBinaryFile(aspect), sl.getLine(), sl.getEndLine(),\\n\t\t\t\t((sl.getCol"
  },
  {
    "method_id": "M2753",
    "name": "getSourceFileName",
    "return_type": "String",
    "signature": "getSourceFileName(ResolvedType aspect)",
    "file_id": "F52",
    "start_line": 334,
    "text_preview": "SourceLocation.NO_COLUMN : sl.getColumn()), sl.getContext(), sourcefilename);\\n\t\treturn sLoc;\\n\t}\\n\\n\tprivate static String getSourceFileName(ResolvedType aspect) {\\n\t\tString sourceFileName = null;\\n\t\tif (aspect instanceof ReferenceType) {\\n\t\t\tString s = ((ReferenceType) aspect).getDelegate().getSourcefilename();\\n\t\t\tint i = s"
  },
  {
    "method_id": "M2754",
    "name": "if",
    "return_type": "",
    "signature": "if(aspect instanceof ReferenceType)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2755",
    "name": "if",
    "return_type": "",
    "signature": "if(i != -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2756",
    "name": "getBinaryFile",
    "return_type": "File",
    "signature": "getBinaryFile(ResolvedType aspect)",
    "file_id": "F52",
    "start_line": 323,
    "text_preview": "FileName = s.substring(i + 1);\\n\t\t\t} else {\\n\t\t\t\tsourceFileName = s;\\n\t\t\t}\\n\t\t}\\n\t\tISourceLocation sLoc = new SourceLocation(getBinaryFile(aspect), sl.getLine(), sl.getEndLine(),\\n\t\t\t\t((sl.getColumn() == 0) ? ISourceLocation.NO_COLUMN : sl.getColumn()), sl.getContext(), sourceFileName);\\n\t\treturn sLoc;\\n\t}\\n\\n\tprivate static ISo"
  },
  {
    "method_id": "M2757",
    "name": "if",
    "return_type": "",
    "signature": "if(i != -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2758",
    "name": "createHierarchy",
    "return_type": "void",
    "signature": "createHierarchy(AsmManager model, ResolvedTypeMunger typeTransformer, ResolvedType aspect)",
    "file_id": "F52",
    "start_line": 132,
    "text_preview": "t) {\\n\t\tif (model == null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (World.createInjarHierarchy && isBinaryAspect(originatingAspect)) {\\n\t\t\tcreateHierarchy(model, typeTransformer, originatingAspect);\\n\t\t}\\n\\n\t\tif (originatingAspect.getSourceLocation() != null) {\\n\t\t\tString sourceHandle = \"\";\\n\t\t\tIProgramElement sourceNode = null;\\n\t\t\tif (typeTr"
  },
  {
    "method_id": "M2759",
    "name": "if",
    "return_type": "",
    "signature": "if(filenode == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2760",
    "name": "if",
    "return_type": "",
    "signature": "if(filenode != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2761",
    "name": "if",
    "return_type": "",
    "signature": "if(binaries == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2762",
    "name": "if",
    "return_type": "location",
    "signature": "if(pkgNode == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2763",
    "name": "addDeclareAnnotationRelationship",
    "return_type": "void",
    "signature": "addDeclareAnnotationRelationship(AsmManager model, ISourceLocation declareAnnotationLocation,\n\t\t\tISourceLocation annotatedLocation, boolean isRemove)",
    "file_id": "F52",
    "start_line": 472,
    "text_preview": "\\n\t * this method if that is the case as they will look the entities up in the structure model.\\n\t */\\n\tpublic static void addDeclareAnnotationRelationship(AsmManager model, ISourceLocation declareAnnotationLocation,\\n\t\t\tISourceLocation annotatedLocation, boolean isRemove) {\\n\t\tif (model == null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tIProgra"
  },
  {
    "method_id": "M2764",
    "name": "if",
    "return_type": "",
    "signature": "if(model == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2765",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2766",
    "name": "if",
    "return_type": "",
    "signature": "if(targetHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2767",
    "name": "if",
    "return_type": "",
    "signature": "if(isRemove)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2768",
    "name": "createHierarchyForBinaryAspect",
    "return_type": "void",
    "signature": "createHierarchyForBinaryAspect(AsmManager asm, ShadowMunger munger)",
    "file_id": "F52",
    "start_line": 85,
    "text_preview": "tSourceLocation() == null || deow.getSourceLocation() == null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (World.createInjarHierarchy) {\\n\t\t\tcreateHierarchyForBinaryAspect(model, deow);\\n\t\t}\\n\\n\t\tIProgramElement targetNode = getNode(model, affectedShadow);\\n\t\tif (targetNode == null) {\\n\t\t\treturn;\\n\t\t}\\n\t\tString targetHandle = targetNode.getHandle"
  },
  {
    "method_id": "M2769",
    "name": "if",
    "return_type": "",
    "signature": "if(binaries == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2770",
    "name": "if",
    "return_type": "location",
    "signature": "if(pkgNode == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2771",
    "name": "addPointcuts",
    "return_type": "void",
    "signature": "addPointcuts(AsmManager model, String sourcefilename, ResolvedType aspect,\n\t\t\tIProgramElement containingAspect, ResolvedMember[] pointcuts)",
    "file_id": "F52",
    "start_line": 597,
    "text_preview": "Modifiers(), null, null);\\n\t\tclassFileNode.addChild(aspectNode);\\n\\n\t\tString sourcefilename = getSourceFileName(aspect);\\n\t\taddPointcuts(asm, sourcefilename, aspect, aspectNode, aspect.getDeclaredPointcuts());\\n\t\taddChildNodes(asm, aspect, aspectNode, aspect.getDeclaredAdvice());\\n\t\taddChildNodes(asm, aspect, aspectNode, asp"
  },
  {
    "method_id": "M2772",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember pointcut : pointcuts)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2773",
    "name": "if",
    "return_type": "",
    "signature": "if(pointcut instanceof ResolvedPointcutDefinition)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2774",
    "name": "if",
    "return_type": "",
    "signature": "if(sLoc == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2775",
    "name": "addChildNodes",
    "return_type": "void",
    "signature": "addChildNodes(AsmManager asm, ResolvedType aspect, IProgramElement parent, ResolvedMember[] children)",
    "file_id": "F52",
    "start_line": 461,
    "text_preview": "ation(aspect, aspect.getSourceLocation()), aspect.getModifiers(), null, null);\\n\t\tclassFileNode.addChild(aspectNode);\\n\\n\t\taddChildNodes(model, aspect, aspectNode, aspect.getDeclaredPointcuts());\\n\\n\t\taddChildNodes(model, aspect, aspectNode, aspect.getDeclaredAdvice());\\n\t\taddChildNodes(model, aspect, aspectNode, aspect.getD"
  },
  {
    "method_id": "M2776",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember pcd : children)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2777",
    "name": "if",
    "return_type": "",
    "signature": "if(pcd instanceof ResolvedPointcutDefinition)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2778",
    "name": "if",
    "return_type": "",
    "signature": "if(sLoc == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2779",
    "name": "addChildNodes",
    "return_type": "void",
    "signature": "addChildNodes(AsmManager asm, ResolvedType aspect, IProgramElement parent, Collection<?> children)",
    "file_id": "F52",
    "start_line": 461,
    "text_preview": "ation(aspect, aspect.getSourceLocation()), aspect.getModifiers(), null, null);\\n\t\tclassFileNode.addChild(aspectNode);\\n\\n\t\taddChildNodes(model, aspect, aspectNode, aspect.getDeclaredPointcuts());\\n\\n\t\taddChildNodes(model, aspect, aspectNode, aspect.getDeclaredAdvice());\\n\t\taddChildNodes(model, aspect, aspectNode, aspect.getD"
  },
  {
    "method_id": "M2780",
    "name": "for",
    "return_type": "",
    "signature": "for(Object element: children)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2781",
    "name": "if",
    "return_type": "",
    "signature": "if(element instanceof DeclareErrorOrWarning)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2782",
    "name": "if",
    "return_type": "else",
    "signature": "if(element instanceof Advice)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2783",
    "name": "if",
    "return_type": "else",
    "signature": "if(element instanceof DeclareParents)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2784",
    "name": "if",
    "return_type": "else",
    "signature": "if(element instanceof BcelTypeMunger)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2785",
    "name": "if",
    "return_type": "",
    "signature": "if(newChild != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2786",
    "name": "createDeclareErrorOrWarningChild",
    "return_type": "",
    "signature": "createDeclareErrorOrWarningChild(AsmManager asm, ShadowMunger munger,\n\t// DeclareErrorOrWarning decl, int count)",
    "file_id": "F52",
    "start_line": 651,
    "text_preview": "r = 0;\\n\t\t\t\tif (decl.isError()) {\\n\t\t\t\t\tcounter = deCtr++;\\n\t\t\t\t} else {\\n\t\t\t\t\tcounter = dwCtr++;\\n\t\t\t\t}\\n\t\t\t\tparent.addChild(createDeclareErrorOrWarningChild(asm, aspect, decl, counter));\\n\t\t\t} else if (element instanceof Advice) {\\n\t\t\t\tAdvice advice = (Advice) element;\\n\t\t\t\tparent.addChild(createAdviceChild(asm, advice));\\n\t\t\t"
  },
  {
    "method_id": "M2787",
    "name": "if",
    "return_type": "",
    "signature": "if(count != -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2788",
    "name": "createDeclareErrorOrWarningChild",
    "return_type": "IProgramElement",
    "signature": "createDeclareErrorOrWarningChild(AsmManager model, ResolvedType aspect,\n\t\t\tDeclareErrorOrWarning decl, int count)",
    "file_id": "F52",
    "start_line": 651,
    "text_preview": "r = 0;\\n\t\t\t\tif (decl.isError()) {\\n\t\t\t\t\tcounter = deCtr++;\\n\t\t\t\t} else {\\n\t\t\t\t\tcounter = dwCtr++;\\n\t\t\t\t}\\n\t\t\t\tparent.addChild(createDeclareErrorOrWarningChild(asm, aspect, decl, counter));\\n\t\t\t} else if (element instanceof Advice) {\\n\t\t\t\tAdvice advice = (Advice) element;\\n\t\t\t\tparent.addChild(createAdviceChild(asm, advice));\\n\t\t\t"
  },
  {
    "method_id": "M2789",
    "name": "if",
    "return_type": "",
    "signature": "if(count != -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2790",
    "name": "createAdviceChild",
    "return_type": "IProgramElement",
    "signature": "createAdviceChild(AsmManager model, Advice advice)",
    "file_id": "F52",
    "start_line": 654,
    "text_preview": ", decl, counter));\\n\t\t\t} else if (element instanceof Advice) {\\n\t\t\t\tAdvice advice = (Advice) element;\\n\t\t\t\tparent.addChild(createAdviceChild(asm, advice));\\n\t\t\t} else if (element instanceof DeclareParents) {\\n\t\t\t\tparent.addChild(createDeclareParentsChild(asm, (DeclareParents) element));\\n\t\t\t} else if (element instanceof Bcel"
  },
  {
    "method_id": "M2791",
    "name": "createIntertypeDeclaredChild",
    "return_type": "IProgramElement",
    "signature": "createIntertypeDeclaredChild(AsmManager model, ResolvedType aspect, BcelTypeMunger itd)",
    "file_id": "F52",
    "start_line": 658,
    "text_preview": "hild(asm, (DeclareParents) element));\\n\t\t\t} else if (element instanceof BcelTypeMunger) {\\n\t\t\t\tIProgramElement newChild = createIntertypeDeclaredChild(asm, aspect, (BcelTypeMunger) element);\\n\t\t\t\t// newChild==null means it is something that could not be handled by createIntertypeDeclaredChild()\\n\t\t\t\tif (newChild != null) {"
  },
  {
    "method_id": "M2792",
    "name": "if",
    "return_type": "",
    "signature": "if(kind == ResolvedTypeMunger.Field)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2793",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == ResolvedTypeMunger.Method)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2794",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == ResolvedTypeMunger.Constructor)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2795",
    "name": "if",
    "return_type": "else",
    "signature": "if(kind == ResolvedTypeMunger.MethodDelegate2)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2796",
    "name": "setParams",
    "return_type": "void",
    "signature": "setParams(IProgramElement pe, ResolvedMember sig)",
    "file_id": "F52",
    "start_line": 732,
    "text_preview": ", itd.getSourceLocation()), rtMunger.getSignature().getModifiers(), null, Collections.<IProgramElement>emptyList());\\n\t\t\tsetParams(pe, sig);\\n\t\t\treturn pe;\\n\t\t} else if (kind == ResolvedTypeMunger.Constructor) {\\n\t\t\tString name = sig.getDeclaringType().getClassName() + \".\" + sig.getDeclaringType().getClassName();\\n\t\t\tif (na"
  },
  {
    "method_id": "M2797",
    "name": "if",
    "return_type": "",
    "signature": "if(ts == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2798",
    "name": "for",
    "return_type": "",
    "signature": "for(UnresolvedType t : ts)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2799",
    "name": "createDeclareParentsChild",
    "return_type": "IProgramElement",
    "signature": "createDeclareParentsChild(AsmManager model, DeclareParents decp)",
    "file_id": "F52",
    "start_line": 656,
    "text_preview": "parent.addChild(createAdviceChild(asm, advice));\\n\t\t\t} else if (element instanceof DeclareParents) {\\n\t\t\t\tparent.addChild(createDeclareParentsChild(asm, (DeclareParents) element));\\n\t\t\t} else if (element instanceof BcelTypeMunger) {\\n\t\t\t\tIProgramElement newChild = createIntertypeDeclaredChild(asm, aspect, (BcelTypeMunger) "
  },
  {
    "method_id": "M2800",
    "name": "setParentTypesOnDeclareParentsNode",
    "return_type": "void",
    "signature": "setParentTypesOnDeclareParentsNode(DeclareParents decp, IProgramElement decpElement)",
    "file_id": "F52",
    "start_line": 779,
    "text_preview": ".getDeclaringType(), decp.getSourceLocation()), Modifier.PUBLIC, null,\\n\t\t\t\tCollections.<IProgramElement>emptyList());\\n\t\tsetParentTypesOnDeclareParentsNode(decp, decpElement);\\n\t\treturn decpElement;\\n\t}\\n\\n\tprivate static void setParentTypesOnDeclareParentsNode(DeclareParents decp, IProgramElement decpElement) {\\n\t\tTypePatte"
  },
  {
    "method_id": "M2801",
    "name": "getHandle",
    "return_type": "String",
    "signature": "getHandle(AsmManager asm, Advice advice)",
    "file_id": "F52",
    "start_line": 792,
    "text_preview": ".getExactType().getName().replaceAll(\"\\\\$\", \".\"));\\n\t\t}\\n\t\tdecpElement.setParentTypes(parents);\\n\t}\\n\\n\tpublic static String getHandle(AsmManager asm, Advice advice) {\\n\t\tif (null == advice.handle) {\\n\t\t\tISourceLocation sl = advice.getSourceLocation();\\n\t\t\tif (sl != null) {\\n\t\t\t\tIProgramElement ipe = asm.getHierarchy().findElem"
  },
  {
    "method_id": "M2802",
    "name": "if",
    "return_type": "",
    "signature": "if(null == advice.handle)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2803",
    "name": "if",
    "return_type": "",
    "signature": "if(sl != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2804",
    "name": "addAdvisedRelationship",
    "return_type": "void",
    "signature": "addAdvisedRelationship(AsmManager model, Shadow matchedShadow, ShadowMunger munger)",
    "file_id": "F52",
    "start_line": 803,
    "text_preview": "SourceLine(sl);\\n\t\t\t\tadvice.handle = ipe.getHandleIdentifier();\\n\t\t\t}\\n\t\t}\\n\t\treturn advice.handle;\\n\t}\\n\\n\tpublic static void addAdvisedRelationship(AsmManager model, Shadow matchedShadow, ShadowMunger munger) {\\n\t\tif (model == null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tif (munger instanceof Advice) {\\n\t\t\tAdvice advice = (Advice) munger;\\n\\n\t\t\ti"
  },
  {
    "method_id": "M2805",
    "name": "if",
    "return_type": "",
    "signature": "if(model == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2806",
    "name": "if",
    "return_type": "",
    "signature": "if(munger instanceof Advice)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2807",
    "name": "if",
    "return_type": "",
    "signature": "if(World.createInjarHierarchy)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2808",
    "name": "if",
    "return_type": "",
    "signature": "if(targetNode == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2809",
    "name": "if",
    "return_type": "",
    "signature": "if(adviceHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2810",
    "name": "if",
    "return_type": "",
    "signature": "if(adviceElement != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2811",
    "name": "if",
    "return_type": "",
    "signature": "if(foreward != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2812",
    "name": "if",
    "return_type": "",
    "signature": "if(back != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2813",
    "name": "if",
    "return_type": "",
    "signature": "if(foreward != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2814",
    "name": "if",
    "return_type": "",
    "signature": "if(back != null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2815",
    "name": "getNode",
    "return_type": "IProgramElement",
    "signature": "getNode(AsmManager model, Shadow shadow)",
    "file_id": "F52",
    "start_line": 88,
    "text_preview": "\t\tif (World.createInjarHierarchy) {\\n\t\t\tcreateHierarchyForBinaryAspect(model, deow);\\n\t\t}\\n\\n\t\tIProgramElement targetNode = getNode(model, affectedShadow);\\n\t\tif (targetNode == null) {\\n\t\t\treturn;\\n\t\t}\\n\t\tString targetHandle = targetNode.getHandleIdentifier();\\n\t\tif (targetHandle == null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tIProgramElement sou"
  },
  {
    "method_id": "M2816",
    "name": "if",
    "return_type": "",
    "signature": "if(shadow instanceof BcelShadow)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2817",
    "name": "if",
    "return_type": "",
    "signature": "if(actualEnclosingMember == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2818",
    "name": "if",
    "return_type": "",
    "signature": "if(enclosingNode == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2819",
    "name": "sourceLinesMatch",
    "return_type": "boolean",
    "signature": "sourceLinesMatch(ISourceLocation location1, ISourceLocation location2)",
    "file_id": "F52",
    "start_line": 926,
    "text_preview": "losingNode, shadowSig, shadow);\\n\t\t\treturn bodyNode;\\n\t\t} else {\\n\t\t\treturn enclosingNode;\\n\t\t}\\n\t}\\n\\n\tprivate static boolean sourceLinesMatch(ISourceLocation location1, ISourceLocation location2) {\\n\t\treturn (location1.getLine() == location2.getLine());\\n\t}\\n\\n\t/**\\n\t * Finds or creates a code IProgramElement for the given shado"
  },
  {
    "method_id": "M2820",
    "name": "findOrCreateCodeNode",
    "return_type": "IProgramElement",
    "signature": "findOrCreateCodeNode(AsmManager asm, IProgramElement enclosingNode, Member shadowSig,\n\t\t\tShadow shadow)",
    "file_id": "F52",
    "start_line": 919,
    "text_preview": "| shadow.getKind() == Shadow.ConstructorCall\\n\t\t\t\t|| !shadowSig.equals(enclosingMember)) {\\n\t\t\tIProgramElement bodyNode = findOrCreateCodeNode(model, enclosingNode, shadowSig, shadow);\\n\t\t\treturn bodyNode;\\n\t\t} else {\\n\t\t\treturn enclosingNode;\\n\t\t}\\n\t}\\n\\n\tprivate static boolean sourceLinesMatch(ISourceLocation location1, ISour"
  },
  {
    "method_id": "M2821",
    "name": "lookupMember",
    "return_type": "IProgramElement",
    "signature": "lookupMember(IHierarchy model, UnresolvedType declaringType, Member member)",
    "file_id": "F52",
    "start_line": 890,
    "text_preview": "r = ((BcelShadow) shadow).getRealEnclosingCodeSignature();\\n\\n\t\t\tif (actualEnclosingMember == null) {\\n\t\t\t\tenclosingNode = lookupMember(model.getHierarchy(), shadow.getEnclosingType(), enclosingMember);\\n\t\t\t} else {\\n\t\t\t\tUnresolvedType type = enclosingMember.getDeclaringType();\\n\t\t\t\tUnresolvedType actualType = actualEnclosin"
  },
  {
    "method_id": "M2822",
    "name": "if",
    "return_type": "",
    "signature": "if(typeElement == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2823",
    "name": "addDeclareAnnotationMethodRelationship",
    "return_type": "void",
    "signature": "addDeclareAnnotationMethodRelationship(ISourceLocation sourceLocation, String affectedTypeName,\n\t\t\tResolvedMember affectedMethod, AsmManager model)",
    "file_id": "F52",
    "start_line": 996,
    "text_preview": "'fragile') bit of code that could break at any moment but it's working for my simple testcase.\\n\t */\\n\tpublic static void addDeclareAnnotationMethodRelationship(ISourceLocation sourceLocation, String affectedTypeName,\\n\t\t\tResolvedMember affectedMethod, AsmManager model) {\\n\t\tif (model == null) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tString pk"
  },
  {
    "method_id": "M2824",
    "name": "if",
    "return_type": "",
    "signature": "if(model == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2825",
    "name": "if",
    "return_type": "",
    "signature": "if(packageSeparator != -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2826",
    "name": "if",
    "return_type": "",
    "signature": "if(typeElem == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2827",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < args.length; i++)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2828",
    "name": "if",
    "return_type": "",
    "signature": "if(methodElem == null && args.length == 0)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2829",
    "name": "if",
    "return_type": "",
    "signature": "if(methodElem == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2830",
    "name": "if",
    "return_type": "",
    "signature": "if(targetHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2831",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2832",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2833",
    "name": "addDeclareAnnotationFieldRelationship",
    "return_type": "void",
    "signature": "addDeclareAnnotationFieldRelationship(AsmManager model, ISourceLocation declareLocation,\n\t\t\tString affectedTypeName, ResolvedMember affectedFieldName, boolean isRemove)",
    "file_id": "F52",
    "start_line": 1076,
    "text_preview": "r it, we have to dig through the structure model under the fields' type in order to locate it.\\n\t */\\n\tpublic static void addDeclareAnnotationFieldRelationship(AsmManager model, ISourceLocation declareLocation,\\n\t\t\tString affectedTypeName, ResolvedMember affectedFieldName, boolean isRemove) {\\n\t\tif (model == null) {\\n\t\t\tret"
  },
  {
    "method_id": "M2834",
    "name": "if",
    "return_type": "",
    "signature": "if(model == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2835",
    "name": "if",
    "return_type": "",
    "signature": "if(packageSeparator != -1)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2836",
    "name": "if",
    "return_type": "",
    "signature": "if(typeElem == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2837",
    "name": "if",
    "return_type": "",
    "signature": "if(fieldElem == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2838",
    "name": "if",
    "return_type": "",
    "signature": "if(targetHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2839",
    "name": "if",
    "return_type": "",
    "signature": "if(sourceHandle == null)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2840",
    "name": "if",
    "return_type": "",
    "signature": "if(isRemove)",
    "file_id": "F52",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2841",
    "name": "genDeclareMessage",
    "return_type": "String",
    "signature": "genDeclareMessage(String message)",
    "file_id": "F53",
    "start_line": 41,
    "text_preview": "ssage\\n\t * \"There should be no printlns\" will return 'declare warning: \"There should be n..\"'\\n\t */\\n\tpublic static String genDeclareMessage(String message) {\\n\t\tint length = message.length();\\n\t\tif (length < MAX_MESSAGE_LENGTH) {\\n\t\t\treturn message;\\n\t\t} else {\\n\t\t\treturn message.substring(0, MAX_MESSAGE_LENGTH - 1) + DOUBLE_"
  },
  {
    "method_id": "M2842",
    "name": "if",
    "return_type": "",
    "signature": "if(length < MAX_MESSAGE_LENGTH)",
    "file_id": "F53",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2843",
    "name": "genPointcutDetails",
    "return_type": "String",
    "signature": "genPointcutDetails(Pointcut pcd)",
    "file_id": "F53",
    "start_line": 54,
    "text_preview": " return '&lt;anonymous pointcut&gt;'\\n\t * and a named pointcut called p() will return 'p()..'\\n\t */\\n\tpublic static String genPointcutDetails(Pointcut pcd) {\\n\t\tStringBuilder details = new StringBuilder();\\n\t\tif (pcd instanceof ReferencePointcut) {\\n\t\t\tReferencePointcut rp = (ReferencePointcut) pcd;\\n\t\t\tdetails.append(rp.name"
  },
  {
    "method_id": "M2844",
    "name": "if",
    "return_type": "",
    "signature": "if(pcd instanceof ReferencePointcut)",
    "file_id": "F53",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2845",
    "name": "if",
    "return_type": "else",
    "signature": "if(pcd instanceof AndPointcut)",
    "file_id": "F53",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2846",
    "name": "if",
    "return_type": "else",
    "signature": "if(pcd instanceof OrPointcut)",
    "file_id": "F53",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2847",
    "name": "DeferredResolvedPointcutDefinition",
    "return_type": "",
    "signature": "DeferredResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name,\n\t\t\tUnresolvedType[] parameterTypes)",
    "file_id": "F55",
    "start_line": 30,
    "text_preview": "thor adrian colyer\\n *\\n */\\npublic class DeferredResolvedPointcutDefinition extends ResolvedPointcutDefinition {\\n\\n\tpublic DeferredResolvedPointcutDefinition(UnresolvedType declaringType, int modifiers, String name,\\n\t\t\tUnresolvedType[] parameterTypes) {\\n\t\tsuper(declaringType, modifiers, name, parameterTypes, UnresolvedTyp"
  },
  {
    "method_id": "M2848",
    "name": "InternalUseOnlyPointcutParser",
    "return_type": "",
    "signature": "InternalUseOnlyPointcutParser(ClassLoader classLoader, ReflectionWorld world)",
    "file_id": "F56",
    "start_line": 21,
    "text_preview": " org.aspectj.weaver.tools.PointcutParser;\\n\\npublic class InternalUseOnlyPointcutParser extends PointcutParser {\\n\\n\tpublic InternalUseOnlyPointcutParser(ClassLoader classLoader, ReflectionWorld world) {\\n\t\tsuper();\\n\t\tsetClassLoader(classLoader);\\n\t\tsetWorld(world);\\n\t}\\n\\n\tpublic InternalUseOnlyPointcutParser(ClassLoader class"
  },
  {
    "method_id": "M2849",
    "name": "InternalUseOnlyPointcutParser",
    "return_type": "",
    "signature": "InternalUseOnlyPointcutParser(ClassLoader classLoader)",
    "file_id": "F56",
    "start_line": 21,
    "text_preview": " org.aspectj.weaver.tools.PointcutParser;\\n\\npublic class InternalUseOnlyPointcutParser extends PointcutParser {\\n\\n\tpublic InternalUseOnlyPointcutParser(ClassLoader classLoader, ReflectionWorld world) {\\n\t\tsuper();\\n\t\tsetClassLoader(classLoader);\\n\t\tsetWorld(world);\\n\t}\\n\\n\tpublic InternalUseOnlyPointcutParser(ClassLoader class"
  },
  {
    "method_id": "M2850",
    "name": "resolvePointcutExpression",
    "return_type": "Pointcut",
    "signature": "resolvePointcutExpression(String expression,\n\t    \t\tClass inScope,\n\t    \t\tPointcutParameter[] formalParameters)",
    "file_id": "F56",
    "start_line": 32,
    "text_preview": "InternalUseOnlyPointcutParser(ClassLoader classLoader) {\\n\t\tsuper();\\n\t\tsetClassLoader(classLoader);\\n\t}\\n\\n\tpublic Pointcut resolvePointcutExpression(\\n\t    \t\tString expression,\\n\t    \t\tClass inScope,\\n\t    \t\tPointcutParameter[] formalParameters) {\\n\t\treturn super.resolvePointcutExpression(expression, inScope, formalParameters"
  },
  {
    "method_id": "M2851",
    "name": "concretizePointcutExpression",
    "return_type": "Pointcut",
    "signature": "concretizePointcutExpression(Pointcut pc, Class inScope, PointcutParameter[] formalParameters)",
    "file_id": "F56",
    "start_line": 39,
    "text_preview": "rmalParameters) {\\n\t\treturn super.resolvePointcutExpression(expression, inScope, formalParameters);\\n\t}\\n\\n\tpublic Pointcut concretizePointcutExpression(Pointcut pc, Class inScope, PointcutParameter[] formalParameters) {\\n\t\treturn super.concretizePointcutExpression(pc, inScope, formalParameters);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M2852",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2853",
    "name": "Java15AnnotationFinder",
    "return_type": "",
    "signature": "Java15AnnotationFinder()",
    "file_id": "F57",
    "start_line": 65,
    "text_preview": "\t\tuseCachingClassLoaderRepository = false;\\n\t\t}\\n\t}\\n\\n\t// must have no-arg constructor for reflective construction\\n\tpublic Java15AnnotationFinder() {\\n\t}\\n\\n\tpublic void setClassLoader(ClassLoader aLoader) {\\n\t\t// Set class loader ref\\n\t\tif (useSingleInstances && staticClassLoaderRef == null) {\\n\t\t\tstaticClassLoaderRef = new Bc"
  },
  {
    "method_id": "M2854",
    "name": "setClassLoader",
    "return_type": "void",
    "signature": "setClassLoader(ClassLoader aLoader)",
    "file_id": "F57",
    "start_line": 68,
    "text_preview": "\t}\\n\t}\\n\\n\t// must have no-arg constructor for reflective construction\\n\tpublic Java15AnnotationFinder() {\\n\t}\\n\\n\tpublic void setClassLoader(ClassLoader aLoader) {\\n\t\t// Set class loader ref\\n\t\tif (useSingleInstances && staticClassLoaderRef == null) {\\n\t\t\tstaticClassLoaderRef = new BcelWeakClassLoaderReference(aLoader);\\n\t\t} els"
  },
  {
    "method_id": "M2855",
    "name": "if",
    "return_type": "ref",
    "signature": "if(useSingleInstances && staticClassLoaderRef == null)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2856",
    "name": "if",
    "return_type": "repository",
    "signature": "if(useCachingClassLoaderRepository)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2857",
    "name": "if",
    "return_type": "",
    "signature": "if(useSingleInstances && staticBcelRepository == null)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2858",
    "name": "if",
    "return_type": "",
    "signature": "if(useSingleInstances && staticBcelRepository == null)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2859",
    "name": "getBcelRepository",
    "return_type": "Repository",
    "signature": "getBcelRepository()",
    "file_id": "F57",
    "start_line": 92,
    "text_preview": " else {\\n\t\t\t\tthis.bcelRepository = new NonCachingClassLoaderRepository(classLoaderRef);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate Repository getBcelRepository() {\\n\t\treturn useSingleInstances ? staticBcelRepository : bcelRepository;\\n\t}\\n\\n\tpublic void setWorld(World aWorld) {\\n\t\tthis.world = aWorld;\\n\t}\\n\\n\tpublic Object getAnnotation(ResolvedTyp"
  },
  {
    "method_id": "M2860",
    "name": "setWorld",
    "return_type": "void",
    "signature": "setWorld(World aWorld)",
    "file_id": "F57",
    "start_line": 96,
    "text_preview": " Repository getBcelRepository() {\\n\t\treturn useSingleInstances ? staticBcelRepository : bcelRepository;\\n\t}\\n\\n\tpublic void setWorld(World aWorld) {\\n\t\tthis.world = aWorld;\\n\t}\\n\\n\tpublic Object getAnnotation(ResolvedType annotationType, Object onObject) {\\n\t\ttry {\\n\t\t\tClass<? extends Annotation> annotationClass = (Class<? exten"
  },
  {
    "method_id": "M2861",
    "name": "getAnnotation",
    "return_type": "Object",
    "signature": "getAnnotation(ResolvedType annotationType, Object onObject)",
    "file_id": "F57",
    "start_line": 100,
    "text_preview": "ticBcelRepository : bcelRepository;\\n\t}\\n\\n\tpublic void setWorld(World aWorld) {\\n\t\tthis.world = aWorld;\\n\t}\\n\\n\tpublic Object getAnnotation(ResolvedType annotationType, Object onObject) {\\n\t\ttry {\\n\t\t\tClass<? extends Annotation> annotationClass = (Class<? extends Annotation>) Class.forName(annotationType.getName(),\\n\t\t\t\t\tfalse,"
  },
  {
    "method_id": "M2862",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException ex)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2863",
    "name": "getAnnotationFromClass",
    "return_type": "Object",
    "signature": "getAnnotationFromClass(ResolvedType annotationType, Class aClass)",
    "file_id": "F57",
    "start_line": 113,
    "text_preview": "tationClass);\\n\t\t\t}\\n\t\t} catch (ClassNotFoundException ex) {\\n\t\t\t// just return null\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tpublic Object getAnnotationFromClass(ResolvedType annotationType, Class aClass) {\\n\t\ttry {\\n\t\t\tClass<? extends Annotation> annotationClass = (Class<? extends Annotation>) Class.forName(annotationType.getName(),\\n\t\t\t\t\t"
  },
  {
    "method_id": "M2864",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException ex)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2865",
    "name": "getAnnotationFromMember",
    "return_type": "Object",
    "signature": "getAnnotationFromMember(ResolvedType annotationType, Member aMember)",
    "file_id": "F57",
    "start_line": 126,
    "text_preview": "tationClass);\\n\t\t\t}\\n\t\t} catch (ClassNotFoundException ex) {\\n\t\t\t// just return null\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tpublic Object getAnnotationFromMember(ResolvedType annotationType, Member aMember) {\\n\t\tif (!(aMember instanceof AccessibleObject))\\n\t\t\treturn null;\\n\t\tAccessibleObject ao = (AccessibleObject) aMember;\\n\t\ttry {\\n\t\t\tClas"
  },
  {
    "method_id": "M2866",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException ex)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2867",
    "name": "getClassLoader",
    "return_type": "ClassLoader",
    "signature": "getClassLoader()",
    "file_id": "F57",
    "start_line": 79,
    "text_preview": "ry) {\\n\t\t\tif (useSingleInstances && staticBcelRepository == null) {\\n\t\t\t\tstaticBcelRepository = new ClassLoaderRepository(getClassLoader());\\n\t\t\t} else {\\n\t\t\t\tthis.bcelRepository = new ClassLoaderRepository(classLoaderRef);\\n\t\t\t}\\n\t\t} else {\\n\t\t\tif (useSingleInstances && staticBcelRepository == null) {\\n\t\t\t\tstaticBcelRepositor"
  },
  {
    "method_id": "M2868",
    "name": "getAnnotationOfType",
    "return_type": "AnnotationAJ",
    "signature": "getAnnotationOfType(UnresolvedType ofType, Member onMember)",
    "file_id": "F57",
    "start_line": 145,
    "text_preview": " useSingleInstances ? staticClassLoaderRef.getClassLoader() : classLoaderRef.getClassLoader();\\n\t}\\n\\n\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType, Member onMember) {\\n\t\tif (!(onMember instanceof AccessibleObject))\\n\t\t\treturn null;\\n\t\t// here we really want both the runtime visible AND the class visible\\n\t\t/"
  },
  {
    "method_id": "M2869",
    "name": "if",
    "return_type": "",
    "signature": "if(onMember instanceof Method)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2870",
    "name": "if",
    "return_type": "",
    "signature": "if(bcelMethod == null)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2871",
    "name": "if",
    "return_type": "else",
    "signature": "if(onMember instanceof Constructor)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2872",
    "name": "if",
    "return_type": "else",
    "signature": "if(onMember instanceof Field)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2873",
    "name": "for",
    "return_type": "type",
    "signature": "for(org.aspectj.apache.bcel.classfile.annotation.AnnotationGen ann : anns)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2874",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException cnfEx)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2875",
    "name": "getAnnotationDefaultValue",
    "return_type": "String",
    "signature": "getAnnotationDefaultValue(Member onMember)",
    "file_id": "F57",
    "start_line": 192,
    "text_preview": "n null;\\n\t\t} catch (ClassNotFoundException cnfEx) {\\n\t\t\t// just use reflection then\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tpublic String getAnnotationDefaultValue(Member onMember) {\\n\t\ttry {\\n\t\t\tJavaClass jc = getBcelRepository().loadClass(onMember.getDeclaringClass());\\n\t\t\tif (onMember instanceof Method) {\\n\t\t\t\torg.aspectj.apache.bcel.cla"
  },
  {
    "method_id": "M2876",
    "name": "if",
    "return_type": "",
    "signature": "if(onMember instanceof Method)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2877",
    "name": "if",
    "return_type": "",
    "signature": "if(bcelMethod == null)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2878",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute attribute : attrs)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2879",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException cnfEx)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2880",
    "name": "getAnnotations",
    "return_type": "ResolvedType[]",
    "signature": "getAnnotations(Member onMember, boolean areRuntimeAnnotationsSufficient)",
    "file_id": "F57",
    "start_line": 165,
    "text_preview": "thod '\"\\n\t\t\t\t\t// +\\n\t\t\t\t\t// onMember.getName()+\"' in class '\"+jc.getClassName()+\"'\");\\n\t\t\t\t} else {\\n\t\t\t\t\tanns = bcelMethod.getAnnotations();\\n\t\t\t\t}\\n\t\t\t} else if (onMember instanceof Constructor) {\\n\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelCons = jc.getMethod((Constructor<?>) onMember);\\n\t\t\t\tanns = bcelCons.getAnnotat"
  },
  {
    "method_id": "M2881",
    "name": "if",
    "return_type": "",
    "signature": "if(!areRuntimeAnnotationsSufficient)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2882",
    "name": "if",
    "return_type": "",
    "signature": "if(onMember instanceof Method)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2883",
    "name": "if",
    "return_type": "",
    "signature": "if(bcelMethod != null)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2884",
    "name": "if",
    "return_type": "else",
    "signature": "if(onMember instanceof Constructor)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2885",
    "name": "if",
    "return_type": "else",
    "signature": "if(onMember instanceof Field)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2886",
    "name": "if",
    "return_type": "",
    "signature": "if(anns == null || anns.length == 0)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2887",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < anns.length; i++)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2888",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException cnfEx)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2889",
    "name": "if",
    "return_type": "",
    "signature": "if(anns.length == 0)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2890",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < anns.length; i++)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2891",
    "name": "getAnnotations",
    "return_type": "ResolvedType[]",
    "signature": "getAnnotations(Class forClass, World inWorld)",
    "file_id": "F57",
    "start_line": 165,
    "text_preview": "thod '\"\\n\t\t\t\t\t// +\\n\t\t\t\t\t// onMember.getName()+\"' in class '\"+jc.getClassName()+\"'\");\\n\t\t\t\t} else {\\n\t\t\t\t\tanns = bcelMethod.getAnnotations();\\n\t\t\t\t}\\n\t\t\t} else if (onMember instanceof Constructor) {\\n\t\t\t\torg.aspectj.apache.bcel.classfile.Method bcelCons = jc.getMethod((Constructor<?>) onMember);\\n\t\t\t\tanns = bcelCons.getAnnotat"
  },
  {
    "method_id": "M2892",
    "name": "if",
    "return_type": "",
    "signature": "if(anns == null)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2893",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < ret.length; i++)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2894",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException cnfEx)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2895",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < classAnnotations.length; i++)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2896",
    "name": "getParameterNames",
    "return_type": "String[]",
    "signature": "getParameterNames(Member forMember)",
    "file_id": "F57",
    "start_line": 301,
    "text_preview": " {\\n\t\t\tret[i] = inWorld.resolve(classAnnotations[i].annotationType().getName());\\n\t\t}\\n\\n\t\treturn ret;\\n\t}\\n\\n\tpublic String[] getParameterNames(Member forMember) {\\n\t\tif (!(forMember instanceof AccessibleObject))\\n\t\t\treturn null;\\n\\n\t\ttry {\\n\t\t\tJavaClass jc = getBcelRepository().loadClass(forMember.getDeclaringClass());\\n\t\t\tLocalV"
  },
  {
    "method_id": "M2897",
    "name": "if",
    "return_type": "",
    "signature": "if(forMember instanceof Method)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2898",
    "name": "if",
    "return_type": "else",
    "signature": "if(forMember instanceof Constructor)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2899",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException cnfEx)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2900",
    "name": "getParameterNamesFromLVT",
    "return_type": "String[]",
    "signature": "getParameterNamesFromLVT(LocalVariableTable lvt, int numVars)",
    "file_id": "F57",
    "start_line": 318,
    "text_preview": "orMember);\\n\t\t\t\tlvt = bcelCons.getLocalVariableTable();\\n\t\t\t\tnumVars = bcelCons.getArgumentTypes().length;\\n\t\t\t}\\n\t\t\treturn getParameterNamesFromLVT(lvt, numVars);\\n\t\t} catch (ClassNotFoundException cnfEx) {\\n\t\t\t; // no luck\\n\t\t}\\n\\n\t\treturn null;\\n\t}\\n\\n\tprivate String[] getParameterNamesFromLVT(LocalVariableTable lvt, int numVar"
  },
  {
    "method_id": "M2901",
    "name": "if",
    "return_type": "",
    "signature": "if(vars.length < numVars)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2902",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < numVars; i++)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2903",
    "name": "getParameterAnnotationTypes",
    "return_type": "ResolvedType[][]",
    "signature": "getParameterAnnotationTypes(Member onMember)",
    "file_id": "F57",
    "start_line": 341,
    "text_preview": "\t\tfor (int i = 0; i < numVars; i++) {\\n\t\t\tret[i] = vars[i + 1].getName();\\n\t\t}\\n\t\treturn ret;\\n\t}\\n\\n\tpublic ResolvedType[][] getParameterAnnotationTypes(Member onMember) {\\n\t\tif (!(onMember instanceof AccessibleObject))\\n\t\t\treturn NO_PARAMETER_ANNOTATIONS;\\n\t\t// here we really want both the runtime visible AND the class visibl"
  },
  {
    "method_id": "M2904",
    "name": "if",
    "return_type": "",
    "signature": "if(onMember instanceof Method)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2905",
    "name": "if",
    "return_type": "",
    "signature": "if(bcelMethod == null)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2906",
    "name": "if",
    "return_type": "else",
    "signature": "if(onMember instanceof Constructor)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2907",
    "name": "if",
    "return_type": "else",
    "signature": "if(onMember instanceof Field)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2908",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < anns.length; i++)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2909",
    "name": "if",
    "return_type": "",
    "signature": "if(anns[i] != null)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2910",
    "name": "for",
    "return_type": "",
    "signature": "for(int j = 0; j < anns[i].length; j++)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2911",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException cnfEx)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2912",
    "name": "if",
    "return_type": "",
    "signature": "if(onMember instanceof Method)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2913",
    "name": "if",
    "return_type": "else",
    "signature": "if(onMember instanceof Constructor)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2914",
    "name": "if",
    "return_type": "else",
    "signature": "if(onMember instanceof Field)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2915",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < anns.length; i++)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2916",
    "name": "if",
    "return_type": "",
    "signature": "if(anns[i] != null)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2917",
    "name": "for",
    "return_type": "",
    "signature": "for(int j = 0; j < anns[i].length; j++)",
    "file_id": "F57",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2918",
    "name": "Java15GenericSignatureInformationProvider",
    "return_type": "",
    "signature": "Java15GenericSignatureInformationProvider(World forWorld)",
    "file_id": "F58",
    "start_line": 31,
    "text_preview": "icSignatureInformationProvider implements\\n\t\tGenericSignatureInformationProvider {\\n\\n\tprivate final World world;\\n\\n\tpublic Java15GenericSignatureInformationProvider(World forWorld) {\\n\t\tthis.world = forWorld;\\n\t}\\n\\n\t/* (non-Javadoc)\\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#getGenericParameterTy"
  },
  {
    "method_id": "M2919",
    "name": "getGenericParameterTypes",
    "return_type": "UnresolvedType[]",
    "signature": "getGenericParameterTypes(ReflectionBasedResolvedMemberImpl resolvedMember)",
    "file_id": "F58",
    "start_line": 36,
    "text_preview": "\\n\t\tthis.world = forWorld;\\n\t}\\n\\n\t/* (non-Javadoc)\\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#getGenericParameterTypes(org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl)\\n\t */\\n\tpublic UnresolvedType[] getGenericParameterTypes(\\n\t\t\tReflectionBasedResolvedMemberImpl resolvedMember) {\\n\t\t"
  },
  {
    "method_id": "M2920",
    "name": "if",
    "return_type": "",
    "signature": "if(member instanceof Method)",
    "file_id": "F58",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2921",
    "name": "if",
    "return_type": "else",
    "signature": "if(member instanceof Constructor)",
    "file_id": "F58",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2922",
    "name": "getGenericReturnType",
    "return_type": "UnresolvedType",
    "signature": "getGenericReturnType(ReflectionBasedResolvedMemberImpl resolvedMember)",
    "file_id": "F58",
    "start_line": 52,
    "text_preview": "verter.fromTypes(pTypes);\\n\t}\\n\\n\t/* (non-Javadoc)\\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#getGenericReturnType(org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl)\\n\t */\\n\tpublic UnresolvedType getGenericReturnType(\\n\t\t\tReflectionBasedResolvedMemberImpl resolvedMember) {\\n\t\tJavaLangTy"
  },
  {
    "method_id": "M2923",
    "name": "if",
    "return_type": "",
    "signature": "if(member instanceof Field)",
    "file_id": "F58",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2924",
    "name": "if",
    "return_type": "else",
    "signature": "if(member instanceof Method)",
    "file_id": "F58",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2925",
    "name": "if",
    "return_type": "else",
    "signature": "if(member instanceof Constructor)",
    "file_id": "F58",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2926",
    "name": "isBridge",
    "return_type": "boolean",
    "signature": "isBridge(ReflectionBasedResolvedMemberImpl resolvedMember)",
    "file_id": "F58",
    "start_line": 70,
    "text_preview": "er type: \" + member);\\n\t\t}\\n\t}\\n\\n\t/* (non-Javadoc)\\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#isBridge()\\n\t */\\n\tpublic boolean isBridge(ReflectionBasedResolvedMemberImpl resolvedMember) {\\n\t\tMember member =  resolvedMember.getMember();\\n\t\tif (member instanceof Method) {\\n\t\t\treturn ((Method)member)"
  },
  {
    "method_id": "M2927",
    "name": "if",
    "return_type": "",
    "signature": "if(member instanceof Method)",
    "file_id": "F58",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2928",
    "name": "isVarArgs",
    "return_type": "boolean",
    "signature": "isVarArgs(ReflectionBasedResolvedMemberImpl resolvedMember)",
    "file_id": "F58",
    "start_line": 82,
    "text_preview": "se {\\n\t\t\treturn false;\\n\t\t}\\n\t}\\n\\n\t/* (non-Javadoc)\\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#isVarArgs()\\n\t */\\n\tpublic boolean isVarArgs(ReflectionBasedResolvedMemberImpl resolvedMember) {\\n\t\tMember member =  resolvedMember.getMember();\\n\t\tif (member instanceof Method) {\\n\t\t\treturn ((Method)membe"
  },
  {
    "method_id": "M2929",
    "name": "if",
    "return_type": "",
    "signature": "if(member instanceof Method)",
    "file_id": "F58",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2930",
    "name": "if",
    "return_type": "else",
    "signature": "if(member instanceof Constructor)",
    "file_id": "F58",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2931",
    "name": "isSynthetic",
    "return_type": "boolean",
    "signature": "isSynthetic(ReflectionBasedResolvedMemberImpl resolvedMember)",
    "file_id": "F58",
    "start_line": 96,
    "text_preview": "se {\\n\t\t\treturn false;\\n\t\t}\\n\t}\\n\\n\t/* (non-Javadoc)\\n\t * @see org.aspectj.weaver.reflect.GenericSignatureInformationProvider#isSynthetic()\\n\t */\\n\tpublic boolean isSynthetic(ReflectionBasedResolvedMemberImpl resolvedMember) {\\n\t\tMember member =  resolvedMember.getMember();\\n\t\treturn member.isSynthetic();\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M2932",
    "name": "Java15ReflectionBasedReferenceTypeDelegate",
    "return_type": "",
    "signature": "Java15ReflectionBasedReferenceTypeDelegate()",
    "file_id": "F59",
    "start_line": 60,
    "text_preview": "nverter;\\n\tprivate Java15AnnotationFinder annotationFinder = null;\\n\tprivate ArgNameFinder argNameFinder = null;\\n\\n\tpublic Java15ReflectionBasedReferenceTypeDelegate() {\\n\t}\\n\\n\t@Override\\n\tpublic void initialize(ReferenceType aType, Class aClass, ClassLoader classLoader, World aWorld) {\\n\t\tsuper.initialize(aType, aClass, clas"
  },
  {
    "method_id": "M2933",
    "name": "initialize",
    "return_type": "void",
    "signature": "initialize(ReferenceType aType, Class aClass, ClassLoader classLoader, World aWorld)",
    "file_id": "F59",
    "start_line": 64,
    "text_preview": "ArgNameFinder argNameFinder = null;\\n\\n\tpublic Java15ReflectionBasedReferenceTypeDelegate() {\\n\t}\\n\\n\t@Override\\n\tpublic void initialize(ReferenceType aType, Class aClass, ClassLoader classLoader, World aWorld) {\\n\t\tsuper.initialize(aType, aClass, classLoader, aWorld);\\n\t\tmyType = AjTypeSystem.getAjType(aClass);\\n\t\tannotationFi"
  },
  {
    "method_id": "M2934",
    "name": "buildGenericType",
    "return_type": "ReferenceType",
    "signature": "buildGenericType()",
    "file_id": "F59",
    "start_line": 75,
    "text_preview": "d(aWorld);\\n\t\tthis.typeConverter = new JavaLangTypeToResolvedTypeConverter(aWorld);\\n\t}\\n\\n\t@Override\\n\tpublic ReferenceType buildGenericType() {\\n\t\treturn (ReferenceType) UnresolvedType.forGenericTypeVariables(getResolvedTypeX().getSignature(), getTypeVariables())\\n\t\t\t\t.resolve(getWorld());\\n\t}\\n\\n\t@Override\\n\tpublic AnnotationA"
  },
  {
    "method_id": "M2935",
    "name": "getAnnotations",
    "return_type": "AnnotationAJ[]",
    "signature": "getAnnotations()",
    "file_id": "F59",
    "start_line": 81,
    "text_preview": "(getResolvedTypeX().getSignature(), getTypeVariables())\\n\t\t\t\t.resolve(getWorld());\\n\t}\\n\\n\t@Override\\n\tpublic AnnotationAJ[] getAnnotations() {\\n\t\t// AMC - we seem not to need to implement this method...\\n\t\t// throw new UnsupportedOperationException(\\n\t\t// \"getAnnotations on Java15ReflectionBasedReferenceTypeDelegate is not im"
  },
  {
    "method_id": "M2936",
    "name": "getAnnotationTypes",
    "return_type": "ResolvedType[]",
    "signature": "getAnnotationTypes()",
    "file_id": "F59",
    "start_line": 91,
    "text_preview": "the right implementation in the reflective case?\\n\t\treturn super.getAnnotations();\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType[] getAnnotationTypes() {\\n\t\tif (annotations == null) {\\n\t\t\tannotations = annotationFinder.getAnnotations(getBaseClass(), getWorld());\\n\t\t}\\n\t\treturn annotations;\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAnnotation"
  },
  {
    "method_id": "M2937",
    "name": "if",
    "return_type": "",
    "signature": "if(annotations == null)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2938",
    "name": "hasAnnotations",
    "return_type": "boolean",
    "signature": "hasAnnotations()",
    "file_id": "F59",
    "start_line": 99,
    "text_preview": "= annotationFinder.getAnnotations(getBaseClass(), getWorld());\\n\t\t}\\n\t\treturn annotations;\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAnnotations() {\\n\t\tif (annotations == null) {\\n\t\t\tannotations = annotationFinder.getAnnotations(getBaseClass(), getWorld());\\n\t\t}\\n\t\treturn annotations.length != 0;\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAn"
  },
  {
    "method_id": "M2939",
    "name": "if",
    "return_type": "",
    "signature": "if(annotations == null)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2940",
    "name": "hasAnnotation",
    "return_type": "boolean",
    "signature": "hasAnnotation(UnresolvedType ofType)",
    "file_id": "F59",
    "start_line": 107,
    "text_preview": "Finder.getAnnotations(getBaseClass(), getWorld());\\n\t\t}\\n\t\treturn annotations.length != 0;\\n\t}\\n\\n\t@Override\\n\tpublic boolean hasAnnotation(UnresolvedType ofType) {\\n\t\tResolvedType[] myAnns = getAnnotationTypes();\\n\t\tResolvedType toLookFor = ofType.resolve(getWorld());\\n\t\tfor (ResolvedType myAnn : myAnns) {\\n\t\t\tif (myAnn == toLo"
  },
  {
    "method_id": "M2941",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedType myAnn : myAnns)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2942",
    "name": "if",
    "return_type": "",
    "signature": "if(myAnn == toLookFor)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2943",
    "name": "getDeclaredFields",
    "return_type": "ResolvedMember[]",
    "signature": "getDeclaredFields()",
    "file_id": "F59",
    "start_line": 120,
    "text_preview": " false;\\n\t}\\n\\n\t// use the MAP to ensure that any aj-synthetic fields are filtered out\\n\t@Override\\n\tpublic ResolvedMember[] getDeclaredFields() {\\n\t\tif (fields == null) {\\n\t\t\tField[] reflectFields = this.myType.getDeclaredFields();\\n\t\t\tResolvedMember[] rFields = new ResolvedMember[reflectFields.length];\\n\t\t\tfor (int i = 0; i <"
  },
  {
    "method_id": "M2944",
    "name": "if",
    "return_type": "",
    "signature": "if(fields == null)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2945",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < reflectFields.length; i++)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2946",
    "name": "getDeclaredGenericSignature",
    "return_type": "String",
    "signature": "getDeclaredGenericSignature()",
    "file_id": "F59",
    "start_line": 133,
    "text_preview": "GenericFieldMember(reflectFields[i]);\\n\t\t\t}\\n\t\t\tthis.fields = rFields;\\n\t\t}\\n\t\treturn fields;\\n\t}\\n\\n\t@Override\\n\tpublic String getDeclaredGenericSignature() {\\n\t\tif (this.genericSignature == null && isGeneric()) {\\n\t\t\t// BUG? what the hell is this doing - see testcode in MemberTestCase15.testMemberSignatureCreation() and run it"
  },
  {
    "method_id": "M2947",
    "name": "getDeclaredInterfaces",
    "return_type": "ResolvedType[]",
    "signature": "getDeclaredInterfaces()",
    "file_id": "F59",
    "start_line": 142,
    "text_preview": "Creation() and run it\\n\t\t\t// off a Reflection World\\n\t\t}\\n\t\treturn genericSignature;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType[] getDeclaredInterfaces() {\\n\t\tif (superInterfaces == null) {\\n\t\t\tType[] genericInterfaces = getBaseClass().getGenericInterfaces();\\n\t\t\tthis.superInterfaces = typeConverter.fromTypes(genericInterfaces);\\n\t\t"
  },
  {
    "method_id": "M2948",
    "name": "if",
    "return_type": "",
    "signature": "if(superInterfaces == null)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2949",
    "name": "getSuperclass",
    "return_type": "ResolvedType",
    "signature": "getSuperclass()",
    "file_id": "F59",
    "start_line": 151,
    "text_preview": "erfaces = typeConverter.fromTypes(genericInterfaces);\\n\t\t}\\n\t\treturn superInterfaces;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType getSuperclass() {\\n\t\t// Superclass of object is null\\n\t\tif (superclass == null && getBaseClass() != Object.class) {\\n\t\t\tType t = this.getBaseClass().getGenericSuperclass();\\n\t\t\tif (t != null) {\\n\t\t\t\tsuperc"
  },
  {
    "method_id": "M2950",
    "name": "if",
    "return_type": "",
    "signature": "if(t != null)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2951",
    "name": "if",
    "return_type": "",
    "signature": "if(t == null)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2952",
    "name": "getTypeVariables",
    "return_type": "TypeVariable[]",
    "signature": "getTypeVariables()",
    "file_id": "F59",
    "start_line": 76,
    "text_preview": "buildGenericType() {\\n\t\treturn (ReferenceType) UnresolvedType.forGenericTypeVariables(getResolvedTypeX().getSignature(), getTypeVariables())\\n\t\t\t\t.resolve(getWorld());\\n\t}\\n\\n\t@Override\\n\tpublic AnnotationAJ[] getAnnotations() {\\n\t\t// AMC - we seem not to need to implement this method...\\n\t\t// throw new UnsupportedOperationExc"
  },
  {
    "method_id": "M2953",
    "name": "if",
    "return_type": "",
    "signature": "if(workInProgressSetOfVariables != null)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2954",
    "name": "if",
    "return_type": "",
    "signature": "if(this.typeVariables == null)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2955",
    "name": "for",
    "return_type": "initialization",
    "signature": "for(int i = 0; i < tVars.length; i++)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2956",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < tVars.length; i++)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2957",
    "name": "getDeclaredMethods",
    "return_type": "ResolvedMember[]",
    "signature": "getDeclaredMethods()",
    "file_id": "F59",
    "start_line": 201,
    "text_preview": "MAP we can filter out advice\\n\t// methods that really shouldn't be seen in this list\\n\t@Override\\n\tpublic ResolvedMember[] getDeclaredMethods() {\\n\t\tif (methods == null) {\\n\t\t\tMethod[] reflectMethods = this.myType.getDeclaredMethods();\\n\t\t\tConstructor[] reflectCons = this.myType.getDeclaredConstructors();\\n\t\t\tResolvedMember[]"
  },
  {
    "method_id": "M2958",
    "name": "if",
    "return_type": "",
    "signature": "if(methods == null)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2959",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < reflectMethods.length; i++)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2960",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < reflectCons.length; i++)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2961",
    "name": "getGenericResolvedType",
    "return_type": "ResolvedType",
    "signature": "getGenericResolvedType()",
    "file_id": "F59",
    "start_line": 220,
    "text_preview": "ethods;\\n\t}\\n\\n\t/**\\n\t * Returns the generic type, regardless of the resolvedType we 'know about'\\n\t */\\n\tpublic ResolvedType getGenericResolvedType() {\\n\t\tResolvedType rt = getResolvedTypeX();\\n\t\tif (rt.isParameterizedType() || rt.isRawType()) {\\n\t\t\treturn rt.getGenericType();\\n\t\t}\\n\t\treturn rt;\\n\t}\\n\\n\tprivate ResolvedMember creat"
  },
  {
    "method_id": "M2962",
    "name": "createGenericMethodMember",
    "return_type": "ResolvedMember",
    "signature": "createGenericMethodMember(Method forMethod)",
    "file_id": "F59",
    "start_line": 207,
    "text_preview": "ber[reflectMethods.length + reflectCons.length];\\n\t\t\tfor (int i = 0; i < reflectMethods.length; i++) {\\n\t\t\t\trMethods[i] = createGenericMethodMember(reflectMethods[i]);\\n\t\t\t}\\n\t\t\tfor (int i = 0; i < reflectCons.length; i++) {\\n\t\t\t\trMethods[i + reflectMethods.length] = createGenericConstructorMember(reflectCons[i]);\\n\t\t\t}\\n\t\t\tt"
  },
  {
    "method_id": "M2963",
    "name": "createGenericConstructorMember",
    "return_type": "ResolvedMember",
    "signature": "createGenericConstructorMember(Constructor<?> forConstructor)",
    "file_id": "F59",
    "start_line": 210,
    "text_preview": "er(reflectMethods[i]);\\n\t\t\t}\\n\t\t\tfor (int i = 0; i < reflectCons.length; i++) {\\n\t\t\t\trMethods[i + reflectMethods.length] = createGenericConstructorMember(reflectCons[i]);\\n\t\t\t}\\n\t\t\tthis.methods = rMethods;\\n\t\t}\\n\t\treturn methods;\\n\t}\\n\\n\t/**\\n\t * Returns the generic type, regardless of the resolvedType we 'know about'\\n\t */\\n\tpubli"
  },
  {
    "method_id": "M2964",
    "name": "createGenericFieldMember",
    "return_type": "ResolvedMember",
    "signature": "createGenericFieldMember(Field forField)",
    "file_id": "F59",
    "start_line": 125,
    "text_preview": "Fields = new ResolvedMember[reflectFields.length];\\n\t\t\tfor (int i = 0; i < reflectFields.length; i++) {\\n\t\t\t\trFields[i] = createGenericFieldMember(reflectFields[i]);\\n\t\t\t}\\n\t\t\tthis.fields = rFields;\\n\t\t}\\n\t\treturn fields;\\n\t}\\n\\n\t@Override\\n\tpublic String getDeclaredGenericSignature() {\\n\t\tif (this.genericSignature == null && isG"
  },
  {
    "method_id": "M2965",
    "name": "getDeclaredPointcuts",
    "return_type": "ResolvedMember[]",
    "signature": "getDeclaredPointcuts()",
    "file_id": "F59",
    "start_line": 260,
    "text_preview": "(new Java15GenericSignatureInformationProvider(this.getWorld()));\\n\t\treturn ret;\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedMember[] getDeclaredPointcuts() {\\n\t\tif (pointcuts == null) {\\n\t\t\tPointcut[] pcs = this.myType.getDeclaredPointcuts();\\n\t\t\tpointcuts = new ResolvedMember[pcs.length];\\n\t\t\tInternalUseOnlyPointcutParser parser = nul"
  },
  {
    "method_id": "M2966",
    "name": "if",
    "return_type": "",
    "signature": "if(pointcuts == null)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2967",
    "name": "if",
    "return_type": "",
    "signature": "if(world instanceof ReflectionWorld)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2968",
    "name": "for",
    "return_type": "",
    "signature": "for(PointcutDesignatorHandler handler : additionalPointcutHandlers)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2969",
    "name": "for",
    "return_type": "that",
    "signature": "for(int i = 0; i < pcs.length; i++)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2970",
    "name": "for",
    "return_type": "",
    "signature": "for(int j = 0; j < weaverPTypes.length; j++)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2971",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < pcs.length; i++)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2972",
    "name": "if",
    "return_type": "",
    "signature": "if(pnames.length != ptypes.length)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2973",
    "name": "for",
    "return_type": "",
    "signature": "for(int j = 0; j < parameters[i].length; j++)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2974",
    "name": "for",
    "return_type": "all",
    "signature": "for(int i = 0; i < pointcuts.length; i++)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2975",
    "name": "tryToDiscoverParameterNames",
    "return_type": "String[]",
    "signature": "tryToDiscoverParameterNames(Pointcut pcut)",
    "file_id": "F59",
    "start_line": 296,
    "text_preview": "meterTypes();\\n\t\t\t\tString[] pnames = pcs[i].getParameterNames();\\n\t\t\t\tif (pnames.length != ptypes.length) {\\n\t\t\t\t\tpnames = tryToDiscoverParameterNames(pcs[i]);\\n\t\t\t\t\tif (pnames == null || (pnames.length != ptypes.length)) {\\n\t\t\t\t\t\tthrow new IllegalStateException(\"Required parameter names not available when parsing pointcut "
  },
  {
    "method_id": "M2976",
    "name": "for",
    "return_type": "",
    "signature": "for(Method m : ms)",
    "file_id": "F59",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2977",
    "name": "isAnnotation",
    "return_type": "boolean",
    "signature": "isAnnotation()",
    "file_id": "F59",
    "start_line": 332,
    "text_preview": "cut.getName())) {\\n\t\t\t\treturn argNameFinder.getParameterNames(m);\\n\t\t\t}\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAnnotation() {\\n\t\treturn getBaseClass().isAnnotation();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAnnotationStyleAspect() {\\n\t\treturn getBaseClass().isAnnotationPresent(Aspect.class);\\n\t}\\n\\n\t@Override\\n\tpublic bo"
  },
  {
    "method_id": "M2978",
    "name": "isAnnotationStyleAspect",
    "return_type": "boolean",
    "signature": "isAnnotationStyleAspect()",
    "file_id": "F59",
    "start_line": 337,
    "text_preview": "\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAnnotation() {\\n\t\treturn getBaseClass().isAnnotation();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAnnotationStyleAspect() {\\n\t\treturn getBaseClass().isAnnotationPresent(Aspect.class);\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAnnotationWithRuntimeRetention() {\\n\t\tif (!isAnnotation()) {\\n\t\t\treturn false;\\n\t\t}"
  },
  {
    "method_id": "M2979",
    "name": "isAnnotationWithRuntimeRetention",
    "return_type": "boolean",
    "signature": "isAnnotationWithRuntimeRetention()",
    "file_id": "F59",
    "start_line": 342,
    "text_preview": "n isAnnotationStyleAspect() {\\n\t\treturn getBaseClass().isAnnotationPresent(Aspect.class);\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAnnotationWithRuntimeRetention() {\\n\t\tif (!isAnnotation()) {\\n\t\t\treturn false;\\n\t\t}\\n\t\tif (getBaseClass().isAnnotationPresent(Retention.class)) {\\n\t\t\tRetention retention = (Retention) getBaseClass().getA"
  },
  {
    "method_id": "M2980",
    "name": "isAspect",
    "return_type": "boolean",
    "signature": "isAspect()",
    "file_id": "F59",
    "start_line": 356,
    "text_preview": "on.value();\\n\t\t\treturn policy == RetentionPolicy.RUNTIME;\\n\t\t} else {\\n\t\t\treturn false;\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAspect() {\\n\t\treturn this.myType.isAspect();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isEnum() {\\n\t\treturn getBaseClass().isEnum();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isGeneric() {\\n\t\t// return false; // for now\\n\t\tr"
  },
  {
    "method_id": "M2981",
    "name": "isEnum",
    "return_type": "boolean",
    "signature": "isEnum()",
    "file_id": "F59",
    "start_line": 361,
    "text_preview": " false;\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAspect() {\\n\t\treturn this.myType.isAspect();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isEnum() {\\n\t\treturn getBaseClass().isEnum();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isGeneric() {\\n\t\t// return false; // for now\\n\t\treturn getBaseClass().getTypeParameters().length > 0;\\n\t}\\n\\n\t@Override\\n\tpublic b"
  },
  {
    "method_id": "M2982",
    "name": "isGeneric",
    "return_type": "boolean",
    "signature": "isGeneric()",
    "file_id": "F59",
    "start_line": 134,
    "text_preview": "}\\n\t\treturn fields;\\n\t}\\n\\n\t@Override\\n\tpublic String getDeclaredGenericSignature() {\\n\t\tif (this.genericSignature == null && isGeneric()) {\\n\t\t\t// BUG? what the hell is this doing - see testcode in MemberTestCase15.testMemberSignatureCreation() and run it\\n\t\t\t// off a Reflection World\\n\t\t}\\n\t\treturn genericSignature;\\n\t}\\n\\n\t@Over"
  },
  {
    "method_id": "M2983",
    "name": "isAnonymous",
    "return_type": "boolean",
    "signature": "isAnonymous()",
    "file_id": "F59",
    "start_line": 372,
    "text_preview": " {\\n\t\t// return false; // for now\\n\t\treturn getBaseClass().getTypeParameters().length > 0;\\n\t}\\n\\n\t@Override\\n\tpublic boolean isAnonymous() {\\n\t\treturn this.myClass.isAnonymousClass();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isNested() {\\n\t\treturn this.myClass.isMemberClass();\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType getOuterClass() {\\n\t\t re"
  },
  {
    "method_id": "M2984",
    "name": "isNested",
    "return_type": "boolean",
    "signature": "isNested()",
    "file_id": "F59",
    "start_line": 377,
    "text_preview": "\t}\\n\\n\t@Override\\n\tpublic boolean isAnonymous() {\\n\t\treturn this.myClass.isAnonymousClass();\\n\t}\\n\\n\t@Override\\n\tpublic boolean isNested() {\\n\t\treturn this.myClass.isMemberClass();\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType getOuterClass() {\\n\t\t return ReflectionBasedReferenceTypeDelegateFactory.resolveTypeInWorld(\\n\t\t\t\t \tmyClass.getEnc"
  },
  {
    "method_id": "M2985",
    "name": "getOuterClass",
    "return_type": "ResolvedType",
    "signature": "getOuterClass()",
    "file_id": "F59",
    "start_line": 382,
    "text_preview": "\\n\t}\\n\\n\t@Override\\n\tpublic boolean isNested() {\\n\t\treturn this.myClass.isMemberClass();\\n\t}\\n\\n\t@Override\\n\tpublic ResolvedType getOuterClass() {\\n\t\t return ReflectionBasedReferenceTypeDelegateFactory.resolveTypeInWorld(\\n\t\t\t\t \tmyClass.getEnclosingClass(),world);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M2986",
    "name": "JavaLangTypeToResolvedTypeConverter",
    "return_type": "",
    "signature": "JavaLangTypeToResolvedTypeConverter(World aWorld)",
    "file_id": "F60",
    "start_line": 38,
    "text_preview": "te Map<Type, TypeVariableReferenceType> typeVariablesInProgress = new HashMap<>();\\n\tprivate final World world;\\n\\n\tpublic JavaLangTypeToResolvedTypeConverter(World aWorld) {\\n\t\tthis.world = aWorld;\\n\t}\\n\\n\tprivate World getWorld() {\\n\t\treturn this.world;\\n\t}\\n\\n\tpublic ResolvedType fromType(Type type) {\\n\t\tif (type instanceof Cla"
  },
  {
    "method_id": "M2987",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F60",
    "start_line": 42,
    "text_preview": "nal World world;\\n\\n\tpublic JavaLangTypeToResolvedTypeConverter(World aWorld) {\\n\t\tthis.world = aWorld;\\n\t}\\n\\n\tprivate World getWorld() {\\n\t\treturn this.world;\\n\t}\\n\\n\tpublic ResolvedType fromType(Type type) {\\n\t\tif (type instanceof Class) {\\n\t\t\tClass<?> clazz = (Class<?>) type;\\n\t\t\tString name = clazz.getName();\\n\t\t\t/**\\n\t\t\t * getN"
  },
  {
    "method_id": "M2988",
    "name": "fromType",
    "return_type": "ResolvedType",
    "signature": "fromType(Type type)",
    "file_id": "F60",
    "start_line": 46,
    "text_preview": "er(World aWorld) {\\n\t\tthis.world = aWorld;\\n\t}\\n\\n\tprivate World getWorld() {\\n\t\treturn this.world;\\n\t}\\n\\n\tpublic ResolvedType fromType(Type type) {\\n\t\tif (type instanceof Class) {\\n\t\t\tClass<?> clazz = (Class<?>) type;\\n\t\t\tString name = clazz.getName();\\n\t\t\t/**\\n\t\t\t * getName() can return:\\n\t\t\t *\\n\t\t\t * 1. If this class object repre"
  },
  {
    "method_id": "M2989",
    "name": "if",
    "return_type": "",
    "signature": "if(type instanceof Class)",
    "file_id": "F60",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2990",
    "name": "if",
    "return_type": "else",
    "signature": "if(type instanceof ParameterizedType)",
    "file_id": "F60",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2991",
    "name": "if",
    "return_type": "else",
    "signature": "if(type instanceof java.lang.reflect.TypeVariable)",
    "file_id": "F60",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2992",
    "name": "if",
    "return_type": "",
    "signature": "if(inprogressVar != null)",
    "file_id": "F60",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2993",
    "name": "if",
    "return_type": "",
    "signature": "if(resBounds.length > 1)",
    "file_id": "F60",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2994",
    "name": "if",
    "return_type": "else",
    "signature": "if(type instanceof WildcardType)",
    "file_id": "F60",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2995",
    "name": "if",
    "return_type": "",
    "signature": "if(isExtends)",
    "file_id": "F60",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2996",
    "name": "if",
    "return_type": "else",
    "signature": "if(type instanceof GenericArrayType)",
    "file_id": "F60",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2997",
    "name": "fromTypes",
    "return_type": "ResolvedType[]",
    "signature": "fromTypes(Type[] types)",
    "file_id": "F60",
    "start_line": 83,
    "text_preview": "e this code which accesses it\\n\t\t\t\t// reflectively).\\n\t\t\t\treturn baseType;\\n\t\t\t}\\n\t\t\tResolvedType[] resolvedTypeArguments = fromTypes(typeArguments);\\n\t\t\treturn TypeFactory.createParameterizedType(baseType, resolvedTypeArguments, getWorld());\\n\t\t} else if (type instanceof java.lang.reflect.TypeVariable) {\\n\t\t\tTypeVariableRefe"
  },
  {
    "method_id": "M2998",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < ret.length; i++)",
    "file_id": "F60",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M2999",
    "name": "Jdk14Trace",
    "return_type": "",
    "signature": "Jdk14Trace(Class clazz)",
    "file_id": "F61",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3000",
    "name": "enter",
    "return_type": "void",
    "signature": "enter(String methodName, Object thiz, Object[] args)",
    "file_id": "F61",
    "start_line": 29,
    "text_preview": "(Class clazz) {\\n\t\tsuper(clazz);\\n\t\tthis.name = clazz.getName();\\n\t\tthis.logger = Logger.getLogger(name);\\n\t}\\n\\n\tpublic void enter(String methodName, Object thiz, Object[] args) {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.entering(name,methodName,formatObj(thiz));\\n\t\t\tif (args != null && logger.isLoggable(Level.FINER)"
  },
  {
    "method_id": "M3001",
    "name": "enter",
    "return_type": "void",
    "signature": "enter(String methodName, Object thiz)",
    "file_id": "F61",
    "start_line": 29,
    "text_preview": "(Class clazz) {\\n\t\tsuper(clazz);\\n\t\tthis.name = clazz.getName();\\n\t\tthis.logger = Logger.getLogger(name);\\n\t}\\n\\n\tpublic void enter(String methodName, Object thiz, Object[] args) {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.entering(name,methodName,formatObj(thiz));\\n\t\t\tif (args != null && logger.isLoggable(Level.FINER)"
  },
  {
    "method_id": "M3002",
    "name": "exit",
    "return_type": "void",
    "signature": "exit(String methodName, Object ret)",
    "file_id": "F61",
    "start_line": 42,
    "text_preview": "gs));\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic void enter(String methodName, Object thiz) {\\n\t\tenter(methodName,thiz,null);\\n\t}\\n\\n\tpublic void exit(String methodName, Object ret) {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.exiting(name,methodName,formatObj(ret));\\n\t\t}\\n\t}\\n\\n\tpublic void exit(String methodName, Throwable th) {\\n\t\tif (logge"
  },
  {
    "method_id": "M3003",
    "name": "exit",
    "return_type": "void",
    "signature": "exit(String methodName, Throwable th)",
    "file_id": "F61",
    "start_line": 42,
    "text_preview": "gs));\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic void enter(String methodName, Object thiz) {\\n\t\tenter(methodName,thiz,null);\\n\t}\\n\\n\tpublic void exit(String methodName, Object ret) {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.exiting(name,methodName,formatObj(ret));\\n\t\t}\\n\t}\\n\\n\tpublic void exit(String methodName, Throwable th) {\\n\t\tif (logge"
  },
  {
    "method_id": "M3004",
    "name": "exit",
    "return_type": "void",
    "signature": "exit(String methodName)",
    "file_id": "F61",
    "start_line": 42,
    "text_preview": "gs));\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic void enter(String methodName, Object thiz) {\\n\t\tenter(methodName,thiz,null);\\n\t}\\n\\n\tpublic void exit(String methodName, Object ret) {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.exiting(name,methodName,formatObj(ret));\\n\t\t}\\n\t}\\n\\n\tpublic void exit(String methodName, Throwable th) {\\n\t\tif (logge"
  },
  {
    "method_id": "M3005",
    "name": "event",
    "return_type": "void",
    "signature": "event(String methodName, Object thiz, Object[] args)",
    "file_id": "F61",
    "start_line": 60,
    "text_preview": "it(String methodName) {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.exiting(name,methodName);\\n\t\t}\\n\t}\\n\\n\tpublic void event(String methodName, Object thiz, Object[] args) {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.logp(Level.FINER,name,methodName,\"EVENT\",formatObj(thiz));\\n\t\t\tif (args != null && logger.isLogga"
  },
  {
    "method_id": "M3006",
    "name": "event",
    "return_type": "void",
    "signature": "event(String methodName)",
    "file_id": "F61",
    "start_line": 60,
    "text_preview": "it(String methodName) {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.exiting(name,methodName);\\n\t\t}\\n\t}\\n\\n\tpublic void event(String methodName, Object thiz, Object[] args) {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.logp(Level.FINER,name,methodName,\"EVENT\",formatObj(thiz));\\n\t\t\tif (args != null && logger.isLogga"
  },
  {
    "method_id": "M3007",
    "name": "isTraceEnabled",
    "return_type": "boolean",
    "signature": "isTraceEnabled()",
    "file_id": "F61",
    "start_line": 75,
    "text_preview": ") {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.logp(Level.FINER,name,methodName,\"EVENT\");\\n\t\t}\\n\t}\\n\\n\tpublic boolean isTraceEnabled() {\\n\t\treturn logger.isLoggable(Level.FINER);\\n\t}\\n\\n\tpublic void setTraceEnabled (boolean b) {\\n\t\tif (b) {\\n\t\t\tlogger.setLevel(Level.FINER);\\n\t\t\tHandler[] handlers = logger.getHandlers();\\n\t\t\t"
  },
  {
    "method_id": "M3008",
    "name": "setTraceEnabled",
    "return_type": "void",
    "signature": "setTraceEnabled(boolean b)",
    "file_id": "F61",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3009",
    "name": "if",
    "return_type": "",
    "signature": "if(b)",
    "file_id": "F61",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3010",
    "name": "if",
    "return_type": "",
    "signature": "if(handlers.length == 0)",
    "file_id": "F61",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3011",
    "name": "for",
    "return_type": "",
    "signature": "for(Handler handler : handlers)",
    "file_id": "F61",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3012",
    "name": "debug",
    "return_type": "void",
    "signature": "debug(String message)",
    "file_id": "F61",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3013",
    "name": "info",
    "return_type": "void",
    "signature": "info(String message)",
    "file_id": "F61",
    "start_line": 102,
    "text_preview": "blic void debug (String message) {\\n\t\tif (logger.isLoggable(Level.FINE)) {\\n\t\t\tlogger.fine(message);\\n\t\t}\\n\t}\\n\\n\tpublic void info(String message) {\\n\t\tif (logger.isLoggable(Level.INFO)) {\\n\t\t\tlogger.info(message);\\n\t\t}\\n\t}\\n\\n\tpublic void warn (String message, Throwable th) {\\n\t\tif (logger.isLoggable(Level.WARNING)) {\\n\t\t\tlogger.lo"
  },
  {
    "method_id": "M3014",
    "name": "warn",
    "return_type": "void",
    "signature": "warn(String message, Throwable th)",
    "file_id": "F61",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3015",
    "name": "error",
    "return_type": "void",
    "signature": "error(String message, Throwable th)",
    "file_id": "F61",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3016",
    "name": "fatal",
    "return_type": "void",
    "signature": "fatal(String message, Throwable th)",
    "file_id": "F61",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3017",
    "name": "getTrace",
    "return_type": "Trace",
    "signature": "getTrace(Class clazz)",
    "file_id": "F62",
    "start_line": 16,
    "text_preview": "***/\\npackage org.aspectj.weaver.tools;\\n\\npublic class Jdk14TraceFactory extends TraceFactory {\\n\\n\t@Override\\n\tpublic Trace getTrace(Class clazz) {\\n\t\treturn new Jdk14Trace(clazz);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3018",
    "name": "WeavingAdaptor",
    "return_type": "",
    "signature": "WeavingAdaptor()",
    "file_id": "F63",
    "start_line": 109,
    "text_preview": "ACKAGE = 0x4;\\n\\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(WeavingAdaptor.class);\\n\\n\tprotected WeavingAdaptor() {\\n\t}\\n\\n\t/**\\n\t * Construct a WeavingAdaptor with a reference to a weaving class loader. The adaptor will automatically search the class loader\\n\t * hierarchy to resolve classes. The adap"
  },
  {
    "method_id": "M3019",
    "name": "WeavingAdaptor",
    "return_type": "",
    "signature": "WeavingAdaptor(WeavingClassLoader loader)",
    "file_id": "F63",
    "start_line": 109,
    "text_preview": "ACKAGE = 0x4;\\n\\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(WeavingAdaptor.class);\\n\\n\tprotected WeavingAdaptor() {\\n\t}\\n\\n\t/**\\n\t * Construct a WeavingAdaptor with a reference to a weaving class loader. The adaptor will automatically search the class loader\\n\t * hierarchy to resolve classes. The adap"
  },
  {
    "method_id": "M3020",
    "name": "WeavingAdaptor",
    "return_type": "",
    "signature": "WeavingAdaptor(GeneratedClassHandler handler, URL[] classURLs, URL[] aspectURLs)",
    "file_id": "F63",
    "start_line": 109,
    "text_preview": "ACKAGE = 0x4;\\n\\n\tprivate static Trace trace = TraceFactory.getTraceFactory().getTrace(WeavingAdaptor.class);\\n\\n\tprotected WeavingAdaptor() {\\n\t}\\n\\n\t/**\\n\t * Construct a WeavingAdaptor with a reference to a weaving class loader. The adaptor will automatically search the class loader\\n\t * hierarchy to resolve classes. The adap"
  },
  {
    "method_id": "M3021",
    "name": "getFullClassPath",
    "return_type": "List<String>",
    "signature": "getFullClassPath(ClassLoader loader)",
    "file_id": "F63",
    "start_line": 122,
    "text_preview": "daptor.<init>(\" + loader +\",\" + aspectURLs.length + \")\");\\n\t\tgeneratedClassHandler = loader;\\n\t\tinit((ClassLoader)loader, getFullClassPath((ClassLoader) loader), getFullAspectPath((ClassLoader) loader/* ,aspectURLs */));\\n\t}\\n\\n\t/**\\n\t * Construct a WeavingAdaptor with a reference to a <code>GeneratedClassHandler</code>, a f"
  },
  {
    "method_id": "M3022",
    "name": "if",
    "return_type": "",
    "signature": "if(loader instanceof URLClassLoader)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3023",
    "name": "getFullAspectPath",
    "return_type": "List<String>",
    "signature": "getFullAspectPath(ClassLoader loader)",
    "file_id": "F63",
    "start_line": 122,
    "text_preview": "Ls.length + \")\");\\n\t\tgeneratedClassHandler = loader;\\n\t\tinit((ClassLoader)loader, getFullClassPath((ClassLoader) loader), getFullAspectPath((ClassLoader) loader/* ,aspectURLs */));\\n\t}\\n\\n\t/**\\n\t * Construct a WeavingAdaptor with a reference to a <code>GeneratedClassHandler</code>, a full search path for resolving classes\\n\t "
  },
  {
    "method_id": "M3024",
    "name": "if",
    "return_type": "",
    "signature": "if(loader instanceof WeavingClassLoader)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3025",
    "name": "getVerbose",
    "return_type": "boolean",
    "signature": "getVerbose()",
    "file_id": "F63",
    "start_line": 87,
    "text_preview": "_INITIAL_CHARS = ASPECTJ_BASE_PACKAGE.charAt(0) + \"sj\";\\n\\n\tprivate boolean enabled = false;\\n\tprotected boolean verbose = getVerbose();\\n\tprotected BcelWorld bcelWorld;\\n\tprotected BcelWeaver weaver;\\n\tprivate IMessageHandler messageHandler;\\n\tprivate WeavingAdaptorMessageHolder messageHolder;\\n\tprivate boolean abortOnError ="
  },
  {
    "method_id": "M3026",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3027",
    "name": "init",
    "return_type": "void",
    "signature": "init(ClassLoader loader, List<String> classPath, List<String> aspectPath)",
    "file_id": "F63",
    "start_line": 122,
    "text_preview": "em.err.println(\"? WeavingAdaptor.<init>(\" + loader +\",\" + aspectURLs.length + \")\");\\n\t\tgeneratedClassHandler = loader;\\n\t\tinit((ClassLoader)loader, getFullClassPath((ClassLoader) loader), getFullAspectPath((ClassLoader) loader/* ,aspectURLs */));\\n\t}\\n\\n\t/**\\n\t * Construct a WeavingAdaptor with a reference to a <code>Generat"
  },
  {
    "method_id": "M3028",
    "name": "initializeCache",
    "return_type": "void",
    "signature": "initializeCache(ClassLoader loader, List<String> aspects, GeneratedClassHandler existingClassHandler, IMessageHandler myMessageHandler)",
    "file_id": "F63",
    "start_line": 207,
    "text_preview": "\\n\t\tbcelWorld.setBehaveInJava5Way(true);\\n\\n\t\tweaver = new BcelWeaver(bcelWorld);\\n\t\tregisterAspectLibraries(aspectPath);\\n\t\tinitializeCache(loader, aspectPath, null, getMessageHandler());\\n\t\tenabled = true;\\n\t}\\n\\n\t/**\\n\t * If the cache is enabled, initialize it and swap out the existing classhandler\\n\t * for the caching one -\\n\t"
  },
  {
    "method_id": "M3029",
    "name": "if",
    "return_type": "cached",
    "signature": "if(cache != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3030",
    "name": "createMessageHandler",
    "return_type": "void",
    "signature": "createMessageHandler()",
    "file_id": "F63",
    "start_line": 195,
    "text_preview": "\t */\\n\tprivate void init(ClassLoader loader, List<String> classPath, List<String> aspectPath) {\\n\t\tabortOnError = true;\\n\t\tcreateMessageHandler();\\n\\n\t\tinfo(\"using classpath: \" + classPath);\\n\t\tinfo(\"using aspectpath: \" + aspectPath);\\n\\n\t\tbcelWorld = new BcelWorld(classPath, messageHandler, null);\\n\t\tbcelWorld.setXnoInline(fal"
  },
  {
    "method_id": "M3031",
    "name": "if",
    "return_type": "",
    "signature": "if(verbose)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3032",
    "name": "getMessageHandler",
    "return_type": "IMessageHandler",
    "signature": "getMessageHandler()",
    "file_id": "F63",
    "start_line": 207,
    "text_preview": "\tweaver = new BcelWeaver(bcelWorld);\\n\t\tregisterAspectLibraries(aspectPath);\\n\t\tinitializeCache(loader, aspectPath, null, getMessageHandler());\\n\t\tenabled = true;\\n\t}\\n\\n\t/**\\n\t * If the cache is enabled, initialize it and swap out the existing classhandler\\n\t * for the caching one -\\n\t *\\n\t * @param loader\t\t\t   classloader for "
  },
  {
    "method_id": "M3033",
    "name": "getMessageHolder",
    "return_type": "IMessageHolder",
    "signature": "getMessageHolder()",
    "file_id": "F63",
    "start_line": 247,
    "text_preview": " //$NON-NLS-1$\\n\t}\\n\\n\tprotected IMessageHandler getMessageHandler() {\\n\t\treturn messageHandler;\\n\t}\\n\\n\tpublic IMessageHolder getMessageHolder() {\\n\t\treturn messageHolder;\\n\t}\\n\\n\tprotected void setMessageHandler(IMessageHandler mh) {\\n\t\tif (mh instanceof ISupportsMessageContext) {\\n\t\t\tISupportsMessageContext smc = (ISupportsMessa"
  },
  {
    "method_id": "M3034",
    "name": "setMessageHandler",
    "return_type": "void",
    "signature": "setMessageHandler(IMessageHandler mh)",
    "file_id": "F63",
    "start_line": 251,
    "text_preview": " {\\n\t\treturn messageHandler;\\n\t}\\n\\n\tpublic IMessageHolder getMessageHolder() {\\n\t\treturn messageHolder;\\n\t}\\n\\n\tprotected void setMessageHandler(IMessageHandler mh) {\\n\t\tif (mh instanceof ISupportsMessageContext) {\\n\t\t\tISupportsMessageContext smc = (ISupportsMessageContext) mh;\\n\t\t\tsmc.setMessageContext(this);\\n\t\t}\\n\t\tif (mh != me"
  },
  {
    "method_id": "M3035",
    "name": "if",
    "return_type": "",
    "signature": "if(mh instanceof ISupportsMessageContext)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3036",
    "name": "if",
    "return_type": "",
    "signature": "if(mh != messageHolder)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3037",
    "name": "disable",
    "return_type": "void",
    "signature": "disable()",
    "file_id": "F63",
    "start_line": 262,
    "text_preview": "\t\tif (mh != messageHolder) {\\n\t\t\tmessageHolder.setDelegate(mh);\\n\t\t}\\n\t\tmessageHolder.flushMessages();\\n\t}\\n\\n\tprotected void disable() {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"disable\", this);\\n\t\t}\\n\\n\t\tenabled = false;\\n\t\tmessageHolder.flushMessages();\\n\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.exit(\"disable\");\\n\t\t}\\n\t}\\n"
  },
  {
    "method_id": "M3038",
    "name": "enable",
    "return_type": "void",
    "signature": "enable()",
    "file_id": "F63",
    "start_line": 275,
    "text_preview": "se;\\n\t\tmessageHolder.flushMessages();\\n\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.exit(\"disable\");\\n\t\t}\\n\t}\\n\\n\tprotected void enable() {\\n\t\tenabled = true;\\n\t\tmessageHolder.flushMessages();\\n\t}\\n\\n\tprotected boolean isEnabled() {\\n\t\treturn enabled;\\n\t}\\n\\n\t/**\\n\t * Appends URL to path used by the WeavingAdptor to resolve classes\\n\t *\\n\t"
  },
  {
    "method_id": "M3039",
    "name": "isEnabled",
    "return_type": "boolean",
    "signature": "isEnabled()",
    "file_id": "F63",
    "start_line": 221,
    "text_preview": "String> aspects, GeneratedClassHandler existingClassHandler, IMessageHandler myMessageHandler) {\\n\t\tif (WeavedClassCache.isEnabled()) {\\n\t\t\tcache = WeavedClassCache.createCache(loader, aspects, existingClassHandler, myMessageHandler);\\n\t\t\t// Wrap the existing class handler so that any generated classes are also cached\\n\t\t\t"
  },
  {
    "method_id": "M3040",
    "name": "addURL",
    "return_type": "void",
    "signature": "addURL(URL url)",
    "file_id": "F63",
    "start_line": 289,
    "text_preview": "to path used by the WeavingAdptor to resolve classes\\n\t *\\n\t * @param url to be appended to search path\\n\t */\\n\tpublic void addURL(URL url) {\\n\t\tFile libFile = new File(url.getPath());\\n\t\ttry {\\n\t\t\tweaver.addLibraryJarFile(libFile);\\n\t\t} catch (IOException ex) {\\n\t\t\twarn(\"bad library: '\" + libFile + \"'\");\\n\t\t}\\n\t}\\n\\n\t/**\\n\t * Weave"
  },
  {
    "method_id": "M3041",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ex)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3042",
    "name": "weaveClass",
    "return_type": "byte[]",
    "signature": "weaveClass(String name, byte[] bytes)",
    "file_id": "F63",
    "start_line": 306,
    "text_preview": " * @param bytes the class bytes\\n\t * @return the woven bytes\\n\t * @exception IOException weave failed\\n\t */\\n\tpublic byte[] weaveClass(String name, byte[] bytes) throws IOException {\\n\t\treturn weaveClass(name, bytes, false);\\n\t}\\n\\n\t// Track if the weaver is already running on this thread - don't allow re-entrant calls\\n\tprivat"
  },
  {
    "method_id": "M3043",
    "name": "initialValue",
    "return_type": "Boolean",
    "signature": "initialValue()",
    "file_id": "F63",
    "start_line": 313,
    "text_preview": "ntrant calls\\n\tprivate ThreadLocal<Boolean> weaverRunning = new ThreadLocal<Boolean>() {\\n\t\t@Override\\n\t\tprotected Boolean initialValue() {\\n\t\t\treturn Boolean.FALSE;\\n\t\t}\\n\t};\\n\\n\t/**\\n\t * Weave a class using aspects previously supplied to the adaptor.\\n\t *\\n\t * @param name      the name of the class in the internal form of fully"
  },
  {
    "method_id": "M3044",
    "name": "weaveClass",
    "return_type": "byte[]",
    "signature": "weaveClass(String name, final byte[] bytes, boolean mustWeave)",
    "file_id": "F63",
    "start_line": 306,
    "text_preview": " * @param bytes the class bytes\\n\t * @return the woven bytes\\n\t * @exception IOException weave failed\\n\t */\\n\tpublic byte[] weaveClass(String name, byte[] bytes) throws IOException {\\n\t\treturn weaveClass(name, bytes, false);\\n\t}\\n\\n\t// Track if the weaver is already running on this thread - don't allow re-entrant calls\\n\tprivat"
  },
  {
    "method_id": "M3045",
    "name": "if",
    "return_type": "",
    "signature": "if(trace == null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3046",
    "name": "if",
    "return_type": "",
    "signature": "if(!enabled)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3047",
    "name": "if",
    "return_type": "",
    "signature": "if(wovenBytes != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3048",
    "name": "if",
    "return_type": "",
    "signature": "if(debugOn)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3049",
    "name": "if",
    "return_type": "",
    "signature": "if(cache != null && !mustWeave)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3050",
    "name": "if",
    "return_type": "",
    "signature": "if(entry != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3051",
    "name": "if",
    "return_type": "weaver",
    "signature": "if(debugOn)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3052",
    "name": "if",
    "return_type": "",
    "signature": "if(mustWeave)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3053",
    "name": "if",
    "return_type": "",
    "signature": "if(debugOn)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3054",
    "name": "if",
    "return_type": "",
    "signature": "if(cacheKey != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3055",
    "name": "if",
    "return_type": "",
    "signature": "if(newBytes == null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3056",
    "name": "if",
    "return_type": "else",
    "signature": "if(debugOn)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3057",
    "name": "if",
    "return_type": "else",
    "signature": "if(debugOn)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3058",
    "name": "wovenWithGeneratedClass",
    "return_type": "byte[]",
    "signature": "wovenWithGeneratedClass(String name)",
    "file_id": "F63",
    "start_line": 362,
    "text_preview": "\tboolean debugOn = !messageHandler.isIgnoring(Message.DEBUG);\\n\\n\t\t\tname = name.replace('/', '.');\\n\t\t\tbyte[] wovenBytes = wovenWithGeneratedClass(name);\\n\t\t\tif (wovenBytes != null) {\\n\t\t\t\tif (debugOn) {\\n\t\t\t\t\tdebug(\"returning woven bytes for '\" + name + \"' that were generated by a previous weaving process\");\\n\t\t\t\t}\\n\t\t\t\tretur"
  },
  {
    "method_id": "M3059",
    "name": "if",
    "return_type": "",
    "signature": "if(woven == null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3060",
    "name": "accept",
    "return_type": "boolean",
    "signature": "accept(String name, byte[] bytes)",
    "file_id": "F63",
    "start_line": 373,
    "text_preview": "\t\t}\\n\t\t\t\treturn wovenBytes;\\n\t\t\t}\\n\\n\t\t\ttry {\\n\t\t\t\tdelegateForCurrentClass = null;\\n\t\t\t\tif (shouldWeaveName(name)) {\\n\t\t\t\t\tif (accept(name, bytes)) {\\n\\n\t\t\t\t\t\t// Determine if we have the weaved class cached\\n\t\t\t\t\t\tCachedClassReference cacheKey = null;\\n\t\t\t\t\t\tif (cache != null && !mustWeave) {\\n\t\t\t\t\t\t\tcacheKey = cache.createCacheKe"
  },
  {
    "method_id": "M3061",
    "name": "shouldDump",
    "return_type": "boolean",
    "signature": "shouldDump(String name, boolean before)",
    "file_id": "F63",
    "start_line": 471,
    "text_preview": "n.getBytes();\\n\t}\\n\\n\t// ATAJ\\n\tprotected boolean accept(String name, byte[] bytes) {\\n\t\treturn true;\\n\t}\\n\\n\tprotected boolean shouldDump(String name, boolean before) {\\n\t\treturn false;\\n\t}\\n\\n\tprivate boolean shouldWeaveName(String name) {\\n\t\tif (PACKAGE_INITIAL_CHARS.indexOf(name.charAt(0)) != -1) {\\n\t\t\tif ((weavingSpecialTypes &"
  },
  {
    "method_id": "M3062",
    "name": "shouldWeaveName",
    "return_type": "boolean",
    "signature": "shouldWeaveName(String name)",
    "file_id": "F63",
    "start_line": 372,
    "text_preview": "y a previous weaving process\");\\n\t\t\t\t}\\n\t\t\t\treturn wovenBytes;\\n\t\t\t}\\n\\n\t\t\ttry {\\n\t\t\t\tdelegateForCurrentClass = null;\\n\t\t\t\tif (shouldWeaveName(name)) {\\n\t\t\t\t\tif (accept(name, bytes)) {\\n\\n\t\t\t\t\t\t// Determine if we have the weaved class cached\\n\t\t\t\t\t\tCachedClassReference cacheKey = null;\\n\t\t\t\t\t\tif (cache != null && !mustWeave) {\\n\t\t\t"
  },
  {
    "method_id": "M3063",
    "name": "if",
    "return_type": "",
    "signature": "if(p != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3064",
    "name": "if",
    "return_type": "",
    "signature": "if(b)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3065",
    "name": "if",
    "return_type": "",
    "signature": "if(b)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3066",
    "name": "if",
    "return_type": "",
    "signature": "if(!haveWarnedOnJavax)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3067",
    "name": "shouldWeaveAnnotationStyleAspect",
    "return_type": "boolean",
    "signature": "shouldWeaveAnnotationStyleAspect(String name, byte[] bytes)",
    "file_id": "F63",
    "start_line": 406,
    "text_preview": "do - we should\\n\t\t\t\t\t\t// expect the user to name them if they want them woven - just like code style\\n\t\t\t\t\t\t// } else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {\\n\t\t\t\t\t\t// if (mustWeave) {\\n\t\t\t\t\t\t// if (bcelWorld.getLint().mustWeaveXmlDefinedAspects.isEnabled()) {\\n\t\t\t\t\t\t// bcelWorld.getLint().mustWeaveXmlDefinedAs"
  },
  {
    "method_id": "M3068",
    "name": "if",
    "return_type": "",
    "signature": "if(delegateForCurrentClass == null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3069",
    "name": "asmCheckAnnotationStyleAspect",
    "return_type": "boolean",
    "signature": "asmCheckAnnotationStyleAspect(byte[] bytes)",
    "file_id": "F63",
    "start_line": 534,
    "text_preview": "String name, byte[] bytes) {\\n\t\tif (delegateForCurrentClass == null) {\\n\t\t\t// if (weaver.getWorld().isASMAround()) return asmCheckAnnotationStyleAspect(bytes);\\n\t\t\t// else\\n\t\t\tensureDelegateInitialized(name, bytes);\\n\t\t}\\n\t\treturn (delegateForCurrentClass.isAnnotationStyleAspect());\\n\t}\\n\\n\t// private boolean asmCheckAnnotation"
  },
  {
    "method_id": "M3070",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception spe)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3071",
    "name": "ensureDelegateInitialized",
    "return_type": "void",
    "signature": "ensureDelegateInitialized(String name, byte[] bytes)",
    "file_id": "F63",
    "start_line": 536,
    "text_preview": "tClass == null) {\\n\t\t\t// if (weaver.getWorld().isASMAround()) return asmCheckAnnotationStyleAspect(bytes);\\n\t\t\t// else\\n\t\t\tensureDelegateInitialized(name, bytes);\\n\t\t}\\n\t\treturn (delegateForCurrentClass.isAnnotationStyleAspect());\\n\t}\\n\\n\t// private boolean asmCheckAnnotationStyleAspect(byte[] bytes) {\\n\t// IsAtAspectAnnotation"
  },
  {
    "method_id": "M3072",
    "name": "if",
    "return_type": "",
    "signature": "if(delegateForCurrentClass == null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3073",
    "name": "getWovenBytes",
    "return_type": "byte[]",
    "signature": "getWovenBytes(String name, byte[] bytes)",
    "file_id": "F63",
    "start_line": 398,
    "text_preview": "ts being applied by 'this' weaver\\n\t\t\t\t\t\tif (debugOn) {\\n\t\t\t\t\t\t\tdebug(\"weaving '\" + name + \"'\");\\n\t\t\t\t\t\t}\\n\t\t\t\t\t\tnewBytes = getWovenBytes(name, bytes);\\n\t\t\t\t\t\t// TODO: Is this OK performance-wise?\\n\t\t\t\t\t\tif (Arrays.equals(bytes, newBytes)) {\\n\t\t\t\t\t\t\t// null means unchanged in java.lang.instrument.ClassFileTransformer::transfo"
  },
  {
    "method_id": "M3074",
    "name": "getAtAspectJAspectBytes",
    "return_type": "byte[]",
    "signature": "getAtAspectJAspectBytes(String name, byte[] bytes)",
    "file_id": "F63",
    "start_line": 416,
    "text_preview": "ed by the aspectOf munger\\n\t\t\t\t\t\t// if (debugOn) {\\n\t\t\t\t\t\t// debug(\"weaving '\" + name + \"'\");\\n\t\t\t\t\t\t// }\\n\t\t\t\t\t\t// bytes = getAtAspectJAspectBytes(name, bytes);\\n\\n\t\t\t\t\t\t// Add the weaved class to the cache only if there\\n\t\t\t\t\t\t// has been an actual change\\n\t\t\t\t\t\t// JVK: Is there a better way to check if the class has\\n\t\t\t\t\t\t/"
  },
  {
    "method_id": "M3075",
    "name": "registerAspectLibraries",
    "return_type": "void",
    "signature": "registerAspectLibraries(List<String> aspectPath)",
    "file_id": "F63",
    "start_line": 206,
    "text_preview": "orld.getLint().loadDefaultProperties();\\n\t\tbcelWorld.setBehaveInJava5Way(true);\\n\\n\t\tweaver = new BcelWeaver(bcelWorld);\\n\t\tregisterAspectLibraries(aspectPath);\\n\t\tinitializeCache(loader, aspectPath, null, getMessageHandler());\\n\t\tenabled = true;\\n\t}\\n\\n\t/**\\n\t * If the cache is enabled, initialize it and swap out the existing c"
  },
  {
    "method_id": "M3076",
    "name": "for",
    "return_type": "",
    "signature": "for(String libName : aspectPath)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3077",
    "name": "addAspectLibrary",
    "return_type": "void",
    "signature": "addAspectLibrary(String aspectLibraryName)",
    "file_id": "F63",
    "start_line": 597,
    "text_preview": "m.err.println(\"? WeavingAdaptor.registerAspectLibraries(\" + aspectPath + \")\");\\n\t\tfor (String libName : aspectPath) {\\n\t\t\taddAspectLibrary(libName);\\n\t\t}\\n\\n\t\tweaver.prepareForWeave();\\n\t}\\n\\n\t/*\\n\t * Register an aspect library with this classloader for use during weaving. This class loader will also return (unmodified) any\\n\t *"
  },
  {
    "method_id": "M3078",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ex)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3079",
    "name": "makeClasspath",
    "return_type": "List<String>",
    "signature": "makeClasspath(String cp)",
    "file_id": "F63",
    "start_line": 137,
    "text_preview": "tURLs) {\\n\t\t// System.err.println(\"? WeavingAdaptor.<init>()\");\\n\t\tgeneratedClassHandler = handler;\\n\t\tinit(null, FileUtil.makeClasspath(classURLs), FileUtil.makeClasspath(aspectURLs));\\n\t}\\n\\n\tprotected List<String> getFullClassPath(ClassLoader loader) {\\n\t\tList<String> list = new LinkedList<>();\\n\t\tfor (; loader != null; loa"
  },
  {
    "method_id": "M3080",
    "name": "if",
    "return_type": "",
    "signature": "if(cp != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3081",
    "name": "debug",
    "return_type": "boolean",
    "signature": "debug(String message)",
    "file_id": "F63",
    "start_line": 365,
    "text_preview": "e('/', '.');\\n\t\t\tbyte[] wovenBytes = wovenWithGeneratedClass(name);\\n\t\t\tif (wovenBytes != null) {\\n\t\t\t\tif (debugOn) {\\n\t\t\t\t\tdebug(\"returning woven bytes for '\" + name + \"' that were generated by a previous weaving process\");\\n\t\t\t\t}\\n\t\t\t\treturn wovenBytes;\\n\t\t\t}\\n\\n\t\t\ttry {\\n\t\t\t\tdelegateForCurrentClass = null;\\n\t\t\t\tif (shouldWeave"
  },
  {
    "method_id": "M3082",
    "name": "info",
    "return_type": "boolean",
    "signature": "info(String message)",
    "file_id": "F63",
    "start_line": 197,
    "text_preview": "ssLoader loader, List<String> classPath, List<String> aspectPath) {\\n\t\tabortOnError = true;\\n\t\tcreateMessageHandler();\\n\\n\t\tinfo(\"using classpath: \" + classPath);\\n\t\tinfo(\"using aspectpath: \" + aspectPath);\\n\\n\t\tbcelWorld = new BcelWorld(classPath, messageHandler, null);\\n\t\tbcelWorld.setXnoInline(false);\\n\t\tbcelWorld.getLint()."
  },
  {
    "method_id": "M3083",
    "name": "warn",
    "return_type": "boolean",
    "signature": "warn(String message)",
    "file_id": "F63",
    "start_line": 147,
    "text_preview": "\t\t\t\tURL[] urls = ((URLClassLoader) loader).getURLs();\\n\t\t\t\tlist.addAll(0, FileUtil.makeClasspath(urls));\\n\t\t\t} else {\\n\t\t\t\twarn(\"cannot determine classpath\");\\n\t\t\t}\\n\t\t}\\n\t\t// On Java9 it is possible to fail to find a URLClassLoader from which to derive a suitable classpath\\n\t\t// For now we can determine it from the java.clas"
  },
  {
    "method_id": "M3084",
    "name": "warn",
    "return_type": "boolean",
    "signature": "warn(String message, Throwable th)",
    "file_id": "F63",
    "start_line": 147,
    "text_preview": "\t\t\t\tURL[] urls = ((URLClassLoader) loader).getURLs();\\n\t\t\t\tlist.addAll(0, FileUtil.makeClasspath(urls));\\n\t\t\t} else {\\n\t\t\t\twarn(\"cannot determine classpath\");\\n\t\t\t}\\n\t\t}\\n\t\t// On Java9 it is possible to fail to find a URLClassLoader from which to derive a suitable classpath\\n\t\t// For now we can determine it from the java.clas"
  },
  {
    "method_id": "M3085",
    "name": "error",
    "return_type": "boolean",
    "signature": "error(String message)",
    "file_id": "F63",
    "start_line": 619,
    "text_preview": "pect library: '\" + aspectLibrary + \"'\");\\n\t\t\t\tweaver.addLibraryJarFile(aspectLibrary);\\n\t\t\t} catch (IOException ex) {\\n\t\t\t\terror(\"exception adding aspect library: '\" + ex + \"'\");\\n\t\t\t}\\n\t\t} else {\\n\t\t\terror(\"bad aspect library: '\" + aspectLibrary + \"'\");\\n\t\t}\\n\t}\\n\\n\tprivate static List<String> makeClasspath(String cp) {\\n\t\tList<"
  },
  {
    "method_id": "M3086",
    "name": "error",
    "return_type": "boolean",
    "signature": "error(String message, Throwable th)",
    "file_id": "F63",
    "start_line": 619,
    "text_preview": "pect library: '\" + aspectLibrary + \"'\");\\n\t\t\t\tweaver.addLibraryJarFile(aspectLibrary);\\n\t\t\t} catch (IOException ex) {\\n\t\t\t\terror(\"exception adding aspect library: '\" + ex + \"'\");\\n\t\t\t}\\n\t\t} else {\\n\t\t\terror(\"bad aspect library: '\" + aspectLibrary + \"'\");\\n\t\t}\\n\t}\\n\\n\tprivate static List<String> makeClasspath(String cp) {\\n\t\tList<"
  },
  {
    "method_id": "M3087",
    "name": "getContextId",
    "return_type": "String",
    "signature": "getContextId()",
    "file_id": "F63",
    "start_line": 661,
    "text_preview": "rowable th) {\\n\t\treturn messageHandler.handleMessage(new Message(message, IMessage.ERROR, th, null));\\n\t}\\n\\n\tpublic String getContextId() {\\n\t\treturn \"WeavingAdaptor\";\\n\t}\\n\\n\t/**\\n\t * Dump the given bytcode in _dump/... (dev mode)\\n\t *\\n\t * @param name\\n\t * @param b\\n\t * @param before whether we are dumping before weaving\\n\t */\\n\tp"
  },
  {
    "method_id": "M3088",
    "name": "dump",
    "return_type": "void",
    "signature": "dump(String name, byte[] b, boolean before)",
    "file_id": "F63",
    "start_line": 672,
    "text_preview": "dev mode)\\n\t *\\n\t * @param name\\n\t * @param b\\n\t * @param before whether we are dumping before weaving\\n\t */\\n\tprotected void dump(String name, byte[] b, boolean before) {\\n\t\tString dirName = getDumpDir();\\n\\n\t\tif (before) {\\n\t\t\tdirName = dirName + File.separator + \"_before\";\\n\t\t}\\n\\n\t\tString className = name.replace('.', '/');\\n\t\tf"
  },
  {
    "method_id": "M3089",
    "name": "if",
    "return_type": "",
    "signature": "if(before)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3090",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ex)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3091",
    "name": "getDumpDir",
    "return_type": "String",
    "signature": "getDumpDir()",
    "file_id": "F63",
    "start_line": 673,
    "text_preview": "her we are dumping before weaving\\n\t */\\n\tprotected void dump(String name, byte[] b, boolean before) {\\n\t\tString dirName = getDumpDir();\\n\\n\t\tif (before) {\\n\t\t\tdirName = dirName + File.separator + \"_before\";\\n\t\t}\\n\\n\t\tString className = name.replace('.', '/');\\n\t\tfinal File dir;\\n\t\tif (className.indexOf('/') > 0) {\\n\t\t\tdir = new F"
  },
  {
    "method_id": "M3092",
    "name": "WeavingAdaptorMessageHolder",
    "return_type": "",
    "signature": "WeavingAdaptorMessageHolder(PrintWriter writer)",
    "file_id": "F63",
    "start_line": 232,
    "text_preview": "sHandler = cache.getCachingClassHandler();\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\\n\tprotected void createMessageHandler() {\\n\t\tmessageHolder = new WeavingAdaptorMessageHolder(new PrintWriter(System.err));\\n\t\tmessageHandler = messageHolder;\\n\t\tif (verbose) {\\n\t\t\tmessageHandler.dontIgnore(IMessage.INFO);\\n\t\t}\\n\t\tif (Boolean.getBoolean(SHOW_WEAVE_INFO_P"
  },
  {
    "method_id": "M3093",
    "name": "traceMessage",
    "return_type": "void",
    "signature": "traceMessage(IMessage message)",
    "file_id": "F63",
    "start_line": 721,
    "text_preview": "\t\tthis.delegate = new WeavingAdaptorMessageWriter(writer);\\n\t\t\tsuper.dontIgnore(IMessage.WEAVEINFO);\\n\t\t}\\n\\n\t\tprivate void traceMessage(IMessage message) {\\n\t\t\tif (message instanceof WeaveMessage) {\\n\t\t\t\ttrace.debug(render(message));\\n\t\t\t} else if (message.isDebug()) {\\n\t\t\t\ttrace.debug(render(message));\\n\t\t\t} else if (message."
  },
  {
    "method_id": "M3094",
    "name": "if",
    "return_type": "",
    "signature": "if(message instanceof WeaveMessage)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3095",
    "name": "render",
    "return_type": "String",
    "signature": "render(IMessage message)",
    "file_id": "F63",
    "start_line": 723,
    "text_preview": "VEINFO);\\n\t\t}\\n\\n\t\tprivate void traceMessage(IMessage message) {\\n\t\t\tif (message instanceof WeaveMessage) {\\n\t\t\t\ttrace.debug(render(message));\\n\t\t\t} else if (message.isDebug()) {\\n\t\t\t\ttrace.debug(render(message));\\n\t\t\t} else if (message.isInfo()) {\\n\t\t\t\ttrace.info(render(message));\\n\t\t\t} else if (message.isWarning()) {\\n\t\t\t\ttrace"
  },
  {
    "method_id": "M3096",
    "name": "flushMessages",
    "return_type": "void",
    "signature": "flushMessages()",
    "file_id": "F63",
    "start_line": 259,
    "text_preview": "\\n\t\t\tsmc.setMessageContext(this);\\n\t\t}\\n\t\tif (mh != messageHolder) {\\n\t\t\tmessageHolder.setDelegate(mh);\\n\t\t}\\n\t\tmessageHolder.flushMessages();\\n\t}\\n\\n\tprotected void disable() {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"disable\", this);\\n\t\t}\\n\\n\t\tenabled = false;\\n\t\tmessageHolder.flushMessages();\\n\\n\t\tif (trace.isTraceEnabled()"
  },
  {
    "method_id": "M3097",
    "name": "if",
    "return_type": "",
    "signature": "if(savedMessages == null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3098",
    "name": "for",
    "return_type": "",
    "signature": "for(IMessage message : savedMessages)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3099",
    "name": "setDelegate",
    "return_type": "void",
    "signature": "setDelegate(IMessageHandler messageHandler)",
    "file_id": "F63",
    "start_line": 257,
    "text_preview": "t smc = (ISupportsMessageContext) mh;\\n\t\t\tsmc.setMessageContext(this);\\n\t\t}\\n\t\tif (mh != messageHolder) {\\n\t\t\tmessageHolder.setDelegate(mh);\\n\t\t}\\n\t\tmessageHolder.flushMessages();\\n\t}\\n\\n\tprotected void disable() {\\n\t\tif (trace.isTraceEnabled()) {\\n\t\t\ttrace.enter(\"disable\", this);\\n\t\t}\\n\\n\t\tenabled = false;\\n\t\tmessageHolder.flushMess"
  },
  {
    "method_id": "M3100",
    "name": "handleMessage",
    "return_type": "boolean",
    "signature": "handleMessage(IMessage message)",
    "file_id": "F63",
    "start_line": 650,
    "text_preview": "Util.warn(messageHandler, message);\\n\t}\\n\\n\tprotected boolean warn(String message, Throwable th) {\\n\t\treturn messageHandler.handleMessage(new Message(message, IMessage.WARNING, th, null));\\n\t}\\n\\n\tprotected boolean error(String message) {\\n\t\treturn MessageUtil.error(messageHandler, message);\\n\t}\\n\\n\tprotected boolean error(String"
  },
  {
    "method_id": "M3101",
    "name": "if",
    "return_type": "",
    "signature": "if(traceMessages)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3102",
    "name": "if",
    "return_type": "",
    "signature": "if(accumulating)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3103",
    "name": "if",
    "return_type": "",
    "signature": "if(savedMessages != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3104",
    "name": "isIgnoring",
    "return_type": "boolean",
    "signature": "isIgnoring(Kind kind)",
    "file_id": "F63",
    "start_line": 359,
    "text_preview": "aceEnabled()) {\\n\t\t\t\t\ttrace.exit(\"weaveClass\", false);\\n\t\t\t\t}\\n\t\t\t\treturn null;\\n\t\t\t}\\n\\n\t\t\tboolean debugOn = !messageHandler.isIgnoring(Message.DEBUG);\\n\\n\t\t\tname = name.replace('/', '.');\\n\t\t\tbyte[] wovenBytes = wovenWithGeneratedClass(name);\\n\t\t\tif (wovenBytes != null) {\\n\t\t\t\tif (debugOn) {\\n\t\t\t\t\tdebug(\"returning woven bytes fo"
  },
  {
    "method_id": "M3105",
    "name": "dontIgnore",
    "return_type": "void",
    "signature": "dontIgnore(IMessage.Kind kind)",
    "file_id": "F63",
    "start_line": 235,
    "text_preview": "AdaptorMessageHolder(new PrintWriter(System.err));\\n\t\tmessageHandler = messageHolder;\\n\t\tif (verbose) {\\n\t\t\tmessageHandler.dontIgnore(IMessage.INFO);\\n\t\t}\\n\t\tif (Boolean.getBoolean(SHOW_WEAVE_INFO_PROPERTY)) {\\n\t\t\tmessageHandler.dontIgnore(IMessage.WEAVEINFO);\\n\t\t}\\n\t\tinfo(\"AspectJ Weaver Version \" + Version.getText() + \" buil"
  },
  {
    "method_id": "M3106",
    "name": "if",
    "return_type": "",
    "signature": "if(null != kind && delegate != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3107",
    "name": "ignore",
    "return_type": "void",
    "signature": "ignore(Kind kind)",
    "file_id": "F63",
    "start_line": 427,
    "text_preview": "\t// If no transform has been applied, mark the class\\n\t\t\t\t\t\t\t// as ignored.\\n\t\t\t\t\t\t\tif (newBytes == null) {\\n\t\t\t\t\t\t\t\tcache.ignore(cacheKey, bytes);\\n\t\t\t\t\t\t\t} else {\\n\t\t\t\t\t\t\t\tcache.put(cacheKey, bytes, newBytes);\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t} else if (debugOn) {\\n\t\t\t\t\t\tdebug(\"not weaving '\" + name + \"'\");\\n\t\t\t\t\t}\\n\t\t\t\t} else if (debu"
  },
  {
    "method_id": "M3108",
    "name": "if",
    "return_type": "",
    "signature": "if(null != kind && delegate != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3109",
    "name": "getUnmodifiableListView",
    "return_type": "List<IMessage>",
    "signature": "getUnmodifiableListView()",
    "file_id": "F63",
    "start_line": 748,
    "text_preview": "flushMessages() {\\n\t\t\tif (savedMessages == null) {\\n\t\t\t\tsavedMessages = new ArrayList<>();\\n\t\t\t\tsavedMessages.addAll(super.getUnmodifiableListView());\\n\t\t\t\tclearMessages();\\n\t\t\t\tfor (IMessage message : savedMessages) {\\n\t\t\t\t\tdelegate.handleMessage(message);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\t// accumulating = false;\\n\t\t\t// messages.clear();\\n\t\t}\\n\\n"
  },
  {
    "method_id": "M3110",
    "name": "WeavingAdaptorMessageWriter",
    "return_type": "",
    "signature": "WeavingAdaptorMessageWriter(PrintWriter writer)",
    "file_id": "F63",
    "start_line": 717,
    "text_preview": "etBoolean(TRACE_MESSAGES_PROPERTY);\\n\\n\t\tpublic WeavingAdaptorMessageHolder(PrintWriter writer) {\\n\\n\t\t\tthis.delegate = new WeavingAdaptorMessageWriter(writer);\\n\t\t\tsuper.dontIgnore(IMessage.WEAVEINFO);\\n\t\t}\\n\\n\t\tprivate void traceMessage(IMessage message) {\\n\t\t\tif (message instanceof WeaveMessage) {\\n\t\t\t\ttrace.debug(render(mess"
  },
  {
    "method_id": "M3111",
    "name": "handleMessage",
    "return_type": "boolean",
    "signature": "handleMessage(IMessage message)",
    "file_id": "F63",
    "start_line": 650,
    "text_preview": "Util.warn(messageHandler, message);\\n\t}\\n\\n\tprotected boolean warn(String message, Throwable th) {\\n\t\treturn messageHandler.handleMessage(new Message(message, IMessage.WARNING, th, null));\\n\t}\\n\\n\tprotected boolean error(String message) {\\n\t\treturn MessageUtil.error(messageHandler, message);\\n\t}\\n\\n\tprotected boolean error(String"
  },
  {
    "method_id": "M3112",
    "name": "isIgnoring",
    "return_type": "boolean",
    "signature": "isIgnoring(Kind kind)",
    "file_id": "F63",
    "start_line": 359,
    "text_preview": "aceEnabled()) {\\n\t\t\t\t\ttrace.exit(\"weaveClass\", false);\\n\t\t\t\t}\\n\t\t\t\treturn null;\\n\t\t\t}\\n\\n\t\t\tboolean debugOn = !messageHandler.isIgnoring(Message.DEBUG);\\n\\n\t\t\tname = name.replace('/', '.');\\n\t\t\tbyte[] wovenBytes = wovenWithGeneratedClass(name);\\n\t\t\tif (wovenBytes != null) {\\n\t\t\t\tif (debugOn) {\\n\t\t\t\t\tdebug(\"returning woven bytes fo"
  },
  {
    "method_id": "M3113",
    "name": "ignore",
    "return_type": "void",
    "signature": "ignore(IMessage.Kind kind)",
    "file_id": "F63",
    "start_line": 427,
    "text_preview": "\t// If no transform has been applied, mark the class\\n\t\t\t\t\t\t\t// as ignored.\\n\t\t\t\t\t\t\tif (newBytes == null) {\\n\t\t\t\t\t\t\t\tcache.ignore(cacheKey, bytes);\\n\t\t\t\t\t\t\t} else {\\n\t\t\t\t\t\t\t\tcache.put(cacheKey, bytes, newBytes);\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t} else if (debugOn) {\\n\t\t\t\t\t\tdebug(\"not weaving '\" + name + \"'\");\\n\t\t\t\t\t}\\n\t\t\t\t} else if (debu"
  },
  {
    "method_id": "M3114",
    "name": "dontIgnore",
    "return_type": "void",
    "signature": "dontIgnore(IMessage.Kind kind)",
    "file_id": "F63",
    "start_line": 235,
    "text_preview": "AdaptorMessageHolder(new PrintWriter(System.err));\\n\t\tmessageHandler = messageHolder;\\n\t\tif (verbose) {\\n\t\t\tmessageHandler.dontIgnore(IMessage.INFO);\\n\t\t}\\n\t\tif (Boolean.getBoolean(SHOW_WEAVE_INFO_PROPERTY)) {\\n\t\t\tmessageHandler.dontIgnore(IMessage.WEAVEINFO);\\n\t\t}\\n\t\tinfo(\"AspectJ Weaver Version \" + Version.getText() + \" buil"
  },
  {
    "method_id": "M3115",
    "name": "if",
    "return_type": "",
    "signature": "if(null != kind)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3116",
    "name": "render",
    "return_type": "String",
    "signature": "render(IMessage message)",
    "file_id": "F63",
    "start_line": 723,
    "text_preview": "VEINFO);\\n\t\t}\\n\\n\t\tprivate void traceMessage(IMessage message) {\\n\t\t\tif (message instanceof WeaveMessage) {\\n\t\t\t\ttrace.debug(render(message));\\n\t\t\t} else if (message.isDebug()) {\\n\t\t\t\ttrace.debug(render(message));\\n\t\t\t} else if (message.isInfo()) {\\n\t\t\t\ttrace.info(render(message));\\n\t\t\t} else if (message.isWarning()) {\\n\t\t\t\ttrace"
  },
  {
    "method_id": "M3117",
    "name": "WeavingClassFileProvider",
    "return_type": "",
    "signature": "WeavingClassFileProvider(String name, byte[] bytes)",
    "file_id": "F63",
    "start_line": 573,
    "text_preview": "\t */\\n\tprivate byte[] getWovenBytes(String name, byte[] bytes) throws IOException {\\n\t\tWeavingClassFileProvider wcp = new WeavingClassFileProvider(name, bytes);\\n\t\tweaver.weave(wcp);\\n\t\treturn wcp.getBytes();\\n\t}\\n\\n\t/**\\n\t * Weave a set of bytes defining a class for only what is needed to turn @AspectJ aspect in a usefull for"
  },
  {
    "method_id": "M3118",
    "name": "setApplyAtAspectJMungersOnly",
    "return_type": "void",
    "signature": "setApplyAtAspectJMungersOnly()",
    "file_id": "F63",
    "start_line": 589,
    "text_preview": "e, byte[] bytes) throws IOException {\\n\t\tWeavingClassFileProvider wcp = new WeavingClassFileProvider(name, bytes);\\n\t\twcp.setApplyAtAspectJMungersOnly();\\n\t\tweaver.weave(wcp);\\n\t\treturn wcp.getBytes();\\n\t}\\n\\n\tprivate void registerAspectLibraries(List<String> aspectPath) {\\n\t\t// System.err.println(\"? WeavingAdaptor.registerAsp"
  },
  {
    "method_id": "M3119",
    "name": "isApplyAtAspectJMungersOnly",
    "return_type": "boolean",
    "signature": "isApplyAtAspectJMungersOnly()",
    "file_id": "F63",
    "start_line": 902,
    "text_preview": "\\n\t\t\t}\\n\\n\t\t}\\n\\n\t\tpublic void setApplyAtAspectJMungersOnly() {\\n\t\t\tisApplyAtAspectJMungersOnly = true;\\n\t\t}\\n\\n\t\tpublic boolean isApplyAtAspectJMungersOnly() {\\n\t\t\treturn isApplyAtAspectJMungersOnly;\\n\t\t}\\n\\n\t\tpublic byte[] getBytes() {\\n\t\t\tif (wovenClass != null) {\\n\t\t\t\treturn wovenClass.getBytes();\\n\t\t\t} else {\\n\t\t\t\treturn unwovenCl"
  },
  {
    "method_id": "M3120",
    "name": "getBytes",
    "return_type": "byte[]",
    "signature": "getBytes()",
    "file_id": "F63",
    "start_line": 386,
    "text_preview": "\t\t\t\t\t// return the original bytes\\n\t\t\t\t\t\t\t\tif (entry.isIgnored()) {\\n\t\t\t\t\t\t\t\t\treturn null;\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\treturn entry.getBytes();\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\\n\t\t\t\t\t\t// TODO @AspectJ problem\\n\t\t\t\t\t\t// Annotation style aspects need to be included regardless in order to get\\n\t\t\t\t\t\t// a valid aspectOf()/hasAspect() generated in them."
  },
  {
    "method_id": "M3121",
    "name": "if",
    "return_type": "",
    "signature": "if(wovenClass != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3122",
    "name": "getClassFileIterator",
    "return_type": "Iterator<UnwovenClassFile>",
    "signature": "getClassFileIterator()",
    "file_id": "F63",
    "start_line": 914,
    "text_preview": "rn wovenClass.getBytes();\\n\t\t\t} else {\\n\t\t\t\treturn unwovenClass.getBytes();\\n\t\t\t}\\n\t\t}\\n\\n\t\tpublic Iterator<UnwovenClassFile> getClassFileIterator() {\\n\t\t\treturn unwovenClasses.iterator();\\n\t\t}\\n\\n\t\tpublic IWeaveRequestor getRequestor() {\\n\t\t\treturn new WeaveRequestor();\\n\t\t}\\n\\n\t\tprivate class WeaveRequestor implements IWeaveReques"
  },
  {
    "method_id": "M3123",
    "name": "getRequestor",
    "return_type": "IWeaveRequestor",
    "signature": "getRequestor()",
    "file_id": "F63",
    "start_line": 918,
    "text_preview": " Iterator<UnwovenClassFile> getClassFileIterator() {\\n\t\t\treturn unwovenClasses.iterator();\\n\t\t}\\n\\n\t\tpublic IWeaveRequestor getRequestor() {\\n\t\t\treturn new WeaveRequestor();\\n\t\t}\\n\\n\t\tprivate class WeaveRequestor implements IWeaveRequestor {\\n\t\t\t@Override\\n\t\t\tpublic void acceptResult(IUnwovenClassFile result) {\\n\t\t\t\tif (wovenClas"
  },
  {
    "method_id": "M3124",
    "name": "acceptResult",
    "return_type": "void",
    "signature": "acceptResult(IUnwovenClassFile result)",
    "file_id": "F63",
    "start_line": 924,
    "text_preview": "turn new WeaveRequestor();\\n\t\t}\\n\\n\t\tprivate class WeaveRequestor implements IWeaveRequestor {\\n\t\t\t@Override\\n\t\t\tpublic void acceptResult(IUnwovenClassFile result) {\\n\t\t\t\tif (wovenClass == null) {\\n\t\t\t\t\twovenClass = result;\\n\t\t\t\t\tString name = result.getClassName();\\n\t\t\t\t\tif (shouldDump(name.replace('/', '.'), false)) {\\n\t\t\t\t\t\td"
  },
  {
    "method_id": "M3125",
    "name": "if",
    "return_type": "",
    "signature": "if(wovenClass == null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3126",
    "name": "processingReweavableState",
    "return_type": "void",
    "signature": "processingReweavableState()",
    "file_id": "F63",
    "start_line": 948,
    "text_preview": "ssName(), wovenClass);\\n\t\t\t\t\tgeneratedClassHandler.acceptClass(className, null, resultBytes);\\n\t\t\t\t}\\n\t\t\t}\\n\\n\t\t\tpublic void processingReweavableState() {}\\n\\n\t\t\tpublic void addingTypeMungers() {}\\n\\n\t\t\tpublic void weavingAspects() {}\\n\\n\t\t\tpublic void weavingClasses() {}\\n\\n\t\t\tpublic void weaveCompleted() {\\n\t\t\t\t// ResolvedType.res"
  },
  {
    "method_id": "M3127",
    "name": "addingTypeMungers",
    "return_type": "void",
    "signature": "addingTypeMungers()",
    "file_id": "F63",
    "start_line": 950,
    "text_preview": "er.acceptClass(className, null, resultBytes);\\n\t\t\t\t}\\n\t\t\t}\\n\\n\t\t\tpublic void processingReweavableState() {}\\n\\n\t\t\tpublic void addingTypeMungers() {}\\n\\n\t\t\tpublic void weavingAspects() {}\\n\\n\t\t\tpublic void weavingClasses() {}\\n\\n\t\t\tpublic void weaveCompleted() {\\n\t\t\t\t// ResolvedType.resetPrimitives();\\n\t\t\t\tif (delegateForCurrentClass"
  },
  {
    "method_id": "M3128",
    "name": "weavingAspects",
    "return_type": "void",
    "signature": "weavingAspects()",
    "file_id": "F63",
    "start_line": 952,
    "text_preview": "ytes);\\n\t\t\t\t}\\n\t\t\t}\\n\\n\t\t\tpublic void processingReweavableState() {}\\n\\n\t\t\tpublic void addingTypeMungers() {}\\n\\n\t\t\tpublic void weavingAspects() {}\\n\\n\t\t\tpublic void weavingClasses() {}\\n\\n\t\t\tpublic void weaveCompleted() {\\n\t\t\t\t// ResolvedType.resetPrimitives();\\n\t\t\t\tif (delegateForCurrentClass != null) {\\n\t\t\t\t\tdelegateForCurrentClas"
  },
  {
    "method_id": "M3129",
    "name": "weavingClasses",
    "return_type": "void",
    "signature": "weavingClasses()",
    "file_id": "F63",
    "start_line": 954,
    "text_preview": "ocessingReweavableState() {}\\n\\n\t\t\tpublic void addingTypeMungers() {}\\n\\n\t\t\tpublic void weavingAspects() {}\\n\\n\t\t\tpublic void weavingClasses() {}\\n\\n\t\t\tpublic void weaveCompleted() {\\n\t\t\t\t// ResolvedType.resetPrimitives();\\n\t\t\t\tif (delegateForCurrentClass != null) {\\n\t\t\t\t\tdelegateForCurrentClass.weavingCompleted();\\n\t\t\t\t}\\n\t\t\t\t// R"
  },
  {
    "method_id": "M3130",
    "name": "weaveCompleted",
    "return_type": "void",
    "signature": "weaveCompleted()",
    "file_id": "F63",
    "start_line": 956,
    "text_preview": "lic void addingTypeMungers() {}\\n\\n\t\t\tpublic void weavingAspects() {}\\n\\n\t\t\tpublic void weavingClasses() {}\\n\\n\t\t\tpublic void weaveCompleted() {\\n\t\t\t\t// ResolvedType.resetPrimitives();\\n\t\t\t\tif (delegateForCurrentClass != null) {\\n\t\t\t\t\tdelegateForCurrentClass.weavingCompleted();\\n\t\t\t\t}\\n\t\t\t\t// ResolvedType.resetPrimitives();\\n\t\t\t\t/"
  },
  {
    "method_id": "M3131",
    "name": "if",
    "return_type": "",
    "signature": "if(delegateForCurrentClass != null)",
    "file_id": "F63",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3132",
    "name": "setActiveProtectionDomain",
    "return_type": "void",
    "signature": "setActiveProtectionDomain(ProtectionDomain protectionDomain)",
    "file_id": "F63",
    "start_line": 967,
    "text_preview": "s();\\n\t\t\t\t// bcelWorld.discardType(typeBeingProcessed.getResolvedTypeX()); // work in progress\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic void setActiveProtectionDomain(ProtectionDomain protectionDomain) {\\n\t\tactiveProtectionDomain = protectionDomain;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3133",
    "name": "AbstractCacheBacking",
    "return_type": "",
    "signature": "AbstractCacheBacking()",
    "file_id": "F64",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3134",
    "name": "crc",
    "return_type": "long",
    "signature": "crc(byte[] bytes)",
    "file_id": "F64",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3135",
    "name": "AbstractFileCacheBacking",
    "return_type": "",
    "signature": "AbstractFileCacheBacking(File cacheDirectory)",
    "file_id": "F65",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3136",
    "name": "getCacheDirectory",
    "return_type": "File",
    "signature": "getCacheDirectory()",
    "file_id": "F65",
    "start_line": 42,
    "text_preview": "eDirectory;\\n    }\\n\\n    protected void writeClassBytes (String key, byte[] bytes) throws Exception {\\n        File    dir=getCacheDirectory(), file=new File(dir, key);\\n        FileOutputStream    out=new FileOutputStream(file);\\n        try {\\n            out.write(bytes);\\n        } finally {\\n        \tclose(out, file);\\n   "
  },
  {
    "method_id": "M3137",
    "name": "writeClassBytes",
    "return_type": "void",
    "signature": "writeClassBytes(String key, byte[] bytes)",
    "file_id": "F65",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3138",
    "name": "delete",
    "return_type": "void",
    "signature": "delete(File file)",
    "file_id": "F65",
    "start_line": 51,
    "text_preview": "    try {\\n            out.write(bytes);\\n        } finally {\\n        \tclose(out, file);\\n        }\\n    }\\n\\n\tprotected void delete(File file) {\\n\t\tif (file.exists() && (!file.delete())) {\\n\t\t\tif ((logger != null) && logger.isTraceEnabled()) {\\n\t\t\t\tlogger.error(\"Error deleting file \" + file.getAbsolutePath());\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpr"
  },
  {
    "method_id": "M3139",
    "name": "close",
    "return_type": "void",
    "signature": "close(OutputStream out, File file)",
    "file_id": "F65",
    "start_line": 47,
    "text_preview": "utputStream    out=new FileOutputStream(file);\\n        try {\\n            out.write(bytes);\\n        } finally {\\n        \tclose(out, file);\\n        }\\n    }\\n\\n\tprotected void delete(File file) {\\n\t\tif (file.exists() && (!file.delete())) {\\n\t\t\tif ((logger != null) && logger.isTraceEnabled()) {\\n\t\t\t\tlogger.error(\"Error deleting"
  },
  {
    "method_id": "M3140",
    "name": "if",
    "return_type": "",
    "signature": "if(out != null)",
    "file_id": "F65",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3141",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F65",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3142",
    "name": "close",
    "return_type": "void",
    "signature": "close(InputStream in, File file)",
    "file_id": "F65",
    "start_line": 47,
    "text_preview": "utputStream    out=new FileOutputStream(file);\\n        try {\\n            out.write(bytes);\\n        } finally {\\n        \tclose(out, file);\\n        }\\n    }\\n\\n\tprotected void delete(File file) {\\n\t\tif (file.exists() && (!file.delete())) {\\n\t\t\tif ((logger != null) && logger.isTraceEnabled()) {\\n\t\t\t\tlogger.error(\"Error deleting"
  },
  {
    "method_id": "M3143",
    "name": "if",
    "return_type": "",
    "signature": "if(in != null)",
    "file_id": "F65",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3144",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F65",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3145",
    "name": "AbstractIndexedFileCacheBacking",
    "return_type": "",
    "signature": "AbstractIndexedFileCacheBacking(File cacheDir)",
    "file_id": "F66",
    "start_line": 46,
    "text_preview": "w IndexEntry[0];\\n\tprotected static final String[]\tEMPTY_KEYS=new String[0];\\n\\n\tprivate final File\tindexFile;\\n\\n\tprotected AbstractIndexedFileCacheBacking(File cacheDir) {\\n\t\tsuper(cacheDir);\\n\\n        indexFile = new File(cacheDir, INDEX_FILE);\\n\t}\\n\\n    public File getIndexFile () {\\n        return indexFile;\\n    }\\n\\n    publ"
  },
  {
    "method_id": "M3146",
    "name": "getIndexFile",
    "return_type": "File",
    "signature": "getIndexFile()",
    "file_id": "F66",
    "start_line": 79,
    "text_preview": "g[0]);\\n        }\\n    }\\n\\n    protected Map<String, IndexEntry> readIndex () {\\n    \treturn readIndex(getCacheDirectory(), getIndexFile());\\n    }\\n\\n    protected void writeIndex () {\\n    \twriteIndex(getIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteIndex(file, getIndex());\\n    \t} cat"
  },
  {
    "method_id": "M3147",
    "name": "getKeys",
    "return_type": "String[]",
    "signature": "getKeys(String regex)",
    "file_id": "F66",
    "start_line": 56,
    "text_preview": " File(cacheDir, INDEX_FILE);\\n\t}\\n\\n    public File getIndexFile () {\\n        return indexFile;\\n    }\\n\\n    public String[] getKeys(String regex) {\\n    \tMap<String, IndexEntry>\tindex=getIndex();\\n    \tif ((index == null) || index.isEmpty()) {\\n    \t\treturn EMPTY_KEYS;\\n    \t}\\n\\n        Collection<String>  matches= new LinkedLi"
  },
  {
    "method_id": "M3148",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(index)",
    "file_id": "F66",
    "start_line": 63,
    "text_preview": "|| index.isEmpty()) {\\n    \t\treturn EMPTY_KEYS;\\n    \t}\\n\\n        Collection<String>  matches= new LinkedList<>();\\n        synchronized(index) {\\n            for (String key : index.keySet()) {\\n                if (key.matches(regex)) {\\n                    matches.add(key);\\n                }\\n            }\\n        }\\n\\n       "
  },
  {
    "method_id": "M3149",
    "name": "readIndex",
    "return_type": "IndexEntry>",
    "signature": "readIndex()",
    "file_id": "F66",
    "start_line": 79,
    "text_preview": "eturn matches.toArray(new String[0]);\\n        }\\n    }\\n\\n    protected Map<String, IndexEntry> readIndex () {\\n    \treturn readIndex(getCacheDirectory(), getIndexFile());\\n    }\\n\\n    protected void writeIndex () {\\n    \twriteIndex(getIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteInde"
  },
  {
    "method_id": "M3150",
    "name": "writeIndex",
    "return_type": "void",
    "signature": "writeIndex()",
    "file_id": "F66",
    "start_line": 83,
    "text_preview": "adIndex () {\\n    \treturn readIndex(getCacheDirectory(), getIndexFile());\\n    }\\n\\n    protected void writeIndex () {\\n    \twriteIndex(getIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteIndex(file, getIndex());\\n    \t} catch(Exception e) {\\n    \t\tif ((logger != null) && logger.isTraceEn"
  },
  {
    "method_id": "M3151",
    "name": "writeIndex",
    "return_type": "void",
    "signature": "writeIndex(File file)",
    "file_id": "F66",
    "start_line": 83,
    "text_preview": "adIndex () {\\n    \treturn readIndex(getCacheDirectory(), getIndexFile());\\n    }\\n\\n    protected void writeIndex () {\\n    \twriteIndex(getIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteIndex(file, getIndex());\\n    \t} catch(Exception e) {\\n    \t\tif ((logger != null) && logger.isTraceEn"
  },
  {
    "method_id": "M3152",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F66",
    "start_line": 89,
    "text_preview": "tIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteIndex(file, getIndex());\\n    \t} catch(Exception e) {\\n    \t\tif ((logger != null) && logger.isTraceEnabled()) {\\n    \t\t\tlogger.warn(\"writeIndex(\" + file + \") \" + e.getClass().getSimpleName() + \": \" + e.getMessage(), e);\\n    \t\t}\\n    \t}\\n"
  },
  {
    "method_id": "M3153",
    "name": "readIndex",
    "return_type": "IndexEntry>",
    "signature": "readIndex(File cacheDir, File cacheFile)",
    "file_id": "F66",
    "start_line": 79,
    "text_preview": "eturn matches.toArray(new String[0]);\\n        }\\n    }\\n\\n    protected Map<String, IndexEntry> readIndex () {\\n    \treturn readIndex(getCacheDirectory(), getIndexFile());\\n    }\\n\\n    protected void writeIndex () {\\n    \twriteIndex(getIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteInde"
  },
  {
    "method_id": "M3154",
    "name": "for",
    "return_type": "",
    "signature": "for(IndexEntry ie : idxValues)",
    "file_id": "F66",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3155",
    "name": "if",
    "return_type": "",
    "signature": "if(resEntry != null)",
    "file_id": "F66",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3156",
    "name": "resolveIndexMapEntry",
    "return_type": "IndexEntry",
    "signature": "resolveIndexMapEntry(File cacheDir, IndexEntry ie)",
    "file_id": "F66",
    "start_line": 109,
    "text_preview": "     \t}\\n        \treturn indexMap;\\n        }\\n\\n        for (IndexEntry ie : idxValues) {\\n            IndexEntry  resEntry=resolveIndexMapEntry(cacheDir, ie);\\n            if (resEntry != null) {\\n                indexMap.put(resEntry.key, resEntry);\\n            } else if ((logger != null) && logger.isTraceEnabled()) {\\n    "
  },
  {
    "method_id": "M3157",
    "name": "readIndex",
    "return_type": "IndexEntry[]",
    "signature": "readIndex(File indexFile)",
    "file_id": "F66",
    "start_line": 79,
    "text_preview": "eturn matches.toArray(new String[0]);\\n        }\\n    }\\n\\n    protected Map<String, IndexEntry> readIndex () {\\n    \treturn readIndex(getCacheDirectory(), getIndexFile());\\n    }\\n\\n    protected void writeIndex () {\\n    \twriteIndex(getIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteInde"
  },
  {
    "method_id": "M3158",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F66",
    "start_line": 89,
    "text_preview": "tIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteIndex(file, getIndex());\\n    \t} catch(Exception e) {\\n    \t\tif ((logger != null) && logger.isTraceEnabled()) {\\n    \t\t\tlogger.warn(\"writeIndex(\" + file + \") \" + e.getClass().getSimpleName() + \": \" + e.getMessage(), e);\\n    \t\t}\\n    \t}\\n"
  },
  {
    "method_id": "M3159",
    "name": "writeIndex",
    "return_type": "void",
    "signature": "writeIndex(File indexFile, Map<String,? extends IndexEntry> index)",
    "file_id": "F66",
    "start_line": 83,
    "text_preview": "adIndex () {\\n    \treturn readIndex(getCacheDirectory(), getIndexFile());\\n    }\\n\\n    protected void writeIndex () {\\n    \twriteIndex(getIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteIndex(file, getIndex());\\n    \t} catch(Exception e) {\\n    \t\tif ((logger != null) && logger.isTraceEn"
  },
  {
    "method_id": "M3160",
    "name": "writeIndex",
    "return_type": "void",
    "signature": "writeIndex(File indexFile, IndexEntry ... entries)",
    "file_id": "F66",
    "start_line": 83,
    "text_preview": "adIndex () {\\n    \treturn readIndex(getCacheDirectory(), getIndexFile());\\n    }\\n\\n    protected void writeIndex () {\\n    \twriteIndex(getIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteIndex(file, getIndex());\\n    \t} catch(Exception e) {\\n    \t\tif ((logger != null) && logger.isTraceEn"
  },
  {
    "method_id": "M3161",
    "name": "writeIndex",
    "return_type": "void",
    "signature": "writeIndex(File indexFile, Collection<? extends IndexEntry> entries)",
    "file_id": "F66",
    "start_line": 83,
    "text_preview": "adIndex () {\\n    \treturn readIndex(getCacheDirectory(), getIndexFile());\\n    }\\n\\n    protected void writeIndex () {\\n    \twriteIndex(getIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteIndex(file, getIndex());\\n    \t} catch(Exception e) {\\n    \t\tif ((logger != null) && logger.isTraceEn"
  },
  {
    "method_id": "M3162",
    "name": "createIndexEntry",
    "return_type": "IndexEntry",
    "signature": "createIndexEntry(CachedClassEntry classEntry, byte[] originalBytes)",
    "file_id": "F66",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3163",
    "name": "if",
    "return_type": "",
    "signature": "if(classEntry == null)",
    "file_id": "F66",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3164",
    "name": "IndexEntry",
    "return_type": "",
    "signature": "IndexEntry()",
    "file_id": "F66",
    "start_line": 185,
    "text_preview": "inalBytes) {\\n        if (classEntry == null) {\\n            return null;\\n        }\\n\\n        IndexEntry  indexEntry = new IndexEntry();\\n        indexEntry.key = classEntry.getKey();\\n        indexEntry.generated = classEntry.isGenerated();\\n        indexEntry.ignored = classEntry.isIgnored();\\n    \tindexEntry.crcClass = crc"
  },
  {
    "method_id": "M3165",
    "name": "clone",
    "return_type": "IndexEntry",
    "signature": "clone()",
    "file_id": "F66",
    "start_line": 216,
    "text_preview": "c IndexEntry () {\\n\t\t\tsuper();\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic IndexEntry clone () {\\n\t\t\ttry {\\n\t\t\t\treturn getClass().cast(super.clone());\\n\t\t\t} catch(CloneNotSupportedException e) {\\n\t\t\t\tthrow new RuntimeException(\"Failed to clone: \" + toString() + \": \" + e.getMessage(), e);\\n\t\t\t}\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic int hashCode() {\\n\t\t\tret"
  },
  {
    "method_id": "M3166",
    "name": "catch",
    "return_type": "",
    "signature": "catch(CloneNotSupportedException e)",
    "file_id": "F66",
    "start_line": 89,
    "text_preview": "tIndexFile());\\n    }\\n\\n    protected void writeIndex (File file) {\\n    \ttry {\\n    \t\twriteIndex(file, getIndex());\\n    \t} catch(Exception e) {\\n    \t\tif ((logger != null) && logger.isTraceEnabled()) {\\n    \t\t\tlogger.warn(\"writeIndex(\" + file + \") \" + e.getClass().getSimpleName() + \": \" + e.getMessage(), e);\\n    \t\t}\\n    \t}\\n"
  },
  {
    "method_id": "M3167",
    "name": "hashCode",
    "return_type": "int",
    "signature": "hashCode()",
    "file_id": "F66",
    "start_line": 223,
    "text_preview": "w new RuntimeException(\"Failed to clone: \" + toString() + \": \" + e.getMessage(), e);\\n\t\t\t}\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic int hashCode() {\\n\t\t\treturn (int) (key.hashCode()\\n\t\t\t\t + (generated ? 1 : 0)\\n\t\t\t\t + (ignored ? 1 : 0)\\n\t\t\t\t + crcClass\\n\t\t\t\t + crcWeaved);\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean equals(Object obj) {\\n\t\t\tif (obj =="
  },
  {
    "method_id": "M3168",
    "name": "equals",
    "return_type": "boolean",
    "signature": "equals(Object obj)",
    "file_id": "F66",
    "start_line": 232,
    "text_preview": "\t\t\t + (generated ? 1 : 0)\\n\t\t\t\t + (ignored ? 1 : 0)\\n\t\t\t\t + crcClass\\n\t\t\t\t + crcWeaved);\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean equals(Object obj) {\\n\t\t\tif (obj == null)\\n\t\t\t\treturn false;\\n\t\t\tif (this == obj)\\n\t\t\t\treturn true;\\n\t\t\tif (getClass() != obj.getClass())\\n\t\t\t\treturn false;\\n\\n\t\t\tIndexEntry\tother=(IndexEntry) obj;\\n\t\t\tif (thi"
  },
  {
    "method_id": "M3169",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F66",
    "start_line": 218,
    "text_preview": "().cast(super.clone());\\n\t\t\t} catch(CloneNotSupportedException e) {\\n\t\t\t\tthrow new RuntimeException(\"Failed to clone: \" + toString() + \": \" + e.getMessage(), e);\\n\t\t\t}\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic int hashCode() {\\n\t\t\treturn (int) (key.hashCode()\\n\t\t\t\t + (generated ? 1 : 0)\\n\t\t\t\t + (ignored ? 1 : 0)\\n\t\t\t\t + crcClass\\n\t\t\t\t + crcWe"
  },
  {
    "method_id": "M3170",
    "name": "AsynchronousFileCacheBacking",
    "return_type": "",
    "signature": "AsynchronousFileCacheBacking(File cacheDir)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3171",
    "name": "getIndex",
    "return_type": "IndexEntry>",
    "signature": "getIndex()",
    "file_id": "F67",
    "start_line": 70,
    "text_preview": ";\\n        exposedBytes = Collections.unmodifiableMap(bytesMap);\\n    }\\n\\n    @Override\\n\tprotected Map<String, IndexEntry> getIndex() {\\n\t\treturn index;\\n\t}\\n\\n\tpublic CachedClassEntry get(CachedClassReference ref, byte[] originalBytes) {\\n        String              key=ref.getKey();\\n        final IndexEntry    indexEntry;\\n  "
  },
  {
    "method_id": "M3172",
    "name": "get",
    "return_type": "CachedClassEntry",
    "signature": "get(CachedClassReference ref, byte[] originalBytes)",
    "file_id": "F67",
    "start_line": 37,
    "text_preview": "ot;synchronize&quot;\\n * the in-memory cache with the persisted copy. Whenever there is a cache miss\\n * from the {@link #get(CachedClassReference, byte[])} call, the weaver issues a\\n * {@link #put(CachedClassEntry, byte[])} call. This call has 2 side-effects:\\n * <UL>\\n * \t\t<LI>\\n * \t\tThe in-memory cache is updated so that"
  },
  {
    "method_id": "M3173",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(index)",
    "file_id": "F67",
    "start_line": 77,
    "text_preview": ", byte[] originalBytes) {\\n        String              key=ref.getKey();\\n        final IndexEntry    indexEntry;\\n        synchronized(index) {\\n            if ((indexEntry=index.get(key)) == null) {\\n                return null;\\n            }\\n        }\\n\\n        if (crc(originalBytes) != indexEntry.crcClass) {\\n            "
  },
  {
    "method_id": "M3174",
    "name": "if",
    "return_type": "",
    "signature": "if(indexEntry.ignored)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3175",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(bytesMap)",
    "file_id": "F67",
    "start_line": 77,
    "text_preview": ", byte[] originalBytes) {\\n        String              key=ref.getKey();\\n        final IndexEntry    indexEntry;\\n        synchronized(index) {\\n            if ((indexEntry=index.get(key)) == null) {\\n                return null;\\n            }\\n        }\\n\\n        if (crc(originalBytes) != indexEntry.crcClass) {\\n            "
  },
  {
    "method_id": "M3176",
    "name": "if",
    "return_type": "",
    "signature": "if(indexEntry.generated)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3177",
    "name": "put",
    "return_type": "void",
    "signature": "put(CachedClassEntry entry, byte[] originalBytes)",
    "file_id": "F67",
    "start_line": 38,
    "text_preview": "never there is a cache miss\\n * from the {@link #get(CachedClassReference, byte[])} call, the weaver issues a\\n * {@link #put(CachedClassEntry, byte[])} call. This call has 2 side-effects:\\n * <UL>\\n * \t\t<LI>\\n * \t\tThe in-memory cache is updated so that subsequent calls to {@link #get(CachedClassReference, byte[])}\\n * \t\twil"
  },
  {
    "method_id": "M3178",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(index)",
    "file_id": "F67",
    "start_line": 77,
    "text_preview": ", byte[] originalBytes) {\\n        String              key=ref.getKey();\\n        final IndexEntry    indexEntry;\\n        synchronized(index) {\\n            if ((indexEntry=index.get(key)) == null) {\\n                return null;\\n            }\\n        }\\n\\n        if (crc(originalBytes) != indexEntry.crcClass) {\\n            "
  },
  {
    "method_id": "M3179",
    "name": "if",
    "return_type": "",
    "signature": "if(indexEntry != null)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3180",
    "name": "remove",
    "return_type": "void",
    "signature": "remove(CachedClassReference ref)",
    "file_id": "F67",
    "start_line": 88,
    "text_preview": "er.debug(\"get(\" + getCacheDirectory() + \") mismatched original class bytes CRC for \" + key);\\n            }\\n\\n            remove(key);\\n            return null;\\n        }\\n\\n        if (indexEntry.ignored) {\\n            return new CachedClassEntry(ref, WeavedClassCache.ZERO_BYTES, CachedClassEntry.EntryType.IGNORED);\\n      "
  },
  {
    "method_id": "M3181",
    "name": "remove",
    "return_type": "IndexEntry",
    "signature": "remove(String key)",
    "file_id": "F67",
    "start_line": 88,
    "text_preview": "er.debug(\"get(\" + getCacheDirectory() + \") mismatched original class bytes CRC for \" + key);\\n            }\\n\\n            remove(key);\\n            return null;\\n        }\\n\\n        if (indexEntry.ignored) {\\n            return new CachedClassEntry(ref, WeavedClassCache.ZERO_BYTES, CachedClassEntry.EntryType.IGNORED);\\n      "
  },
  {
    "method_id": "M3182",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(index)",
    "file_id": "F67",
    "start_line": 77,
    "text_preview": ", byte[] originalBytes) {\\n        String              key=ref.getKey();\\n        final IndexEntry    indexEntry;\\n        synchronized(index) {\\n            if ((indexEntry=index.get(key)) == null) {\\n                return null;\\n            }\\n        }\\n\\n        if (crc(originalBytes) != indexEntry.crcClass) {\\n            "
  },
  {
    "method_id": "M3183",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(bytesMap)",
    "file_id": "F67",
    "start_line": 77,
    "text_preview": ", byte[] originalBytes) {\\n        String              key=ref.getKey();\\n        final IndexEntry    indexEntry;\\n        synchronized(index) {\\n            if ((indexEntry=index.get(key)) == null) {\\n                return null;\\n            }\\n        }\\n\\n        if (crc(originalBytes) != indexEntry.crcClass) {\\n            "
  },
  {
    "method_id": "M3184",
    "name": "if",
    "return_type": "",
    "signature": "if(entry != null)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3185",
    "name": "getIndexEntries",
    "return_type": "List<IndexEntry>",
    "signature": "getIndexEntries()",
    "file_id": "F67",
    "start_line": 228,
    "text_preview": "ectory());\\n    }\\n\\n    protected void executeUpdateIndexCommand () throws Exception {\\n        writeIndex(getIndexFile(), getIndexEntries());\\n    }\\n\\n    protected void executeInsertCommand (InsertCommand cmd) throws Exception {\\n        writeIndex(getIndexFile(), getIndexEntries());\\n\\n        byte[]  bytes=cmd.getClassByte"
  },
  {
    "method_id": "M3186",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(index)",
    "file_id": "F67",
    "start_line": 77,
    "text_preview": ", byte[] originalBytes) {\\n        String              key=ref.getKey();\\n        final IndexEntry    indexEntry;\\n        synchronized(index) {\\n            if ((indexEntry=index.get(key)) == null) {\\n                return null;\\n            }\\n        }\\n\\n        if (crc(originalBytes) != indexEntry.crcClass) {\\n            "
  },
  {
    "method_id": "M3187",
    "name": "getIndexMap",
    "return_type": "IndexEntry>",
    "signature": "getIndexMap()",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3188",
    "name": "getBytesMap",
    "return_type": "byte[]>",
    "signature": "getBytesMap()",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3189",
    "name": "clear",
    "return_type": "void",
    "signature": "clear()",
    "file_id": "F67",
    "start_line": 196,
    "text_preview": "xposedIndex;\\n    }\\n\\n    public Map<String, byte[]> getBytesMap () {\\n        return exposedBytes;\\n    }\\n\\n    public void clear() {\\n        synchronized(index) {\\n            index.clear();\\n        }\\n\\n        if (!postCacheCommand(new ClearCommand(this))) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n  "
  },
  {
    "method_id": "M3190",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(index)",
    "file_id": "F67",
    "start_line": 77,
    "text_preview": ", byte[] originalBytes) {\\n        String              key=ref.getKey();\\n        final IndexEntry    indexEntry;\\n        synchronized(index) {\\n            if ((indexEntry=index.get(key)) == null) {\\n                return null;\\n            }\\n        }\\n\\n        if (crc(originalBytes) != indexEntry.crcClass) {\\n            "
  },
  {
    "method_id": "M3191",
    "name": "executeCommand",
    "return_type": "void",
    "signature": "executeCommand(AsyncCommand cmd)",
    "file_id": "F67",
    "start_line": 300,
    "text_preview": "                        AsynchronousFileCacheBacking    cache=cmd.getCache();\\n                                    cache.executeCommand(cmd);\\n                                } catch(Exception e) {\\n                                    if ((trace != null) && trace.isTraceEnabled()) {\\n                                       "
  },
  {
    "method_id": "M3192",
    "name": "if",
    "return_type": "",
    "signature": "if(cmd instanceof ClearCommand)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3193",
    "name": "if",
    "return_type": "else",
    "signature": "if(cmd instanceof UpdateIndexCommand)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3194",
    "name": "if",
    "return_type": "else",
    "signature": "if(cmd instanceof InsertCommand)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3195",
    "name": "if",
    "return_type": "else",
    "signature": "if(cmd instanceof RemoveCommand)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3196",
    "name": "executeClearCommand",
    "return_type": "void",
    "signature": "executeClearCommand()",
    "file_id": "F67",
    "start_line": 210,
    "text_preview": "tected void executeCommand (AsyncCommand cmd) throws Exception {\\n        if (cmd instanceof ClearCommand) {\\n            executeClearCommand();\\n        } else if (cmd instanceof UpdateIndexCommand) {\\n            executeUpdateIndexCommand();\\n        } else if (cmd instanceof InsertCommand) {\\n            executeInsertComm"
  },
  {
    "method_id": "M3197",
    "name": "executeUpdateIndexCommand",
    "return_type": "void",
    "signature": "executeUpdateIndexCommand()",
    "file_id": "F67",
    "start_line": 212,
    "text_preview": " ClearCommand) {\\n            executeClearCommand();\\n        } else if (cmd instanceof UpdateIndexCommand) {\\n            executeUpdateIndexCommand();\\n        } else if (cmd instanceof InsertCommand) {\\n            executeInsertCommand((InsertCommand) cmd);\\n        } else if (cmd instanceof RemoveCommand) {\\n            ex"
  },
  {
    "method_id": "M3198",
    "name": "executeInsertCommand",
    "return_type": "void",
    "signature": "executeInsertCommand(InsertCommand cmd)",
    "file_id": "F67",
    "start_line": 214,
    "text_preview": "IndexCommand) {\\n            executeUpdateIndexCommand();\\n        } else if (cmd instanceof InsertCommand) {\\n            executeInsertCommand((InsertCommand) cmd);\\n        } else if (cmd instanceof RemoveCommand) {\\n            executeRemoveCommand((RemoveCommand) cmd);\\n        } else {\\n            throw new UnsupportedO"
  },
  {
    "method_id": "M3199",
    "name": "if",
    "return_type": "",
    "signature": "if(bytes != null)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3200",
    "name": "executeRemoveCommand",
    "return_type": "void",
    "signature": "executeRemoveCommand(RemoveCommand cmd)",
    "file_id": "F67",
    "start_line": 216,
    "text_preview": "{\\n            executeInsertCommand((InsertCommand) cmd);\\n        } else if (cmd instanceof RemoveCommand) {\\n            executeRemoveCommand((RemoveCommand) cmd);\\n        } else {\\n            throw new UnsupportedOperationException(\"Unknown command: \" + cmd);\\n        }\\n    }\\n\\n    protected void executeClearCommand () t"
  },
  {
    "method_id": "M3201",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F67",
    "start_line": 244,
    "text_preview": "cmd) throws Exception {\\n        Exception err=null;\\n        try {\\n            removeClassBytes(cmd.getKey());\\n        } catch(Exception e) {\\n            err = e;\\n        }\\n\\n        writeIndex(getIndexFile(), getIndexEntries());\\n\\n        if (err != null) {\\n            throw err;  // check if the class bytes remove had a"
  },
  {
    "method_id": "M3202",
    "name": "if",
    "return_type": "",
    "signature": "if(err != null)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3203",
    "name": "removeClassBytes",
    "return_type": "void",
    "signature": "removeClassBytes(String key)",
    "file_id": "F67",
    "start_line": 243,
    "text_preview": " void executeRemoveCommand (RemoveCommand cmd) throws Exception {\\n        Exception err=null;\\n        try {\\n            removeClassBytes(cmd.getKey());\\n        } catch(Exception e) {\\n            err = e;\\n        }\\n\\n        writeIndex(getIndexFile(), getIndexEntries());\\n\\n        if (err != null) {\\n            throw err;"
  },
  {
    "method_id": "M3204",
    "name": "createBacking",
    "return_type": "T",
    "signature": "createBacking(File cacheDir, AsynchronousFileCacheBackingCreator<T> creator)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3205",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(execService)",
    "file_id": "F67",
    "start_line": 77,
    "text_preview": ", byte[] originalBytes) {\\n        String              key=ref.getKey();\\n        final IndexEntry    indexEntry;\\n        synchronized(index) {\\n            if ((indexEntry=index.get(key)) == null) {\\n                return null;\\n            }\\n        }\\n\\n        if (crc(originalBytes) != indexEntry.crcClass) {\\n            "
  },
  {
    "method_id": "M3206",
    "name": "if",
    "return_type": "",
    "signature": "if(commandsRunner == null)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3207",
    "name": "submit",
    "return_type": "",
    "signature": "submit(new Runnable()",
    "file_id": "F67",
    "start_line": 292,
    "text_preview": "     synchronized(execService) {\\n            if (commandsRunner == null) {\\n                commandsRunner = execService.submit(new Runnable() {\\n                    @SuppressWarnings(\"synthetic-access\")\\n                    public void run() {\\n                        for ( ; ; ) {\\n                            try {\\n      "
  },
  {
    "method_id": "M3208",
    "name": "run",
    "return_type": "void",
    "signature": "run()",
    "file_id": "F67",
    "start_line": 294,
    "text_preview": "rvice.submit(new Runnable() {\\n                    @SuppressWarnings(\"synthetic-access\")\\n                    public void run() {\\n                        for ( ; ; ) {\\n                            try {\\n                                AsyncCommand    cmd=commandsQ.take();\\n                                try {\\n            "
  },
  {
    "method_id": "M3209",
    "name": "for",
    "return_type": "",
    "signature": "for(; ;)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3210",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F67",
    "start_line": 244,
    "text_preview": "cmd) throws Exception {\\n        Exception err=null;\\n        try {\\n            removeClassBytes(cmd.getKey());\\n        } catch(Exception e) {\\n            err = e;\\n        }\\n\\n        writeIndex(getIndexFile(), getIndexEntries());\\n\\n        if (err != null) {\\n            throw err;  // check if the class bytes remove had a"
  },
  {
    "method_id": "M3211",
    "name": "catch",
    "return_type": "",
    "signature": "catch(InterruptedException e)",
    "file_id": "F67",
    "start_line": 244,
    "text_preview": "cmd) throws Exception {\\n        Exception err=null;\\n        try {\\n            removeClassBytes(cmd.getKey());\\n        } catch(Exception e) {\\n            err = e;\\n        }\\n\\n        writeIndex(getIndexFile(), getIndexEntries());\\n\\n        if (err != null) {\\n            throw err;  // check if the class bytes remove had a"
  },
  {
    "method_id": "M3212",
    "name": "postCacheCommand",
    "return_type": "boolean",
    "signature": "postCacheCommand(AsyncCommand cmd)",
    "file_id": "F67",
    "start_line": 134,
    "text_preview": "   indexEntry = createIndexEntry(entry, originalBytes);\\n            index.put(key, indexEntry);\\n        }\\n\\n        if (!postCacheCommand(new InsertCommand(this, key, bytes))) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.error(\"put(\" + getCacheDirectory() + \") Failed to post in"
  },
  {
    "method_id": "M3213",
    "name": "AbstractCommand",
    "return_type": "",
    "signature": "AbstractCommand(AsynchronousFileCacheBacking backing)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3214",
    "name": "getCache",
    "return_type": "AsynchronousFileCacheBacking",
    "signature": "getCache()",
    "file_id": "F67",
    "start_line": 299,
    "text_preview": "();\\n                                try {\\n                                    AsynchronousFileCacheBacking    cache=cmd.getCache();\\n                                    cache.executeCommand(cmd);\\n                                } catch(Exception e) {\\n                                    if ((trace != null) && trace.isTra"
  },
  {
    "method_id": "M3215",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F67",
    "start_line": 265,
    "text_preview": "t Map<String, byte[]> readClassBytes (Map<String,IndexEntry> indexMap, File cacheDir);\\n\\n    @Override\\n    public String toString() {\\n        return getClass().getSimpleName() + \"[\" + String.valueOf(getCacheDirectory()) + \"]\";\\n    }\\n\\n    protected static final <T extends AsynchronousFileCacheBacking> T createBacking (\\n "
  },
  {
    "method_id": "M3216",
    "name": "ClearCommand",
    "return_type": "",
    "signature": "ClearCommand(AsynchronousFileCacheBacking cache)",
    "file_id": "F67",
    "start_line": 201,
    "text_preview": "ic void clear() {\\n        synchronized(index) {\\n            index.clear();\\n        }\\n\\n        if (!postCacheCommand(new ClearCommand(this))) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.error(\"Failed to post clear command for \" + getIndexFile());\\n            }\\n        }\\n    }\\n"
  },
  {
    "method_id": "M3217",
    "name": "UpdateIndexCommand",
    "return_type": "",
    "signature": "UpdateIndexCommand(AsynchronousFileCacheBacking cache)",
    "file_id": "F67",
    "start_line": 212,
    "text_preview": "ommand) {\\n            executeClearCommand();\\n        } else if (cmd instanceof UpdateIndexCommand) {\\n            executeUpdateIndexCommand();\\n        } else if (cmd instanceof InsertCommand) {\\n            executeInsertCommand((InsertCommand) cmd);\\n        } else if (cmd instanceof RemoveCommand) {\\n            executeRe"
  },
  {
    "method_id": "M3218",
    "name": "KeyedCommand",
    "return_type": "",
    "signature": "KeyedCommand(AsynchronousFileCacheBacking cache, String keyValue)",
    "file_id": "F67",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3219",
    "name": "getKey",
    "return_type": "String",
    "signature": "getKey()",
    "file_id": "F67",
    "start_line": 75,
    "text_preview": "\\n\t}\\n\\n\tpublic CachedClassEntry get(CachedClassReference ref, byte[] originalBytes) {\\n        String              key=ref.getKey();\\n        final IndexEntry    indexEntry;\\n        synchronized(index) {\\n            if ((indexEntry=index.get(key)) == null) {\\n                return null;\\n            }\\n        }\\n\\n        if "
  },
  {
    "method_id": "M3220",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F67",
    "start_line": 265,
    "text_preview": "t Map<String, byte[]> readClassBytes (Map<String,IndexEntry> indexMap, File cacheDir);\\n\\n    @Override\\n    public String toString() {\\n        return getClass().getSimpleName() + \"[\" + String.valueOf(getCacheDirectory()) + \"]\";\\n    }\\n\\n    protected static final <T extends AsynchronousFileCacheBacking> T createBacking (\\n "
  },
  {
    "method_id": "M3221",
    "name": "RemoveCommand",
    "return_type": "",
    "signature": "RemoveCommand(AsynchronousFileCacheBacking cache, String keyValue)",
    "file_id": "F67",
    "start_line": 159,
    "text_preview": "     }\\n\\n        synchronized(bytesMap) {\\n            bytesMap.remove(key);\\n        }\\n\\n        if (!postCacheCommand(new RemoveCommand(this, key))) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.error(\"remove(\" + getCacheDirectory() + \") Failed to post remove command for \" + key)"
  },
  {
    "method_id": "M3222",
    "name": "InsertCommand",
    "return_type": "",
    "signature": "InsertCommand(AsynchronousFileCacheBacking cache, String keyValue, byte[] classBytes)",
    "file_id": "F67",
    "start_line": 134,
    "text_preview": "eIndexEntry(entry, originalBytes);\\n            index.put(key, indexEntry);\\n        }\\n\\n        if (!postCacheCommand(new InsertCommand(this, key, bytes))) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.error(\"put(\" + getCacheDirectory() + \") Failed to post insert command for \" + "
  },
  {
    "method_id": "M3223",
    "name": "getClassBytes",
    "return_type": "byte[]",
    "signature": "getClassBytes()",
    "file_id": "F67",
    "start_line": 234,
    "text_preview": "InsertCommand cmd) throws Exception {\\n        writeIndex(getIndexFile(), getIndexEntries());\\n\\n        byte[]  bytes=cmd.getClassBytes();\\n        if (bytes != null) {\\n            writeClassBytes(cmd.getKey(), bytes);\\n        }\\n    }\\n\\n    protected void executeRemoveCommand (RemoveCommand cmd) throws Exception {\\n        "
  },
  {
    "method_id": "M3224",
    "name": "hit",
    "return_type": "void",
    "signature": "hit()",
    "file_id": "F71",
    "start_line": 27,
    "text_preview": "generated;\\n\tprivate volatile int ignored;\\n\tprivate volatile int puts;\\n\tprivate volatile int puts_ignored;\\n\\n\tpublic void hit() {\\n\t\thits++;\\n\t}\\n\\n\tpublic void miss() {\\n\t\tmisses++;\\n\t}\\n\\n\tpublic void weaved() {\\n\t\tweaved++;\\n\t}\\n\\n\tpublic void generated() {\\n\t\tgenerated++;\\n\t}\\n\\n\tpublic void ignored() {\\n\t\tignored++;\\n\t}\\n\\n\tpublic void"
  },
  {
    "method_id": "M3225",
    "name": "miss",
    "return_type": "void",
    "signature": "miss()",
    "file_id": "F71",
    "start_line": 31,
    "text_preview": "nored;\\n\tprivate volatile int puts;\\n\tprivate volatile int puts_ignored;\\n\\n\tpublic void hit() {\\n\t\thits++;\\n\t}\\n\\n\tpublic void miss() {\\n\t\tmisses++;\\n\t}\\n\\n\tpublic void weaved() {\\n\t\tweaved++;\\n\t}\\n\\n\tpublic void generated() {\\n\t\tgenerated++;\\n\t}\\n\\n\tpublic void ignored() {\\n\t\tignored++;\\n\t}\\n\\n\tpublic void put() {\\n\t\tputs++;\\n\t}\\n\\n\tpublic void"
  },
  {
    "method_id": "M3226",
    "name": "weaved",
    "return_type": "void",
    "signature": "weaved()",
    "file_id": "F71",
    "start_line": 35,
    "text_preview": "ivate volatile int puts_ignored;\\n\\n\tpublic void hit() {\\n\t\thits++;\\n\t}\\n\\n\tpublic void miss() {\\n\t\tmisses++;\\n\t}\\n\\n\tpublic void weaved() {\\n\t\tweaved++;\\n\t}\\n\\n\tpublic void generated() {\\n\t\tgenerated++;\\n\t}\\n\\n\tpublic void ignored() {\\n\t\tignored++;\\n\t}\\n\\n\tpublic void put() {\\n\t\tputs++;\\n\t}\\n\\n\tpublic void putIgnored() {\\n\t\tputs_ignored++;\\n\t}\\n\\n"
  },
  {
    "method_id": "M3227",
    "name": "generated",
    "return_type": "void",
    "signature": "generated()",
    "file_id": "F71",
    "start_line": 39,
    "text_preview": "c void hit() {\\n\t\thits++;\\n\t}\\n\\n\tpublic void miss() {\\n\t\tmisses++;\\n\t}\\n\\n\tpublic void weaved() {\\n\t\tweaved++;\\n\t}\\n\\n\tpublic void generated() {\\n\t\tgenerated++;\\n\t}\\n\\n\tpublic void ignored() {\\n\t\tignored++;\\n\t}\\n\\n\tpublic void put() {\\n\t\tputs++;\\n\t}\\n\\n\tpublic void putIgnored() {\\n\t\tputs_ignored++;\\n\t}\\n\\n\\n\tpublic int getHits() {\\n\t\treturn hits;\\n"
  },
  {
    "method_id": "M3228",
    "name": "ignored",
    "return_type": "void",
    "signature": "ignored()",
    "file_id": "F71",
    "start_line": 43,
    "text_preview": "() {\\n\t\tmisses++;\\n\t}\\n\\n\tpublic void weaved() {\\n\t\tweaved++;\\n\t}\\n\\n\tpublic void generated() {\\n\t\tgenerated++;\\n\t}\\n\\n\tpublic void ignored() {\\n\t\tignored++;\\n\t}\\n\\n\tpublic void put() {\\n\t\tputs++;\\n\t}\\n\\n\tpublic void putIgnored() {\\n\t\tputs_ignored++;\\n\t}\\n\\n\\n\tpublic int getHits() {\\n\t\treturn hits;\\n\t}\\n\\n\tpublic int getMisses() {\\n\t\treturn misses;"
  },
  {
    "method_id": "M3229",
    "name": "put",
    "return_type": "void",
    "signature": "put()",
    "file_id": "F71",
    "start_line": 47,
    "text_preview": " {\\n\t\tweaved++;\\n\t}\\n\\n\tpublic void generated() {\\n\t\tgenerated++;\\n\t}\\n\\n\tpublic void ignored() {\\n\t\tignored++;\\n\t}\\n\\n\tpublic void put() {\\n\t\tputs++;\\n\t}\\n\\n\tpublic void putIgnored() {\\n\t\tputs_ignored++;\\n\t}\\n\\n\\n\tpublic int getHits() {\\n\t\treturn hits;\\n\t}\\n\\n\tpublic int getMisses() {\\n\t\treturn misses;\\n\t}\\n\\n\tpublic int getWeaved() {\\n\t\treturn we"
  },
  {
    "method_id": "M3230",
    "name": "putIgnored",
    "return_type": "void",
    "signature": "putIgnored()",
    "file_id": "F71",
    "start_line": 51,
    "text_preview": "erated() {\\n\t\tgenerated++;\\n\t}\\n\\n\tpublic void ignored() {\\n\t\tignored++;\\n\t}\\n\\n\tpublic void put() {\\n\t\tputs++;\\n\t}\\n\\n\tpublic void putIgnored() {\\n\t\tputs_ignored++;\\n\t}\\n\\n\\n\tpublic int getHits() {\\n\t\treturn hits;\\n\t}\\n\\n\tpublic int getMisses() {\\n\t\treturn misses;\\n\t}\\n\\n\tpublic int getWeaved() {\\n\t\treturn weaved;\\n\t}\\n\\n\tpublic int getGenerated("
  },
  {
    "method_id": "M3231",
    "name": "getHits",
    "return_type": "int",
    "signature": "getHits()",
    "file_id": "F71",
    "start_line": 56,
    "text_preview": "() {\\n\t\tignored++;\\n\t}\\n\\n\tpublic void put() {\\n\t\tputs++;\\n\t}\\n\\n\tpublic void putIgnored() {\\n\t\tputs_ignored++;\\n\t}\\n\\n\\n\tpublic int getHits() {\\n\t\treturn hits;\\n\t}\\n\\n\tpublic int getMisses() {\\n\t\treturn misses;\\n\t}\\n\\n\tpublic int getWeaved() {\\n\t\treturn weaved;\\n\t}\\n\\n\tpublic int getGenerated() {\\n\t\treturn generated;\\n\t}\\n\\n\tpublic int getIgnored"
  },
  {
    "method_id": "M3232",
    "name": "getMisses",
    "return_type": "int",
    "signature": "getMisses()",
    "file_id": "F71",
    "start_line": 60,
    "text_preview": "\t\tputs++;\\n\t}\\n\\n\tpublic void putIgnored() {\\n\t\tputs_ignored++;\\n\t}\\n\\n\\n\tpublic int getHits() {\\n\t\treturn hits;\\n\t}\\n\\n\tpublic int getMisses() {\\n\t\treturn misses;\\n\t}\\n\\n\tpublic int getWeaved() {\\n\t\treturn weaved;\\n\t}\\n\\n\tpublic int getGenerated() {\\n\t\treturn generated;\\n\t}\\n\\n\tpublic int getIgnored() {\\n\t\treturn ignored;\\n\t}\\n\\n\tpublic int getP"
  },
  {
    "method_id": "M3233",
    "name": "getWeaved",
    "return_type": "int",
    "signature": "getWeaved()",
    "file_id": "F71",
    "start_line": 64,
    "text_preview": "s_ignored++;\\n\t}\\n\\n\\n\tpublic int getHits() {\\n\t\treturn hits;\\n\t}\\n\\n\tpublic int getMisses() {\\n\t\treturn misses;\\n\t}\\n\\n\tpublic int getWeaved() {\\n\t\treturn weaved;\\n\t}\\n\\n\tpublic int getGenerated() {\\n\t\treturn generated;\\n\t}\\n\\n\tpublic int getIgnored() {\\n\t\treturn ignored;\\n\t}\\n\\n\tpublic int getPuts() {\\n\t\treturn puts;\\n\t}\\n\\n\tpublic int getPutsI"
  },
  {
    "method_id": "M3234",
    "name": "getGenerated",
    "return_type": "int",
    "signature": "getGenerated()",
    "file_id": "F71",
    "start_line": 68,
    "text_preview": "urn hits;\\n\t}\\n\\n\tpublic int getMisses() {\\n\t\treturn misses;\\n\t}\\n\\n\tpublic int getWeaved() {\\n\t\treturn weaved;\\n\t}\\n\\n\tpublic int getGenerated() {\\n\t\treturn generated;\\n\t}\\n\\n\tpublic int getIgnored() {\\n\t\treturn ignored;\\n\t}\\n\\n\tpublic int getPuts() {\\n\t\treturn puts;\\n\t}\\n\\n\tpublic int getPutsIgnored() {\\n\t\treturn puts_ignored;\\n\t}\\n\\n\\n\tpublic "
  },
  {
    "method_id": "M3235",
    "name": "getIgnored",
    "return_type": "int",
    "signature": "getIgnored()",
    "file_id": "F71",
    "start_line": 72,
    "text_preview": "es;\\n\t}\\n\\n\tpublic int getWeaved() {\\n\t\treturn weaved;\\n\t}\\n\\n\tpublic int getGenerated() {\\n\t\treturn generated;\\n\t}\\n\\n\tpublic int getIgnored() {\\n\t\treturn ignored;\\n\t}\\n\\n\tpublic int getPuts() {\\n\t\treturn puts;\\n\t}\\n\\n\tpublic int getPutsIgnored() {\\n\t\treturn puts_ignored;\\n\t}\\n\\n\\n\tpublic void reset() {\\n\t\thits = 0;\\n\t\tmisses = 0;\\n\t\tweaved = 0"
  },
  {
    "method_id": "M3236",
    "name": "getPuts",
    "return_type": "int",
    "signature": "getPuts()",
    "file_id": "F71",
    "start_line": 76,
    "text_preview": ";\\n\t}\\n\\n\tpublic int getGenerated() {\\n\t\treturn generated;\\n\t}\\n\\n\tpublic int getIgnored() {\\n\t\treturn ignored;\\n\t}\\n\\n\tpublic int getPuts() {\\n\t\treturn puts;\\n\t}\\n\\n\tpublic int getPutsIgnored() {\\n\t\treturn puts_ignored;\\n\t}\\n\\n\\n\tpublic void reset() {\\n\t\thits = 0;\\n\t\tmisses = 0;\\n\t\tweaved = 0;\\n\t\tgenerated = 0;\\n\t\tignored = 0;\\n\t\tputs = 0;\\n\t\tp"
  },
  {
    "method_id": "M3237",
    "name": "getPutsIgnored",
    "return_type": "int",
    "signature": "getPutsIgnored()",
    "file_id": "F71",
    "start_line": 80,
    "text_preview": " generated;\\n\t}\\n\\n\tpublic int getIgnored() {\\n\t\treturn ignored;\\n\t}\\n\\n\tpublic int getPuts() {\\n\t\treturn puts;\\n\t}\\n\\n\tpublic int getPutsIgnored() {\\n\t\treturn puts_ignored;\\n\t}\\n\\n\\n\tpublic void reset() {\\n\t\thits = 0;\\n\t\tmisses = 0;\\n\t\tweaved = 0;\\n\t\tgenerated = 0;\\n\t\tignored = 0;\\n\t\tputs = 0;\\n\t\tputs_ignored = 0;\\n\t}\\n\\n\t@Override\\n\tpublic Str"
  },
  {
    "method_id": "M3238",
    "name": "reset",
    "return_type": "void",
    "signature": "reset()",
    "file_id": "F71",
    "start_line": 85,
    "text_preview": "\\n\t}\\n\\n\tpublic int getPuts() {\\n\t\treturn puts;\\n\t}\\n\\n\tpublic int getPutsIgnored() {\\n\t\treturn puts_ignored;\\n\t}\\n\\n\\n\tpublic void reset() {\\n\t\thits = 0;\\n\t\tmisses = 0;\\n\t\tweaved = 0;\\n\t\tgenerated = 0;\\n\t\tignored = 0;\\n\t\tputs = 0;\\n\t\tputs_ignored = 0;\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn \"CacheStatistics{\" +\\n\t\t\t\t\"hits=\" +"
  },
  {
    "method_id": "M3239",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F71",
    "start_line": 96,
    "text_preview": "misses = 0;\\n\t\tweaved = 0;\\n\t\tgenerated = 0;\\n\t\tignored = 0;\\n\t\tputs = 0;\\n\t\tputs_ignored = 0;\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn \"CacheStatistics{\" +\\n\t\t\t\t\"hits=\" + hits +\\n\t\t\t\t\", misses=\" + misses +\\n\t\t\t\t\", weaved=\" + weaved +\\n\t\t\t\t\", generated=\" + generated +\\n\t\t\t\t\", ignored=\" + ignored +\\n\t\t\t\t\", puts=\" + puts"
  },
  {
    "method_id": "M3240",
    "name": "CachedClassEntry",
    "return_type": "",
    "signature": "CachedClassEntry(CachedClassReference ref, byte[] weavedBytes, EntryType type)",
    "file_id": "F72",
    "start_line": 29,
    "text_preview": "ate final CachedClassReference ref;\\n    private final byte[] weavedBytes;\\n    private final EntryType type;\\n\\n    public CachedClassEntry(CachedClassReference ref, byte[] weavedBytes, EntryType type) {\\n        this.weavedBytes = weavedBytes;\\n        this.ref = ref;\\n        this.type = type;\\n    }\\n\\n    public String getC"
  },
  {
    "method_id": "M3241",
    "name": "getClassName",
    "return_type": "String",
    "signature": "getClassName()",
    "file_id": "F72",
    "start_line": 35,
    "text_preview": "e) {\\n        this.weavedBytes = weavedBytes;\\n        this.ref = ref;\\n        this.type = type;\\n    }\\n\\n    public String getClassName() {\\n        return ref.getClassName();\\n    }\\n\\n    public byte[] getBytes() {\\n        return weavedBytes;\\n    }\\n\\n    public String getKey() {\\n        return ref.getKey();\\n    }\\n\\n    public"
  },
  {
    "method_id": "M3242",
    "name": "getBytes",
    "return_type": "byte[]",
    "signature": "getBytes()",
    "file_id": "F72",
    "start_line": 39,
    "text_preview": "this.type = type;\\n    }\\n\\n    public String getClassName() {\\n        return ref.getClassName();\\n    }\\n\\n    public byte[] getBytes() {\\n        return weavedBytes;\\n    }\\n\\n    public String getKey() {\\n        return ref.getKey();\\n    }\\n\\n    public boolean isGenerated() {\\n        return type == EntryType.GENERATED;\\n    }\\n\\n "
  },
  {
    "method_id": "M3243",
    "name": "getKey",
    "return_type": "String",
    "signature": "getKey()",
    "file_id": "F72",
    "start_line": 43,
    "text_preview": "  return ref.getClassName();\\n    }\\n\\n    public byte[] getBytes() {\\n        return weavedBytes;\\n    }\\n\\n    public String getKey() {\\n        return ref.getKey();\\n    }\\n\\n    public boolean isGenerated() {\\n        return type == EntryType.GENERATED;\\n    }\\n\\n    public boolean isWeaved() {\\n        return type == EntryType.WE"
  },
  {
    "method_id": "M3244",
    "name": "isGenerated",
    "return_type": "boolean",
    "signature": "isGenerated()",
    "file_id": "F72",
    "start_line": 47,
    "text_preview": "\\n        return weavedBytes;\\n    }\\n\\n    public String getKey() {\\n        return ref.getKey();\\n    }\\n\\n    public boolean isGenerated() {\\n        return type == EntryType.GENERATED;\\n    }\\n\\n    public boolean isWeaved() {\\n        return type == EntryType.WEAVED;\\n    }\\n\\n    public boolean isIgnored() {\\n        return type "
  },
  {
    "method_id": "M3245",
    "name": "isWeaved",
    "return_type": "boolean",
    "signature": "isWeaved()",
    "file_id": "F72",
    "start_line": 51,
    "text_preview": "tKey();\\n    }\\n\\n    public boolean isGenerated() {\\n        return type == EntryType.GENERATED;\\n    }\\n\\n    public boolean isWeaved() {\\n        return type == EntryType.WEAVED;\\n    }\\n\\n    public boolean isIgnored() {\\n        return type == EntryType.IGNORED;\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return "
  },
  {
    "method_id": "M3246",
    "name": "isIgnored",
    "return_type": "boolean",
    "signature": "isIgnored()",
    "file_id": "F72",
    "start_line": 55,
    "text_preview": "pe.GENERATED;\\n    }\\n\\n    public boolean isWeaved() {\\n        return type == EntryType.WEAVED;\\n    }\\n\\n    public boolean isIgnored() {\\n        return type == EntryType.IGNORED;\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return getClassName().hashCode()\\n             + getKey().hashCode()\\n             + type"
  },
  {
    "method_id": "M3247",
    "name": "hashCode",
    "return_type": "int",
    "signature": "hashCode()",
    "file_id": "F72",
    "start_line": 60,
    "text_preview": ";\\n    }\\n\\n    public boolean isIgnored() {\\n        return type == EntryType.IGNORED;\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return getClassName().hashCode()\\n             + getKey().hashCode()\\n             + type.hashCode()\\n             ;\\n    }\\n\\n    @Override\\n    public boolean equals(Object obj) {\\n    "
  },
  {
    "method_id": "M3248",
    "name": "equals",
    "return_type": "boolean",
    "signature": "equals(Object obj)",
    "file_id": "F72",
    "start_line": 68,
    "text_preview": "            + getKey().hashCode()\\n             + type.hashCode()\\n             ;\\n    }\\n\\n    @Override\\n    public boolean equals(Object obj) {\\n        if (obj == null)\\n            return false;\\n        if (this == obj)\\n            return true;\\n        if (getClass() != obj.getClass())\\n            return false;\\n\\n        C"
  },
  {
    "method_id": "M3249",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F72",
    "start_line": 87,
    "text_preview": "{\\n             return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return getClassName() + \"[\" + type + \"]\";\\n    }\\n}\\n"
  },
  {
    "method_id": "M3250",
    "name": "CachedClassReference",
    "return_type": "",
    "signature": "CachedClassReference(String key, CacheKeyResolver resolver)",
    "file_id": "F73",
    "start_line": 36,
    "text_preview": "tryType {\\n\t\tGENERATED,\\n\t\tWEAVED,\\n\t\tIGNORED,\\n\t}\\n\\n\tprivate final String key;\\n\tprivate final String className;\\n\\n\tprotected CachedClassReference(String key, CacheKeyResolver resolver) {\\n\t\tthis(key, resolver.keyToClass(key));\\n\t}\\n\\n\t/**\\n\t * Protected to allow only the WeavedClassCache initialization rights\\n\t *\\n\t * @param key\t"
  },
  {
    "method_id": "M3251",
    "name": "CachedClassReference",
    "return_type": "",
    "signature": "CachedClassReference(String key, String className)",
    "file_id": "F73",
    "start_line": 36,
    "text_preview": "tryType {\\n\t\tGENERATED,\\n\t\tWEAVED,\\n\t\tIGNORED,\\n\t}\\n\\n\tprivate final String key;\\n\tprivate final String className;\\n\\n\tprotected CachedClassReference(String key, CacheKeyResolver resolver) {\\n\t\tthis(key, resolver.keyToClass(key));\\n\t}\\n\\n\t/**\\n\t * Protected to allow only the WeavedClassCache initialization rights\\n\t *\\n\t * @param key\t"
  },
  {
    "method_id": "M3252",
    "name": "getKey",
    "return_type": "String",
    "signature": "getKey()",
    "file_id": "F73",
    "start_line": 51,
    "text_preview": "CachedClassReference(String key, String className) {\\n\t\tthis.key = key;\\n\t\tthis.className = className;\\n\t}\\n\\n\tpublic String getKey() {\\n\t\treturn key;\\n\t}\\n\\n\tpublic String getClassName() {\\n\t\treturn className;\\n\t}\\n\\n\t@Override\\n\tpublic int hashCode() {\\n\t\treturn getKey().hashCode() + getClassName().hashCode();\\n\t}\\n\\n\t@Override\\n\tpubli"
  },
  {
    "method_id": "M3253",
    "name": "getClassName",
    "return_type": "String",
    "signature": "getClassName()",
    "file_id": "F73",
    "start_line": 55,
    "text_preview": "sName) {\\n\t\tthis.key = key;\\n\t\tthis.className = className;\\n\t}\\n\\n\tpublic String getKey() {\\n\t\treturn key;\\n\t}\\n\\n\tpublic String getClassName() {\\n\t\treturn className;\\n\t}\\n\\n\t@Override\\n\tpublic int hashCode() {\\n\t\treturn getKey().hashCode() + getClassName().hashCode();\\n\t}\\n\\n\t@Override\\n\tpublic boolean equals(Object obj) {\\n        if (o"
  },
  {
    "method_id": "M3254",
    "name": "hashCode",
    "return_type": "int",
    "signature": "hashCode()",
    "file_id": "F73",
    "start_line": 60,
    "text_preview": "blic String getKey() {\\n\t\treturn key;\\n\t}\\n\\n\tpublic String getClassName() {\\n\t\treturn className;\\n\t}\\n\\n\t@Override\\n\tpublic int hashCode() {\\n\t\treturn getKey().hashCode() + getClassName().hashCode();\\n\t}\\n\\n\t@Override\\n\tpublic boolean equals(Object obj) {\\n        if (obj == null)\\n            return false;\\n        if (this == obj)\\n "
  },
  {
    "method_id": "M3255",
    "name": "equals",
    "return_type": "boolean",
    "signature": "equals(Object obj)",
    "file_id": "F73",
    "start_line": 65,
    "text_preview": "rride\\n\tpublic int hashCode() {\\n\t\treturn getKey().hashCode() + getClassName().hashCode();\\n\t}\\n\\n\t@Override\\n\tpublic boolean equals(Object obj) {\\n        if (obj == null)\\n            return false;\\n        if (this == obj)\\n            return true;\\n        if (getClass() != obj.getClass())\\n            return false;\\n\\n        C"
  },
  {
    "method_id": "M3256",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F73",
    "start_line": 83,
    "text_preview": "assName().equals(other.getClassName())) {\\n\t\t\treturn true;\\n\t\t} else {\\n\t\t\treturn false;\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic String toString() {\\n\t\treturn getClassName() + \"[\" + getKey() + \"]\";\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3257",
    "name": "createResolver",
    "return_type": "CacheKeyResolver",
    "signature": "createResolver()",
    "file_id": "F74",
    "start_line": 19,
    "text_preview": " backing and resolving classes.\\n */\\npublic class DefaultCacheFactory implements CacheFactory {\\n\tpublic CacheKeyResolver createResolver() {\\n\t\treturn new DefaultCacheKeyResolver();\\n\t}\\n\\n\tpublic CacheBacking createBacking(String scope) {\\n\t\treturn DefaultFileCacheBacking.createBacking(scope);\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3258",
    "name": "createBacking",
    "return_type": "CacheBacking",
    "signature": "createBacking(String scope)",
    "file_id": "F74",
    "start_line": 23,
    "text_preview": "eFactory {\\n\tpublic CacheKeyResolver createResolver() {\\n\t\treturn new DefaultCacheKeyResolver();\\n\t}\\n\\n\tpublic CacheBacking createBacking(String scope) {\\n\t\treturn DefaultFileCacheBacking.createBacking(scope);\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3259",
    "name": "createClassLoaderScope",
    "return_type": "String",
    "signature": "createClassLoaderScope(ClassLoader cl, List<String> aspects)",
    "file_id": "F75",
    "start_line": 51,
    "text_preview": "pects the aspects\\n\t * @return a unique string for URLClassloaders, otherwise a non-unique classname\\n\t */\\n\tpublic String createClassLoaderScope(ClassLoader cl, List<String> aspects) {\\n\t\tString name = cl != null ? cl.getClass().getSimpleName() : \"unknown\";\\n\\n\t\tList<String> hashableStrings = new LinkedList<>();\\n\t\tStringBui"
  },
  {
    "method_id": "M3260",
    "name": "if",
    "return_type": "list",
    "signature": "if(cl instanceof URLClassLoader)",
    "file_id": "F75",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3261",
    "name": "for",
    "return_type": "",
    "signature": "for(URL url : urls)",
    "file_id": "F75",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3262",
    "name": "for",
    "return_type": "",
    "signature": "for(String url : hashableStrings)",
    "file_id": "F75",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3263",
    "name": "crc",
    "return_type": "String",
    "signature": "crc(byte[] input)",
    "file_id": "F75",
    "start_line": 72,
    "text_preview": "Strings) {\\n\t\t\thashable.append(url);\\n\t\t}\\n\t\tString hash = null;\\n\t\tbyte[] bytes = hashable.toString().getBytes();\\n\t\thash = crc(bytes);\\n\\n\t\treturn name + '.' + hash;\\n\t}\\n\\n\tprivate String crc(byte[] input) {\\n\t\tCRC32 crc32 = new CRC32();\\n\t\tcrc32.update(input);\\n\t\treturn String.valueOf(crc32.getValue());\\n\t}\\n\\n\tpublic String getGe"
  },
  {
    "method_id": "M3264",
    "name": "getGeneratedRegex",
    "return_type": "String",
    "signature": "getGeneratedRegex()",
    "file_id": "F75",
    "start_line": 83,
    "text_preview": "ut) {\\n\t\tCRC32 crc32 = new CRC32();\\n\t\tcrc32.update(input);\\n\t\treturn String.valueOf(crc32.getValue());\\n\t}\\n\\n\tpublic String getGeneratedRegex() {\\n\t\treturn \".*\" + GENERATED_SUFFIX;\\n\t}\\n\\n\tpublic String getWeavedRegex() {\\n\t\treturn \".*\" + WEAVED_SUFFIX;\\n\t}\\n\\n\\n\t/**\\n\t * Converts a cache key back to a className\\n\t *\\n\t * @param key t"
  },
  {
    "method_id": "M3265",
    "name": "getWeavedRegex",
    "return_type": "String",
    "signature": "getWeavedRegex()",
    "file_id": "F75",
    "start_line": 87,
    "text_preview": "alueOf(crc32.getValue());\\n\t}\\n\\n\tpublic String getGeneratedRegex() {\\n\t\treturn \".*\" + GENERATED_SUFFIX;\\n\t}\\n\\n\tpublic String getWeavedRegex() {\\n\t\treturn \".*\" + WEAVED_SUFFIX;\\n\t}\\n\\n\\n\t/**\\n\t * Converts a cache key back to a className\\n\t *\\n\t * @param key to convert\\n\t * @return className, e.g. \"com.foo.Bar\"\\n\t */\\n\tpublic String key"
  },
  {
    "method_id": "M3266",
    "name": "keyToClass",
    "return_type": "String",
    "signature": "keyToClass(String key)",
    "file_id": "F75",
    "start_line": 98,
    "text_preview": "che key back to a className\\n\t *\\n\t * @param key to convert\\n\t * @return className, e.g. \"com.foo.Bar\"\\n\t */\\n\tpublic String keyToClass(String key) {\\n\t\tif (key.endsWith(GENERATED_SUFFIX)) {\\n\t\t\treturn key.replaceAll(GENERATED_SUFFIX + \"$\", \"\");\\n\t\t}\\n\t\tif (key.endsWith(WEAVED_SUFFIX)) {\\n\t\t\treturn key.replaceAll(\"\\\\.[^.]+\" + WE"
  },
  {
    "method_id": "M3267",
    "name": "weavedKey",
    "return_type": "CachedClassReference",
    "signature": "weavedKey(String className, byte[] original_bytes)",
    "file_id": "F75",
    "start_line": 108,
    "text_preview": "SUFFIX)) {\\n\t\t\treturn key.replaceAll(\"\\\\.[^.]+\" + WEAVED_SUFFIX, \"\");\\n\t\t}\\n\t\treturn key;\\n\t}\\n\\n\tpublic CachedClassReference weavedKey(String className, byte[] original_bytes) {\\n\t\tString hash = crc(original_bytes);\\n\t\treturn new CachedClassReference(className + \".\" + hash + WEAVED_SUFFIX, className);\\n\\n\t}\\n\\n\tpublic CachedClass"
  },
  {
    "method_id": "M3268",
    "name": "generatedKey",
    "return_type": "CachedClassReference",
    "signature": "generatedKey(String className)",
    "file_id": "F75",
    "start_line": 114,
    "text_preview": "\t\treturn new CachedClassReference(className + \".\" + hash + WEAVED_SUFFIX, className);\\n\\n\t}\\n\\n\tpublic CachedClassReference generatedKey(String className) {\\n\t\treturn new CachedClassReference(className + GENERATED_SUFFIX, className);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3269",
    "name": "DefaultFileCacheBacking",
    "return_type": "",
    "signature": "DefaultFileCacheBacking(File cacheDir)",
    "file_id": "F76",
    "start_line": 54,
    "text_preview": "eBacking {\\n\tprivate final Map<String, IndexEntry> index;\\n\\n\tprivate static final Object LOCK = new Object();\\n\\n\tprotected DefaultFileCacheBacking(File cacheDir) {\\n\t\tsuper(cacheDir);\\n\t\tindex = readIndex();\\n\t}\\n\\n\tpublic static final DefaultFileCacheBacking createBacking(File cacheDir) {\\n\t\tif (!cacheDir.exists()) {\\n\t\t\tif (!c"
  },
  {
    "method_id": "M3270",
    "name": "createBacking",
    "return_type": "DefaultFileCacheBacking",
    "signature": "createBacking(File cacheDir)",
    "file_id": "F76",
    "start_line": 59,
    "text_preview": "acheBacking(File cacheDir) {\\n\t\tsuper(cacheDir);\\n\t\tindex = readIndex();\\n\t}\\n\\n\tpublic static final DefaultFileCacheBacking createBacking(File cacheDir) {\\n\t\tif (!cacheDir.exists()) {\\n\t\t\tif (!cacheDir.mkdirs()) {\\n\t\t\t\tMessageUtil.error(\"Unable to create cache directory at \" + cacheDir.getName());\\n\t\t\t\treturn null;\\n\t\t\t}\\n\t\t} el"
  },
  {
    "method_id": "M3271",
    "name": "getIndex",
    "return_type": "IndexEntry>",
    "signature": "getIndex()",
    "file_id": "F76",
    "start_line": 78,
    "text_preview": "\t\treturn null;\\n\t\t}\\n\t\treturn new DefaultFileCacheBacking(cacheDir);\\n\t}\\n\\n    @Override\\n\tprotected Map<String, IndexEntry> getIndex() {\\n\t\treturn index;\\n\t}\\n\\n\t@Override\\n    protected IndexEntry resolveIndexMapEntry (File cacheDir, IndexEntry ie) {\\n        File cacheEntry = new File(cacheDir, ie.key);\\n        if (ie.ignored "
  },
  {
    "method_id": "M3272",
    "name": "resolveIndexMapEntry",
    "return_type": "IndexEntry",
    "signature": "resolveIndexMapEntry(File cacheDir, IndexEntry ie)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3273",
    "name": "removeIndexEntry",
    "return_type": "void",
    "signature": "removeIndexEntry(String key)",
    "file_id": "F76",
    "start_line": 92,
    "text_preview": "cacheEntry.canRead()) {\\n            return ie;\\n        } else {\\n            return null;\\n        }\\n    }\\n\\n\tprivate void removeIndexEntry(String key) {\\n\t\tsynchronized (LOCK) {\\n\t\t\tindex.remove(key);\\n\t\t\twriteIndex();\\n\t\t}\\n\t}\\n\\n\tprivate void addIndexEntry(IndexEntry ie) {\\n\t\tsynchronized (LOCK) {\\n\t\t\tindex.put(ie.key, ie);\\n\t\t\t"
  },
  {
    "method_id": "M3274",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(LOCK)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3275",
    "name": "addIndexEntry",
    "return_type": "void",
    "signature": "addIndexEntry(IndexEntry ie)",
    "file_id": "F76",
    "start_line": 99,
    "text_preview": "oid removeIndexEntry(String key) {\\n\t\tsynchronized (LOCK) {\\n\t\t\tindex.remove(key);\\n\t\t\twriteIndex();\\n\t\t}\\n\t}\\n\\n\tprivate void addIndexEntry(IndexEntry ie) {\\n\t\tsynchronized (LOCK) {\\n\t\t\tindex.put(ie.key, ie);\\n\t\t\twriteIndex();\\n\t\t}\\n\t}\\n\\n    @Override\\n\tprotected Map<String, IndexEntry> readIndex() {\\n\t\tsynchronized (LOCK) {\\n\t\t\tretu"
  },
  {
    "method_id": "M3276",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(LOCK)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3277",
    "name": "readIndex",
    "return_type": "IndexEntry>",
    "signature": "readIndex()",
    "file_id": "F76",
    "start_line": 56,
    "text_preview": "tic final Object LOCK = new Object();\\n\\n\tprotected DefaultFileCacheBacking(File cacheDir) {\\n\t\tsuper(cacheDir);\\n\t\tindex = readIndex();\\n\t}\\n\\n\tpublic static final DefaultFileCacheBacking createBacking(File cacheDir) {\\n\t\tif (!cacheDir.exists()) {\\n\t\t\tif (!cacheDir.mkdirs()) {\\n\t\t\t\tMessageUtil.error(\"Unable to create cache dire"
  },
  {
    "method_id": "M3278",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(LOCK)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3279",
    "name": "writeIndex",
    "return_type": "void",
    "signature": "writeIndex()",
    "file_id": "F76",
    "start_line": 95,
    "text_preview": "rn null;\\n        }\\n    }\\n\\n\tprivate void removeIndexEntry(String key) {\\n\t\tsynchronized (LOCK) {\\n\t\t\tindex.remove(key);\\n\t\t\twriteIndex();\\n\t\t}\\n\t}\\n\\n\tprivate void addIndexEntry(IndexEntry ie) {\\n\t\tsynchronized (LOCK) {\\n\t\t\tindex.put(ie.key, ie);\\n\t\t\twriteIndex();\\n\t\t}\\n\t}\\n\\n    @Override\\n\tprotected Map<String, IndexEntry> readIndex"
  },
  {
    "method_id": "M3280",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(LOCK)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3281",
    "name": "clear",
    "return_type": "void",
    "signature": "clear()",
    "file_id": "F76",
    "start_line": 120,
    "text_preview": ";\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tprotected void writeIndex() {\\n\t\tsynchronized (LOCK) {\\n\t\t\tsuper.writeIndex();\\n\t\t}\\n\t}\\n\\n\tpublic void clear() {\\n\t\tFile\tcacheDir=getCacheDirectory();\\n\t\tint\t\tnumDeleted=0;\\n\t\tsynchronized (LOCK) {\\n\t\t\tnumDeleted = FileUtil.deleteContents(cacheDir);\\n\t\t}\\n\\n\t\tif ((numDeleted > 0) && (logger != null) && logger"
  },
  {
    "method_id": "M3282",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(LOCK)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3283",
    "name": "createBacking",
    "return_type": "CacheBacking",
    "signature": "createBacking(String scope)",
    "file_id": "F76",
    "start_line": 59,
    "text_preview": "acheBacking(File cacheDir) {\\n\t\tsuper(cacheDir);\\n\t\tindex = readIndex();\\n\t}\\n\\n\tpublic static final DefaultFileCacheBacking createBacking(File cacheDir) {\\n\t\tif (!cacheDir.exists()) {\\n\t\t\tif (!cacheDir.mkdirs()) {\\n\t\t\t\tMessageUtil.error(\"Unable to create cache directory at \" + cacheDir.getName());\\n\t\t\t\treturn null;\\n\t\t\t}\\n\t\t} el"
  },
  {
    "method_id": "M3284",
    "name": "if",
    "return_type": "",
    "signature": "if(cache == null)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3285",
    "name": "getKeys",
    "return_type": "String[]",
    "signature": "getKeys(final String regex)",
    "file_id": "F76",
    "start_line": 143,
    "text_preview": " null;\\n\t\t}\\n\\n\t\tFile cacheDir = new File(cache, scope);\\n\t\treturn createBacking(cacheDir);\\n\t}\\n\\n\t@Override\\n\tpublic String[] getKeys(final String regex) {\\n\t\tFile\tcacheDirectory = getCacheDirectory();\\n\t\tFile[] files = cacheDirectory.listFiles(new FilenameFilter() {\\n\t\t\t\tpublic boolean accept(File file, String s) {\\n\t\t\t\t\tif (s."
  },
  {
    "method_id": "M3286",
    "name": "listFiles",
    "return_type": "",
    "signature": "listFiles(new FilenameFilter()",
    "file_id": "F76",
    "start_line": 145,
    "text_preview": "lic String[] getKeys(final String regex) {\\n\t\tFile\tcacheDirectory = getCacheDirectory();\\n\t\tFile[] files = cacheDirectory.listFiles(new FilenameFilter() {\\n\t\t\t\tpublic boolean accept(File file, String s) {\\n\t\t\t\t\tif (s.matches(regex)) {\\n\t\t\t\t\t\treturn true;\\n\t\t\t\t\t}\\n\t\t\t\t\treturn false;\\n\t\t\t\t}\\n\t\t\t});\\n\t\tif (LangUtil.isEmpty(files)) "
  },
  {
    "method_id": "M3287",
    "name": "accept",
    "return_type": "boolean",
    "signature": "accept(File file, String s)",
    "file_id": "F76",
    "start_line": 146,
    "text_preview": "cheDirectory = getCacheDirectory();\\n\t\tFile[] files = cacheDirectory.listFiles(new FilenameFilter() {\\n\t\t\t\tpublic boolean accept(File file, String s) {\\n\t\t\t\t\tif (s.matches(regex)) {\\n\t\t\t\t\t\treturn true;\\n\t\t\t\t\t}\\n\t\t\t\t\treturn false;\\n\t\t\t\t}\\n\t\t\t});\\n\t\tif (LangUtil.isEmpty(files)) {\\n\t\t\treturn EMPTY_KEYS;\\n\t\t}\\n\t\tString[] keys = new St"
  },
  {
    "method_id": "M3288",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < files.length; i++)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3289",
    "name": "get",
    "return_type": "CachedClassEntry",
    "signature": "get(CachedClassReference ref, byte[] originalBytes)",
    "file_id": "F76",
    "start_line": 163,
    "text_preview": "r (int i = 0; i < files.length; i++) {\\n\t\t\tkeys[i] = files[i].getName();\\n\t\t}\\n\t\treturn keys;\\n\t}\\n\\n\tpublic CachedClassEntry get(CachedClassReference ref, byte[] originalBytes) {\\n\t\tFile cacheDirectory = getCacheDirectory();\\n\t\tString\trefKey=ref.getKey();\\n\t\tFile cacheFile = new File(cacheDirectory, refKey);\\n\t\tIndexEntry ie = "
  },
  {
    "method_id": "M3290",
    "name": "if",
    "return_type": "",
    "signature": "if(ie == null)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3291",
    "name": "if",
    "return_type": "",
    "signature": "if(ie.ignored)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3292",
    "name": "if",
    "return_type": "",
    "signature": "if(bytes != null)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3293",
    "name": "if",
    "return_type": "",
    "signature": "if(!ie.generated)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3294",
    "name": "put",
    "return_type": "void",
    "signature": "put(CachedClassEntry entry, byte[] originalBytes)",
    "file_id": "F76",
    "start_line": 101,
    "text_preview": "dex.remove(key);\\n\t\t\twriteIndex();\\n\t\t}\\n\t}\\n\\n\tprivate void addIndexEntry(IndexEntry ie) {\\n\t\tsynchronized (LOCK) {\\n\t\t\tindex.put(ie.key, ie);\\n\t\t\twriteIndex();\\n\t\t}\\n\t}\\n\\n    @Override\\n\tprotected Map<String, IndexEntry> readIndex() {\\n\t\tsynchronized (LOCK) {\\n\t\t\treturn super.readIndex();\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tprotected void writeIn"
  },
  {
    "method_id": "M3295",
    "name": "if",
    "return_type": "",
    "signature": "if(writeEntryBytes)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3296",
    "name": "remove",
    "return_type": "void",
    "signature": "remove(CachedClassReference ref)",
    "file_id": "F76",
    "start_line": 94,
    "text_preview": "            return null;\\n        }\\n    }\\n\\n\tprivate void removeIndexEntry(String key) {\\n\t\tsynchronized (LOCK) {\\n\t\t\tindex.remove(key);\\n\t\t\twriteIndex();\\n\t\t}\\n\t}\\n\\n\tprivate void addIndexEntry(IndexEntry ie) {\\n\t\tsynchronized (LOCK) {\\n\t\t\tindex.put(ie.key, ie);\\n\t\t\twriteIndex();\\n\t\t}\\n\t}\\n\\n    @Override\\n\tprotected Map<String, Index"
  },
  {
    "method_id": "M3297",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(LOCK)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3298",
    "name": "delete",
    "return_type": "void",
    "signature": "delete(File file)",
    "file_id": "F76",
    "start_line": 170,
    "text_preview": " = new File(cacheDirectory, refKey);\\n\t\tIndexEntry ie = index.get(refKey);\\n\t\tif (ie == null) {\\n\t\t\t// no index, delete\\n\t\t\tdelete(cacheFile);\\n\t\t\treturn null;\\n\t\t}\\n\\n\t\t// check if original file changed\\n\t\tif (crc(originalBytes) != ie.crcClass) {\\n\t\t\tdelete(cacheFile);\\n\t\t\treturn null;\\n\t\t}\\n\\n\t\tif (ie.ignored) {\\n\t\t\treturn new Cach"
  },
  {
    "method_id": "M3299",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(LOCK)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3300",
    "name": "read",
    "return_type": "byte[]",
    "signature": "read(File file, long expectedCRC)",
    "file_id": "F76",
    "start_line": 185,
    "text_preview": ", WeavedClassCache.ZERO_BYTES, CachedClassEntry.EntryType.IGNORED);\\n\t\t}\\n\\n\t\tif (cacheFile.canRead()) {\\n\t\t\tbyte[] bytes = read(cacheFile, ie.crcWeaved);\\n\t\t\tif (bytes != null) {\\n\t\t\t\tif (!ie.generated) {\\n\t\t\t\t\treturn new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.WEAVED);\\n\t\t\t\t} else {\\n\t\t\t\t\treturn new CachedClas"
  },
  {
    "method_id": "M3301",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(LOCK)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3302",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3303",
    "name": "write",
    "return_type": "long",
    "signature": "write(File file, byte[] bytes)",
    "file_id": "F76",
    "start_line": 216,
    "text_preview": "\tif (writeEntryBytes) {\\n\t\t\tie = createIndexEntry(entry, originalBytes);\\n\t\t\tif (!entry.isIgnored()) {\\n\t\t\t\tie.crcWeaved = write(cacheFile, entry.getBytes());\\n\t\t\t}\\n\t\t\taddIndexEntry(ie);\\n\t\t}\\n\t}\\n\\n\tpublic void remove(CachedClassReference ref) {\\n\t\tFile\tcacheDirectory = getCacheDirectory();\\n\t\tString\trefKey = ref.getKey();\\n\t\tFi"
  },
  {
    "method_id": "M3304",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(LOCK)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3305",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F76",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3306",
    "name": "create",
    "return_type": "FlatFileCacheBacking",
    "signature": "create(File cacheDir)",
    "file_id": "F77",
    "start_line": 42,
    "text_preview": "          new AsynchronousFileCacheBackingCreator<FlatFileCacheBacking>() {\\n                public FlatFileCacheBacking create(File cacheDir) {\\n                    return new FlatFileCacheBacking(cacheDir);\\n                }\\n        };\\n    public FlatFileCacheBacking(File cacheDir) {\\n        super(cacheDir);\\n    }\\n\\n   "
  },
  {
    "method_id": "M3307",
    "name": "FlatFileCacheBacking",
    "return_type": "",
    "signature": "FlatFileCacheBacking(File cacheDir)",
    "file_id": "F77",
    "start_line": 43,
    "text_preview": "ileCacheBacking>() {\\n                public FlatFileCacheBacking create(File cacheDir) {\\n                    return new FlatFileCacheBacking(cacheDir);\\n                }\\n        };\\n    public FlatFileCacheBacking(File cacheDir) {\\n        super(cacheDir);\\n    }\\n\\n    public static final FlatFileCacheBacking createBacking"
  },
  {
    "method_id": "M3308",
    "name": "createBacking",
    "return_type": "FlatFileCacheBacking",
    "signature": "createBacking(File cacheDir)",
    "file_id": "F77",
    "start_line": 51,
    "text_preview": "    super(cacheDir);\\n    }\\n\\n    public static final FlatFileCacheBacking createBacking (File cacheDir) {\\n        return createBacking(cacheDir, defaultCreator);\\n    }\\n\\n    @Override\\n    protected Map<String, byte[]> readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir) {\\n        return readClassBytes(indexMap"
  },
  {
    "method_id": "M3309",
    "name": "readClassBytes",
    "return_type": "byte[]>",
    "signature": "readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir)",
    "file_id": "F77",
    "start_line": 55,
    "text_preview": "heDir) {\\n        return createBacking(cacheDir, defaultCreator);\\n    }\\n\\n    @Override\\n    protected Map<String, byte[]> readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir) {\\n        return readClassBytes(indexMap, cacheDir.listFiles());\\n    }\\n\\n    protected Map<String, byte[]> readClassBytes (Map<String,Ind"
  },
  {
    "method_id": "M3310",
    "name": "readClassBytes",
    "return_type": "byte[]>",
    "signature": "readClassBytes(Map<String,IndexEntry> indexMap, File[] files)",
    "file_id": "F77",
    "start_line": 55,
    "text_preview": "heDir) {\\n        return createBacking(cacheDir, defaultCreator);\\n    }\\n\\n    @Override\\n    protected Map<String, byte[]> readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir) {\\n        return readClassBytes(indexMap, cacheDir.listFiles());\\n    }\\n\\n    protected Map<String, byte[]> readClassBytes (Map<String,Ind"
  },
  {
    "method_id": "M3311",
    "name": "for",
    "return_type": "",
    "signature": "for(File file : files)",
    "file_id": "F77",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3312",
    "name": "if",
    "return_type": "",
    "signature": "if(crc != entry.crcWeaved)",
    "file_id": "F77",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3313",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException  e)",
    "file_id": "F77",
    "start_line": 95,
    "text_preview": "     logger.debug(\"readClassBytes(\" + key + \") cached from \" + file.getAbsolutePath());\\n                }\\n            } catch(IOException  e) {\\n                if ((logger != null) && logger.isTraceEnabled()) {\\n                    logger.error(\"Failed (\" + e.getClass().getSimpleName() + \")\"\\n                            "
  },
  {
    "method_id": "M3314",
    "name": "resolveIndexMapEntry",
    "return_type": "IndexEntry",
    "signature": "resolveIndexMapEntry(File cacheDir, IndexEntry ie)",
    "file_id": "F77",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3315",
    "name": "writeClassBytes",
    "return_type": "void",
    "signature": "writeClassBytes(String key, byte[] bytes)",
    "file_id": "F77",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3316",
    "name": "removeClassBytes",
    "return_type": "void",
    "signature": "removeClassBytes(String key)",
    "file_id": "F77",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3317",
    "name": "GeneratedCachedClassHandler",
    "return_type": "",
    "signature": "GeneratedCachedClassHandler(WeavedClassCache cache, GeneratedClassHandler nextHandler)",
    "file_id": "F78",
    "start_line": 26,
    "text_preview": "ndler {\\n\tprivate final WeavedClassCache cache;\\n\tprivate final GeneratedClassHandler nextGeneratedClassHandler;\\n\\n\tpublic GeneratedCachedClassHandler(WeavedClassCache cache, GeneratedClassHandler nextHandler) {\\n\t\tthis.cache = cache;\\n\t\tthis.nextGeneratedClassHandler = nextHandler;\\n\t}\\n\\n\tpublic void acceptClass (String name"
  },
  {
    "method_id": "M3318",
    "name": "acceptClass",
    "return_type": "void",
    "signature": "acceptClass(String name, byte[] originalBytes, byte[] wovenBytes)",
    "file_id": "F78",
    "start_line": 36,
    "text_preview": ");\\n\t\tcache.put(ref, originalBytes, wovenBytes);\\n\t\tif (nextGeneratedClassHandler != null) {\\n\t\t\tnextGeneratedClassHandler.acceptClass(name, originalBytes, wovenBytes);\\n\t\t}\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3319",
    "name": "if",
    "return_type": "",
    "signature": "if(nextGeneratedClassHandler != null)",
    "file_id": "F78",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3320",
    "name": "SimpleCache",
    "return_type": "",
    "signature": "SimpleCache(String folder, boolean enabled)",
    "file_id": "F79",
    "start_line": 54,
    "text_preview": "ate static final String GENERATED_CACHE_SEPARATOR = \";\";\\n\\n\tpublic static final String IMPL_NAME = \"shared\";\\n\\n\tprotected SimpleCache(String folder, boolean enabled) {\\n\t\tthis.enabled = enabled;\\n\\n\t\tcacheMap = Collections.synchronizedMap(StoreableCachingMap.init(folder));\\n\\n\t\tif (enabled) {\\n\t\t\tString generatedCachePath = fo"
  },
  {
    "method_id": "M3321",
    "name": "if",
    "return_type": "",
    "signature": "if(enabled)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3322",
    "name": "getAndInitialize",
    "return_type": "Optional<byte[]>",
    "signature": "getAndInitialize(String classname,\n\t\tbyte[] bytes,\n\t\tClassLoader loader,\n\t\tProtectionDomain protectionDomain)",
    "file_id": "F79",
    "start_line": 82,
    "text_preview": "s bytes are identical to the original bytes.\\n\t */\\n\t@SuppressWarnings(\"OptionalAssignedToNull\")\\n\tpublic Optional<byte[]> getAndInitialize(\\n\t\tString classname,\\n\t\tbyte[] bytes,\\n\t\tClassLoader loader,\\n\t\tProtectionDomain protectionDomain\\n\t)\\n\t{\\n\t\tif (!enabled) {\\n\t\t\t// Cache disabled\\n\t\t\treturn null;\\n\t\t}\\n\t\tbyte[] res = get(clas"
  },
  {
    "method_id": "M3323",
    "name": "if",
    "return_type": "",
    "signature": "if(!enabled)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3324",
    "name": "if",
    "return_type": "",
    "signature": "if(res != null)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3325",
    "name": "get",
    "return_type": "byte[]",
    "signature": "get(String classname, byte[] bytes)",
    "file_id": "F79",
    "start_line": 93,
    "text_preview": "er,\\n\t\tProtectionDomain protectionDomain\\n\t)\\n\t{\\n\t\tif (!enabled) {\\n\t\t\t// Cache disabled\\n\t\t\treturn null;\\n\t\t}\\n\t\tbyte[] res = get(classname, bytes);\\n\t\tif (Arrays.equals(SAME_BYTES, res)) {\\n\t\t\t// Cache hit: unwoven class\\n\t\t\treturn Optional.empty();\\n\t\t}\\n\t\tif (res != null) {\\n\t\t\t// Cache hit: woven class\\n\t\t\tinitializeClass(class"
  },
  {
    "method_id": "M3326",
    "name": "put",
    "return_type": "void",
    "signature": "put(String classname, byte[] origbytes, byte[] wovenbytes)",
    "file_id": "F79",
    "start_line": 112,
    "text_preview": "g classname, byte[] bytes) {\\n\t\tString key = generateKey(classname, bytes);\\n\t\treturn cacheMap.get(key);\\n\t}\\n\\n\tpublic void put(String classname, byte[] origbytes, byte[] wovenbytes) {\\n\t\tif (!enabled) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tString key = generateKey(classname, origbytes);\\n\\n\t\tif (wovenbytes == null || Arrays.equals(origbytes, w"
  },
  {
    "method_id": "M3327",
    "name": "if",
    "return_type": "",
    "signature": "if(!enabled)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3328",
    "name": "generateKey",
    "return_type": "String",
    "signature": "generateKey(String classname, byte[] bytes)",
    "file_id": "F79",
    "start_line": 108,
    "text_preview": "al.of(res);\\n\t\t}\\n\t\t// Cache miss\\n\t\treturn null;\\n\t}\\n\\n\tprivate byte[] get(String classname, byte[] bytes) {\\n\t\tString key = generateKey(classname, bytes);\\n\t\treturn cacheMap.get(key);\\n\t}\\n\\n\tpublic void put(String classname, byte[] origbytes, byte[] wovenbytes) {\\n\t\tif (!enabled) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tString key = generateKey(cl"
  },
  {
    "method_id": "M3329",
    "name": "initTrace",
    "return_type": "void",
    "signature": "initTrace()",
    "file_id": "F79",
    "start_line": 152,
    "text_preview": "int DEF_STORING_TIMER = 60000; //ms\\n\t\tprivate final int storingTimer;\\n\\n\t\tprivate transient Trace trace;\\n\\n\t\tprivate void initTrace() {\\n\t\t\ttrace = TraceFactory.getTraceFactory().getTrace(StoreableCachingMap.class);\\n\t\t}\\n\\n\t\tprivate StoreableCachingMap(String folder, int storingTimer) {\\n\t\t\tthis.folder = folder;\\n\t\t\tinitTrace"
  },
  {
    "method_id": "M3330",
    "name": "StoreableCachingMap",
    "return_type": "",
    "signature": "StoreableCachingMap(String folder, int storingTimer)",
    "file_id": "F79",
    "start_line": 156,
    "text_preview": "rivate void initTrace() {\\n\t\t\ttrace = TraceFactory.getTraceFactory().getTrace(StoreableCachingMap.class);\\n\t\t}\\n\\n\t\tprivate StoreableCachingMap(String folder, int storingTimer) {\\n\t\t\tthis.folder = folder;\\n\t\t\tinitTrace();\\n\t\t\tthis.storingTimer = storingTimer;\\n\t\t}\\n\\n\t\tpublic static StoreableCachingMap init(String folder) {\\n\t\t\tr"
  },
  {
    "method_id": "M3331",
    "name": "init",
    "return_type": "StoreableCachingMap",
    "signature": "init(String folder)",
    "file_id": "F79",
    "start_line": 57,
    "text_preview": "ring folder, boolean enabled) {\\n\t\tthis.enabled = enabled;\\n\\n\t\tcacheMap = Collections.synchronizedMap(StoreableCachingMap.init(folder));\\n\\n\t\tif (enabled) {\\n\t\t\tString generatedCachePath = folder + File.separator + GENERATED_CACHE_SUBFOLDER;\\n\t\t\tFile f = new File(generatedCachePath);\\n\t\t\tif (!f.exists()) {\\n\t\t\t\tf.mkdir();\\n\t\t\t}"
  },
  {
    "method_id": "M3332",
    "name": "init",
    "return_type": "StoreableCachingMap",
    "signature": "init(String folder, int storingTimer)",
    "file_id": "F79",
    "start_line": 57,
    "text_preview": "ring folder, boolean enabled) {\\n\t\tthis.enabled = enabled;\\n\\n\t\tcacheMap = Collections.synchronizedMap(StoreableCachingMap.init(folder));\\n\\n\t\tif (enabled) {\\n\t\t\tString generatedCachePath = folder + File.separator + GENERATED_CACHE_SUBFOLDER;\\n\t\t\tFile f = new File(generatedCachePath);\\n\t\t\tif (!f.exists()) {\\n\t\t\t\tf.mkdir();\\n\t\t\t}"
  },
  {
    "method_id": "M3333",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3334",
    "name": "get",
    "return_type": "Object",
    "signature": "get(Object obj)",
    "file_id": "F79",
    "start_line": 93,
    "text_preview": "er,\\n\t\tProtectionDomain protectionDomain\\n\t)\\n\t{\\n\t\tif (!enabled) {\\n\t\t\t// Cache disabled\\n\t\t\treturn null;\\n\t\t}\\n\t\tbyte[] res = get(classname, bytes);\\n\t\tif (Arrays.equals(SAME_BYTES, res)) {\\n\t\t\t// Cache hit: unwoven class\\n\t\t\treturn Optional.empty();\\n\t\t}\\n\t\tif (res != null) {\\n\t\t\t// Cache hit: woven class\\n\t\t\tinitializeClass(class"
  },
  {
    "method_id": "M3335",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3336",
    "name": "put",
    "return_type": "Object",
    "signature": "put(Object key, Object value)",
    "file_id": "F79",
    "start_line": 112,
    "text_preview": "g classname, byte[] bytes) {\\n\t\tString key = generateKey(classname, bytes);\\n\t\treturn cacheMap.get(key);\\n\t}\\n\\n\tpublic void put(String classname, byte[] origbytes, byte[] wovenbytes) {\\n\t\tif (!enabled) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tString key = generateKey(classname, origbytes);\\n\\n\t\tif (wovenbytes == null || Arrays.equals(origbytes, w"
  },
  {
    "method_id": "M3337",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3338",
    "name": "storeMap",
    "return_type": "void",
    "signature": "storeMap()",
    "file_id": "F79",
    "start_line": 219,
    "text_preview": "\t\t\t\t}\\n\t\t\t\telse {\\n\t\t\t\t\tpath = writeToPath((String) key, valueBytes);\\n\t\t\t\t}\\n\t\t\t\tObject result = super.put(key, path);\\n\t\t\t\tstoreMap();\\n\t\t\t\treturn result;\\n\t\t\t}\\n\t\t\tcatch (IOException e) {\\n\t\t\t\ttrace.error(\"Error inserting in cache: key:\" + key + \"; value:\" + value.toString(), e);\\n\t\t\t\tDump.dumpWithException(e);\\n\t\t\t}\\n\t\t\treturn"
  },
  {
    "method_id": "M3339",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3340",
    "name": "readFromPath",
    "return_type": "byte[]",
    "signature": "readFromPath(String fullPath)",
    "file_id": "F79",
    "start_line": 193,
    "text_preview": " path = (String) super.get(obj);\\n\t\t\t\t\tif (path.equals(SAME_BYTES_STRING)) {\\n\t\t\t\t\t\treturn SAME_BYTES;\\n\t\t\t\t\t}\\n\t\t\t\t\treturn readFromPath(path);\\n\t\t\t\t}\\n\t\t\t\telse {\\n\t\t\t\t\treturn null;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\tcatch (IOException e) {\\n\t\t\t\ttrace.error(\"Error reading key:\" + obj.toString(), e);\\n\t\t\t\tDump.dumpWithException(e);\\n\t\t\t}\\n\t\t\treturn nu"
  },
  {
    "method_id": "M3341",
    "name": "catch",
    "return_type": "",
    "signature": "catch(FileNotFoundException e)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3342",
    "name": "writeToPath",
    "return_type": "String",
    "signature": "writeToPath(String key, byte[] bytes)",
    "file_id": "F79",
    "start_line": 216,
    "text_preview": "]) value;\\n\\n\t\t\t\tif (Arrays.equals(valueBytes, SAME_BYTES)) {\\n\t\t\t\t\tpath = SAME_BYTES_STRING;\\n\t\t\t\t}\\n\t\t\t\telse {\\n\t\t\t\t\tpath = writeToPath((String) key, valueBytes);\\n\t\t\t\t}\\n\t\t\t\tObject result = super.put(key, path);\\n\t\t\t\tstoreMap();\\n\t\t\t\treturn result;\\n\t\t\t}\\n\t\t\tcatch (IOException e) {\\n\t\t\t\ttrace.error(\"Error inserting in cache: key"
  },
  {
    "method_id": "M3343",
    "name": "initializeClass",
    "return_type": "void",
    "signature": "initializeClass(String className, byte[] bytes,\n\t\tClassLoader loader, ProtectionDomain protectionDomain)",
    "file_id": "F79",
    "start_line": 100,
    "text_preview": ") {\\n\t\t\t// Cache hit: unwoven class\\n\t\t\treturn Optional.empty();\\n\t\t}\\n\t\tif (res != null) {\\n\t\t\t// Cache hit: woven class\\n\t\t\tinitializeClass(classname, res, loader, protectionDomain);\\n\t\t\treturn Optional.of(res);\\n\t\t}\\n\t\t// Cache miss\\n\t\treturn null;\\n\t}\\n\\n\tprivate byte[] get(String classname, byte[] bytes) {\\n\t\tString key = gener"
  },
  {
    "method_id": "M3344",
    "name": "if",
    "return_type": "",
    "signature": "if(generatedClassesNames == null)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3345",
    "name": "for",
    "return_type": "",
    "signature": "for(String generatedClassName : generatedClassesNames)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3346",
    "name": "if",
    "return_type": "",
    "signature": "if(protectionDomain == null)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3347",
    "name": "getGeneratedClassesNames",
    "return_type": "String[]",
    "signature": "getGeneratedClassesNames(String className, byte[] bytes)",
    "file_id": "F79",
    "start_line": 284,
    "text_preview": "assName, byte[] bytes,\\n\t\tClassLoader loader, ProtectionDomain protectionDomain\\n\t)\\n\t{\\n\t\tString[] generatedClassesNames = getGeneratedClassesNames(className, bytes);\\n\t\tif (generatedClassesNames == null) {\\n\t\t\treturn;\\n\t\t}\\n\t\tfor (String generatedClassName : generatedClassesNames) {\\n\t\t\tbyte[] generatedBytes = get(generatedCl"
  },
  {
    "method_id": "M3348",
    "name": "if",
    "return_type": "",
    "signature": "if(readBytes == null)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3349",
    "name": "addGeneratedClassesNames",
    "return_type": "void",
    "signature": "addGeneratedClassesNames(String parentClassName, byte[] parentBytes, String generatedClassName)",
    "file_id": "F79",
    "start_line": 310,
    "text_preview": "\t\t}\\n\t\tString readString = new String(readBytes);\\n\t\treturn readString.split(GENERATED_CACHE_SEPARATOR);\\n\t}\\n\\n\tpublic void addGeneratedClassesNames(String parentClassName, byte[] parentBytes, String generatedClassName) {\\n\t\tif (!enabled) {\\n\t\t\treturn;\\n\t\t}\\n\t\tString key = generateKey(parentClassName, parentBytes);\\n\\n\t\tbyte[] s"
  },
  {
    "method_id": "M3350",
    "name": "if",
    "return_type": "",
    "signature": "if(!enabled)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3351",
    "name": "if",
    "return_type": "",
    "signature": "if(storedBytes == null)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3352",
    "name": "defineClass",
    "return_type": "void",
    "signature": "defineClass(ClassLoader loader, String name, byte[] bytes)",
    "file_id": "F79",
    "start_line": 291,
    "text_preview": "eratedClassesNames) {\\n\t\t\tbyte[] generatedBytes = get(generatedClassName, bytes);\\n\t\t\tif (protectionDomain == null) {\\n\t\t\t\tdefineClass(loader, generatedClassName, generatedBytes);\\n\t\t\t}\\n\t\t\telse {\\n\t\t\t\tdefineClass(loader, generatedClassName, generatedBytes, protectionDomain);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate String[] getGeneratedClasse"
  },
  {
    "method_id": "M3353",
    "name": "if",
    "return_type": "",
    "signature": "if(defineClassMethod == null)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3354",
    "name": "catch",
    "return_type": "",
    "signature": "catch(InvocationTargetException e)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3355",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3356",
    "name": "defineClass",
    "return_type": "void",
    "signature": "defineClass(ClassLoader loader, String name, byte[] bytes, ProtectionDomain protectionDomain)",
    "file_id": "F79",
    "start_line": 291,
    "text_preview": "eratedClassesNames) {\\n\t\t\tbyte[] generatedBytes = get(generatedClassName, bytes);\\n\t\t\tif (protectionDomain == null) {\\n\t\t\t\tdefineClass(loader, generatedClassName, generatedBytes);\\n\t\t\t}\\n\t\t\telse {\\n\t\t\t\tdefineClass(loader, generatedClassName, generatedBytes, protectionDomain);\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tprivate String[] getGeneratedClasse"
  },
  {
    "method_id": "M3357",
    "name": "if",
    "return_type": "",
    "signature": "if(defineClassWithProtectionDomainMethod == null)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3358",
    "name": "catch",
    "return_type": "",
    "signature": "catch(InvocationTargetException e)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3359",
    "name": "catch",
    "return_type": "",
    "signature": "catch(NullPointerException e)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3360",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F79",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3361",
    "name": "createSimpleCache",
    "return_type": "SimpleCache",
    "signature": "createSimpleCache()",
    "file_id": "F80",
    "start_line": 34,
    "text_preview": "boolean determinedIfEnabled = false;\\n\tprivate static SimpleCache lacache=null;\\n\\n\tpublic static synchronized SimpleCache createSimpleCache(){\\n\t\tif (lacache==null){\\n\t\t \tif (!determinedIfEnabled) {\\n\t\t \t\tdetermineIfEnabled();\\n\t\t \t}\\n\\n\t\t\tif (!enabled) {\\n\t\t\t\treturn null;\\n\t\t\t}\\n\\n\t\t\ttry {\\n\t\t\t\tpath = System.getProperty(CACHE_DIR)"
  },
  {
    "method_id": "M3362",
    "name": "if",
    "return_type": "",
    "signature": "if(lacache==null)",
    "file_id": "F80",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3363",
    "name": "if",
    "return_type": "",
    "signature": "if(!determinedIfEnabled)",
    "file_id": "F80",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3364",
    "name": "if",
    "return_type": "",
    "signature": "if(!enabled)",
    "file_id": "F80",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3365",
    "name": "if",
    "return_type": "",
    "signature": "if(path == null)",
    "file_id": "F80",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3366",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F80",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3367",
    "name": "determineIfEnabled",
    "return_type": "void",
    "signature": "determineIfEnabled()",
    "file_id": "F80",
    "start_line": 37,
    "text_preview": "\tpublic static synchronized SimpleCache createSimpleCache(){\\n\t\tif (lacache==null){\\n\t\t \tif (!determinedIfEnabled) {\\n\t\t \t\tdetermineIfEnabled();\\n\t\t \t}\\n\\n\t\t\tif (!enabled) {\\n\t\t\t\treturn null;\\n\t\t\t}\\n\\n\t\t\ttry {\\n\t\t\t\tpath = System.getProperty(CACHE_DIR);\\n\t\t\t\tif (path == null){\\n\t\t\t\t\tpath = PATH_DEFAULT;\\n\t\t\t\t}\\n\\n\t\t\t} catch (Throwable "
  },
  {
    "method_id": "M3368",
    "name": "if",
    "return_type": "",
    "signature": "if(property == null)",
    "file_id": "F80",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3369",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F80",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3370",
    "name": "isEnabled",
    "return_type": "boolean",
    "signature": "isEnabled()",
    "file_id": "F80",
    "start_line": 96,
    "text_preview": "e first will set determinedIfEnabled but only after\\n\t// it has set 'enabled' to the right value.\\n\tpublic static boolean isEnabled() {\\n\t\tif (!determinedIfEnabled) {\\n\t\t\tdetermineIfEnabled();\\n\t\t}\\n\t\treturn enabled;\\n\t}\\n\\n\\n}\\n"
  },
  {
    "method_id": "M3371",
    "name": "if",
    "return_type": "",
    "signature": "if(!determinedIfEnabled)",
    "file_id": "F80",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3372",
    "name": "WeavedClassCache",
    "return_type": "",
    "signature": "WeavedClassCache(GeneratedClassHandler existingClassHandler,\n\t\t\t\t\t\t\t   IMessageHandler messageHandler,\n\t\t\t\t\t\t\t   String name,\n\t\t\t\t\t\t\t   CacheBacking backing,\n\t\t\t\t\t\t\t   CacheKeyResolver resolver)",
    "file_id": "F81",
    "start_line": 88,
    "text_preview": "rivate final String name;\\n\\n\tprivate static final List<WeavedClassCache> cacheRegistry = new LinkedList<>();\\n\\n\tprotected WeavedClassCache(GeneratedClassHandler existingClassHandler,\\n\t\t\t\t\t\t\t   IMessageHandler messageHandler,\\n\t\t\t\t\t\t\t   String name,\\n\t\t\t\t\t\t\t   CacheBacking backing,\\n\t\t\t\t\t\t\t   CacheKeyResolver resolver) {\\n\t\tt"
  },
  {
    "method_id": "M3373",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(cacheRegistry)",
    "file_id": "F81",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3374",
    "name": "createCache",
    "return_type": "WeavedClassCache",
    "signature": "createCache(ClassLoader loader, List<String> aspects, GeneratedClassHandler existingClassHandler, IMessageHandler messageHandler)",
    "file_id": "F81",
    "start_line": 114,
    "text_preview": "param messageHandler\t   the existing messageHandler used by the weaver\\n\t * @return\\n\t */\\n\tpublic static WeavedClassCache createCache(ClassLoader loader, List<String> aspects, GeneratedClassHandler existingClassHandler, IMessageHandler messageHandler) {\\n\t\tCacheKeyResolver resolver = DEFAULT_FACTORY.createResolver();\\n\t\tSt"
  },
  {
    "method_id": "M3375",
    "name": "if",
    "return_type": "",
    "signature": "if(name == null)",
    "file_id": "F81",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3376",
    "name": "if",
    "return_type": "",
    "signature": "if(backing != null)",
    "file_id": "F81",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3377",
    "name": "getName",
    "return_type": "String",
    "signature": "getName()",
    "file_id": "F81",
    "start_line": 127,
    "text_preview": " WeavedClassCache(existingClassHandler, messageHandler, name, backing, resolver);\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tpublic String getName() {\\n\t\treturn name;\\n\t}\\n\\n\t/**\\n\t * The Cache and be extended in two ways, through a specialized CacheKeyResolver and\\n\t * a specialized CacheBacking. The default factory used to create these class"
  },
  {
    "method_id": "M3378",
    "name": "setDefaultCacheFactory",
    "return_type": "void",
    "signature": "setDefaultCacheFactory(CacheFactory factory)",
    "file_id": "F81",
    "start_line": 139,
    "text_preview": " this method must be\\n\t * called before the weaver is first initialized.\\n\t *\\n\t * @param factory\\n\t */\\n\tpublic static void setDefaultCacheFactory(CacheFactory factory) {\\n\t\tDEFAULT_FACTORY = factory;\\n\t}\\n\\n\t/**\\n\t * Created a key for a generated class\\n\t *\\n\t * @param className ClassName, e.g. \"com.foo.Bar\"\\n\t * @return the cach"
  },
  {
    "method_id": "M3379",
    "name": "createGeneratedCacheKey",
    "return_type": "CachedClassReference",
    "signature": "createGeneratedCacheKey(String className)",
    "file_id": "F81",
    "start_line": 149,
    "text_preview": "g. \"com.foo.Bar\"\\n\t * @return the cache key, or null if no caching should be performed\\n\t */\\n\tpublic CachedClassReference createGeneratedCacheKey(String className) {\\n\t\treturn resolver.generatedKey(className);\\n\t}\\n\\n\t/**\\n\t * Create a key for a normal weaved class\\n\t *\\n\t * @param className\t ClassName, e.g. \"com.foo.Bar\"\\n\t * @"
  },
  {
    "method_id": "M3380",
    "name": "createCacheKey",
    "return_type": "CachedClassReference",
    "signature": "createCacheKey(String className, byte[] originalBytes)",
    "file_id": "F81",
    "start_line": 160,
    "text_preview": "array of the class\\n\t * @return a cache key, or null if no caching should be performed\\n\t */\\n\tpublic CachedClassReference createCacheKey(String className, byte[] originalBytes) {\\n\t\treturn resolver.weavedKey(className, originalBytes);\\n\t}\\n\\n\t/**\\n\t * Returns a generated class handler which wraps the handler this cache was in"
  },
  {
    "method_id": "M3381",
    "name": "getCachingClassHandler",
    "return_type": "GeneratedClassHandler",
    "signature": "getCachingClassHandler()",
    "file_id": "F81",
    "start_line": 169,
    "text_preview": "andler should be used to make sure that generated classes are added\\n\t * to the cache\\n\t */\\n\tpublic GeneratedClassHandler getCachingClassHandler() {\\n\t\treturn cachingClassHandler;\\n\t}\\n\\n\t/**\\n\t * Has caching been enabled through the System property,\\n\t * WEAVED_CLASS_CACHE_ENABLED\\n\t *\\n\t * @return true if caching is enabled\\n\t "
  },
  {
    "method_id": "M3382",
    "name": "isEnabled",
    "return_type": "boolean",
    "signature": "isEnabled()",
    "file_id": "F81",
    "start_line": 179,
    "text_preview": " System property,\\n\t * WEAVED_CLASS_CACHE_ENABLED\\n\t *\\n\t * @return true if caching is enabled\\n\t */\\n\tpublic static boolean isEnabled() {\\n\t\tString enabled = System.getProperty(WEAVED_CLASS_CACHE_ENABLED);\\n\t\tString impl = System.getProperty(CACHE_IMPL);\\n\t\treturn (enabled != null && (impl == null || !SimpleCache.IMPL_NAME.eq"
  },
  {
    "method_id": "M3383",
    "name": "put",
    "return_type": "void",
    "signature": "put(CachedClassReference ref, byte[] classBytes, byte[] weavedBytes)",
    "file_id": "F81",
    "start_line": 192,
    "text_preview": "gh createCacheKey\\n\t * @param classBytes pre-weaving class bytes\\n\t * @param weavedBytes bytes to cache\\n\t */\\n\tpublic void put(CachedClassReference ref, byte[] classBytes, byte[] weavedBytes) {\\n\t\tCachedClassEntry.EntryType type = CachedClassEntry.EntryType.WEAVED;\\n\t\tif (ref.getKey().matches(resolver.getGeneratedRegex())) "
  },
  {
    "method_id": "M3384",
    "name": "get",
    "return_type": "CachedClassEntry",
    "signature": "get(CachedClassReference ref, byte[] classBytes)",
    "file_id": "F81",
    "start_line": 209,
    "text_preview": "hanged original class\\n\t * @return the CacheEntry, or null if no entry exists in the cache\\n\t */\\n\tpublic CachedClassEntry get(CachedClassReference ref, byte[] classBytes) {\\n\t\tCachedClassEntry entry = backing.get(ref, classBytes);\\n\t\tif (entry == null) {\\n\t\t\tstats.miss();\\n\t\t} else {\\n\t\t\tstats.hit();\\n\t\t\tif (entry.isGenerated("
  },
  {
    "method_id": "M3385",
    "name": "if",
    "return_type": "",
    "signature": "if(entry == null)",
    "file_id": "F81",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3386",
    "name": "ignore",
    "return_type": "void",
    "signature": "ignore(CachedClassReference ref, byte[] classBytes)",
    "file_id": "F81",
    "start_line": 229,
    "text_preview": "hould be used.\\n\t *\\n\t * @param ref The cache reference\\n\t * @param classBytes The un-weaved class bytes\\n\t */\\n\tpublic void ignore(CachedClassReference ref, byte[] classBytes) {\\n\t\tstats.putIgnored();\\n\t\tbacking.put(new CachedClassEntry(ref, ZERO_BYTES, CachedClassEntry.EntryType.IGNORED), classBytes);\\n\t}\\n\\n\t/**\\n\t * Invalidat"
  },
  {
    "method_id": "M3387",
    "name": "remove",
    "return_type": "void",
    "signature": "remove(CachedClassReference ref)",
    "file_id": "F81",
    "start_line": 239,
    "text_preview": "dClassEntry.EntryType.IGNORED), classBytes);\\n\t}\\n\\n\t/**\\n\t * Invalidate a cache entry\\n\t *\\n\t * @param ref\\n\t */\\n\tpublic void remove(CachedClassReference ref) {\\n\t\tbacking.remove(ref);\\n\t}\\n\\n\t/**\\n\t * Clear the entire cache\\n\t */\\n\tpublic void clear() {\\n\t\tbacking.clear();\\n\t}\\n\\n\t/**\\n\t * Get the statistics associated with this cache,"
  },
  {
    "method_id": "M3388",
    "name": "clear",
    "return_type": "void",
    "signature": "clear()",
    "file_id": "F81",
    "start_line": 246,
    "text_preview": "ic void remove(CachedClassReference ref) {\\n\t\tbacking.remove(ref);\\n\t}\\n\\n\t/**\\n\t * Clear the entire cache\\n\t */\\n\tpublic void clear() {\\n\t\tbacking.clear();\\n\t}\\n\\n\t/**\\n\t * Get the statistics associated with this cache, or\\n\t * null if statistics have not been enabled.\\n\t *\\n\t * @return\\n\t */\\n\tpublic CacheStatistics getStats() {\\n\t\tre"
  },
  {
    "method_id": "M3389",
    "name": "getStats",
    "return_type": "CacheStatistics",
    "signature": "getStats()",
    "file_id": "F81",
    "start_line": 256,
    "text_preview": "sociated with this cache, or\\n\t * null if statistics have not been enabled.\\n\t *\\n\t * @return\\n\t */\\n\tpublic CacheStatistics getStats() {\\n\t\treturn stats;\\n\t}\\n\\n\t/**\\n\t * Return a list of all WeavedClassCaches which have been initialized\\n\t *\\n\t * @return\\n\t */\\n\tpublic static List<WeavedClassCache> getCaches() {\\n\t\tsynchronized (ca"
  },
  {
    "method_id": "M3390",
    "name": "getCaches",
    "return_type": "List<WeavedClassCache>",
    "signature": "getCaches()",
    "file_id": "F81",
    "start_line": 265,
    "text_preview": " a list of all WeavedClassCaches which have been initialized\\n\t *\\n\t * @return\\n\t */\\n\tpublic static List<WeavedClassCache> getCaches() {\\n\t\tsynchronized (cacheRegistry) {\\n\t\t\treturn new LinkedList<>(cacheRegistry);\\n\t\t}\\n\t}\\n\\n\tprotected void error(String message, Throwable th) {\\n\t\tmessageHandler.handleMessage(new Message(messa"
  },
  {
    "method_id": "M3391",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(cacheRegistry)",
    "file_id": "F81",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3392",
    "name": "error",
    "return_type": "void",
    "signature": "error(String message, Throwable th)",
    "file_id": "F81",
    "start_line": 271,
    "text_preview": "ache> getCaches() {\\n\t\tsynchronized (cacheRegistry) {\\n\t\t\treturn new LinkedList<>(cacheRegistry);\\n\t\t}\\n\t}\\n\\n\tprotected void error(String message, Throwable th) {\\n\t\tmessageHandler.handleMessage(new Message(message, IMessage.ERROR, th, null));\\n\t}\\n\\n\tprotected void error(String message) {\\n\t\tMessageUtil.error(messageHandler, me"
  },
  {
    "method_id": "M3393",
    "name": "error",
    "return_type": "void",
    "signature": "error(String message)",
    "file_id": "F81",
    "start_line": 271,
    "text_preview": "ache> getCaches() {\\n\t\tsynchronized (cacheRegistry) {\\n\t\t\treturn new LinkedList<>(cacheRegistry);\\n\t\t}\\n\t}\\n\\n\tprotected void error(String message, Throwable th) {\\n\t\tmessageHandler.handleMessage(new Message(message, IMessage.ERROR, th, null));\\n\t}\\n\\n\tprotected void error(String message) {\\n\t\tMessageUtil.error(messageHandler, me"
  },
  {
    "method_id": "M3394",
    "name": "info",
    "return_type": "void",
    "signature": "info(String message)",
    "file_id": "F81",
    "start_line": 279,
    "text_preview": ", null));\\n\t}\\n\\n\tprotected void error(String message) {\\n\t\tMessageUtil.error(messageHandler, message);\\n\t}\\n\\n\tprotected void info(String message) {\\n\t\tMessageUtil.info(message);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3395",
    "name": "create",
    "return_type": "ZippedFileCacheBacking",
    "signature": "create(File cacheDir)",
    "file_id": "F82",
    "start_line": 49,
    "text_preview": "      new AsynchronousFileCacheBackingCreator<ZippedFileCacheBacking>() {\\n                public ZippedFileCacheBacking create(File cacheDir) {\\n                    return new ZippedFileCacheBacking(cacheDir);\\n                }\\n        };\\n\\n    private final File  zipFile;\\n    public ZippedFileCacheBacking(File cacheDir)"
  },
  {
    "method_id": "M3396",
    "name": "ZippedFileCacheBacking",
    "return_type": "",
    "signature": "ZippedFileCacheBacking(File cacheDir)",
    "file_id": "F82",
    "start_line": 50,
    "text_preview": "eCacheBacking>() {\\n                public ZippedFileCacheBacking create(File cacheDir) {\\n                    return new ZippedFileCacheBacking(cacheDir);\\n                }\\n        };\\n\\n    private final File  zipFile;\\n    public ZippedFileCacheBacking(File cacheDir) {\\n        super(cacheDir);\\n        zipFile = new File("
  },
  {
    "method_id": "M3397",
    "name": "getZipFile",
    "return_type": "File",
    "signature": "getZipFile()",
    "file_id": "F82",
    "start_line": 70,
    "text_preview": "e\\n    protected void writeClassBytes(String key, byte[] bytes) throws Exception {\\n        File                  outFile=getZipFile();\\n        Map<String,byte[]>    entriesMap;\\n        try {\\n            entriesMap = readZipClassBytes(outFile);\\n        } catch(Exception e) {\\n            if ((logger != null) && logger.isT"
  },
  {
    "method_id": "M3398",
    "name": "createBacking",
    "return_type": "ZippedFileCacheBacking",
    "signature": "createBacking(File cacheDir)",
    "file_id": "F82",
    "start_line": 65,
    "text_preview": "   return zipFile;\\n    }\\n\\n    public static final ZippedFileCacheBacking createBacking (File cacheDir) {\\n        return createBacking(cacheDir, defaultCreator);\\n    }\\n\\n    @Override\\n    protected void writeClassBytes(String key, byte[] bytes) throws Exception {\\n        File                  outFile=getZipFile();\\n      "
  },
  {
    "method_id": "M3399",
    "name": "writeClassBytes",
    "return_type": "void",
    "signature": "writeClassBytes(String key, byte[] bytes)",
    "file_id": "F82",
    "start_line": 69,
    "text_preview": "cking (File cacheDir) {\\n        return createBacking(cacheDir, defaultCreator);\\n    }\\n\\n    @Override\\n    protected void writeClassBytes(String key, byte[] bytes) throws Exception {\\n        File                  outFile=getZipFile();\\n        Map<String,byte[]>    entriesMap;\\n        try {\\n            entriesMap = readZi"
  },
  {
    "method_id": "M3400",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F82",
    "start_line": 74,
    "text_preview": "\\n        Map<String,byte[]>    entriesMap;\\n        try {\\n            entriesMap = readZipClassBytes(outFile);\\n        } catch(Exception e) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.warn(\"writeClassBytes(\" + outFile + \")[\" + key + \"]\"\\n                          + \" failed (\" "
  },
  {
    "method_id": "M3401",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F82",
    "start_line": 74,
    "text_preview": "\\n        Map<String,byte[]>    entriesMap;\\n        try {\\n            entriesMap = readZipClassBytes(outFile);\\n        } catch(Exception e) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.warn(\"writeClassBytes(\" + outFile + \")[\" + key + \"]\"\\n                          + \" failed (\" "
  },
  {
    "method_id": "M3402",
    "name": "removeClassBytes",
    "return_type": "void",
    "signature": "removeClassBytes(String key)",
    "file_id": "F82",
    "start_line": 107,
    "text_preview": "     e);\\n            }\\n\\n            FileUtil.deleteContents(outFile);\\n        }\\n    }\\n\\n    @Override\\n    protected void removeClassBytes(String key) throws Exception {\\n        File                  outFile=getZipFile();\\n        Map<String,byte[]>    entriesMap;\\n        try {\\n            entriesMap = readZipClassBytes(o"
  },
  {
    "method_id": "M3403",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F82",
    "start_line": 74,
    "text_preview": "\\n        Map<String,byte[]>    entriesMap;\\n        try {\\n            entriesMap = readZipClassBytes(outFile);\\n        } catch(Exception e) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.warn(\"writeClassBytes(\" + outFile + \")[\" + key + \"]\"\\n                          + \" failed (\" "
  },
  {
    "method_id": "M3404",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F82",
    "start_line": 74,
    "text_preview": "\\n        Map<String,byte[]>    entriesMap;\\n        try {\\n            entriesMap = readZipClassBytes(outFile);\\n        } catch(Exception e) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.warn(\"writeClassBytes(\" + outFile + \")[\" + key + \"]\"\\n                          + \" failed (\" "
  },
  {
    "method_id": "M3405",
    "name": "readClassBytes",
    "return_type": "byte[]>",
    "signature": "readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir)",
    "file_id": "F82",
    "start_line": 145,
    "text_preview": "      }\\n\\n            FileUtil.deleteContents(outFile);\\n        }\\n    }\\n\\n    @Override\\n    protected Map<String, byte[]> readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir) {\\n        File                dataFile=new File(cacheDir, ZIP_FILE);\\n        Map<String,byte[]>  entriesMap;\\n        boolean            "
  },
  {
    "method_id": "M3406",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F82",
    "start_line": 74,
    "text_preview": "\\n        Map<String,byte[]>    entriesMap;\\n        try {\\n            entriesMap = readZipClassBytes(outFile);\\n        } catch(Exception e) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.warn(\"writeClassBytes(\" + outFile + \")[\" + key + \"]\"\\n                          + \" failed (\" "
  },
  {
    "method_id": "M3407",
    "name": "if",
    "return_type": "",
    "signature": "if(!okEntries)",
    "file_id": "F82",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3408",
    "name": "syncIndexEntries",
    "return_type": "Collection<String>",
    "signature": "syncIndexEntries(File dataFile, Map<String, IndexEntry> indexMap, Map<String,byte[]>  entriesMap)",
    "file_id": "F82",
    "start_line": 175,
    "text_preview": "taFile);\\n\\n            if (!entriesMap.isEmpty()) {\\n                entriesMap.clear();\\n            }\\n        }\\n\\n        syncIndexEntries(dataFile, indexMap, entriesMap);\\n\\n        return entriesMap;\\n    }\\n\\n    // remove all non-ignored entries that have no class bytes\\n    protected Collection<String> syncIndexEntries (F"
  },
  {
    "method_id": "M3409",
    "name": "if",
    "return_type": "",
    "signature": "if(indexEntry.ignored)",
    "file_id": "F82",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3410",
    "name": "if",
    "return_type": "",
    "signature": "if(toDelete == null)",
    "file_id": "F82",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3411",
    "name": "if",
    "return_type": "",
    "signature": "if(toDelete == null)",
    "file_id": "F82",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3412",
    "name": "for",
    "return_type": "",
    "signature": "for(String key : toDelete)",
    "file_id": "F82",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3413",
    "name": "syncClassBytesEntries",
    "return_type": "boolean",
    "signature": "syncClassBytesEntries(File dataFile, Map<String, IndexEntry> indexMap, Map<String,byte[]>  entriesMap)",
    "file_id": "F82",
    "start_line": 163,
    "text_preview": "    e);\\n            }\\n\\n            entriesMap = new TreeMap<>();\\n            okEntries = false;\\n        }\\n\\n        if (!syncClassBytesEntries(dataFile, indexMap, entriesMap)) {\\n            okEntries = false;\\n        }\\n\\n        if (!okEntries) {\\n            FileUtil.deleteContents(dataFile);\\n\\n            if (!entriesMap"
  },
  {
    "method_id": "M3414",
    "name": "if",
    "return_type": "",
    "signature": "if(crc != indexEntry.crcWeaved)",
    "file_id": "F82",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3415",
    "name": "resolveIndexMapEntry",
    "return_type": "IndexEntry",
    "signature": "resolveIndexMapEntry(File cacheDir, IndexEntry ie)",
    "file_id": "F82",
    "start_line": 249,
    "text_preview": "             continue;\\n            }\\n        }\\n\\n        return okEntries;\\n    }\\n\\n    @Override\\n    protected IndexEntry resolveIndexMapEntry(File cacheDir, IndexEntry ie) {\\n        if (cacheDir.exists()) {\\n            return ie;  // we will take care of non-existing index entries in the readClassBytes method\\n        } "
  },
  {
    "method_id": "M3416",
    "name": "readZipClassBytes",
    "return_type": "byte[]>",
    "signature": "readZipClassBytes(File file)",
    "file_id": "F82",
    "start_line": 73,
    "text_preview": "                 outFile=getZipFile();\\n        Map<String,byte[]>    entriesMap;\\n        try {\\n            entriesMap = readZipClassBytes(outFile);\\n        } catch(Exception e) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.warn(\"writeClassBytes(\" + outFile + \")[\" + key + \"]\"\\n  "
  },
  {
    "method_id": "M3417",
    "name": "if",
    "return_type": "",
    "signature": "if(prev != null)",
    "file_id": "F82",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3418",
    "name": "writeZipClassBytes",
    "return_type": "void",
    "signature": "writeZipClassBytes(File file, Map<String,byte[]> entriesMap)",
    "file_id": "F82",
    "start_line": 93,
    "text_preview": "singletonMap(key, bytes);\\n        } else {\\n            entriesMap.put(key, bytes);\\n        }\\n\\n        try {\\n            writeZipClassBytes(outFile, entriesMap);\\n        } catch(Exception e) {\\n            if ((logger != null) && logger.isTraceEnabled()) {\\n                logger.warn(\"writeClassBytes(\" + outFile + \")[\" +"
  },
  {
    "method_id": "M3419",
    "name": "Proxy1",
    "return_type": "",
    "signature": "Proxy1(InvocationHandler arg0)",
    "file_id": "F83",
    "start_line": 17,
    "text_preview": "onHandler;\\nimport java.lang.reflect.Proxy;\\n\\npublic class $Proxy1 extends Proxy implements MessageService {\\n\\n\tprotected $Proxy1(InvocationHandler arg0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic Object get1(Long t) {\\n\t\treturn null;\\n\t}\\n\\n\tpublic Object get2(Serializable s) {\\n\t\treturn null;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3420",
    "name": "get1",
    "return_type": "Object",
    "signature": "get1(Long t)",
    "file_id": "F83",
    "start_line": 21,
    "text_preview": "tends Proxy implements MessageService {\\n\\n\tprotected $Proxy1(InvocationHandler arg0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic Object get1(Long t) {\\n\t\treturn null;\\n\t}\\n\\n\tpublic Object get2(Serializable s) {\\n\t\treturn null;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3421",
    "name": "get2",
    "return_type": "Object",
    "signature": "get2(Serializable s)",
    "file_id": "F83",
    "start_line": 25,
    "text_preview": "ed $Proxy1(InvocationHandler arg0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic Object get1(Long t) {\\n\t\treturn null;\\n\t}\\n\\n\tpublic Object get2(Serializable s) {\\n\t\treturn null;\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3422",
    "name": "increment1ForAnonymousPointcut",
    "return_type": "void",
    "signature": "increment1ForAnonymousPointcut()",
    "file_id": "F84",
    "start_line": 27,
    "text_preview": "t\\npublic class CounterAspect {\\n\\n    int count;\\n\\n    @Before(\"execution(* set*(..)) && bean(testBean1)\")\\n    public void increment1ForAnonymousPointcut() {\\n        count++;\\n    }\\n\\n    @Pointcut(\"execution(* toString(..)) && bean(testBean1)\")\\n    public void testBean1toString() {\\n    }\\n\\n    @Pointcut(\"execution(* setAge("
  },
  {
    "method_id": "M3423",
    "name": "testBean1toString",
    "return_type": "void",
    "signature": "testBean1toString()",
    "file_id": "F84",
    "start_line": 32,
    "text_preview": "ymousPointcut() {\\n        count++;\\n    }\\n\\n    @Pointcut(\"execution(* toString(..)) && bean(testBean1)\")\\n    public void testBean1toString() {\\n    }\\n\\n    @Pointcut(\"execution(* setAge(..)) && bean(testBean1)\")\\n    public void testBean1SetAge() {\\n    }\\n\\n    @Pointcut(\"execution(* setAge(..)) && bean(testBean2)\")\\n    publ"
  },
  {
    "method_id": "M3424",
    "name": "testBean1SetAge",
    "return_type": "void",
    "signature": "testBean1SetAge()",
    "file_id": "F84",
    "start_line": 36,
    "text_preview": "   public void testBean1toString() {\\n    }\\n\\n    @Pointcut(\"execution(* setAge(..)) && bean(testBean1)\")\\n    public void testBean1SetAge() {\\n    }\\n\\n    @Pointcut(\"execution(* setAge(..)) && bean(testBean2)\")\\n    public void testBean2SetAge() {\\n    }\\n\\n    @Before(\"testBean1SetAge()\")\\n    public void increment1() {\\n      "
  },
  {
    "method_id": "M3425",
    "name": "testBean2SetAge",
    "return_type": "void",
    "signature": "testBean2SetAge()",
    "file_id": "F84",
    "start_line": 40,
    "text_preview": "\\n    public void testBean1SetAge() {\\n    }\\n\\n    @Pointcut(\"execution(* setAge(..)) && bean(testBean2)\")\\n    public void testBean2SetAge() {\\n    }\\n\\n    @Before(\"testBean1SetAge()\")\\n    public void increment1() {\\n        count++;\\n    }\\n\\n    @Before(\"testBean2SetAge()\")\\n    public void increment2() {\\n        count++;\\n    "
  },
  {
    "method_id": "M3426",
    "name": "increment1",
    "return_type": "void",
    "signature": "increment1()",
    "file_id": "F84",
    "start_line": 44,
    "text_preview": "e(..)) && bean(testBean2)\")\\n    public void testBean2SetAge() {\\n    }\\n\\n    @Before(\"testBean1SetAge()\")\\n    public void increment1() {\\n        count++;\\n    }\\n\\n    @Before(\"testBean2SetAge()\")\\n    public void increment2() {\\n        count++;\\n    }\\n}\\n"
  },
  {
    "method_id": "M3427",
    "name": "increment2",
    "return_type": "void",
    "signature": "increment2()",
    "file_id": "F84",
    "start_line": 49,
    "text_preview": "Bean1SetAge()\")\\n    public void increment1() {\\n        count++;\\n    }\\n\\n    @Before(\"testBean2SetAge()\")\\n    public void increment2() {\\n        count++;\\n    }\\n}\\n"
  },
  {
    "method_id": "M3428",
    "name": "ignoreMe",
    "return_type": "void",
    "signature": "ignoreMe()",
    "file_id": "F91",
    "start_line": 6,
    "text_preview": ""
  },
  {
    "method_id": "M3429",
    "name": "before_method_call",
    "return_type": "void",
    "signature": "before_method_call()",
    "file_id": "F91",
    "start_line": 8,
    "text_preview": ".aspectj.runtime.internal.AroundClosure;\\n\\npublic class Aspect {\\n\\n\tpublic static void ignoreMe() {}\\n\\n\tpublic static void before_method_call() {\\n\t\tSystem.out.println(\"before\");\\n\t}\\n\\n\tpublic static void afterReturning_method_call() {\\n\t\tSystem.out.println(\"afterReturning\");\\n\t}\\n\\n\tpublic static void afterThrowing_method_execu"
  },
  {
    "method_id": "M3430",
    "name": "afterReturning_method_call",
    "return_type": "void",
    "signature": "afterReturning_method_call()",
    "file_id": "F91",
    "start_line": 12,
    "text_preview": " void ignoreMe() {}\\n\\n\tpublic static void before_method_call() {\\n\t\tSystem.out.println(\"before\");\\n\t}\\n\\n\tpublic static void afterReturning_method_call() {\\n\t\tSystem.out.println(\"afterReturning\");\\n\t}\\n\\n\tpublic static void afterThrowing_method_execution(Throwable t) {\\n\t\tSystem.out.println(\"afterThrowing \" + t);\\n\t\tt.printStackT"
  },
  {
    "method_id": "M3431",
    "name": "afterThrowing_method_execution",
    "return_type": "void",
    "signature": "afterThrowing_method_execution(Throwable t)",
    "file_id": "F91",
    "start_line": 16,
    "text_preview": "\\n\t}\\n\\n\tpublic static void afterReturning_method_call() {\\n\t\tSystem.out.println(\"afterReturning\");\\n\t}\\n\\n\tpublic static void afterThrowing_method_execution(Throwable t) {\\n\t\tSystem.out.println(\"afterThrowing \" + t);\\n\t\tt.printStackTrace();\\n\t}\\n\\n\tpublic static Object aroundFun(AroundClosure c) {\\n\t\tSystem.out.println(\"around\");\\n"
  },
  {
    "method_id": "M3432",
    "name": "aroundFun",
    "return_type": "Object",
    "signature": "aroundFun(AroundClosure c)",
    "file_id": "F91",
    "start_line": 21,
    "text_preview": "d_execution(Throwable t) {\\n\t\tSystem.out.println(\"afterThrowing \" + t);\\n\t\tt.printStackTrace();\\n\t}\\n\\n\tpublic static Object aroundFun(AroundClosure c) {\\n\t\tSystem.out.println(\"around\");\\n\t\ttry {\\n\t\t\treturn c.run(new Object[0]);\\n\t\t} catch (Throwable t) {\\n\t\t\treturn null;\\n\t\t}\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3433",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F91",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3434",
    "name": "onlyBase",
    "return_type": "void",
    "signature": "onlyBase()",
    "file_id": "F92",
    "start_line": 5,
    "text_preview": ") {}\\n\\n\tpu"
  },
  {
    "method_id": "M3435",
    "name": "both",
    "return_type": "void",
    "signature": "both()",
    "file_id": "F92",
    "start_line": 6,
    "text_preview": "eNotSuppo"
  },
  {
    "method_id": "M3436",
    "name": "onlyBaseNonStatic",
    "return_type": "void",
    "signature": "onlyBaseNonStatic()",
    "file_id": "F92",
    "start_line": 8,
    "text_preview": "}\\n}\\n"
  },
  {
    "method_id": "M3437",
    "name": "bothNonStatic",
    "return_type": "void",
    "signature": "bothNonStatic()",
    "file_id": "F92",
    "start_line": 9,
    "text_preview": "se {\\n\\n\tpublic static void onlyBase() {}\\n\tpublic static void both() {}\\n\\n\tpublic void onlyBaseNonStatic() {}\\n\tpublic void bothNonStatic() {}\\n\\n\tpublic int onlyBase;\\n\tpublic int both;\\n\\n\tpublic Base() {}\\n\tpublic Base(int i) {}\\n\\n\tpublic void m() throws CloneNotSupportedException {}\\n}\\n"
  },
  {
    "method_id": "M3438",
    "name": "Base",
    "return_type": "",
    "signature": "Base()",
    "file_id": "F92",
    "start_line": 5,
    "text_preview": "\\n\\n\tpublic"
  },
  {
    "method_id": "M3439",
    "name": "Base",
    "return_type": "",
    "signature": "Base(int i)",
    "file_id": "F92",
    "start_line": 5,
    "text_preview": "\\n\\n\tpublic"
  },
  {
    "method_id": "M3440",
    "name": "m",
    "return_type": "void",
    "signature": "m()",
    "file_id": "F92",
    "start_line": 17,
    "text_preview": "oid bothNonStatic() {}\\n\\n\tpublic int onlyBase;\\n\tpublic int both;\\n\\n\tpublic Base() {}\\n\tpublic Base(int i) {}\\n\\n\tpublic void m() throws CloneNotSupportedException {}\\n}\\n"
  },
  {
    "method_id": "M3441",
    "name": "onlyDerived",
    "return_type": "void",
    "signature": "onlyDerived()",
    "file_id": "F93",
    "start_line": 7,
    "text_preview": ""
  },
  {
    "method_id": "M3442",
    "name": "both",
    "return_type": "void",
    "signature": "both()",
    "file_id": "F93",
    "start_line": 8,
    "text_preview": "extends Base {\\n\\n\tpublic static void onlyDerived() throws IOException, CloneNotSupportedException {}\\n\tpublic static void both() {}\\n\\n\tpublic void onlyDerivedNonStatic() {}\\n\tpublic void bothNonStatic() {}\\n\\n\tpublic int onlyDerived;\\n\tpublic int both;\\n\\n\tpublic Derived() {}\\n\\n\tpublic void m() {}\\n\\n}\\n"
  },
  {
    "method_id": "M3443",
    "name": "onlyDerivedNonStatic",
    "return_type": "void",
    "signature": "onlyDerivedNonStatic()",
    "file_id": "F93",
    "start_line": 10,
    "text_preview": "static void onlyDerived() throws IOException, CloneNotSupportedException {}\\n\tpublic static void both() {}\\n\\n\tpublic void onlyDerivedNonStatic() {}\\n\tpublic void bothNonStatic() {}\\n\\n\tpublic int onlyDerived;\\n\tpublic int both;\\n\\n\tpublic Derived() {}\\n\\n\tpublic void m() {}\\n\\n}\\n"
  },
  {
    "method_id": "M3444",
    "name": "bothNonStatic",
    "return_type": "void",
    "signature": "bothNonStatic()",
    "file_id": "F93",
    "start_line": 11,
    "text_preview": "ption, CloneNotSupportedException {}\\n\tpublic static void both() {}\\n\\n\tpublic void onlyDerivedNonStatic() {}\\n\tpublic void bothNonStatic() {}\\n\\n\tpublic int onlyDerived;\\n\tpublic int both;\\n\\n\tpublic Derived() {}\\n\\n\tpublic void m() {}\\n\\n}\\n"
  },
  {
    "method_id": "M3445",
    "name": "Derived",
    "return_type": "",
    "signature": "Derived()",
    "file_id": "F93",
    "start_line": 7,
    "text_preview": ""
  },
  {
    "method_id": "M3446",
    "name": "m",
    "return_type": "void",
    "signature": "m()",
    "file_id": "F93",
    "start_line": 18,
    "text_preview": "ic() {}\\n\tpublic void bothNonStatic() {}\\n\\n\tpublic int onlyDerived;\\n\tpublic int both;\\n\\n\tpublic Derived() {}\\n\\n\tpublic void m() {}\\n\\n}\\n"
  },
  {
    "method_id": "M3447",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F94",
    "start_line": 24,
    "text_preview": "c class ReflectionWorldAdvancedPointcutExpressionTest extends CommonAdvancedPointcutExpressionTests {\\n\\n\tprotected World getWorld() {\\n\t\tWorld w = new ReflectionWorld(false, getClass().getClassLoader());\\n\t\tw.setBehaveInJava5Way(true);\\n\t\treturn w;\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3448",
    "name": "testIsTraceEnabled",
    "return_type": "void",
    "signature": "testIsTraceEnabled()",
    "file_id": "F95",
    "start_line": 25,
    "text_preview": "rk.TestCase;\\n\\npublic abstract class AbstractTraceTest extends TestCase {\\n\\n\tprotected AbstractTrace trace;\\n\\n\tpublic void testIsTraceEnabled() {\\n\t\tDefaultTrace trace = new DefaultTrace(getClass());\\n\t\tassertFalse(trace.isTraceEnabled());\\n\t}\\n\\n\tpublic void testEnterWithThisAndArgs() {\\n\t\ttrace.enter(\"testEnterWithThisAndArgs"
  },
  {
    "method_id": "M3449",
    "name": "testEnterWithThisAndArgs",
    "return_type": "void",
    "signature": "testEnterWithThisAndArgs()",
    "file_id": "F95",
    "start_line": 30,
    "text_preview": "nabled() {\\n\t\tDefaultTrace trace = new DefaultTrace(getClass());\\n\t\tassertFalse(trace.isTraceEnabled());\\n\t}\\n\\n\tpublic void testEnterWithThisAndArgs() {\\n\t\ttrace.enter(\"testEnterWithThisAndArgs\",this,new Object[] { \"arg1\", \"arg2\" });\\n\t}\\n\\n\tpublic void testEnterWithThisAndArray() {\\n\t\tObject arg1 = new String[] { \"s1\", \"s2\" };"
  },
  {
    "method_id": "M3450",
    "name": "testEnterWithThisAndArray",
    "return_type": "void",
    "signature": "testEnterWithThisAndArray()",
    "file_id": "F95",
    "start_line": 34,
    "text_preview": "terWithThisAndArgs() {\\n\t\ttrace.enter(\"testEnterWithThisAndArgs\",this,new Object[] { \"arg1\", \"arg2\" });\\n\t}\\n\\n\tpublic void testEnterWithThisAndArray() {\\n\t\tObject arg1 = new String[] { \"s1\", \"s2\" };\\n\t\tObject arg2 = new char[] { 'a', 'b', 'c' };\\n\t\ttrace.enter(getName(),this,new Object[] { arg1, arg2 });\\n\t}\\n\\n\tpublic void tes"
  },
  {
    "method_id": "M3451",
    "name": "testEnterWithThisAndCollection",
    "return_type": "void",
    "signature": "testEnterWithThisAndCollection()",
    "file_id": "F95",
    "start_line": 40,
    "text_preview": "Object arg2 = new char[] { 'a', 'b', 'c' };\\n\t\ttrace.enter(getName(),this,new Object[] { arg1, arg2 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndCollection() {\\n\t\tObject arg1 = new ArrayList();\\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndTraceable () {\\n\t\tObject arg1 = new Traceab"
  },
  {
    "method_id": "M3452",
    "name": "testEnterWithThisAndTraceable",
    "return_type": "void",
    "signature": "testEnterWithThisAndTraceable()",
    "file_id": "F95",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3453",
    "name": "Traceable",
    "return_type": "new",
    "signature": "Traceable()",
    "file_id": "F95",
    "start_line": 46,
    "text_preview": "ce.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndTraceable () {\\n\t\tObject arg1 = new Traceable() {\\n\\n\t\t\tpublic String toTraceString() {\\n\t\t\t\treturn getClass().getName() + \"[Traceable]\";\\n\t\t\t}\\n\\n\t\t};\\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAnd"
  },
  {
    "method_id": "M3454",
    "name": "toTraceString",
    "return_type": "String",
    "signature": "toTraceString()",
    "file_id": "F95",
    "start_line": 48,
    "text_preview": "ct[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndTraceable () {\\n\t\tObject arg1 = new Traceable() {\\n\\n\t\t\tpublic String toTraceString() {\\n\t\t\t\treturn getClass().getName() + \"[Traceable]\";\\n\t\t\t}\\n\\n\t\t};\\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndToStringException () {\\n\t\tObject "
  },
  {
    "method_id": "M3455",
    "name": "testEnterWithThisAndToStringException",
    "return_type": "void",
    "signature": "testEnterWithThisAndToStringException()",
    "file_id": "F95",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3456",
    "name": "Object",
    "return_type": "new",
    "signature": "Object()",
    "file_id": "F95",
    "start_line": 57,
    "text_preview": "(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndToStringException () {\\n\t\tObject arg1 = new Object() {\\n\\n\t\t\tpublic String toString() {\\n\t\t\t\tthrow new RuntimeException(\"toString() can throw an Exception\");\\n\t\t\t}\\n\\n\t\t};\\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnte"
  },
  {
    "method_id": "M3457",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F95",
    "start_line": 59,
    "text_preview": "{ arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndToStringException () {\\n\t\tObject arg1 = new Object() {\\n\\n\t\t\tpublic String toString() {\\n\t\t\t\tthrow new RuntimeException(\"toString() can throw an Exception\");\\n\t\t\t}\\n\\n\t\t};\\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndHashCodeException"
  },
  {
    "method_id": "M3458",
    "name": "testEnterWithThisAndHashCodeException",
    "return_type": "void",
    "signature": "testEnterWithThisAndHashCodeException()",
    "file_id": "F95",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3459",
    "name": "Object",
    "return_type": "new",
    "signature": "Object()",
    "file_id": "F95",
    "start_line": 57,
    "text_preview": "(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndToStringException () {\\n\t\tObject arg1 = new Object() {\\n\\n\t\t\tpublic String toString() {\\n\t\t\t\tthrow new RuntimeException(\"toString() can throw an Exception\");\\n\t\t\t}\\n\\n\t\t};\\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnte"
  },
  {
    "method_id": "M3460",
    "name": "hashCode",
    "return_type": "int",
    "signature": "hashCode()",
    "file_id": "F95",
    "start_line": 70,
    "text_preview": "[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndHashCodeException () {\\n\t\tObject arg1 = new Object() {\\n\\n\t\t\tpublic int hashCode() {\\n\t\t\t\tthrow new RuntimeException(\"hashCode can throw an Exception\");\\n\t\t\t}\\n\\n\t\t};\\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndClassLoader () {\\n\t\t"
  },
  {
    "method_id": "M3461",
    "name": "testEnterWithThisAndClassLoader",
    "return_type": "void",
    "signature": "testEnterWithThisAndClassLoader()",
    "file_id": "F95",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3462",
    "name": "ClassLoader",
    "return_type": "new",
    "signature": "ClassLoader()",
    "file_id": "F95",
    "start_line": 79,
    "text_preview": ".enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndClassLoader () {\\n\t\tObject arg1 = new ClassLoader() {\\n\\n\t\t\tpublic String toString() {\\n\t\t\t\tthrow new Error(\"Don't call ClassLoader.toString()\");\\n\t\t\t}\\n\\n\t\t};\\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithT"
  },
  {
    "method_id": "M3463",
    "name": "toString",
    "return_type": "String",
    "signature": "toString()",
    "file_id": "F95",
    "start_line": 59,
    "text_preview": "{ arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndToStringException () {\\n\t\tObject arg1 = new Object() {\\n\\n\t\t\tpublic String toString() {\\n\t\t\t\tthrow new RuntimeException(\"toString() can throw an Exception\");\\n\t\t\t}\\n\\n\t\t};\\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThisAndHashCodeException"
  },
  {
    "method_id": "M3464",
    "name": "testEnterWithThis",
    "return_type": "void",
    "signature": "testEnterWithThis()",
    "file_id": "F95",
    "start_line": 89,
    "text_preview": "(\"Don't call ClassLoader.toString()\");\\n\t\t\t}\\n\\n\t\t};\\n\t\ttrace.enter(getName(),this,new Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThis() {\\n\t\ttrace.enter(\"testEnterWithThis\",this);\\n\t}\\n\\n\tpublic void testEnter() {\\n\t\ttrace.enter(\"testEnter\");\\n\t}\\n\\n\tpublic void testExitWithReturn() {\\n\t\ttrace.exit(\"testExitWithReturn\",\"ret"
  },
  {
    "method_id": "M3465",
    "name": "testEnter",
    "return_type": "void",
    "signature": "testEnter()",
    "file_id": "F95",
    "start_line": 93,
    "text_preview": "ew Object[] { arg1 });\\n\t}\\n\\n\tpublic void testEnterWithThis() {\\n\t\ttrace.enter(\"testEnterWithThis\",this);\\n\t}\\n\\n\tpublic void testEnter() {\\n\t\ttrace.enter(\"testEnter\");\\n\t}\\n\\n\tpublic void testExitWithReturn() {\\n\t\ttrace.exit(\"testExitWithReturn\",\"ret\");\\n\t}\\n\\n\tpublic void testExitWithThrowable() {\\n\t\ttrace.exit(\"testExitWithThrowab"
  },
  {
    "method_id": "M3466",
    "name": "testExitWithReturn",
    "return_type": "void",
    "signature": "testExitWithReturn()",
    "file_id": "F95",
    "start_line": 97,
    "text_preview": " {\\n\t\ttrace.enter(\"testEnterWithThis\",this);\\n\t}\\n\\n\tpublic void testEnter() {\\n\t\ttrace.enter(\"testEnter\");\\n\t}\\n\\n\tpublic void testExitWithReturn() {\\n\t\ttrace.exit(\"testExitWithReturn\",\"ret\");\\n\t}\\n\\n\tpublic void testExitWithThrowable() {\\n\t\ttrace.exit(\"testExitWithThrowable\",new RuntimeException());\\n\t}\\n\\n\tpublic void testExit() {\\n"
  },
  {
    "method_id": "M3467",
    "name": "testExitWithThrowable",
    "return_type": "void",
    "signature": "testExitWithThrowable()",
    "file_id": "F95",
    "start_line": 101,
    "text_preview": ".enter(\"testEnter\");\\n\t}\\n\\n\tpublic void testExitWithReturn() {\\n\t\ttrace.exit(\"testExitWithReturn\",\"ret\");\\n\t}\\n\\n\tpublic void testExitWithThrowable() {\\n\t\ttrace.exit(\"testExitWithThrowable\",new RuntimeException());\\n\t}\\n\\n\tpublic void testExit() {\\n\t\ttrace.exit(\"testExit\");\\n\t}\\n\\n\tpublic void testEvent() {\\n\t\ttrace.event(\"testEvent\""
  },
  {
    "method_id": "M3468",
    "name": "testExit",
    "return_type": "void",
    "signature": "testExit()",
    "file_id": "F95",
    "start_line": 105,
    "text_preview": "\\n\\n\tpublic void testExitWithThrowable() {\\n\t\ttrace.exit(\"testExitWithThrowable\",new RuntimeException());\\n\t}\\n\\n\tpublic void testExit() {\\n\t\ttrace.exit(\"testExit\");\\n\t}\\n\\n\tpublic void testEvent() {\\n\t\ttrace.event(\"testEvent\");\\n\t}\\n\\n\tpublic void testEventWithThisAndArgs() {\\n\t\ttrace.event(\"testEventWithThisAndArgs\",this,new Object"
  },
  {
    "method_id": "M3469",
    "name": "testEvent",
    "return_type": "void",
    "signature": "testEvent()",
    "file_id": "F95",
    "start_line": 109,
    "text_preview": "estExitWithThrowable\",new RuntimeException());\\n\t}\\n\\n\tpublic void testExit() {\\n\t\ttrace.exit(\"testExit\");\\n\t}\\n\\n\tpublic void testEvent() {\\n\t\ttrace.event(\"testEvent\");\\n\t}\\n\\n\tpublic void testEventWithThisAndArgs() {\\n\t\ttrace.event(\"testEventWithThisAndArgs\",this,new Object[] { \"arg1\", \"arg2\" });\\n\t}\\n\\n\tpublic void testEventWithTh"
  },
  {
    "method_id": "M3470",
    "name": "testEventWithThisAndArgs",
    "return_type": "void",
    "signature": "testEventWithThisAndArgs()",
    "file_id": "F95",
    "start_line": 113,
    "text_preview": "void testExit() {\\n\t\ttrace.exit(\"testExit\");\\n\t}\\n\\n\tpublic void testEvent() {\\n\t\ttrace.event(\"testEvent\");\\n\t}\\n\\n\tpublic void testEventWithThisAndArgs() {\\n\t\ttrace.event(\"testEventWithThisAndArgs\",this,new Object[] { \"arg1\", \"arg2\" });\\n\t}\\n\\n\tpublic void testEventWithThisAndArg() {\\n\t\ttrace.event(\"testEventWithThisAndArg\",this,\""
  },
  {
    "method_id": "M3471",
    "name": "testEventWithThisAndArg",
    "return_type": "void",
    "signature": "testEventWithThisAndArg()",
    "file_id": "F95",
    "start_line": 117,
    "text_preview": "entWithThisAndArgs() {\\n\t\ttrace.event(\"testEventWithThisAndArgs\",this,new Object[] { \"arg1\", \"arg2\" });\\n\t}\\n\\n\tpublic void testEventWithThisAndArg() {\\n\t\ttrace.event(\"testEventWithThisAndArg\",this,\"arg1\");\\n\t}\\n\\n\tpublic void testDebug() {\\n\t\ttrace.debug(\"debug\");\\n\t}\\n\\n\tpublic void testInfo() {\\n\t\ttrace.info(\"information\");\\n\t}\\n\\n"
  },
  {
    "method_id": "M3472",
    "name": "testDebug",
    "return_type": "void",
    "signature": "testDebug()",
    "file_id": "F95",
    "start_line": 121,
    "text_preview": "});\\n\t}\\n\\n\tpublic void testEventWithThisAndArg() {\\n\t\ttrace.event(\"testEventWithThisAndArg\",this,\"arg1\");\\n\t}\\n\\n\tpublic void testDebug() {\\n\t\ttrace.debug(\"debug\");\\n\t}\\n\\n\tpublic void testInfo() {\\n\t\ttrace.info(\"information\");\\n\t}\\n\\n\tpublic void testWarn() {\\n\t\ttrace.warn(\"warning\");\\n\t}\\n\\n\tpublic void testWarnWithException() {\\n\t\ttra"
  },
  {
    "method_id": "M3473",
    "name": "testInfo",
    "return_type": "void",
    "signature": "testInfo()",
    "file_id": "F95",
    "start_line": 125,
    "text_preview": "e.event(\"testEventWithThisAndArg\",this,\"arg1\");\\n\t}\\n\\n\tpublic void testDebug() {\\n\t\ttrace.debug(\"debug\");\\n\t}\\n\\n\tpublic void testInfo() {\\n\t\ttrace.info(\"information\");\\n\t}\\n\\n\tpublic void testWarn() {\\n\t\ttrace.warn(\"warning\");\\n\t}\\n\\n\tpublic void testWarnWithException() {\\n\t\ttrace.warn(\"warning\",new RuntimeException(\"warning\"));\\n\t}\\n"
  },
  {
    "method_id": "M3474",
    "name": "testWarn",
    "return_type": "void",
    "signature": "testWarn()",
    "file_id": "F95",
    "start_line": 129,
    "text_preview": " void testDebug() {\\n\t\ttrace.debug(\"debug\");\\n\t}\\n\\n\tpublic void testInfo() {\\n\t\ttrace.info(\"information\");\\n\t}\\n\\n\tpublic void testWarn() {\\n\t\ttrace.warn(\"warning\");\\n\t}\\n\\n\tpublic void testWarnWithException() {\\n\t\ttrace.warn(\"warning\",new RuntimeException(\"warning\"));\\n\t}\\n\\n\tpublic void testError() {\\n\t\ttrace.error(\"error\");\\n\t}\\n\\n\tpu"
  },
  {
    "method_id": "M3475",
    "name": "testWarnWithException",
    "return_type": "void",
    "signature": "testWarnWithException()",
    "file_id": "F95",
    "start_line": 133,
    "text_preview": " void testInfo() {\\n\t\ttrace.info(\"information\");\\n\t}\\n\\n\tpublic void testWarn() {\\n\t\ttrace.warn(\"warning\");\\n\t}\\n\\n\tpublic void testWarnWithException() {\\n\t\ttrace.warn(\"warning\",new RuntimeException(\"warning\"));\\n\t}\\n\\n\tpublic void testError() {\\n\t\ttrace.error(\"error\");\\n\t}\\n\\n\tpublic void testErrorWithException() {\\n\t\ttrace.error(\"err"
  },
  {
    "method_id": "M3476",
    "name": "testError",
    "return_type": "void",
    "signature": "testError()",
    "file_id": "F95",
    "start_line": 137,
    "text_preview": ");\\n\t}\\n\\n\tpublic void testWarnWithException() {\\n\t\ttrace.warn(\"warning\",new RuntimeException(\"warning\"));\\n\t}\\n\\n\tpublic void testError() {\\n\t\ttrace.error(\"error\");\\n\t}\\n\\n\tpublic void testErrorWithException() {\\n\t\ttrace.error(\"error\",new RuntimeException(\"error\"));\\n\t}\\n\\n\tpublic void testFatal() {\\n\t\ttrace.fatal(\"fatal\");\\n\t}\\n\\n\tpubl"
  },
  {
    "method_id": "M3477",
    "name": "testErrorWithException",
    "return_type": "void",
    "signature": "testErrorWithException()",
    "file_id": "F95",
    "start_line": 141,
    "text_preview": "arn(\"warning\",new RuntimeException(\"warning\"));\\n\t}\\n\\n\tpublic void testError() {\\n\t\ttrace.error(\"error\");\\n\t}\\n\\n\tpublic void testErrorWithException() {\\n\t\ttrace.error(\"error\",new RuntimeException(\"error\"));\\n\t}\\n\\n\tpublic void testFatal() {\\n\t\ttrace.fatal(\"fatal\");\\n\t}\\n\\n\tpublic void testFatalWithException() {\\n\t\ttrace.fatal(\"fatal"
  },
  {
    "method_id": "M3478",
    "name": "testFatal",
    "return_type": "void",
    "signature": "testFatal()",
    "file_id": "F95",
    "start_line": 145,
    "text_preview": "r\");\\n\t}\\n\\n\tpublic void testErrorWithException() {\\n\t\ttrace.error(\"error\",new RuntimeException(\"error\"));\\n\t}\\n\\n\tpublic void testFatal() {\\n\t\ttrace.fatal(\"fatal\");\\n\t}\\n\\n\tpublic void testFatalWithException() {\\n\t\ttrace.fatal(\"fatal\",new RuntimeException(\"fatal\"));\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3479",
    "name": "testFatalWithException",
    "return_type": "void",
    "signature": "testFatalWithException()",
    "file_id": "F95",
    "start_line": 149,
    "text_preview": "e.error(\"error\",new RuntimeException(\"error\"));\\n\t}\\n\\n\tpublic void testFatal() {\\n\t\ttrace.fatal(\"fatal\");\\n\t}\\n\\n\tpublic void testFatalWithException() {\\n\t\ttrace.fatal(\"fatal\",new RuntimeException(\"fatal\"));\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3480",
    "name": "testSignature",
    "return_type": "void",
    "signature": "testSignature()",
    "file_id": "F96",
    "start_line": 26,
    "text_preview": "dedReferenceType extendsClass;\\n\tBoundedReferenceType superClass;\\n\tBoundedReferenceType extendsWithExtras;\\n\\n\tpublic void testSignature() {\\n\t\tString extendsSig = extendsClass.getSignature();\\n\t\tassertEquals(\"+Ljava/lang/Class;\", extendsSig);\\n\t\tassertEquals(\"-Ljava/lang/Class;\", superClass.getSignature());\\n\t}\\n\\n\tpublic void"
  },
  {
    "method_id": "M3481",
    "name": "testExtendsBounds",
    "return_type": "void",
    "signature": "testExtendsBounds()",
    "file_id": "F96",
    "start_line": 32,
    "text_preview": "ls(\"+Ljava/lang/Class;\", extendsSig);\\n\t\tassertEquals(\"-Ljava/lang/Class;\", superClass.getSignature());\\n\t}\\n\\n\tpublic void testExtendsBounds() {\\n\t\tassertFalse(\"has no lower bound\", extendsClass.hasLowerBound());\\n\t\tassertNull(\"no lower bound\", extendsClass.getLowerBound());\\n\t\tassertEquals(javaLangClass, extendsClass.getUpp"
  },
  {
    "method_id": "M3482",
    "name": "testSuperBounds",
    "return_type": "void",
    "signature": "testSuperBounds()",
    "file_id": "F96",
    "start_line": 39,
    "text_preview": "getUpperBound());\\n\t\tassertEquals(\"no interface bounds\", 0, extendsClass.getAdditionalBounds().length);\\n\t}\\n\\n\tpublic void testSuperBounds() {\\n\t\tassertTrue(\"has lower bound\", superClass.hasLowerBound());\\n\t\tassertEquals(javaLangClass, superClass.getLowerBound());\\n\t\tassertEquals(\"Ljava/lang/Object;\", superClass.getUpperBoun"
  },
  {
    "method_id": "M3483",
    "name": "testIsExtends",
    "return_type": "void",
    "signature": "testIsExtends()",
    "file_id": "F96",
    "start_line": 46,
    "text_preview": "().getSignature());\\n\t\tassertEquals(\"no interface bounds\", 0, superClass.getAdditionalBounds().length);\\n\t}\\n\\n\tpublic void testIsExtends() {\\n\t\tassertTrue(extendsClass.kind == BoundedReferenceType.EXTENDS);\\n\t\tassertFalse(superClass.kind == BoundedReferenceType.EXTENDS);\\n\t}\\n\\n\tpublic void testIsSuper() {\\n\t\tassertTrue(superCl"
  },
  {
    "method_id": "M3484",
    "name": "testIsSuper",
    "return_type": "void",
    "signature": "testIsSuper()",
    "file_id": "F96",
    "start_line": 51,
    "text_preview": "kind == BoundedReferenceType.EXTENDS);\\n\t\tassertFalse(superClass.kind == BoundedReferenceType.EXTENDS);\\n\t}\\n\\n\tpublic void testIsSuper() {\\n\t\tassertTrue(superClass.kind == BoundedReferenceType.SUPER);\\n\t\tassertFalse(extendsClass.kind == BoundedReferenceType.SUPER);\\n\t}\\n\\n\tpublic void testGetDeclaredInterfacesNoAdditions() {\\n\t"
  },
  {
    "method_id": "M3485",
    "name": "testGetDeclaredInterfacesNoAdditions",
    "return_type": "void",
    "signature": "testGetDeclaredInterfacesNoAdditions()",
    "file_id": "F96",
    "start_line": 56,
    "text_preview": "s.kind == BoundedReferenceType.SUPER);\\n\t\tassertFalse(extendsClass.kind == BoundedReferenceType.SUPER);\\n\t}\\n\\n\tpublic void testGetDeclaredInterfacesNoAdditions() {\\n\t\tResolvedType[] rt1 = extendsClass.getDeclaredInterfaces();\\n\t\tResolvedType[] rt2 = javaLangClass.getDeclaredInterfaces();\\n\t\tassertEquals(\"same length\", rt1.le"
  },
  {
    "method_id": "M3486",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < rt2.length; i++)",
    "file_id": "F96",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3487",
    "name": "testGetDeclaredInterfacesWithInterfaceBounds",
    "return_type": "void",
    "signature": "testGetDeclaredInterfacesWithInterfaceBounds()",
    "file_id": "F96",
    "start_line": 65,
    "text_preview": "length);\\n\t\tfor (int i = 0; i < rt2.length; i++) {\\n\t\t\tassertEquals(\"same methods\", rt1[i], rt2[i]);\\n\t\t}\\n\t}\\n\\n\tpublic void testGetDeclaredInterfacesWithInterfaceBounds() {\\n\t\tResolvedType[] rt1 = extendsWithExtras.getDeclaredInterfaces();\\n\t\tResolvedType[] rt2 = javaLangClass.getDeclaredInterfaces();\\n\t\tassertEquals(\"one ext"
  },
  {
    "method_id": "M3488",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < rt2.length; i++)",
    "file_id": "F96",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3489",
    "name": "testGetDeclaredMethodsExtends",
    "return_type": "void",
    "signature": "testGetDeclaredMethodsExtends()",
    "file_id": "F96",
    "start_line": 77,
    "text_preview": "gnature());\\n\t}\\n\\n\t// all other methods in signature are delegated to upper bound...\\n\t// representative test\\n\tpublic void testGetDeclaredMethodsExtends() {\\n\t\tResolvedMember[] rm1 = extendsClass.getDeclaredMethods();\\n\t\tResolvedMember[] rm2 = javaLangClass.getDeclaredMethods();\\n\t\tassertEquals(\"same length\", rm1.length, rm2"
  },
  {
    "method_id": "M3490",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < rm2.length; i++)",
    "file_id": "F96",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3491",
    "name": "testGetDeclaredMethodsSuper",
    "return_type": "void",
    "signature": "testGetDeclaredMethodsSuper()",
    "file_id": "F96",
    "start_line": 86,
    "text_preview": "length);\\n\t\tfor (int i = 0; i < rm2.length; i++) {\\n\t\t\tassertEquals(\"same methods\", rm1[i], rm2[i]);\\n\t\t}\\n\t}\\n\\n\tpublic void testGetDeclaredMethodsSuper() {\\n\t\tResolvedMember[] rm1 = superClass.getDeclaredMethods();\\n\t\tResolvedMember[] rm2 = javaLangObject.getDeclaredMethods();\\n\t\tassertEquals(\"same length\", rm1.length, rm2.le"
  },
  {
    "method_id": "M3492",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < rm2.length; i++)",
    "file_id": "F96",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3493",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F96",
    "start_line": 96,
    "text_preview": " (int i = 0; i < rm2.length; i++) {\\n\t\t\tassertEquals(\"same methods\", rm1[i], rm2[i]);\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tBcelWorld world = new BcelWorld();\\n\t\tjavaLangClass = (ReferenceType) world.resolve(UnresolvedType.forName(\"java/lang/Class\"));\\n\t\tjavaLangObject = (Referen"
  },
  {
    "method_id": "M3494",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F97",
    "start_line": 24,
    "text_preview": "ss CommonReferenceTypeTests extends TestCase {\\n\\n\tprivate World world;\\n\\n\tpublic abstract World getWorld();\\n\\n\tpublic void setUp() {\\n\t\tworld = getWorld();\\n\t}\\n\\n\tpublic void testUnresolvedTypeSignatureProcessing() {\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType ut = null;\\n\t\tut = UnresolvedType.forName(\"java.util.List<"
  },
  {
    "method_id": "M3495",
    "name": "testUnresolvedTypeSignatureProcessing",
    "return_type": "void",
    "signature": "testUnresolvedTypeSignatureProcessing()",
    "file_id": "F97",
    "start_line": 28,
    "text_preview": "private World world;\\n\\n\tpublic abstract World getWorld();\\n\\n\tpublic void setUp() {\\n\t\tworld = getWorld();\\n\t}\\n\\n\tpublic void testUnresolvedTypeSignatureProcessing() {\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType ut = null;\\n\t\tut = UnresolvedType.forName(\"java.util.List<java.util.List<java.lang.String>>[]\").resolve(wor"
  },
  {
    "method_id": "M3496",
    "name": "testArrays",
    "return_type": "void",
    "signature": "testArrays()",
    "file_id": "F97",
    "start_line": 37,
    "text_preview": "\tassertEquals(\"Names not equal \", \"java.util.List<java.util.List<java.lang.String>>[]\", ut.getName());\\n\t}\\n\\n\tpublic void testArrays() {\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType ut = null;\\n\t\tut = UnresolvedType.forName(\"[Ljava.lang.String;\");\\n\t\tassertEquals(\"[Ljava/lang/String;\",ut.getSignature());\\n\t\tUnresolve"
  },
  {
    "method_id": "M3497",
    "name": "testIsRawTrue",
    "return_type": "void",
    "signature": "testIsRawTrue()",
    "file_id": "F97",
    "start_line": 59,
    "text_preview": "ssertTrue(rt.isArray());\\n\t\tassertTrue(rt.getComponentType().isArray());\\n\t\tassertFalse(rt.isMissing());\\n\t}\\n\\n\tpublic void testIsRawTrue() {\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType javaLangClass = UnresolvedType.forName(\"java.lang.Class\");\\n\t\tResolvedType rtx = world.resolve(javaLangClass);\\n\t\tassertTrue(\"Resolv"
  },
  {
    "method_id": "M3498",
    "name": "testIsRawFalse",
    "return_type": "void",
    "signature": "testIsRawFalse()",
    "file_id": "F97",
    "start_line": 68,
    "text_preview": "e));\\n\t\tReferenceType rt = (ReferenceType) rtx;\\n\t\tassertTrue(\"java.lang.Class is raw\", rt.isRawType());\\n\t}\\n\\n\tpublic void testIsRawFalse() {\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType javaLangObject = UnresolvedType.forName(\"java.lang.Object\");\\n\t\tResolvedType rtx = world.resolve(javaLangObject);\\n\t\tassertTrue(\"Re"
  },
  {
    "method_id": "M3499",
    "name": "testIsGenericTrue",
    "return_type": "void",
    "signature": "testIsGenericTrue()",
    "file_id": "F97",
    "start_line": 77,
    "text_preview": "ReferenceType rt = (ReferenceType) rtx;\\n\t\tassertFalse(\"java.lang.Object is  not raw\", rt.isRawType());\\n\t}\\n\\n\tpublic void testIsGenericTrue() {\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType javaLangClass = UnresolvedType.forName(\"java.lang.Class\");\\n\t\tResolvedType rtx = world.resolve(javaLangClass);\\n\t\tassertTrue(\"ja"
  },
  {
    "method_id": "M3500",
    "name": "testIsGenericFalse",
    "return_type": "void",
    "signature": "testIsGenericFalse()",
    "file_id": "F97",
    "start_line": 84,
    "text_preview": ";\\n\t\tassertTrue(\"java.lang.Class has underpinning generic type\", rtx.getGenericType().isGenericType());\\n\t}\\n\\n\tpublic void testIsGenericFalse() {\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType javaLangObject = UnresolvedType.forName(\"java.lang.Object\");\\n\t\tResolvedType rtx = world.resolve(javaLangObject);\\n\t\tassertFals"
  },
  {
    "method_id": "M3501",
    "name": "testGetTraceFactory",
    "return_type": "void",
    "signature": "testGetTraceFactory()",
    "file_id": "F98",
    "start_line": 20,
    "text_preview": "r.tools.Trace;\\n\\nimport junit.framework.TestCase;\\n\\npublic class CommonsTraceFactoryTest extends TestCase {\\n\\n\tpublic void testGetTraceFactory() {\\n\t\tCommonsTraceFactory factory = new CommonsTraceFactory();\\n\t\tTrace trace = factory.getTrace(getClass());\\n\t\tassertFalse(\"Tracing should be disbled by default\",trace.isTraceEnabl"
  },
  {
    "method_id": "M3502",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F99",
    "start_line": 17,
    "text_preview": "port org.aspectj.weaver.tools.CommonsTrace;\\n\\npublic class CommonsTraceTest extends AbstractTraceTest {\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\ttrace = new CommonsTrace(getClass());\\n\t\ttrace.setTraceEnabled(true);\\n\t}\\n\\n\tpublic void testCommonsTrace() {\\n//\t\tCommonsTrace trace =\\n\t\t\tnew CommonsTrace(ge"
  },
  {
    "method_id": "M3503",
    "name": "testCommonsTrace",
    "return_type": "void",
    "signature": "testCommonsTrace()",
    "file_id": "F99",
    "start_line": 23,
    "text_preview": "ws Exception {\\n\t\tsuper.setUp();\\n\t\ttrace = new CommonsTrace(getClass());\\n\t\ttrace.setTraceEnabled(true);\\n\t}\\n\\n\tpublic void testCommonsTrace() {\\n//\t\tCommonsTrace trace =\\n\t\t\tnew CommonsTrace(getClass());\\n\t}\\n\\n\tpublic void testSetTraceEnabled() {\\n\t\tCommonsTrace trace = new CommonsTrace(getClass());\\n\t\ttrace.setTraceEnabled(tru"
  },
  {
    "method_id": "M3504",
    "name": "testSetTraceEnabled",
    "return_type": "void",
    "signature": "testSetTraceEnabled()",
    "file_id": "F99",
    "start_line": 28,
    "text_preview": "true);\\n\t}\\n\\n\tpublic void testCommonsTrace() {\\n//\t\tCommonsTrace trace =\\n\t\t\tnew CommonsTrace(getClass());\\n\t}\\n\\n\tpublic void testSetTraceEnabled() {\\n\t\tCommonsTrace trace = new CommonsTrace(getClass());\\n\t\ttrace.setTraceEnabled(true);\\n\t\t/* XXX Need to find out how to turn tracing on */\\n//\t\tassertTrue(trace.isTraceEnabled());\\n"
  },
  {
    "method_id": "M3505",
    "name": "testGetTrace",
    "return_type": "void",
    "signature": "testGetTrace()",
    "file_id": "F100",
    "start_line": 20,
    "text_preview": "r.tools.Trace;\\n\\nimport junit.framework.TestCase;\\n\\npublic class DefaultTraceFactoryTest extends TestCase {\\n\\n\tpublic void testGetTrace() {\\n\t\tDefaultTraceFactory factory = new DefaultTraceFactory();\\n\t\tTrace trace = factory.getTrace(getClass());\\n\t\tassertFalse(\"Tracing should be disbled by default\",trace.isTraceEnabled());\\n"
  },
  {
    "method_id": "M3506",
    "name": "testIsEnabled",
    "return_type": "void",
    "signature": "testIsEnabled()",
    "file_id": "F100",
    "start_line": 26,
    "text_preview": ".getTrace(getClass());\\n\t\tassertFalse(\"Tracing should be disbled by default\",trace.isTraceEnabled());\\n\t}\\n\\n//\tpublic void testIsEnabled() {\\n//\t\tfail(\"Not yet implemented\");\\n//\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3507",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F101",
    "start_line": 17,
    "text_preview": "port org.aspectj.weaver.tools.DefaultTrace;\\n\\npublic class DefaultTraceTest extends AbstractTraceTest {\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\ttrace = new DefaultTrace(getClass());\\n\t\ttrace.setTraceEnabled(true);\\n\t}\\n\\n\tpublic void testDefaultTrace() {\\n//\t\tDefaultTrace trace =\\n\t\t\tnew DefaultTrace(ge"
  },
  {
    "method_id": "M3508",
    "name": "testDefaultTrace",
    "return_type": "void",
    "signature": "testDefaultTrace()",
    "file_id": "F101",
    "start_line": 23,
    "text_preview": "ws Exception {\\n\t\tsuper.setUp();\\n\t\ttrace = new DefaultTrace(getClass());\\n\t\ttrace.setTraceEnabled(true);\\n\t}\\n\\n\tpublic void testDefaultTrace() {\\n//\t\tDefaultTrace trace =\\n\t\t\tnew DefaultTrace(getClass());\\n\t}\\n\\n\tpublic void testSetTraceEnabled() {\\n\t\tDefaultTrace trace = new DefaultTrace(getClass());\\n\t\ttrace.setTraceEnabled(tru"
  },
  {
    "method_id": "M3509",
    "name": "testSetTraceEnabled",
    "return_type": "void",
    "signature": "testSetTraceEnabled()",
    "file_id": "F101",
    "start_line": 28,
    "text_preview": "true);\\n\t}\\n\\n\tpublic void testDefaultTrace() {\\n//\t\tDefaultTrace trace =\\n\t\t\tnew DefaultTrace(getClass());\\n\t}\\n\\n\tpublic void testSetTraceEnabled() {\\n\t\tDefaultTrace trace = new DefaultTrace(getClass());\\n\t\ttrace.setTraceEnabled(true);\\n\t\tassertTrue(trace.isTraceEnabled());\\n\t}\\n\\n\tpublic void testSetPrintStream () {\\n\t\tDefaultTrac"
  },
  {
    "method_id": "M3510",
    "name": "testSetPrintStream",
    "return_type": "void",
    "signature": "testSetPrintStream()",
    "file_id": "F101",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3511",
    "name": "DumpTestCase",
    "return_type": "",
    "signature": "DumpTestCase(String name)",
    "file_id": "F102",
    "start_line": 36,
    "text_preview": "blic class DumpTestCase extends TestCase {\\n\\n\tprivate File dumpFile;\\n\tprivate IMessage.Kind savedDumpCondition;\\n\\n\tpublic DumpTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\\n\t\tdumpFile = null;\\n\t\tsavedDumpCondition = Dump.getDumpOnExit();\\n\t}\\n\\n\tprotected void tearDown"
  },
  {
    "method_id": "M3512",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F102",
    "start_line": 40,
    "text_preview": "ile;\\n\tprivate IMessage.Kind savedDumpCondition;\\n\\n\tpublic DumpTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\\n\t\tdumpFile = null;\\n\t\tsavedDumpCondition = Dump.getDumpOnExit();\\n\t}\\n\\n\tprotected void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\\n\t\tif (dumpFile != nu"
  },
  {
    "method_id": "M3513",
    "name": "tearDown",
    "return_type": "void",
    "signature": "tearDown()",
    "file_id": "F102",
    "start_line": 47,
    "text_preview": "hrows Exception {\\n\t\tsuper.setUp();\\n\\n\t\tdumpFile = null;\\n\t\tsavedDumpCondition = Dump.getDumpOnExit();\\n\t}\\n\\n\tprotected void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\\n\t\tif (dumpFile != null && dumpFile.exists()) {\\n\t\t\tboolean deleted = dumpFile.delete();\\n\t\t\tassertTrue(\"Dump file '\" + dumpFile.getPath() + \"' could no"
  },
  {
    "method_id": "M3514",
    "name": "testSetDumpOnException",
    "return_type": "void",
    "signature": "testSetDumpOnException()",
    "file_id": "F102",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3515",
    "name": "testSetDumpOnExit",
    "return_type": "void",
    "signature": "testSetDumpOnExit()",
    "file_id": "F102",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3516",
    "name": "testDump",
    "return_type": "void",
    "signature": "testDump()",
    "file_id": "F102",
    "start_line": 69,
    "text_preview": "ble to set condition 'junk'\",Dump.setDumpOnExit(\"junk\"));\\n\t}\\n\\n\tpublic void testDump () {\\n\t\tString fileName = Dump.dump(\"testDump()\");\\n\t\tdumpFile = new File(fileName);\\n\t\tassertTrue(\"Dump file '\" + fileName + \"' should exist\",dumpFile.exists());\\n\t}\\n\\n\tpublic void testDumpWithException () {\\n\t\tString message = \"testDumpWith"
  },
  {
    "method_id": "M3517",
    "name": "testDumpWithException",
    "return_type": "void",
    "signature": "testDumpWithException()",
    "file_id": "F102",
    "start_line": 75,
    "text_preview": "le '\" + fileName + \"' should exist\",dumpFile.exists());\\n\t}\\n\\n\tpublic void testDumpWithException () {\\n\t\tString message = \"testDumpWithException()\";\\n\t\tString fileName = recursiveCall(message,100);\\n\t\tdumpFile = new File(fileName);\\n\t\tassertContents(dumpFile,\"Exception Information\",message);\\n\t}\\n\\n\tpublic void testDumpOnExit ("
  },
  {
    "method_id": "M3518",
    "name": "testDumpOnExit",
    "return_type": "void",
    "signature": "testDumpOnExit()",
    "file_id": "F102",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3519",
    "name": "testDumpOnExitExcluded",
    "return_type": "void",
    "signature": "testDumpOnExitExcluded()",
    "file_id": "F102",
    "start_line": 93,
    "text_preview": ";\\n\t\tIMessageHolder holder = new MessageHandler();\\n\t\tDump.saveMessageHolder(holder);\\n\t\tholder.handleMessage(new Message(\"testDumpOnExitExcluded()\",IMessage.ERROR,null,null));\\n\t\tString fileName = Dump.dumpOnExit();\\n\t\tdumpFile = new File(fileName);\\n\t\tassertEquals(\"Dump '\" + fileName + \"' should be excluded\",Dump.DUMP_EXCL"
  },
  {
    "method_id": "M3520",
    "name": "testDumpOnExitIncluded",
    "return_type": "void",
    "signature": "testDumpOnExitIncluded()",
    "file_id": "F102",
    "start_line": 103,
    "text_preview": "or\");\\n\t\tIMessageHolder holder = new MessageHandler();\\n\t\tDump.saveMessageHolder(holder);\\n\t\tIMessage error = new Message(\"testDumpOnExitIncluded()\",IMessage.ERROR,null,null);\\n\t\tholder.handleMessage(error);\\n\t\tString fileName = Dump.dumpOnExit();\\n\t\tdumpFile = new File(fileName);\\n\t\tassertContents(dumpFile,\"Compiler Messages"
  },
  {
    "method_id": "M3521",
    "name": "assertContents",
    "return_type": "void",
    "signature": "assertContents(File dumpFile, String heading, String contents)",
    "file_id": "F102",
    "start_line": 78,
    "text_preview": "message = \"testDumpWithException()\";\\n\t\tString fileName = recursiveCall(message,100);\\n\t\tdumpFile = new File(fileName);\\n\t\tassertContents(dumpFile,\"Exception Information\",message);\\n\t}\\n\\n\tpublic void testDumpOnExit () {\\n\t\tDump.setDumpOnExit(\"abort\");\\n\t\tDump.saveMessageHolder(null);\\n\t\tString fileName = Dump.dumpOnExit();\\n\t\td"
  },
  {
    "method_id": "M3522",
    "name": "fileContains",
    "return_type": "boolean",
    "signature": "fileContains(File dumpFile, String heading, String contents)",
    "file_id": "F102",
    "start_line": 113,
    "text_preview": "hould exist\",dumpFile.exists());\\n\t\tassertTrue(\"Dump file '\" + dumpFile.getPath()+ \"' should contain '\" + contents + \"'\",fileContains(dumpFile,heading,contents));\\n\t}\\n\\n\tprivate static boolean fileContains (File dumpFile, String heading, String contents) {\\n\t\tboolean result = false;\\n\\n\t\ttry {\\n\t\t\tBufferedReader reader = new "
  },
  {
    "method_id": "M3523",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ex)",
    "file_id": "F102",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3524",
    "name": "recursiveCall",
    "return_type": "String",
    "signature": "recursiveCall(String message, int depth)",
    "file_id": "F102",
    "start_line": 76,
    "text_preview": "xists());\\n\t}\\n\\n\tpublic void testDumpWithException () {\\n\t\tString message = \"testDumpWithException()\";\\n\t\tString fileName = recursiveCall(message,100);\\n\t\tdumpFile = new File(fileName);\\n\t\tassertContents(dumpFile,\"Exception Information\",message);\\n\t}\\n\\n\tpublic void testDumpOnExit () {\\n\t\tDump.setDumpOnExit(\"abort\");\\n\t\tDump.save"
  },
  {
    "method_id": "M3525",
    "name": "if",
    "return_type": "",
    "signature": "if(depth == 0)",
    "file_id": "F102",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3526",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F103",
    "start_line": 28,
    "text_preview": "lement\\n */\\npublic class GenericSignatureParserTest extends TestCase {\\n\\n\tGenericSignatureParser parser;\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tparser = new GenericSignatureParser();\\n\t}\\n\\n\tpublic void testClassSignatureParsingInJDK() throws Exception {\\n\t\tSyntheticRepository repository = SyntheticRe"
  },
  {
    "method_id": "M3527",
    "name": "testClassSignatureParsingInJDK",
    "return_type": "void",
    "signature": "testClassSignatureParsingInJDK()",
    "file_id": "F103",
    "start_line": 33,
    "text_preview": "\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tparser = new GenericSignatureParser();\\n\t}\\n\\n\tpublic void testClassSignatureParsingInJDK() throws Exception {\\n\t\tSyntheticRepository repository = SyntheticRepository.getInstance();\\n\t\tString[] testClasses = new String[] { \"java.lang.Comparable\", \"java.lang.Ite"
  },
  {
    "method_id": "M3528",
    "name": "for",
    "return_type": "",
    "signature": "for(String testClass : testClasses)",
    "file_id": "F103",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3529",
    "name": "testMethodSignatureParsingInJDK",
    "return_type": "void",
    "signature": "testMethodSignatureParsingInJDK()",
    "file_id": "F103",
    "start_line": 46,
    "text_preview": "dClass(testClass);\\n\t\t\tString sig = jc.getGenericSignature();\\n\t\t\tparser.parseAsClassSignature(sig);\\n\t\t}\\n\t}\\n\\n\tpublic void testMethodSignatureParsingInJDK() throws Exception {\\n\t\tSyntheticRepository repository = SyntheticRepository.getInstance();\\n\t\tString[] testClasses = new String[] { \"java.lang.Comparable\", \"java.lang.It"
  },
  {
    "method_id": "M3530",
    "name": "for",
    "return_type": "",
    "signature": "for(String testClass : testClasses)",
    "file_id": "F103",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3531",
    "name": "for",
    "return_type": "",
    "signature": "for(Method method : methods)",
    "file_id": "F103",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3532",
    "name": "testResolveGeneric",
    "return_type": "void",
    "signature": "testResolveGeneric()",
    "file_id": "F104",
    "start_line": 26,
    "text_preview": "\\n\\n\t/**\\n\t * Let's play about with a generic type and ensure we can work with it in a reflective world.\\n\t */\\n\tpublic void testResolveGeneric() {\\n\t\tUnresolvedType collectionType = UnresolvedType.forName(\"java.util.Collection\");\\n\t\tworld.resolve(collectionType).getRawType().resolve(world);\\n\t\tResolvedMember[] methods = world"
  },
  {
    "method_id": "M3533",
    "name": "for",
    "return_type": "",
    "signature": "for(int j=0;j<methods.length;j++)",
    "file_id": "F104",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3534",
    "name": "testResolveEnum",
    "return_type": "void",
    "signature": "testResolveEnum()",
    "file_id": "F104",
    "start_line": 48,
    "text_preview": "getSignatureErased().equals(expectedSignature));\\n\t}\\n\\n\t/**\\n\t * Can we resolve the dreaded Enum type...\\n\t */\\n\tpublic void testResolveEnum() {\\n\t\tResolvedType enumType = world.resolve(\"java.lang.Enum\");\\n\t\tassertTrue(\"Should be the raw type but is \" + enumType.typeKind, enumType.isRawType());\\n\t\tResolvedType theGenericEnumTy"
  },
  {
    "method_id": "M3535",
    "name": "testResolveClass",
    "return_type": "void",
    "signature": "testResolveClass()",
    "file_id": "F104",
    "start_line": 58,
    "text_preview": "rue(\"Type variable should be '\" + expected + \"' but is '\" + tv + \"'\", tv.toString().equals(expected));\\n\t}\\n\\n\tpublic void testResolveClass() {\\n\t\tworld.resolve(\"java.lang.Class\").getGenericType();\\n\t}\\n\\n\tpublic void testGenericInterfaceSuperclass_ReflectionWorldResolution() {\\n\\n\t\tUnresolvedType javaUtilMap = UnresolvedType.f"
  },
  {
    "method_id": "M3536",
    "name": "testGenericInterfaceSuperclass_ReflectionWorldResolution",
    "return_type": "void",
    "signature": "testGenericInterfaceSuperclass_ReflectionWorldResolution()",
    "file_id": "F104",
    "start_line": 62,
    "text_preview": "expected));\\n\t}\\n\\n\tpublic void testResolveClass() {\\n\t\tworld.resolve(\"java.lang.Class\").getGenericType();\\n\t}\\n\\n\tpublic void testGenericInterfaceSuperclass_ReflectionWorldResolution() {\\n\\n\t\tUnresolvedType javaUtilMap = UnresolvedType.forName(\"java.util.Map\");\\n\\n\t\tReferenceType rawType = (ReferenceType) world.resolve(javaUtilM"
  },
  {
    "method_id": "M3537",
    "name": "testAnnotationFinderClassRetention",
    "return_type": "void",
    "signature": "testAnnotationFinderClassRetention()",
    "file_id": "F104",
    "start_line": 83,
    "text_preview": " runtime\\n\t * annotation info then we use reflection and don't go digging through the classfile bytes.\\n\t */\\n\tpublic void testAnnotationFinderClassRetention() throws Exception {\\n\t\tResolvedType type = world.resolve(AnnoTesting.class.getName());\\n\t\tResolvedMember[] ms = type.getDeclaredMethods();\\n\\n\t\tResolvedMember methodWit"
  },
  {
    "method_id": "M3538",
    "name": "a",
    "return_type": "void",
    "signature": "a()",
    "file_id": "F104",
    "start_line": 131,
    "text_preview": "s {}\\n\\n\t@Retention(RetentionPolicy.RUNTIME)\\n\t@interface AnnoRuntime {}\\n\\n\tclass AnnoTesting {\\n\\n\t\t@AnnoClass\\n\t\tpublic void a() {}\\n\\n\t\t@AnnoRuntime\\n\t\tpublic void b() {}\\n\\n\t\t@AnnoClass @AnnoRuntime\\n\t\tpublic void c() {}\\n\\n\t\t@AnnoClass @AnnoRuntime\\n\t\tpublic void d() {}\\n\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3539",
    "name": "b",
    "return_type": "void",
    "signature": "b()",
    "file_id": "F104",
    "start_line": 134,
    "text_preview": "TIME)\\n\t@interface AnnoRuntime {}\\n\\n\tclass AnnoTesting {\\n\\n\t\t@AnnoClass\\n\t\tpublic void a() {}\\n\\n\t\t@AnnoRuntime\\n\t\tpublic void b() {}\\n\\n\t\t@AnnoClass @AnnoRuntime\\n\t\tpublic void c() {}\\n\\n\t\t@AnnoClass @AnnoRuntime\\n\t\tpublic void d() {}\\n\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3540",
    "name": "c",
    "return_type": "void",
    "signature": "c()",
    "file_id": "F104",
    "start_line": 26,
    "text_preview": "play about with a generic type and ensure we can work with it in a reflective world.\\n\t */\\n\tpublic void testResolveGeneric() {\\n\t\tUnresolvedType collectionType = UnresolvedType.forName(\"java.util.Collection\");\\n\t\tworld.resolve(collectionType).getRawType().resolve(world);\\n\t\tResolvedMember[] methods = world.resolve(collecti"
  },
  {
    "method_id": "M3541",
    "name": "d",
    "return_type": "void",
    "signature": "d()",
    "file_id": "F104",
    "start_line": 41,
    "text_preview": "/Object;\";\\n\\n\t\tassertTrue(\"Expected signature of '\" + expectedSignature + \"' but it was '\" + methods[i].getSignatureErased(), methods[i]\\n\t\t\t\t.getSignatureErased().equals(expectedSignature));\\n\t}\\n\\n\t/**\\n\t * Can we resolve the dreaded Enum type...\\n\t */\\n\tpublic void testResolveEnum() {\\n\t\tResolvedType enumType = world.resolve"
  },
  {
    "method_id": "M3542",
    "name": "testJdk14TraceFactory",
    "return_type": "void",
    "signature": "testJdk14TraceFactory()",
    "file_id": "F105",
    "start_line": 20,
    "text_preview": "ver.tools.Trace;\\n\\nimport junit.framework.TestCase;\\n\\npublic class Jdk14TraceFactoryTest extends TestCase {\\n\\n\tpublic void testJdk14TraceFactory() {\\n\t\tnew Jdk14TraceFactory();\\n\t}\\n\\n\tpublic void testGetTrace() {\\n\t\tJdk14TraceFactory factory = new Jdk14TraceFactory();\\n\t\tTrace trace = factory.getTrace(getClass());\\n\t\tassertFals"
  },
  {
    "method_id": "M3543",
    "name": "testGetTrace",
    "return_type": "void",
    "signature": "testGetTrace()",
    "file_id": "F105",
    "start_line": 24,
    "text_preview": "TraceFactoryTest extends TestCase {\\n\\n\tpublic void testJdk14TraceFactory() {\\n\t\tnew Jdk14TraceFactory();\\n\t}\\n\\n\tpublic void testGetTrace() {\\n\t\tJdk14TraceFactory factory = new Jdk14TraceFactory();\\n\t\tTrace trace = factory.getTrace(getClass());\\n\t\tassertFalse(\"Tracing should be disbled by default\",trace.isTraceEnabled());\\n\t}\\n\\n"
  },
  {
    "method_id": "M3544",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F106",
    "start_line": 18,
    "text_preview": ";\\nimport org.aspectj.weaver.tools.Jdk14Trace;\\n\\npublic class Jdk14TraceTest extends AbstractTraceTest {\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\ttrace = new Jdk14Trace(getClass());\\n\t\ttrace.setTraceEnabled(true);\\n\t}\\n\\n\tpublic void testJdk14Trace() {\\n\t\tnew Jdk14Trace(getClass());\\n\t}\\n\\n\tpublic void test"
  },
  {
    "method_id": "M3545",
    "name": "testJdk14Trace",
    "return_type": "void",
    "signature": "testJdk14Trace()",
    "file_id": "F106",
    "start_line": 24,
    "text_preview": "rows Exception {\\n\t\tsuper.setUp();\\n\t\ttrace = new Jdk14Trace(getClass());\\n\t\ttrace.setTraceEnabled(true);\\n\t}\\n\\n\tpublic void testJdk14Trace() {\\n\t\tnew Jdk14Trace(getClass());\\n\t}\\n\\n\tpublic void testSetTraceEnabled() {\\n\t\tDefaultTrace trace = new DefaultTrace(getClass());\\n\t\ttrace.setTraceEnabled(true);\\n\t\tassertTrue(trace.isTrace"
  },
  {
    "method_id": "M3546",
    "name": "testSetTraceEnabled",
    "return_type": "void",
    "signature": "testSetTraceEnabled()",
    "file_id": "F106",
    "start_line": 28,
    "text_preview": "s());\\n\t\ttrace.setTraceEnabled(true);\\n\t}\\n\\n\tpublic void testJdk14Trace() {\\n\t\tnew Jdk14Trace(getClass());\\n\t}\\n\\n\tpublic void testSetTraceEnabled() {\\n\t\tDefaultTrace trace = new DefaultTrace(getClass());\\n\t\ttrace.setTraceEnabled(true);\\n\t\tassertTrue(trace.isTraceEnabled());\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3547",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F107",
    "start_line": 29,
    "text_preview": "stCase;\\n\\n/**\\n * @author Andy Clement\\n */\\npublic class JoinPointSignatureIteratorTest extends TestCase {\\n\\n\tprivate World getWorld() {\\n\t\treturn new ReflectionWorld(getClass().getClassLoader());\\n\t}\\n\\n\t/**\\n\t * Checking the signatures for a dynamic proxy - which is created using erased information and so is completely generi"
  },
  {
    "method_id": "M3548",
    "name": "testPr268419",
    "return_type": "void",
    "signature": "testPr268419()",
    "file_id": "F107",
    "start_line": 36,
    "text_preview": "for a dynamic proxy - which is created using erased information and so is completely generics unaware\\n\t */\\n\tpublic void testPr268419() {\\n\t\tWorld w = getWorld();\\n\t\tw.setBehaveInJava5Way(true);\\n\\n\t\t// The proxy class here is not generated, it is simply loaded up. $Proxy1 is in the java5-testsrc folder, but it\\n\t\t// obeys t"
  },
  {
    "method_id": "M3549",
    "name": "for",
    "return_type": "",
    "signature": "for(Object object : l)",
    "file_id": "F107",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3550",
    "name": "LocaleTest",
    "return_type": "",
    "signature": "LocaleTest(String name)",
    "file_id": "F108",
    "start_line": 23,
    "text_preview": "j.apache.bcel.util.ByteSequence;\\n\\nimport junit.framework.TestCase;\\n\\npublic class LocaleTest extends TestCase {\\n\\n\tpublic LocaleTest(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testNormalLocale() {\\n\t\tdoBipush();\\n\t}\\n\\n\tpublic void testTurkishLocale() {\\n\t\tLocale def = Locale.getDefault();\\n\t\tLocale.setDefault(new Locale(\""
  },
  {
    "method_id": "M3551",
    "name": "testNormalLocale",
    "return_type": "void",
    "signature": "testNormalLocale()",
    "file_id": "F108",
    "start_line": 27,
    "text_preview": "estCase;\\n\\npublic class LocaleTest extends TestCase {\\n\\n\tpublic LocaleTest(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testNormalLocale() {\\n\t\tdoBipush();\\n\t}\\n\\n\tpublic void testTurkishLocale() {\\n\t\tLocale def = Locale.getDefault();\\n\t\tLocale.setDefault(new Locale(\"tr\", \"\"));\\n\t\ttry {\\n\t\t\tdoBipush();\\n\t\t} finally {\\n\t\t\tLocale."
  },
  {
    "method_id": "M3552",
    "name": "testTurkishLocale",
    "return_type": "void",
    "signature": "testTurkishLocale()",
    "file_id": "F108",
    "start_line": 31,
    "text_preview": "\\n\\n\tpublic LocaleTest(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testNormalLocale() {\\n\t\tdoBipush();\\n\t}\\n\\n\tpublic void testTurkishLocale() {\\n\t\tLocale def = Locale.getDefault();\\n\t\tLocale.setDefault(new Locale(\"tr\", \"\"));\\n\t\ttry {\\n\t\t\tdoBipush();\\n\t\t} finally {\\n\t\t\tLocale.setDefault(def);\\n\t\t}\\n\t}\\n\\n\tprivate static void doBipu"
  },
  {
    "method_id": "M3553",
    "name": "doBipush",
    "return_type": "void",
    "signature": "doBipush()",
    "file_id": "F108",
    "start_line": 28,
    "text_preview": "LocaleTest extends TestCase {\\n\\n\tpublic LocaleTest(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testNormalLocale() {\\n\t\tdoBipush();\\n\t}\\n\\n\tpublic void testTurkishLocale() {\\n\t\tLocale def = Locale.getDefault();\\n\t\tLocale.setDefault(new Locale(\"tr\", \"\"));\\n\t\ttry {\\n\t\t\tdoBipush();\\n\t\t} finally {\\n\t\t\tLocale.setDefault(def);\\n\t\t}\\n\t}"
  },
  {
    "method_id": "M3554",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F108",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3555",
    "name": "testCanBeParameterizedRegularMethod",
    "return_type": "void",
    "signature": "testCanBeParameterizedRegularMethod()",
    "file_id": "F109",
    "start_line": 24,
    "text_preview": "rk.TestCase;\\n\\n/**\\n * @author colyer\\n * @author clement\\n */\\npublic class Member15Test extends TestCase {\\n\\n\t  public void testCanBeParameterizedRegularMethod() {\\n\t    \tBcelWorld world = new BcelWorld();\\n\t    \tResolvedType javaLangClass = world.resolve(UnresolvedType.forName(\"java/lang/Class\"));\\n\t    \tResolvedMember[] met"
  },
  {
    "method_id": "M3556",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F109",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3557",
    "name": "if",
    "return_type": "",
    "signature": "if(getAnnotations != null)",
    "file_id": "F109",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3558",
    "name": "testCanBeParameterizedGenericMethod",
    "return_type": "void",
    "signature": "testCanBeParameterizedGenericMethod()",
    "file_id": "F109",
    "start_line": 41,
    "text_preview": "System.out.println(\"got it\");\\n\t    \t\tassertFalse(getAnnotations.canBeParameterized());\\n\t    \t}\\n\t    }\\n\\n\t    public void testCanBeParameterizedGenericMethod() {\\n\t    \tBcelWorld world = new BcelWorld();\\n\t    \tworld.setBehaveInJava5Way(true);\\n\t    \tResolvedType javaLangClass = world.resolve(UnresolvedType.forName(\"java.la"
  },
  {
    "method_id": "M3559",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F109",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3560",
    "name": "if",
    "return_type": "",
    "signature": "if(asSubclass != null)",
    "file_id": "F109",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3561",
    "name": "testCanBeParameterizedMethodInGenericType",
    "return_type": "void",
    "signature": "testCanBeParameterizedMethodInGenericType()",
    "file_id": "F109",
    "start_line": 61,
    "text_preview": "   \t\tSystem.out.println(\"got it\");\\n\t    \t\tassertTrue(asSubclass.canBeParameterized());\\n\t    \t}\\n\t    }\\n\\n\t    public void testCanBeParameterizedMethodInGenericType() {\\n\t       \tBcelWorld world = new BcelWorld();\\n\t       \tworld.setBehaveInJava5Way(true);\\n\t    \tResolvedType javaUtilList = world.resolve(UnresolvedType.forNa"
  },
  {
    "method_id": "M3562",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F109",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3563",
    "name": "if",
    "return_type": "",
    "signature": "if(add != null)",
    "file_id": "F109",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3564",
    "name": "testGenericReferenceTypeCreation",
    "return_type": "void",
    "signature": "testGenericReferenceTypeCreation()",
    "file_id": "F109",
    "start_line": 81,
    "text_preview": "   \t\tSystem.out.println(\"got it\");\\n\t    \t\tassertTrue(add.canBeParameterized());\\n\t    \t}\\n\t    }\\n\t    /*\\n\t    public void testGenericReferenceTypeCreation() {\\n\t    \tUnresolvedType genericType = UnresolvedType.forGenericTypeSignature(\"Lorg/aspectj/weaver/MemberTestCase15$One;\",\"<T:Ljava/lang/Object;>Ljava/lang/Object;\");\\n"
  },
  {
    "method_id": "M3565",
    "name": "testMemberSignatureCreation",
    "return_type": "void",
    "signature": "testMemberSignatureCreation()",
    "file_id": "F109",
    "start_line": 87,
    "text_preview": " \tassertEquals(\"Lorg/aspectj/weaver/MemberTestCase15$One;\",genericType.getErasureSignature());\\n\t    }\\n\\n\t    public void testMemberSignatureCreation() {\\n\t\t\tWorld world = new BcelWorld(\"../weaver5/bin/\");\\n\t    \t//new ReflectionWorld(false, getClass().getClassLoader());\\n\t       \tworld.setBehaveInJava5Way(true);\\n\t       \tR"
  },
  {
    "method_id": "M3566",
    "name": "findMethod",
    "return_type": "ResolvedMember",
    "signature": "findMethod(String name, ResolvedType type)",
    "file_id": "F109",
    "start_line": 96,
    "text_preview": "e.isMissing());\\n\\n\t       \t// Look at the methods on the parameterized type One<String>\\n\t       \tResolvedMember member = findMethod(\"getter\",one);\\n\t       \tString erasedSignature = MemberImpl.typesToSignature(member.getReturnType(),member.getParameterTypes(),true);\\n\t       \tassertEquals(\"()Ljava/lang/String;\",erasedSign"
  },
  {
    "method_id": "M3567",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember member: members)",
    "file_id": "F109",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3568",
    "name": "getter",
    "return_type": "T",
    "signature": "getter()",
    "file_id": "F109",
    "start_line": 147,
    "text_preview": "rn member;\\n\t       \t\t}\\n\t       \t}\\n\t       \treturn null;\\n\t    }\\n\\n\t    // testcode\\n\t    class One<T> {\\n\t    \tT t;\\n\t    \tT getter() {\\n\t    \t\treturn null;\\n\t    \t}\\n\t    \tList<T> getterTwo() {\\n\t    \t\treturn null;\\n\t    \t}\\n\t    }\\n\t    */\\n}\\n"
  },
  {
    "method_id": "M3569",
    "name": "getterTwo",
    "return_type": "List<T>",
    "signature": "getterTwo()",
    "file_id": "F109",
    "start_line": 150,
    "text_preview": "l;\\n\t    }\\n\\n\t    // testcode\\n\t    class One<T> {\\n\t    \tT t;\\n\t    \tT getter() {\\n\t    \t\treturn null;\\n\t    \t}\\n\t    \tList<T> getterTwo() {\\n\t    \t\treturn null;\\n\t    \t}\\n\t    }\\n\t    */\\n}\\n"
  },
  {
    "method_id": "M3570",
    "name": "testCanBeParameterizedRegularMethod",
    "return_type": "void",
    "signature": "testCanBeParameterizedRegularMethod()",
    "file_id": "F110",
    "start_line": 24,
    "text_preview": "unit.framework.TestCase;\\n\\n/**\\n * @author colyer\\n *\\n */\\npublic class Member15TestCase extends TestCase {\\n\\n\t  public void testCanBeParameterizedRegularMethod() {\\n\t    \tBcelWorld world = new BcelWorld();\\n\t    \tResolvedType javaLangClass = world.resolve(UnresolvedType.forName(\"java/lang/Class\"));\\n\t    \tResolvedMember[] met"
  },
  {
    "method_id": "M3571",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F110",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3572",
    "name": "if",
    "return_type": "",
    "signature": "if(getAnnotations != null)",
    "file_id": "F110",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3573",
    "name": "testCanBeParameterizedGenericMethod",
    "return_type": "void",
    "signature": "testCanBeParameterizedGenericMethod()",
    "file_id": "F110",
    "start_line": 41,
    "text_preview": "System.out.println(\"got it\");\\n\t    \t\tassertFalse(getAnnotations.canBeParameterized());\\n\t    \t}\\n\t    }\\n\\n\t    public void testCanBeParameterizedGenericMethod() {\\n\t    \tBcelWorld world = new BcelWorld();\\n\t    \tworld.setBehaveInJava5Way(true);\\n\t    \tResolvedType javaLangClass = world.resolve(UnresolvedType.forName(\"java.la"
  },
  {
    "method_id": "M3574",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F110",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3575",
    "name": "if",
    "return_type": "",
    "signature": "if(asSubclass != null)",
    "file_id": "F110",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3576",
    "name": "testCanBeParameterizedMethodInGenericType",
    "return_type": "void",
    "signature": "testCanBeParameterizedMethodInGenericType()",
    "file_id": "F110",
    "start_line": 61,
    "text_preview": "   \t\tSystem.out.println(\"got it\");\\n\t    \t\tassertTrue(asSubclass.canBeParameterized());\\n\t    \t}\\n\t    }\\n\\n\t    public void testCanBeParameterizedMethodInGenericType() {\\n\t       \tBcelWorld world = new BcelWorld();\\n\t       \tworld.setBehaveInJava5Way(true);\\n\t    \tResolvedType javaUtilList = world.resolve(UnresolvedType.forNa"
  },
  {
    "method_id": "M3577",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F110",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3578",
    "name": "if",
    "return_type": "",
    "signature": "if(add != null)",
    "file_id": "F110",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3579",
    "name": "MemberTestCase",
    "return_type": "",
    "signature": "MemberTestCase(String name)",
    "file_id": "F111",
    "start_line": 28,
    "text_preview": " for all the portions of Member that don't require a world.\\n */\\npublic class MemberTestCase extends TestCase {\\n\\n\tpublic MemberTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testMethodConstruction() {\\n\t\tMember s = TestUtils.methodFromString(\"void Foo.goo(int)\");\\n\t\tMember t = MemberImpl.method(UnresolvedType.for"
  },
  {
    "method_id": "M3580",
    "name": "testMethodConstruction",
    "return_type": "void",
    "signature": "testMethodConstruction()",
    "file_id": "F111",
    "start_line": 32,
    "text_preview": "/\\npublic class MemberTestCase extends TestCase {\\n\\n\tpublic MemberTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testMethodConstruction() {\\n\t\tMember s = TestUtils.methodFromString(\"void Foo.goo(int)\");\\n\t\tMember t = MemberImpl.method(UnresolvedType.forName(\"Foo\"), 0, \"goo\", \"(I)V\");\\n\t\tMember u = TestUtils.methodF"
  },
  {
    "method_id": "M3581",
    "name": "testMethodContents",
    "return_type": "void",
    "signature": "testMethodContents()",
    "file_id": "F111",
    "start_line": 66,
    "text_preview": "se);\\n\t\tTestUtil.assertCommutativeEquals(t, v, false);\\n\t\tTestUtil.assertCommutativeEquals(u, v, false);\\n\t}\\n\\n\tpublic void testMethodContents() {\\n\t\tMember m = TestUtils.methodFromString(\"void Foo.goo(int)\");\\n\t\tkindTest(m, Member.METHOD);\\n\t\tdeclaringTypeTest(m, \"Foo\");\\n\t\tnameTest(m, \"goo\");\\n\t\tparameterTypesTest(m, new Unre"
  },
  {
    "method_id": "M3582",
    "name": "testFieldContents",
    "return_type": "void",
    "signature": "testFieldContents()",
    "file_id": "F111",
    "start_line": 123,
    "text_preview": "faceTest(m, false);\\n\t\tisPrivateTest(m, false);\\n\t\tisConstructorTest(m, false);\\n\t\tisStaticTest(m, true);\\n\t}\\n\\n\tpublic void testFieldContents() {\\n\t\tMember m = TestUtils.fieldFromString(\"int Foo.goo\");\\n\t\tkindTest(m, Member.FIELD);\\n\t\tdeclaringTypeTest(m, \"Foo\");\\n\t\tnameTest(m, \"goo\");\\n\t\tparameterTypesTest(m, UnresolvedType.NO"
  },
  {
    "method_id": "M3583",
    "name": "isStaticTest",
    "return_type": "void",
    "signature": "isStaticTest(Member m, boolean b)",
    "file_id": "F111",
    "start_line": 76,
    "text_preview": "eTest(m, UnresolvedType.VOID);\\n\t\tisInterfaceTest(m, false);\\n\t\tisPrivateTest(m, false);\\n\t\tisConstructorTest(m, false);\\n\t\tisStaticTest(m, false);\\n\\n\t\tm = TestUtils.methodFromString(\"interface java.lang.Object java.util.Iterator.next()\");\\n\t\tkindTest(m, Member.METHOD);\\n\t\tdeclaringTypeTest(m, \"java.util.Iterator\");\\n\t\tnameTes"
  },
  {
    "method_id": "M3584",
    "name": "isConstructorTest",
    "return_type": "void",
    "signature": "isConstructorTest(Member m, boolean b)",
    "file_id": "F111",
    "start_line": 75,
    "text_preview": "esolvedType.INT });\\n\t\treturnTypeTest(m, UnresolvedType.VOID);\\n\t\tisInterfaceTest(m, false);\\n\t\tisPrivateTest(m, false);\\n\t\tisConstructorTest(m, false);\\n\t\tisStaticTest(m, false);\\n\\n\t\tm = TestUtils.methodFromString(\"interface java.lang.Object java.util.Iterator.next()\");\\n\t\tkindTest(m, Member.METHOD);\\n\t\tdeclaringTypeTest(m, \""
  },
  {
    "method_id": "M3585",
    "name": "isPrivateTest",
    "return_type": "void",
    "signature": "isPrivateTest(Member m, boolean b)",
    "file_id": "F111",
    "start_line": 74,
    "text_preview": " new UnresolvedType[] { UnresolvedType.INT });\\n\t\treturnTypeTest(m, UnresolvedType.VOID);\\n\t\tisInterfaceTest(m, false);\\n\t\tisPrivateTest(m, false);\\n\t\tisConstructorTest(m, false);\\n\t\tisStaticTest(m, false);\\n\\n\t\tm = TestUtils.methodFromString(\"interface java.lang.Object java.util.Iterator.next()\");\\n\t\tkindTest(m, Member.METHOD"
  },
  {
    "method_id": "M3586",
    "name": "isInterfaceTest",
    "return_type": "void",
    "signature": "isInterfaceTest(Member m, boolean b)",
    "file_id": "F111",
    "start_line": 73,
    "text_preview": "oo\");\\n\t\tparameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT });\\n\t\treturnTypeTest(m, UnresolvedType.VOID);\\n\t\tisInterfaceTest(m, false);\\n\t\tisPrivateTest(m, false);\\n\t\tisConstructorTest(m, false);\\n\t\tisStaticTest(m, false);\\n\\n\t\tm = TestUtils.methodFromString(\"interface java.lang.Object java.util.Iterator.next()\")"
  },
  {
    "method_id": "M3587",
    "name": "returnTypeTest",
    "return_type": "void",
    "signature": "returnTypeTest(Member m, UnresolvedType returnType)",
    "file_id": "F111",
    "start_line": 72,
    "text_preview": "laringTypeTest(m, \"Foo\");\\n\t\tnameTest(m, \"goo\");\\n\t\tparameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT });\\n\t\treturnTypeTest(m, UnresolvedType.VOID);\\n\t\tisInterfaceTest(m, false);\\n\t\tisPrivateTest(m, false);\\n\t\tisConstructorTest(m, false);\\n\t\tisStaticTest(m, false);\\n\\n\t\tm = TestUtils.methodFromString(\"interface ja"
  },
  {
    "method_id": "M3588",
    "name": "parameterTypesTest",
    "return_type": "void",
    "signature": "parameterTypesTest(Member m, UnresolvedType[] paramTypes)",
    "file_id": "F111",
    "start_line": 71,
    "text_preview": "odFromString(\"void Foo.goo(int)\");\\n\t\tkindTest(m, Member.METHOD);\\n\t\tdeclaringTypeTest(m, \"Foo\");\\n\t\tnameTest(m, \"goo\");\\n\t\tparameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT });\\n\t\treturnTypeTest(m, UnresolvedType.VOID);\\n\t\tisInterfaceTest(m, false);\\n\t\tisPrivateTest(m, false);\\n\t\tisConstructorTest(m, false);\\n\t\ti"
  },
  {
    "method_id": "M3589",
    "name": "nameTest",
    "return_type": "void",
    "signature": "nameTest(Member m, String name)",
    "file_id": "F111",
    "start_line": 70,
    "text_preview": "ber m = TestUtils.methodFromString(\"void Foo.goo(int)\");\\n\t\tkindTest(m, Member.METHOD);\\n\t\tdeclaringTypeTest(m, \"Foo\");\\n\t\tnameTest(m, \"goo\");\\n\t\tparameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT });\\n\t\treturnTypeTest(m, UnresolvedType.VOID);\\n\t\tisInterfaceTest(m, false);\\n\t\tisPrivateTest(m, false);\\n\t\tisConstruc"
  },
  {
    "method_id": "M3590",
    "name": "declaringTypeTest",
    "return_type": "void",
    "signature": "declaringTypeTest(Member m, String declaringName)",
    "file_id": "F111",
    "start_line": 69,
    "text_preview": "id testMethodContents() {\\n\t\tMember m = TestUtils.methodFromString(\"void Foo.goo(int)\");\\n\t\tkindTest(m, Member.METHOD);\\n\t\tdeclaringTypeTest(m, \"Foo\");\\n\t\tnameTest(m, \"goo\");\\n\t\tparameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT });\\n\t\treturnTypeTest(m, UnresolvedType.VOID);\\n\t\tisInterfaceTest(m, false);\\n\t\tisPriv"
  },
  {
    "method_id": "M3591",
    "name": "kindTest",
    "return_type": "void",
    "signature": "kindTest(Member m, MemberKind kind)",
    "file_id": "F111",
    "start_line": 68,
    "text_preview": "s(u, v, false);\\n\t}\\n\\n\tpublic void testMethodContents() {\\n\t\tMember m = TestUtils.methodFromString(\"void Foo.goo(int)\");\\n\t\tkindTest(m, Member.METHOD);\\n\t\tdeclaringTypeTest(m, \"Foo\");\\n\t\tnameTest(m, \"goo\");\\n\t\tparameterTypesTest(m, new UnresolvedType[] { UnresolvedType.INT });\\n\t\treturnTypeTest(m, UnresolvedType.VOID);\\n\t\tisInt"
  },
  {
    "method_id": "M3592",
    "name": "testDeclaredMethodWithParameter",
    "return_type": "void",
    "signature": "testDeclaredMethodWithParameter()",
    "file_id": "F112",
    "start_line": 33,
    "text_preview": "ass ParameterizedReferenceTypeTestCase extends TestCase {\\n\\n\tBcelWorld world;\\n\tReferenceType listOfString;\\n\\n\tpublic void testDeclaredMethodWithParameter() {\\n\t\tResolvedMember[] methods = listOfString.getDeclaredMethods();\\n\t\tResolvedMember add = null;\\n\t\tfor (ResolvedMember resolvedMember : methods) {\\n\t\t\tif (resolvedMember"
  },
  {
    "method_id": "M3593",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember resolvedMember : methods)",
    "file_id": "F112",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3594",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F112",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3595",
    "name": "testDeclaredMethodWithParameterizedReturnType",
    "return_type": "void",
    "signature": "testDeclaredMethodWithParameterizedReturnType()",
    "file_id": "F112",
    "start_line": 63,
    "text_preview": "ype returnType = get.getReturnType();\\n\t\tassertEquals(\"Ljava/lang/String;\",returnType.getSignature());\\n\\n\t}\\n\\n\tpublic void testDeclaredMethodWithParameterizedReturnType() {\\n\t\tResolvedMember[] methods = listOfString.getDeclaredMethods();\\n\t\tResolvedMember iterator = null;\\n\t\tfor (ResolvedMember method : methods) {\\n\t\t\tif (met"
  },
  {
    "method_id": "M3596",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember method : methods)",
    "file_id": "F112",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3597",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F112",
    "start_line": 77,
    "text_preview": "eturnType();\\n\t\tassertEquals(\"Pjava/util/Iterator<Ljava/lang/String;>;\",returnType.getSignature());\\n\\n\t}\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tworld = new BcelWorld();\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tlistOfString = (ReferenceType)\\n\t\t\tTypeFactory.createTypeFromSignature(\"Pjava/util/List<Ljava"
  },
  {
    "method_id": "M3598",
    "name": "testIsRawTrue",
    "return_type": "void",
    "signature": "testIsRawTrue()",
    "file_id": "F113",
    "start_line": 29,
    "text_preview": "ressWarnings({ \"unused\", \"rawtypes\", \"unchecked\" })\\npublic class ReferenceTypeTestCase extends TestCase {\\n\\n\tpublic void testIsRawTrue() {\\n\t\tBcelWorld world = new BcelWorld();\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType javaLangClass = UnresolvedType.forName(\"java.lang.Class\");\\n\t\tResolvedType rtx = world.resolve"
  },
  {
    "method_id": "M3599",
    "name": "testIsRawFalse",
    "return_type": "void",
    "signature": "testIsRawFalse()",
    "file_id": "F113",
    "start_line": 39,
    "text_preview": "e));\\n\t\tReferenceType rt = (ReferenceType) rtx;\\n\t\tassertTrue(\"java.lang.Class is raw\", rt.isRawType());\\n\t}\\n\\n\tpublic void testIsRawFalse() {\\n\t\tBcelWorld world = new BcelWorld();\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType javaLangObject = UnresolvedType.forName(\"java.lang.Object\");\\n\t\tResolvedType rtx = world.reso"
  },
  {
    "method_id": "M3600",
    "name": "testIsGenericTrue",
    "return_type": "void",
    "signature": "testIsGenericTrue()",
    "file_id": "F113",
    "start_line": 49,
    "text_preview": "ReferenceType rt = (ReferenceType) rtx;\\n\t\tassertFalse(\"java.lang.Object is  not raw\", rt.isRawType());\\n\t}\\n\\n\tpublic void testIsGenericTrue() {\\n\t\tBcelWorld world = new BcelWorld();\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType javaLangClass = UnresolvedType.forName(\"java.lang.Class\");\\n\t\tResolvedType rtx = world.res"
  },
  {
    "method_id": "M3601",
    "name": "testIsGenericFalse",
    "return_type": "void",
    "signature": "testIsGenericFalse()",
    "file_id": "F113",
    "start_line": 57,
    "text_preview": ";\\n\t\tassertTrue(\"java.lang.Class has underpinning generic type\", rtx.getGenericType().isGenericType());\\n\t}\\n\\n\tpublic void testIsGenericFalse() {\\n\t\tBcelWorld world = new BcelWorld();\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tUnresolvedType javaLangObject = UnresolvedType.forName(\"java.lang.Object\");\\n\t\tResolvedType rtx = world."
  },
  {
    "method_id": "M3602",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F113",
    "start_line": 68,
    "text_preview": "rtx = world.resolve(javaLangObject);\\n\t\tassertFalse(rtx.isGenericType());\\n\t}\\n\\n\tBcelWorld world;\\n\\n\t@Override\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tworld = new BcelWorld();\\n\t\tworld.setBehaveInJava5Way(true);\\n\t}\\n\\n\tpublic void testCoercion01() {\\n\t\tReferenceType listOfString = (ReferenceType) world.resol"
  },
  {
    "method_id": "M3603",
    "name": "testCoercion01",
    "return_type": "void",
    "signature": "testCoercion01()",
    "file_id": "F113",
    "start_line": 74,
    "text_preview": "Up() throws Exception {\\n\t\tsuper.setUp();\\n\t\tworld = new BcelWorld();\\n\t\tworld.setBehaveInJava5Way(true);\\n\t}\\n\\n\tpublic void testCoercion01() {\\n\t\tReferenceType listOfString = (ReferenceType) world.resolve(UnresolvedType\\n\t\t\t\t.forSignature(\"Pjava/util/List<Ljava/lang/String;>;\"));\\n\t\tReferenceType listOfInteger = (ReferenceTyp"
  },
  {
    "method_id": "M3604",
    "name": "testAssignable01",
    "return_type": "void",
    "signature": "testAssignable01()",
    "file_id": "F113",
    "start_line": 85,
    "text_preview": "fInteger.isCoerceableFrom(listOfString));\\n\t\tassertFalse(listOfString.isCoerceableFrom(listOfInteger));\\n\t}\\n\\n\tpublic void testAssignable01() {\\n\t\tList list = new ArrayList();\\n\t\tList<String> listOfString = new ArrayList<>();\\n\t\tList<?> listOfSomething = new ArrayList<Integer>();\\n\t\tList<? extends Number> listOfSomethingNumbe"
  },
  {
    "method_id": "M3605",
    "name": "m1",
    "return_type": "void",
    "signature": "m1(List<Integer> e)",
    "file_id": "F113",
    "start_line": 148,
    "text_preview": "rue(ajListOfSomethingNumberish.isCoerceableFrom(ajListOfSomethingSuperDouble));\\n\t}\\n\\n\tclass C<E extends Number> {\\n\t\tvoid m1(List<Integer> e) {\\n\t\t}\\n\\n\t\tvoid m2(List<? extends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tv"
  },
  {
    "method_id": "M3606",
    "name": "m2",
    "return_type": "void",
    "signature": "m2(List<? extends Number> e)",
    "file_id": "F113",
    "start_line": 151,
    "text_preview": "oerceableFrom(ajListOfSomethingSuperDouble));\\n\t}\\n\\n\tclass C<E extends Number> {\\n\t\tvoid m1(List<Integer> e) {\\n\t\t}\\n\\n\t\tvoid m2(List<? extends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? exten"
  },
  {
    "method_id": "M3607",
    "name": "m3",
    "return_type": "void",
    "signature": "m3(List<Number> e)",
    "file_id": "F113",
    "start_line": 154,
    "text_preview": ");\\n\t}\\n\\n\tclass C<E extends Number> {\\n\t\tvoid m1(List<Integer> e) {\\n\t\t}\\n\\n\t\tvoid m2(List<? extends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t"
  },
  {
    "method_id": "M3608",
    "name": "m4",
    "return_type": "void",
    "signature": "m4(List<?> e)",
    "file_id": "F113",
    "start_line": 157,
    "text_preview": " {\\n\t\tvoid m1(List<Integer> e) {\\n\t\t}\\n\\n\t\tvoid m2(List<? extends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t\tvoid m9(E e) {\\n\t\t}\\n\t}\\n\\n\tclass A1"
  },
  {
    "method_id": "M3609",
    "name": "m5",
    "return_type": "void",
    "signature": "m5(List<E> e)",
    "file_id": "F113",
    "start_line": 160,
    "text_preview": ") {\\n\t\t}\\n\\n\t\tvoid m2(List<? extends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t\tvoid m9(E e) {\\n\t\t}\\n\t}\\n\\n\tclass A1 {\\n\t}\\n\\n\tclass B1 extends A1 "
  },
  {
    "method_id": "M3610",
    "name": "m6",
    "return_type": "void",
    "signature": "m6(List<? extends E> e)",
    "file_id": "F113",
    "start_line": 163,
    "text_preview": "tends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t\tvoid m9(E e) {\\n\t\t}\\n\t}\\n\\n\tclass A1 {\\n\t}\\n\\n\tclass B1 extends A1 {\\n\t}\\n\\n\tclass C1 extends B1 {"
  },
  {
    "method_id": "M3611",
    "name": "m7",
    "return_type": "void",
    "signature": "m7(List<? extends List<? extends E>> e)",
    "file_id": "F113",
    "start_line": 166,
    "text_preview": "<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t\tvoid m9(E e) {\\n\t\t}\\n\t}\\n\\n\tclass A1 {\\n\t}\\n\\n\tclass B1 extends A1 {\\n\t}\\n\\n\tclass C1 extends B1 {\\n\t}\\n\\n\tclass D1 extends C1 {\\n\t}\\n\\n\tclass"
  },
  {
    "method_id": "M3612",
    "name": "m8",
    "return_type": "void",
    "signature": "m8(List e)",
    "file_id": "F113",
    "start_line": 169,
    "text_preview": "m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t\tvoid m9(E e) {\\n\t\t}\\n\t}\\n\\n\tclass A1 {\\n\t}\\n\\n\tclass B1 extends A1 {\\n\t}\\n\\n\tclass C1 extends B1 {\\n\t}\\n\\n\tclass D1 extends C1 {\\n\t}\\n\\n\tclass D2<E2 extends C1> {\\n\t\tvoid m5(List<E2> e) {\\n\t\t}\\n\t}\\n\\n\t"
  },
  {
    "method_id": "M3613",
    "name": "m9",
    "return_type": "void",
    "signature": "m9(E e)",
    "file_id": "F113",
    "start_line": 172,
    "text_preview": "id m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t\tvoid m9(E e) {\\n\t\t}\\n\t}\\n\\n\tclass A1 {\\n\t}\\n\\n\tclass B1 extends A1 {\\n\t}\\n\\n\tclass C1 extends B1 {\\n\t}\\n\\n\tclass D1 extends C1 {\\n\t}\\n\\n\tclass D2<E2 extends C1> {\\n\t\tvoid m5(List<E2> e) {\\n\t\t}\\n\t}\\n\\n\tpublic void testAssignabl"
  },
  {
    "method_id": "M3614",
    "name": "m5",
    "return_type": "void",
    "signature": "m5(List<E2> e)",
    "file_id": "F113",
    "start_line": 160,
    "text_preview": ") {\\n\t\t}\\n\\n\t\tvoid m2(List<? extends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t\tvoid m9(E e) {\\n\t\t}\\n\t}\\n\\n\tclass A1 {\\n\t}\\n\\n\tclass B1 extends A1 "
  },
  {
    "method_id": "M3615",
    "name": "testAssignable02",
    "return_type": "void",
    "signature": "testAssignable02()",
    "file_id": "F113",
    "start_line": 193,
    "text_preview": " C1 extends B1 {\\n\t}\\n\\n\tclass D1 extends C1 {\\n\t}\\n\\n\tclass D2<E2 extends C1> {\\n\t\tvoid m5(List<E2> e) {\\n\t\t}\\n\t}\\n\\n\tpublic void testAssignable02() {\\n\t\tList list = new ArrayList();\\n\t\tList arraylist = null;\\n\t\tList<String> listOfString = new ArrayList<>();\\n\t\tList<?> listOfSomething = new ArrayList<Integer>();\\n\t\tList<?> arrayListO"
  },
  {
    "method_id": "M3616",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3617",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3618",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3619",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3620",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3621",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<? extends Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3622",
    "name": "args",
    "return_type": "",
    "signature": "args(List)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3623",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3624",
    "name": "args",
    "return_type": "",
    "signature": "args(List<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3625",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3626",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<String>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3627",
    "name": "testAssignable03_method_m2",
    "return_type": "void",
    "signature": "testAssignable03_method_m2()",
    "file_id": "F113",
    "start_line": 276,
    "text_preview": "ssignableFrom(ajListOfInteger));\\n\t\tassertFalse(ajArrayListOfString.isCoerceableFrom(ajListOfInteger));\\n\t}\\n\\n\tpublic void testAssignable03_method_m2() {\\n\t\tList list = new ArrayList();\\n\t\tList arraylist = null;\\n\t\tList<String> listOfString = new ArrayList<>();\\n\t\tList<?> listOfSomething = new ArrayList<Integer>();\\n\t\tList<?> "
  },
  {
    "method_id": "M3628",
    "name": "m2",
    "return_type": "void",
    "signature": "m2(List<? extends Number> e)",
    "file_id": "F113",
    "start_line": 151,
    "text_preview": "oerceableFrom(ajListOfSomethingSuperDouble));\\n\t}\\n\\n\tclass C<E extends Number> {\\n\t\tvoid m1(List<Integer> e) {\\n\t\t}\\n\\n\t\tvoid m2(List<? extends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? exten"
  },
  {
    "method_id": "M3629",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3630",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3631",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3632",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3633",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3634",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<? extends Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3635",
    "name": "args",
    "return_type": "",
    "signature": "args(List)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3636",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3637",
    "name": "args",
    "return_type": "",
    "signature": "args(List<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3638",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3639",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<String>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3640",
    "name": "testAssignable04_method_m3",
    "return_type": "void",
    "signature": "testAssignable04_method_m3()",
    "file_id": "F113",
    "start_line": 363,
    "text_preview": "SomethingNumberish));\\n\t\tassertFalse(ajArrayListOfString.isCoerceableFrom(ajListOfSomethingNumberish));\\n\t}\\n\\n\tpublic void testAssignable04_method_m3() {\\n\t\tList list = new ArrayList();\\n\t\tArrayList arraylist = null;\\n\t\tList<String> listOfString = new ArrayList<>();\\n\t\tList<?> listOfSomething = new ArrayList<Integer>();\\n\t\tLis"
  },
  {
    "method_id": "M3641",
    "name": "m3",
    "return_type": "void",
    "signature": "m3(List<Number> e)",
    "file_id": "F113",
    "start_line": 154,
    "text_preview": ");\\n\t}\\n\\n\tclass C<E extends Number> {\\n\t\tvoid m1(List<Integer> e) {\\n\t\t}\\n\\n\t\tvoid m2(List<? extends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t"
  },
  {
    "method_id": "M3642",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3643",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3644",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3645",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3646",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3647",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<? extends Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3648",
    "name": "args",
    "return_type": "",
    "signature": "args(List)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3649",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3650",
    "name": "args",
    "return_type": "",
    "signature": "args(List<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3651",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3652",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<String>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3653",
    "name": "testAssignability_pr267559",
    "return_type": "void",
    "signature": "testAssignability_pr267559()",
    "file_id": "F113",
    "start_line": 462,
    "text_preview": "ic class ClassB<T> implements IMarker<ClassA<T>> {\\n\t}\\n\\n\tstatic class ClassC<T> implements IMarker<T> {\\n\t}\\n\\n\tpublic void testAssignability_pr267559() {\\n\t\tClassB cb = new ClassB();\\n\t\tClassB cb2 = new ClassB();\\n\\n\t\tReferenceType rcb = resolve(\"Lorg/aspectj/weaver/ReferenceTypeTestCase$ClassB;\");\\n\t\tReferenceType rcb2 = reso"
  },
  {
    "method_id": "M3654",
    "name": "testAssignable03_method_m4",
    "return_type": "void",
    "signature": "testAssignable03_method_m4()",
    "file_id": "F113",
    "start_line": 479,
    "text_preview": "org/aspectj/weaver/ReferenceTypeTestCase$ClassB;\");\\n\t\tb = rcb.isAssignableFrom(rcb2);\\n\t\tassertTrue(b);\\n\t}\\n\\n\tpublic void testAssignable03_method_m4() {\\n\t\tList list = new ArrayList();\\n\t\tList arraylist = null;\\n\t\tList<String> listOfString = new ArrayList<>();\\n\t\tList<?> listOfSomething = new ArrayList<Integer>();\\n\t\tList<?> "
  },
  {
    "method_id": "M3655",
    "name": "m4",
    "return_type": "void",
    "signature": "m4(List<?> e)",
    "file_id": "F113",
    "start_line": 157,
    "text_preview": " {\\n\t\tvoid m1(List<Integer> e) {\\n\t\t}\\n\\n\t\tvoid m2(List<? extends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t\tvoid m9(E e) {\\n\t\t}\\n\t}\\n\\n\tclass A1"
  },
  {
    "method_id": "M3656",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3657",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3658",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3659",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3660",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3661",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<? extends Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3662",
    "name": "args",
    "return_type": "",
    "signature": "args(List)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3663",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3664",
    "name": "args",
    "return_type": "",
    "signature": "args(List<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3665",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3666",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<String>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3667",
    "name": "IfaceInitList",
    "return_type": "",
    "signature": "IfaceInitList(ResolvedType onType)",
    "file_id": "F113",
    "start_line": 570,
    "text_preview": "s PartialOrder.PartialComparable {\\n\t\tfinal ResolvedType onType;\\n\t\tList<ConcreteTypeMunger> list = new ArrayList<>();\\n\\n\t\tIfaceInitList(ResolvedType onType) {\\n\t\t\tthis.onType = onType;\\n\t\t}\\n\\n\t\tpublic int compareTo(Object other) {\\n\t\t\tIfaceInitList o = (IfaceInitList) other;\\n\t\t\tif (onType.isAssignableFrom(o.onType)) {\\n\t\t\t\tre"
  },
  {
    "method_id": "M3668",
    "name": "compareTo",
    "return_type": "int",
    "signature": "compareTo(Object other)",
    "file_id": "F113",
    "start_line": 574,
    "text_preview": "ypeMunger> list = new ArrayList<>();\\n\\n\t\tIfaceInitList(ResolvedType onType) {\\n\t\t\tthis.onType = onType;\\n\t\t}\\n\\n\t\tpublic int compareTo(Object other) {\\n\t\t\tIfaceInitList o = (IfaceInitList) other;\\n\t\t\tif (onType.isAssignableFrom(o.onType)) {\\n\t\t\t\treturn +1;\\n\t\t\t} else if (o.onType.isAssignableFrom(onType)) {\\n\t\t\t\treturn -1;\\n\t\t\t} "
  },
  {
    "method_id": "M3669",
    "name": "fallbackCompareTo",
    "return_type": "int",
    "signature": "fallbackCompareTo(Object other)",
    "file_id": "F113",
    "start_line": 585,
    "text_preview": " +1;\\n\t\t\t} else if (o.onType.isAssignableFrom(onType)) {\\n\t\t\t\treturn -1;\\n\t\t\t} else {\\n\t\t\t\treturn 0;\\n\t\t\t}\\n\t\t}\\n\\n\t\tpublic int fallbackCompareTo(Object other) {\\n\t\t\treturn 0;\\n\t\t}\\n\t}\\n\\n\tpublic void testExpensiveAssignableChecks_309336() {\\n\t\tList objects = new ArrayList();\\n\t\tReferenceType rcb = resolve(\"Lorg/aspectj/weaver/Refere"
  },
  {
    "method_id": "M3670",
    "name": "testExpensiveAssignableChecks_309336",
    "return_type": "void",
    "signature": "testExpensiveAssignableChecks_309336()",
    "file_id": "F113",
    "start_line": 590,
    "text_preview": "1;\\n\t\t\t} else {\\n\t\t\t\treturn 0;\\n\t\t\t}\\n\t\t}\\n\\n\t\tpublic int fallbackCompareTo(Object other) {\\n\t\t\treturn 0;\\n\t\t}\\n\t}\\n\\n\tpublic void testExpensiveAssignableChecks_309336() {\\n\t\tList objects = new ArrayList();\\n\t\tReferenceType rcb = resolve(\"Lorg/aspectj/weaver/ReferenceTypeTestCase$Foo;\");\\n\t\tReferenceType i = (ReferenceType) rcb.getD"
  },
  {
    "method_id": "M3671",
    "name": "for",
    "return_type": "",
    "signature": "for(int loop = 0; loop < 10; loop++)",
    "file_id": "F113",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3672",
    "name": "for",
    "return_type": "",
    "signature": "for(int j = 0; j < 10; j++)",
    "file_id": "F113",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3673",
    "name": "execute",
    "return_type": "T",
    "signature": "execute(String aArg)",
    "file_id": "F113",
    "start_line": 613,
    "text_preview": "10 extends Throwable, E11 extends Throwable, E12 extends Throwable, E13 extends Throwable, E14 extends Throwable> {\\n\t\tT execute(String aArg) throws E1, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11, E12, E13, E14, RemoteException;\\n\t}\\n\\n\tpublic interface Operator13<T, E1 extends Throwable, E2 extends Throwable, E3 extends Thr"
  },
  {
    "method_id": "M3674",
    "name": "execute",
    "return_type": "String",
    "signature": "execute(String aArg)",
    "file_id": "F113",
    "start_line": 613,
    "text_preview": "10 extends Throwable, E11 extends Throwable, E12 extends Throwable, E13 extends Throwable, E14 extends Throwable> {\\n\t\tT execute(String aArg) throws E1, E2, E3, E4, E5, E6, E7, E8, E9, E10, E11, E12, E13, E14, RemoteException;\\n\t}\\n\\n\tpublic interface Operator13<T, E1 extends Throwable, E2 extends Throwable, E3 extends Thr"
  },
  {
    "method_id": "M3675",
    "name": "testAssignable_method_m5",
    "return_type": "void",
    "signature": "testAssignable_method_m5()",
    "file_id": "F113",
    "start_line": 679,
    "text_preview": ") throws NullPointerException, RemoteException {\\n\t\t\tSystem.out.println(\"Doh!\");\\n\t\t\treturn aArg;\\n\t\t}\\n\t}\\n\\n\t// public void testAssignable_method_m5() {\\n\t// List list = new ArrayList();\\n\t// ArrayList arraylist = null;\\n\t// List<String> listOfString = new ArrayList<String>();\\n\t// List<?> listOfSomething = new ArrayList<Integ"
  },
  {
    "method_id": "M3676",
    "name": "m5",
    "return_type": "void",
    "signature": "m5(List<E> e)",
    "file_id": "F113",
    "start_line": 160,
    "text_preview": ") {\\n\t\t}\\n\\n\t\tvoid m2(List<? extends Number> e) {\\n\t\t}\\n\\n\t\tvoid m3(List<Number> e) {\\n\t\t}\\n\\n\t\tvoid m4(List<?> e) {\\n\t\t}\\n\\n\t\tvoid m5(List<E> e) {\\n\t\t}\\n\\n\t\tvoid m6(List<? extends E> e) {\\n\t\t}\\n\\n\t\tvoid m7(List<? extends List<? extends E>> e) {\\n\t\t}\\n\\n\t\tvoid m8(List e) {\\n\t\t}\\n\\n\t\tvoid m9(E e) {\\n\t\t}\\n\t}\\n\\n\tclass A1 {\\n\t}\\n\\n\tclass B1 extends A1 "
  },
  {
    "method_id": "M3677",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3678",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3679",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3680",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3681",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3682",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<? extends Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3683",
    "name": "args",
    "return_type": "",
    "signature": "args(List)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3684",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3685",
    "name": "args",
    "return_type": "",
    "signature": "args(List<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3686",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3687",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<String>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3688",
    "name": "args",
    "return_type": "",
    "signature": "args(List<D1>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3689",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<D1>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3690",
    "name": "args",
    "return_type": "",
    "signature": "args(List<C1>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3691",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<C1>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3692",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends B1>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3693",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<? extends\n\t// // B1>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3694",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends C1>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3695",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<? extends\n\t// // C1>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3696",
    "name": "args",
    "return_type": "",
    "signature": "args(List)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3697",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3698",
    "name": "args",
    "return_type": "",
    "signature": "args(List<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3699",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3700",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<String>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3701",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3702",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3703",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3704",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3705",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends\n\t// // Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3706",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<? extends\n\t// // Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3707",
    "name": "args",
    "return_type": "",
    "signature": "args(List)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3708",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3709",
    "name": "args",
    "return_type": "",
    "signature": "args(List<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3710",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3711",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<String>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3712",
    "name": "args",
    "return_type": "",
    "signature": "args(List<List<Integer>>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3713",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<List<Integer>>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3714",
    "name": "args",
    "return_type": "",
    "signature": "args(List<List<Number>>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3715",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<List<Number>>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3716",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends\n\t// // List<Number>>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3717",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList< ? extends\n\t// // List<Number>>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3718",
    "name": "args",
    "return_type": "",
    "signature": "args(List< ? extends List<?\n\t// // extends Number>>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3719",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList< ? extends\n\t// // List<? extends Number>>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3720",
    "name": "args",
    "return_type": "",
    "signature": "args(List)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3721",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3722",
    "name": "args",
    "return_type": "",
    "signature": "args(List<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3723",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3724",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<List<String>>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3725",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3726",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3727",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3728",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3729",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends\n\t// // Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3730",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<? extends\n\t// // Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3731",
    "name": "args",
    "return_type": "",
    "signature": "args(List)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3732",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3733",
    "name": "args",
    "return_type": "",
    "signature": "args(List<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3734",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3735",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<String>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3736",
    "name": "args",
    "return_type": "",
    "signature": "args(List<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3737",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<Integer>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3738",
    "name": "args",
    "return_type": "",
    "signature": "args(Number)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3739",
    "name": "args",
    "return_type": "",
    "signature": "args(Integer)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3740",
    "name": "args",
    "return_type": "",
    "signature": "args(List<? extends\n\t// // Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3741",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<? extends\n\t// // Number>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3742",
    "name": "args",
    "return_type": "",
    "signature": "args(List)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3743",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3744",
    "name": "args",
    "return_type": "",
    "signature": "args(List<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3745",
    "name": "args",
    "return_type": "",
    "signature": "args(ArrayList<?>)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3746",
    "name": "args",
    "return_type": "",
    "signature": "args(String)",
    "file_id": "F113",
    "start_line": 223,
    "text_preview": "er the advice matches is based on whether what we pass at the joinpoint could\\n\t\t// be bound to the specification in the args() pointcut\\n\\n\t\t// void around(): execution(* C.m1(..)) && args(List<Integer>){} //: Should match (it does)\\n\t\tassertTrue(ajListOfInteger.isAssignableFrom(ajListOfInteger));\\n\\n\t\t// void around(): exe"
  },
  {
    "method_id": "M3747",
    "name": "resolve",
    "return_type": "ReferenceType",
    "signature": "resolve(String sig)",
    "file_id": "F113",
    "start_line": 33,
    "text_preview": "nJava5Way(true);\\n\t\tUnresolvedType javaLangClass = UnresolvedType.forName(\"java.lang.Class\");\\n\t\tResolvedType rtx = world.resolve(javaLangClass);\\n\t\tassertTrue(\"Resolves to reference type\", (rtx instanceof ReferenceType));\\n\t\tReferenceType rt = (ReferenceType) rtx;\\n\t\tassertTrue(\"java.lang.Class is raw\", rt.isRawType());\\n\t}"
  },
  {
    "method_id": "M3748",
    "name": "testBaseOnlyStaticMethod",
    "return_type": "void",
    "signature": "testBaseOnlyStaticMethod()",
    "file_id": "F114",
    "start_line": 28,
    "text_preview": "ends TestCase {\\n\\n\tWorld world;\\n\tUnresolvedType baseType;\\n\tUnresolvedType derivedType;\\n\\n\t// STATIC METHODS\\n\\n\tpublic void testBaseOnlyStaticMethod() {\\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\\n\t\t\t\t\t\t\t\t   (Modifier.PUBLIC | Modifier.STATIC),\\n\t\t\t\t\t\t\t\t   UnresolvedType.forSignature(\"V\"),\\n\t\t\t\t\t\t\t\t   \"onlyBase\""
  },
  {
    "method_id": "M3749",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember rm: foundMembers)",
    "file_id": "F114",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3750",
    "name": "testBothStaticMethod",
    "return_type": "void",
    "signature": "testBothStaticMethod()",
    "file_id": "F114",
    "start_line": 54,
    "text_preview": "t was \"+foundMembers[1]+\". All=\"+s,\"Lfluffy/Base;\",foundMembers[1].getDeclaringType().getSignature());\\n\t}\\n\\n\tpublic void testBothStaticMethod() {\\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\\n\t\t\t\t   (Modifier.PUBLIC | Modifier.STATIC),\\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\\n\t\t\t\t   \"both\",\\n\t\t\t\t   new Unresol"
  },
  {
    "method_id": "M3751",
    "name": "testDerivedStaticMethod",
    "return_type": "void",
    "signature": "testDerivedStaticMethod()",
    "file_id": "F114",
    "start_line": 76,
    "text_preview": "Members.length);\\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\\n\t}\\n\\n\tpublic void testDerivedStaticMethod() {\\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\\n\t\t\t\t   (Modifier.PUBLIC | Modifier.STATIC),\\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\\n\t\t\t\t   \"onlyDerived\",\\n\t\t\t\t   n"
  },
  {
    "method_id": "M3752",
    "name": "testBaseOnlyMethod",
    "return_type": "void",
    "signature": "testBaseOnlyMethod()",
    "file_id": "F114",
    "start_line": 100,
    "text_preview": "tEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\\n\t}\\n\\n\t// NON-STATIC METHODS\\n\\n\tpublic void testBaseOnlyMethod() {\\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\\n\t\t\t\t\t\t\t\t   Modifier.PUBLIC,\\n\t\t\t\t\t\t\t\t   UnresolvedType.forSignature(\"V\"),\\n\t\t\t\t\t\t\t\t   \"onlyBaseNonStatic\",\\n\t\t\t\t\t\t\t\t   new "
  },
  {
    "method_id": "M3753",
    "name": "testBothMethod",
    "return_type": "void",
    "signature": "testBothMethod()",
    "file_id": "F114",
    "start_line": 124,
    "text_preview": ").getSignature());\\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[1].getDeclaringType().getSignature());\\n\\n\t}\\n\\n\tpublic void testBothMethod() {\\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\\n\t\t\t\t   Modifier.PUBLIC, UnresolvedType.forSignature(\"V\"),\\n\t\t\t\t   \"bothNonStatic\", UnresolvedType.NONE);\\n\t\tResolvedMember[] f"
  },
  {
    "method_id": "M3754",
    "name": "testDerivedMethod",
    "return_type": "void",
    "signature": "testDerivedMethod()",
    "file_id": "F114",
    "start_line": 141,
    "text_preview": "().getSignature());\\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[1].getDeclaringType().getSignature());\\n\t}\\n\\n\tpublic void testDerivedMethod() {\\n\t\tMember toFind = new MemberImpl(Member.METHOD,baseType,\\n\t\t\t\t   Modifier.PUBLIC,\\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\\n\t\t\t\t   \"onlyDerivedNonStatic\",\\n\t\t\t\t   new UnresolvedType"
  },
  {
    "method_id": "M3755",
    "name": "testChangingThrowsClause",
    "return_type": "void",
    "signature": "testChangingThrowsClause()",
    "file_id": "F114",
    "start_line": 163,
    "text_preview": "Members.length);\\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\\n\t}\\n\\n\tpublic void testChangingThrowsClause() {\\n\t\tMember toFind = new MemberImpl(Member.METHOD,derivedType,\\n\t\t\t\t   Modifier.PUBLIC,\\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\\n\t\t\t\t   \"m\",\\n\t\t\t\t   new UnresolvedType[0]\\n\t\t\t\t "
  },
  {
    "method_id": "M3756",
    "name": "testNoWalkUpMatchingConstructor",
    "return_type": "void",
    "signature": "testNoWalkUpMatchingConstructor()",
    "file_id": "F114",
    "start_line": 182,
    "text_preview": "\\n\t\tassertEquals(\"doesn't throw anything\",0,foundMembers[0].getExceptions().length);\\n\t}\\n\\n\t// CONSTRUCTORS\\n\\n\t public void testNoWalkUpMatchingConstructor() {\\n\t\tMember toFind = new MemberImpl(Member.CONSTRUCTOR,derivedType,\\n\t\t\t\t   Modifier.PUBLIC,\\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\\n\t\t\t\t   \"<init>\",\\n\t\t\t\t   new Unreso"
  },
  {
    "method_id": "M3757",
    "name": "testNoWalkUpNoMatchingConstructor",
    "return_type": "void",
    "signature": "testNoWalkUpNoMatchingConstructor()",
    "file_id": "F114",
    "start_line": 194,
    "text_preview": "mbers.length);\\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\\n\t }\\n\\n\t public void testNoWalkUpNoMatchingConstructor() {\\n\t\tMember toFind = new MemberImpl(Member.CONSTRUCTOR,derivedType,\\n\t\t\t\t   Modifier.PUBLIC,\\n\t\t\t\t   UnresolvedType.forSignature(\"V\"),\\n\t\t\t\t   \"<init>\",\\n\t\t\t\t   new Unre"
  },
  {
    "method_id": "M3758",
    "name": "testBaseOnlyField",
    "return_type": "void",
    "signature": "testBaseOnlyField()",
    "file_id": "F114",
    "start_line": 207,
    "text_preview": "etJoinPointSignatures(toFind, world);\\n\t\tassertEquals(\"No matches\",0,foundMembers.length);\\n\t }\\n\\n\t// FIELDS\\n\\n\tpublic void testBaseOnlyField() {\\n\t\tMember toFind = new MemberImpl(Member.FIELD,baseType,\\n\t\t\t\t\t\t\t\t   Modifier.PUBLIC,\\n\t\t\t\t\t\t\t\t   UnresolvedType.forSignature(\"I\"),\\n\t\t\t\t\t\t\t\t   \"onlyBase\",\\n\t\t\t\t\t\t\t\t   new UnresolvedT"
  },
  {
    "method_id": "M3759",
    "name": "testBothField",
    "return_type": "void",
    "signature": "testBothField()",
    "file_id": "F114",
    "start_line": 230,
    "text_preview": "().getSignature());\\n\t\tassertEquals(\"Lfluffy/Base;\",foundMembers[1].getDeclaringType().getSignature());\\n\t}\\n\\n\tpublic void testBothField() {\\n\t\tMember toFind = new MemberImpl(Member.FIELD,baseType,\\n\t\t\t\t   Modifier.PUBLIC,\\n\t\t\t\t   UnresolvedType.forSignature(\"I\"),\\n\t\t\t\t   \"both\",\\n\t\t\t\t   new UnresolvedType[0]\\n\t\t\t\t   );\\n\t\tResol"
  },
  {
    "method_id": "M3760",
    "name": "testDerivedField",
    "return_type": "void",
    "signature": "testDerivedField()",
    "file_id": "F114",
    "start_line": 252,
    "text_preview": "Members.length);\\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\\n\t}\\n\\n\tpublic void testDerivedField() {\\n\t\tMember toFind = new MemberImpl(Member.FIELD,baseType,\\n\t\t\t\t   Modifier.PUBLIC,\\n\t\t\t\t   UnresolvedType.forSignature(\"I\"),\\n\t\t\t\t   \"onlyDerived\",\\n\t\t\t\t   new UnresolvedType[0]\\n\t\t\t\t   "
  },
  {
    "method_id": "M3761",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F114",
    "start_line": 274,
    "text_preview": "bers.length);\\n\t\tassertEquals(\"Lfluffy/Derived;\",foundMembers[0].getDeclaringType().getSignature());\\n\t}\\n\\n\tprotected void setUp() throws Exception {\\n\t\tworld = new BcelWorld();\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tbaseType = UnresolvedType.forSignature(\"Lfluffy/Base;\");\\n\t\tderivedType = UnresolvedType.forSignature(\"Lfluffy"
  },
  {
    "method_id": "M3762",
    "name": "TestShadow",
    "return_type": "",
    "signature": "TestShadow(Kind kind, Member signature, UnresolvedType thisType, World world)",
    "file_id": "F115",
    "start_line": 23,
    "text_preview": "\\npublic class TestShadow extends Shadow {\\n\\n\tprivate final World world;\\n\tprivate final UnresolvedType thisType;\\n\\n\tpublic TestShadow(Kind kind, Member signature, UnresolvedType thisType, World world) {\\n\t\tsuper(kind, signature, null);\\n\t\tthis.world = world;\\n\t\tthis.thisType = thisType;\\n\t}\\n\\n\tpublic World getIWorld() {\\n\t\tretu"
  },
  {
    "method_id": "M3763",
    "name": "getIWorld",
    "return_type": "World",
    "signature": "getIWorld()",
    "file_id": "F115",
    "start_line": 29,
    "text_preview": "ype, World world) {\\n\t\tsuper(kind, signature, null);\\n\t\tthis.world = world;\\n\t\tthis.thisType = thisType;\\n\t}\\n\\n\tpublic World getIWorld() {\\n\t\treturn world;\\n\t}\\n\\n\t/** this is subtly wrong. ha ha */\\n\tpublic UnresolvedType getEnclosingType() {\\n\t\treturn thisType;\\n\t}\\n\\n\tpublic Var getThisVar() {\\n\t\t// we should thorw if we don't hav"
  },
  {
    "method_id": "M3764",
    "name": "getEnclosingType",
    "return_type": "UnresolvedType",
    "signature": "getEnclosingType()",
    "file_id": "F115",
    "start_line": 34,
    "text_preview": "hisType;\\n\t}\\n\\n\tpublic World getIWorld() {\\n\t\treturn world;\\n\t}\\n\\n\t/** this is subtly wrong. ha ha */\\n\tpublic UnresolvedType getEnclosingType() {\\n\t\treturn thisType;\\n\t}\\n\\n\tpublic Var getThisVar() {\\n\t\t// we should thorw if we don't have a this\\n\t\treturn new Var(getThisType().resolve(world));\\n\t}\\n\\n\tpublic Var getTargetVar() {\\n\t\ti"
  },
  {
    "method_id": "M3765",
    "name": "getThisVar",
    "return_type": "Var",
    "signature": "getThisVar()",
    "file_id": "F115",
    "start_line": 38,
    "text_preview": "\\n\t}\\n\\n\t/** this is subtly wrong. ha ha */\\n\tpublic UnresolvedType getEnclosingType() {\\n\t\treturn thisType;\\n\t}\\n\\n\tpublic Var getThisVar() {\\n\t\t// we should thorw if we don't have a this\\n\t\treturn new Var(getThisType().resolve(world));\\n\t}\\n\\n\tpublic Var getTargetVar() {\\n\t\tif (!hasTarget())\\n\t\t\tthrow new RuntimeException(\"bad\");\\n\t"
  },
  {
    "method_id": "M3766",
    "name": "getTargetVar",
    "return_type": "Var",
    "signature": "getTargetVar()",
    "file_id": "F115",
    "start_line": 43,
    "text_preview": "hisVar() {\\n\t\t// we should thorw if we don't have a this\\n\t\treturn new Var(getThisType().resolve(world));\\n\t}\\n\\n\tpublic Var getTargetVar() {\\n\t\tif (!hasTarget())\\n\t\t\tthrow new RuntimeException(\"bad\");\\n\t\treturn new Var(getTargetType().resolve(world));\\n\t}\\n\\n\tpublic Var getArgVar(int i) {\\n\t\treturn new Var(getArgType(i).resolve(w"
  },
  {
    "method_id": "M3767",
    "name": "getArgVar",
    "return_type": "Var",
    "signature": "getArgVar(int i)",
    "file_id": "F115",
    "start_line": 49,
    "text_preview": " (!hasTarget())\\n\t\t\tthrow new RuntimeException(\"bad\");\\n\t\treturn new Var(getTargetType().resolve(world));\\n\t}\\n\\n\tpublic Var getArgVar(int i) {\\n\t\treturn new Var(getArgType(i).resolve(world));\\n\t}\\n\\n\tpublic Var getThisEnclosingJoinPointStaticPartVar() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Var getThisJoin"
  },
  {
    "method_id": "M3768",
    "name": "getThisEnclosingJoinPointStaticPartVar",
    "return_type": "Var",
    "signature": "getThisEnclosingJoinPointStaticPartVar()",
    "file_id": "F115",
    "start_line": 53,
    "text_preview": "e().resolve(world));\\n\t}\\n\\n\tpublic Var getArgVar(int i) {\\n\t\treturn new Var(getArgType(i).resolve(world));\\n\t}\\n\\n\tpublic Var getThisEnclosingJoinPointStaticPartVar() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Var getThisJoinPointStaticPartVar() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic V"
  },
  {
    "method_id": "M3769",
    "name": "getThisJoinPointStaticPartVar",
    "return_type": "Var",
    "signature": "getThisJoinPointStaticPartVar()",
    "file_id": "F115",
    "start_line": 57,
    "text_preview": "\\n\\n\tpublic Var getThisEnclosingJoinPointStaticPartVar() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Var getThisJoinPointStaticPartVar() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Var getThisAspectInstanceVar(ResolvedType aspectType) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n"
  },
  {
    "method_id": "M3770",
    "name": "getThisAspectInstanceVar",
    "return_type": "Var",
    "signature": "getThisAspectInstanceVar(ResolvedType aspectType)",
    "file_id": "F115",
    "start_line": 61,
    "text_preview": "ted\");\\n\t}\\n\\n\tpublic Var getThisJoinPointStaticPartVar() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Var getThisAspectInstanceVar(ResolvedType aspectType) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Var getThisJoinPointVar() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic IS"
  },
  {
    "method_id": "M3771",
    "name": "getThisJoinPointVar",
    "return_type": "Var",
    "signature": "getThisJoinPointVar()",
    "file_id": "F115",
    "start_line": 65,
    "text_preview": " Var getThisAspectInstanceVar(ResolvedType aspectType) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Var getThisJoinPointVar() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic ISourceLocation getSourceLocation() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Member getEnclosingC"
  },
  {
    "method_id": "M3772",
    "name": "getSourceLocation",
    "return_type": "ISourceLocation",
    "signature": "getSourceLocation()",
    "file_id": "F115",
    "start_line": 69,
    "text_preview": "d\");\\n\t}\\n\\n\tpublic Var getThisJoinPointVar() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic ISourceLocation getSourceLocation() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Member getEnclosingCodeSignature() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @"
  },
  {
    "method_id": "M3773",
    "name": "getEnclosingCodeSignature",
    "return_type": "Member",
    "signature": "getEnclosingCodeSignature()",
    "file_id": "F115",
    "start_line": 73,
    "text_preview": "\");\\n\t}\\n\\n\tpublic ISourceLocation getSourceLocation() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\tpublic Member getEnclosingCodeSignature() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weaver.Shadow#getKindedAnnotationVar()\\n\t */\\n\tpublic Var getKindedAnnotat"
  },
  {
    "method_id": "M3774",
    "name": "getKindedAnnotationVar",
    "return_type": "Var",
    "signature": "getKindedAnnotationVar(UnresolvedType annotationType)",
    "file_id": "F115",
    "start_line": 80,
    "text_preview": "ure() {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weaver.Shadow#getKindedAnnotationVar()\\n\t */\\n\tpublic Var getKindedAnnotationVar(UnresolvedType annotationType) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weav"
  },
  {
    "method_id": "M3775",
    "name": "getWithinAnnotationVar",
    "return_type": "Var",
    "signature": "getWithinAnnotationVar(UnresolvedType annotationType)",
    "file_id": "F115",
    "start_line": 89,
    "text_preview": "Type) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weaver.Shadow#getWithinAnnotationVar()\\n\t */\\n\tpublic Var getWithinAnnotationVar(UnresolvedType annotationType) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weav"
  },
  {
    "method_id": "M3776",
    "name": "getWithinCodeAnnotationVar",
    "return_type": "Var",
    "signature": "getWithinCodeAnnotationVar(UnresolvedType annotationType)",
    "file_id": "F115",
    "start_line": 98,
    "text_preview": "Type) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weaver.Shadow#getWithinCodeAnnotationVar()\\n\t */\\n\tpublic Var getWithinCodeAnnotationVar(UnresolvedType annotationType) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspe"
  },
  {
    "method_id": "M3777",
    "name": "getThisAnnotationVar",
    "return_type": "Var",
    "signature": "getThisAnnotationVar(UnresolvedType annotationType)",
    "file_id": "F115",
    "start_line": 107,
    "text_preview": "Type) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weaver.Shadow#getThisAnnotationVar()\\n\t */\\n\tpublic Var getThisAnnotationVar(UnresolvedType annotationType) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weaver.S"
  },
  {
    "method_id": "M3778",
    "name": "getTargetAnnotationVar",
    "return_type": "Var",
    "signature": "getTargetAnnotationVar(UnresolvedType annotationType)",
    "file_id": "F115",
    "start_line": 116,
    "text_preview": "Type) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weaver.Shadow#getTargetAnnotationVar()\\n\t */\\n\tpublic Var getTargetAnnotationVar(UnresolvedType annotationType) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weav"
  },
  {
    "method_id": "M3779",
    "name": "getArgAnnotationVar",
    "return_type": "Var",
    "signature": "getArgAnnotationVar(int i, UnresolvedType annotationType)",
    "file_id": "F115",
    "start_line": 125,
    "text_preview": "Type) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n\t/*\\n\t * (non-Javadoc)\\n\t *\\n\t * @see org.aspectj.weaver.Shadow#getArgAnnotationVar(int)\\n\t */\\n\tpublic Var getArgAnnotationVar(int i, UnresolvedType annotationType) {\\n\t\tthrow new RuntimeException(\"unimplemented\");\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3780",
    "name": "testGetTraceFactory",
    "return_type": "void",
    "signature": "testGetTraceFactory()",
    "file_id": "F116",
    "start_line": 20,
    "text_preview": "r.tools.TraceFactory;\\n\\nimport junit.framework.TestCase;\\n\\npublic class TraceFactoryTest extends TestCase {\\n\\n\tpublic void testGetTraceFactory() {\\n\t\tTraceFactory traceFactory = TraceFactory.getTraceFactory();\\n\t\tassertNotNull(traceFactory);\\n\t}\\n\\n\tpublic void testGetTrace() {\\n\t\tTraceFactory traceFactory = TraceFactory.getTra"
  },
  {
    "method_id": "M3781",
    "name": "testGetTrace",
    "return_type": "void",
    "signature": "testGetTrace()",
    "file_id": "F116",
    "start_line": 25,
    "text_preview": "ctory() {\\n\t\tTraceFactory traceFactory = TraceFactory.getTraceFactory();\\n\t\tassertNotNull(traceFactory);\\n\t}\\n\\n\tpublic void testGetTrace() {\\n\t\tTraceFactory traceFactory = TraceFactory.getTraceFactory();\\n\t\tTrace trace = traceFactory.getTrace(getClass());\\n\t\tassertNotNull(trace);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3782",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F117",
    "start_line": 33,
    "text_preview": "BoundedReferenceType superClass;\\n\tBoundedReferenceType extendsWithExtras;\\n\tBcelWorld world;\\n\\n\t@Override\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tworld = new BcelWorld(\"../bin\");\\n\t\tworld.setBehaveInJava5Way(true);\\n\t\tjavaLangClass = (ReferenceType) world.resolve(UnresolvedType.forName(\"java/lang/Clas"
  },
  {
    "method_id": "M3783",
    "name": "testConstructionByNameAndVariable",
    "return_type": "void",
    "signature": "testConstructionByNameAndVariable()",
    "file_id": "F117",
    "start_line": 46,
    "text_preview": "new ReferenceType[] { (ReferenceType) world\\n\t\t\t\t.resolve(UnresolvedType.forName(\"java/util/List\")) });\\n\t}\\n\\n\tpublic void testConstructionByNameAndVariable() {\\n\t\tTypeVariable tv = new TypeVariable(\"T\", javaLangClass);\\n\t\tTypeVariableReferenceType tvrt = new TypeVariableReferenceType(tv, world);\\n\t\tassertEquals(\"T\", tvrt.ge"
  },
  {
    "method_id": "M3784",
    "name": "testBounds",
    "return_type": "void",
    "signature": "testBounds()",
    "file_id": "F117",
    "start_line": 53,
    "text_preview": "t.getTypeVariable().getName());\\n\t\tassertEquals(javaLangClass, tvrt.getTypeVariable().getUpperBound());\\n\t}\\n\\n\tpublic void testBounds() {\\n\t\t// Load up the testclass from below\\n\t\tResolvedType testerClass = world.resolve(Tester1.class.getName());\\n\t\tResolvedType genericTesterClass = testerClass.getGenericType();\\n\\n\t\t// Check "
  },
  {
    "method_id": "M3785",
    "name": "method",
    "return_type": "void",
    "signature": "method(T t)",
    "file_id": "F117",
    "start_line": 77,
    "text_preview": "ertEquals(jlNumber, tvReference.getDelegate().getResolvedTypeX());\\n\t}\\n\\n\tclass Tester1<T extends Number> {\\n\t\tpublic void method(T t) {\\n\t\t}\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3786",
    "name": "testName",
    "return_type": "void",
    "signature": "testName()",
    "file_id": "F118",
    "start_line": 26,
    "text_preview": ";\\n\tprivate UnresolvedType javaUtilList;\\n\tprivate UnresolvedType javaIoSerializable;\\n\tprivate World world;\\n\\n\tpublic void testName() {\\n\t\tTypeVariable tv = new TypeVariable(\"T\");\\n\t\tassertEquals(\"T\", tv.getName());\\n\t}\\n\\n\tpublic void testDefaultBounds() {\\n\t\tTypeVariable tv = new TypeVariable(\"T\");\\n\t\tassertEquals(\"Object\", Un"
  },
  {
    "method_id": "M3787",
    "name": "testDefaultBounds",
    "return_type": "void",
    "signature": "testDefaultBounds()",
    "file_id": "F118",
    "start_line": 31,
    "text_preview": "public void testName() {\\n\t\tTypeVariable tv = new TypeVariable(\"T\");\\n\t\tassertEquals(\"T\", tv.getName());\\n\t}\\n\\n\tpublic void testDefaultBounds() {\\n\t\tTypeVariable tv = new TypeVariable(\"T\");\\n\t\tassertEquals(\"Object\", UnresolvedType.OBJECT, tv.getFirstBound());\\n\t\tassertNull(tv.getUpperBound());\\n\t\tassertEquals(\"no additional bo"
  },
  {
    "method_id": "M3788",
    "name": "testUpperBound",
    "return_type": "void",
    "signature": "testUpperBound()",
    "file_id": "F118",
    "start_line": 38,
    "text_preview": "rtNull(tv.getUpperBound());\\n\t\tassertEquals(\"no additional bounds\", 0, tv.getSuperInterfaces().length);\\n\t}\\n\\n\tpublic void testUpperBound() {\\n\t\tTypeVariable tv = new TypeVariable(\"N\", javaLangNumber);\\n\t\tassertEquals(\"java.lang.Number\", javaLangNumber, tv.getUpperBound());\\n\t}\\n\\n\tpublic void testAdditionalUpperBounds() {\\n\t\tT"
  },
  {
    "method_id": "M3789",
    "name": "testAdditionalUpperBounds",
    "return_type": "void",
    "signature": "testAdditionalUpperBounds()",
    "file_id": "F118",
    "start_line": 43,
    "text_preview": "Variable(\"N\", javaLangNumber);\\n\t\tassertEquals(\"java.lang.Number\", javaLangNumber, tv.getUpperBound());\\n\t}\\n\\n\tpublic void testAdditionalUpperBounds() {\\n\t\tTypeVariable tv = new TypeVariable(\"E\", UnresolvedType.OBJECT, new UnresolvedType[] { javaUtilList });\\n\t\tassertEquals(\"1 additional bound\", 1, tv.getSuperInterfaces().l"
  },
  {
    "method_id": "M3790",
    "name": "testResolution",
    "return_type": "void",
    "signature": "testResolution()",
    "file_id": "F118",
    "start_line": 53,
    "text_preview": "SuperInterfaces().length);\\n\t\tassertEquals(\"java.util.List\", javaUtilList, tv.getSuperInterfaces()[0]);\\n\t}\\n\\n\tpublic void testResolution() {\\n\t\tTypeVariable tv = new TypeVariable(\"T\", javaLangNumber, new UnresolvedType[] { javaUtilList });\\n\t\ttv.resolve(world);\\n\t\tassertEquals(\"resolved number\", javaLangNumber.resolve(world"
  },
  {
    "method_id": "M3791",
    "name": "testBindWithoutResolve",
    "return_type": "void",
    "signature": "testBindWithoutResolve()",
    "file_id": "F118",
    "start_line": 60,
    "text_preview": "perBound());\\n\t\tassertEquals(\"resolved list\", javaUtilList.resolve(world), tv.getSuperInterfaces()[0]);\\n\t}\\n\\n\tpublic void testBindWithoutResolve() {\\n\t\tTypeVariable tv = new TypeVariable(\"X\");\\n\t\ttry {\\n\t\t\ttv.canBeBoundTo(null);\\n\t\t\tfail(\"Should throw illegal state exception\");\\n\t\t} catch (IllegalStateException ex) {\\n\t\t}\\n\t}\\n\\n"
  },
  {
    "method_id": "M3792",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IllegalStateException ex)",
    "file_id": "F118",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3793",
    "name": "testCanBindToUpperMatch",
    "return_type": "void",
    "signature": "testCanBindToUpperMatch()",
    "file_id": "F118",
    "start_line": 69,
    "text_preview": "dTo(null);\\n\t\t\tfail(\"Should throw illegal state exception\");\\n\t\t} catch (IllegalStateException ex) {\\n\t\t}\\n\t}\\n\\n\tpublic void testCanBindToUpperMatch() {\\n\t\tTypeVariable tv = new TypeVariable(\"X\", javaLangNumber);\\n\t\ttv.resolve(world);\\n\t\tassertTrue(tv.canBeBoundTo(javaLangDouble.resolve(world)));\\n\t}\\n\\n\tpublic void testCanBindTo"
  },
  {
    "method_id": "M3794",
    "name": "testCanBindToUpperFail",
    "return_type": "void",
    "signature": "testCanBindToUpperFail()",
    "file_id": "F118",
    "start_line": 75,
    "text_preview": "\", javaLangNumber);\\n\t\ttv.resolve(world);\\n\t\tassertTrue(tv.canBeBoundTo(javaLangDouble.resolve(world)));\\n\t}\\n\\n\tpublic void testCanBindToUpperFail() {\\n\t\tTypeVariable tv = new TypeVariable(\"X\", javaLangNumber);\\n\t\ttv.resolve(world);\\n\t\tassertFalse(tv.canBeBoundTo(UnresolvedType.OBJECT.resolve(world)));\\n\t}\\n\\n\tpublic void testCa"
  },
  {
    "method_id": "M3795",
    "name": "testCanBindToInterfaceMatch",
    "return_type": "void",
    "signature": "testCanBindToInterfaceMatch()",
    "file_id": "F118",
    "start_line": 81,
    "text_preview": "angNumber);\\n\t\ttv.resolve(world);\\n\t\tassertFalse(tv.canBeBoundTo(UnresolvedType.OBJECT.resolve(world)));\\n\t}\\n\\n\tpublic void testCanBindToInterfaceMatch() {\\n\t\tTypeVariable tv = new TypeVariable(\"T\", javaLangNumber, new UnresolvedType[] { javaIoSerializable });\\n\t\ttv.resolve(world);\\n\t\tassertTrue(tv.canBeBoundTo(javaLangDouble"
  },
  {
    "method_id": "M3796",
    "name": "testCanBindToInterfaceFail",
    "return_type": "void",
    "signature": "testCanBindToInterfaceFail()",
    "file_id": "F118",
    "start_line": 87,
    "text_preview": "aIoSerializable });\\n\t\ttv.resolve(world);\\n\t\tassertTrue(tv.canBeBoundTo(javaLangDouble.resolve(world)));\\n\t}\\n\\n\tpublic void testCanBindToInterfaceFail() {\\n\t\tTypeVariable tv = new TypeVariable(\"T\", javaLangNumber, new UnresolvedType[] { javaUtilList });\\n\t\ttv.resolve(world);\\n\t\tassertFalse(tv.canBeBoundTo(javaLangDouble.resol"
  },
  {
    "method_id": "M3797",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F118",
    "start_line": 96,
    "text_preview": ".resolve(world);\\n\t\tassertFalse(tv.canBeBoundTo(javaLangDouble.resolve(world)));\\n\t}\\n\\n\t// ---\\n\\n\t@Override\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tjavaLangNumber = UnresolvedType.forSignature(\"Ljava/lang/Number;\");\\n\t\tjavaLangDouble = UnresolvedType.forSignature(\"Ljava/lang/Double;\");\\n\t\tjavaIoSerializ"
  },
  {
    "method_id": "M3798",
    "name": "tearDown",
    "return_type": "void",
    "signature": "tearDown()",
    "file_id": "F118",
    "start_line": 106,
    "text_preview": "vaUtilList = UnresolvedType.forSignature(\"Ljava/util/List;\");\\n\t\tworld = new BcelWorld();\\n\t}\\n\\n\t@Override\\n\tprotected void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3799",
    "name": "TypeXTestCase",
    "return_type": "",
    "signature": "TypeXTestCase(String name)",
    "file_id": "F119",
    "start_line": 26,
    "text_preview": "he portions of UnresolvedType that don't require a world.\\n */\\npublic class TypeXTestCase extends TestCase {\\n\\n    public TypeXTestCase(String name) {\\n        super(name);\\n    }\\n\\n    public void testUnresolvedTypes() {\\n        // basic equality\\n        String[] testNames =\\n            new String[] {\"int\", \"long\", \"int[]\""
  },
  {
    "method_id": "M3800",
    "name": "testUnresolvedTypes",
    "return_type": "void",
    "signature": "testUnresolvedTypes()",
    "file_id": "F119",
    "start_line": 30,
    "text_preview": "s TypeXTestCase extends TestCase {\\n\\n    public TypeXTestCase(String name) {\\n        super(name);\\n    }\\n\\n    public void testUnresolvedTypes() {\\n        // basic equality\\n        String[] testNames =\\n            new String[] {\"int\", \"long\", \"int[]\", \"boolean[][]\",\\n                           \"java.lang.String\", \"java.lan"
  },
  {
    "method_id": "M3801",
    "name": "testNameAndSigWithInners",
    "return_type": "void",
    "signature": "testNameAndSigWithInners()",
    "file_id": "F119",
    "start_line": 58,
    "text_preview": "estSigs), sizes);\\n\\n        isPrimitiveTest(UnresolvedType.forSignatures(testSigs), isPrimitive);\\n    }\\n\\n    public void testNameAndSigWithInners() {\\n    \tUnresolvedType t = UnresolvedType.forName(\"java.util.Map$Entry\");\\n    \tassertEquals(t.getName(), \"java.util.Map$Entry\");\\n    \tassertEquals(t.getSignature(), \"Ljava/ut"
  },
  {
    "method_id": "M3802",
    "name": "testNameAndSigWithParameters",
    "return_type": "void",
    "signature": "testNameAndSigWithParameters()",
    "file_id": "F119",
    "start_line": 66,
    "text_preview": "resolvedType.forName(\"java.util.Map\").getOutermostType(), UnresolvedType.forName(\"java.util.Map\"));\\n    }\\n\\n\tpublic void testNameAndSigWithParameters() {\\n\t\tUnresolvedType t = UnresolvedType.forName(\"java.util.List<java.lang.String>\");\\n\t\tassertEquals(t.getName(),\"java.util.List<java.lang.String>\");\\n\t\tassertEquals(t.getSi"
  },
  {
    "method_id": "M3803",
    "name": "testTypexGenericSignatureProcessing",
    "return_type": "void",
    "signature": "testTypexGenericSignatureProcessing()",
    "file_id": "F119",
    "start_line": 92,
    "text_preview": "alse #params=0\\n     *     UnresolvedType:  signature=Ljava/lang/String; parameterized=false #params=0\\n\t */\\n\tpublic void testTypexGenericSignatureProcessing() {\\n\t\tUnresolvedType tx = null;\\n\\n\t\ttx = UnresolvedType.forSignature(\"Pjava/util/Set<Ljava/lang/String;>;\");\\n\t\tcheckTX(tx,true,1);\\n\\n\t\ttx = UnresolvedType.forSignatur"
  },
  {
    "method_id": "M3804",
    "name": "testTypeXForParameterizedTypes",
    "return_type": "void",
    "signature": "testTypeXForParameterizedTypes()",
    "file_id": "F119",
    "start_line": 108,
    "text_preview": "ameters()[0],true,1);\\n\t\tcheckTX(tx.getTypeParameters()[1],false,0);\\n//\t\tSystem.err.println(tx.dump());\\n\t}\\n\\n\tpublic void testTypeXForParameterizedTypes() {\\n\t\tWorld world = new BcelWorld();\\n\t\tUnresolvedType stringType = UnresolvedType.forName(\"java/lang/String\");\\n\t\tResolvedType listOfStringType =\\n\t\t\tTypeFactory.createPar"
  },
  {
    "method_id": "M3805",
    "name": "testTypeFactoryForParameterizedTypes",
    "return_type": "void",
    "signature": "testTypeFactoryForParameterizedTypes()",
    "file_id": "F119",
    "start_line": 122,
    "text_preview": "\t\tassertTrue(listOfStringType.isParameterizedType());\\n\t\tassertFalse(listOfStringType.isGenericType());\\n\t}\\n\\n\tpublic void testTypeFactoryForParameterizedTypes() {\\n\t\tUnresolvedType enumOfSimpleType =\\n\t\t\tTypeFactory.createTypeFromSignature(\"Pjava/lang/Enum<Ljava/lang/String;>;\");\\n\t\tassertEquals(1, enumOfSimpleType.getTypeP"
  },
  {
    "method_id": "M3806",
    "name": "checkTX",
    "return_type": "void",
    "signature": "checkTX(UnresolvedType tx,boolean shouldBeParameterized,int numberOfTypeParameters)",
    "file_id": "F119",
    "start_line": 96,
    "text_preview": "rocessing() {\\n\t\tUnresolvedType tx = null;\\n\\n\t\ttx = UnresolvedType.forSignature(\"Pjava/util/Set<Ljava/lang/String;>;\");\\n\t\tcheckTX(tx,true,1);\\n\\n\t\ttx = UnresolvedType.forSignature(\"Pjava/util/Set<Pjava/util/List<Ljava/lang/String;>;>;\");\\n\t\tcheckTX(tx,true,1);\\n\\n\t\ttx = UnresolvedType.forSignature(\"Pjava/util/Map<Pjava/util/L"
  },
  {
    "method_id": "M3807",
    "name": "if",
    "return_type": "",
    "signature": "if(numberOfTypeParameters==0)",
    "file_id": "F119",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3808",
    "name": "isPrimitiveTest",
    "return_type": "void",
    "signature": "isPrimitiveTest(UnresolvedType[] types, boolean[] isPrimitives)",
    "file_id": "F119",
    "start_line": 55,
    "text_preview": "t(UnresolvedType.forNames(testNames), sizes);\\n        sizeTest(UnresolvedType.forSignatures(testSigs), sizes);\\n\\n        isPrimitiveTest(UnresolvedType.forSignatures(testSigs), isPrimitive);\\n    }\\n\\n    public void testNameAndSigWithInners() {\\n    \tUnresolvedType t = UnresolvedType.forName(\"java.util.Map$Entry\");\\n    \tas"
  },
  {
    "method_id": "M3809",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = types.length; i < len; i++)",
    "file_id": "F119",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3810",
    "name": "sizeTest",
    "return_type": "void",
    "signature": "sizeTest(UnresolvedType[] types, int[] sizes)",
    "file_id": "F119",
    "start_line": 52,
    "text_preview": "rNames(testNames), componentNames);\\n        arrayTest(UnresolvedType.forSignatures(testSigs), componentNames);\\n\\n        sizeTest(UnresolvedType.forNames(testNames), sizes);\\n        sizeTest(UnresolvedType.forSignatures(testSigs), sizes);\\n\\n        isPrimitiveTest(UnresolvedType.forSignatures(testSigs), isPrimitive);\\n   "
  },
  {
    "method_id": "M3811",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = types.length; i < len; i++)",
    "file_id": "F119",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3812",
    "name": "arrayTest",
    "return_type": "void",
    "signature": "arrayTest(UnresolvedType[] types, String[] components)",
    "file_id": "F119",
    "start_line": 49,
    "text_preview": "ew boolean[] { true, true, false, false, false, false, true };\\n\\n        nameSignatureTest(testNames, testSigs);\\n        arrayTest(UnresolvedType.forNames(testNames), componentNames);\\n        arrayTest(UnresolvedType.forSignatures(testSigs), componentNames);\\n\\n        sizeTest(UnresolvedType.forNames(testNames), sizes);\\n"
  },
  {
    "method_id": "M3813",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = types.length; i < len; i++)",
    "file_id": "F119",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3814",
    "name": "nameSignatureTest",
    "return_type": "void",
    "signature": "nameSignatureTest(String[] ns, String[] ss)",
    "file_id": "F119",
    "start_line": 48,
    "text_preview": ";\\n\\n        boolean[] isPrimitive =\\n            new boolean[] { true, true, false, false, false, false, true };\\n\\n        nameSignatureTest(testNames, testSigs);\\n        arrayTest(UnresolvedType.forNames(testNames), componentNames);\\n        arrayTest(UnresolvedType.forSignatures(testSigs), componentNames);\\n\\n        sizeT"
  },
  {
    "method_id": "M3815",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0, len = ns.length; i < len; i++)",
    "file_id": "F119",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3816",
    "name": "for",
    "return_type": "",
    "signature": "for(int j = 0; j < len; j++)",
    "file_id": "F119",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3817",
    "name": "testAllMessagesDefined",
    "return_type": "void",
    "signature": "testAllMessagesDefined()",
    "file_id": "F120",
    "start_line": 25,
    "text_preview": "mework.TestCase;\\n\\n/**\\n * @author Adrian Colyer\\n */\\npublic class WeaverMessagesTestCase extends TestCase {\\n\\n\tpublic void testAllMessagesDefined() {\\n\\n\t\tClass<?> wmClass = WeaverMessages.class;\\n\t\tField[] fields = wmClass.getDeclaredFields();\\n\t\tList<String> fieldList = new ArrayList<>();\\n\t\tfor (Field f : fields) {\\n\t\t\tif (f"
  },
  {
    "method_id": "M3818",
    "name": "for",
    "return_type": "",
    "signature": "for(Field f : fields)",
    "file_id": "F120",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3819",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IllegalAccessException ex)",
    "file_id": "F120",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3820",
    "name": "catch",
    "return_type": "",
    "signature": "catch(MissingResourceException mrEx)",
    "file_id": "F120",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3821",
    "name": "suite",
    "return_type": "Test",
    "signature": "suite()",
    "file_id": "F121",
    "start_line": 75,
    "text_preview": "ork.TestCase;\\nimport junit.framework.TestSuite;\\n\\npublic class WeaverModuleTests extends TestCase {\\n\\n\tpublic static Test suite() {\\n\t\tTestSuite suite = new TestSuite(WeaverModuleTests.class.getName());\\n\t\tsuite.addTestSuite(BoundedReferenceTypeTestCase.class);\\n\t\tsuite.addTestSuite(CommonsTraceFactoryTest.class);\\n\t\tsuite.a"
  },
  {
    "method_id": "M3822",
    "name": "WeaverModuleTests",
    "return_type": "",
    "signature": "WeaverModuleTests(String name)",
    "file_id": "F121",
    "start_line": 166,
    "text_preview": "ntcutExpressionTest.class);\\n\t\tsuite.addTestSuite(TypeVariableReferenceTypeTestCase.class);\\n\\n\t\treturn suite;\\n\t}\\n\\n\tpublic WeaverModuleTests(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3823",
    "name": "getOutdir",
    "return_type": "File",
    "signature": "getOutdir()",
    "file_id": "F122",
    "start_line": 27,
    "text_preview": "g OUTDIR_PATH = \"../weaver/out\";\\n\\n\t/** @return File outDir (writable) or null if unable to write */\\n\tpublic static File getOutdir() {\\n\t\tFile result = new File(OUTDIR_PATH);\\n\t\tif (result.mkdirs() || (result.canWrite() && result.isDirectory())) {\\n\t\t\treturn result;\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\t/** best efforts to delete the ou"
  },
  {
    "method_id": "M3824",
    "name": "removeOutDir",
    "return_type": "void",
    "signature": "removeOutDir()",
    "file_id": "F122",
    "start_line": 36,
    "text_preview": "result;\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\t/** best efforts to delete the output directory and any contents */\\n\tpublic static void removeOutDir() {\\n\t\tFile outDir = getOutdir();\\n\t\tif (null != outDir) {\\n\t\t\tFileUtil.deleteContents(outDir);\\n\t\t\toutDir.delete();\\n\t\t}\\n\t}\\n\\n\tpublic WeaverTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3825",
    "name": "if",
    "return_type": "",
    "signature": "if(null != outDir)",
    "file_id": "F122",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3826",
    "name": "WeaverTestCase",
    "return_type": "",
    "signature": "WeaverTestCase(String name)",
    "file_id": "F122",
    "start_line": 44,
    "text_preview": "e outDir = getOutdir();\\n\t\tif (null != outDir) {\\n\t\t\tFileUtil.deleteContents(outDir);\\n\t\t\toutDir.delete();\\n\t\t}\\n\t}\\n\\n\tpublic WeaverTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3827",
    "name": "AfterReturningWeaveTestCase",
    "return_type": "",
    "signature": "AfterReturningWeaveTestCase(String name)",
    "file_id": "F123",
    "start_line": 25,
    "text_preview": ";\\n\\npublic class AfterReturningWeaveTestCase extends WeaveTestCase {\\n    {\\n        regenerate = false;\\n    }\\n\\n    public AfterReturningWeaveTestCase(String name) {\\n        super(name);\\n    }\\n\\n    public void testAfterReturning() throws IOException {\\n        weaveTest(\\n            getStandardTargets(),\\n            \"After"
  },
  {
    "method_id": "M3828",
    "name": "testAfterReturning",
    "return_type": "void",
    "signature": "testAfterReturning()",
    "file_id": "F123",
    "start_line": 29,
    "text_preview": "erate = false;\\n    }\\n\\n    public AfterReturningWeaveTestCase(String name) {\\n        super(name);\\n    }\\n\\n    public void testAfterReturning() throws IOException {\\n        weaveTest(\\n            getStandardTargets(),\\n            \"AfterReturning\",\\n            makeAdviceAll(\"afterReturning\"));\\n    }\\n\\n    public void testAf"
  },
  {
    "method_id": "M3829",
    "name": "testAfterReturningParam",
    "return_type": "void",
    "signature": "testAfterReturningParam()",
    "file_id": "F123",
    "start_line": 36,
    "text_preview": "etStandardTargets(),\\n            \"AfterReturning\",\\n            makeAdviceAll(\"afterReturning\"));\\n    }\\n\\n    public void testAfterReturningParam() throws IOException {\\n        weaveTest(\\n            getStandardTargets(),\\n            \"AfterReturningParam\",\\n            makeAdviceField(\"afterReturning\", \"java.lang.Object\")"
  },
  {
    "method_id": "M3830",
    "name": "testAfterReturningCheckcastParam",
    "return_type": "void",
    "signature": "testAfterReturningCheckcastParam()",
    "file_id": "F123",
    "start_line": 42,
    "text_preview": "       \"AfterReturningParam\",\\n            makeAdviceField(\"afterReturning\", \"java.lang.Object\"));\\n    }\\n    public void testAfterReturningCheckcastParam() throws IOException {\\n        weaveTest(\\n            getStandardTargets(),\\n            \"AfterReturningCheckcastParam\",\\n            makeAdviceField(\"afterReturning\", \""
  },
  {
    "method_id": "M3831",
    "name": "testAfterReturningConversionParam",
    "return_type": "void",
    "signature": "testAfterReturningConversionParam()",
    "file_id": "F123",
    "start_line": 49,
    "text_preview": "ingCheckcastParam\",\\n            makeAdviceField(\"afterReturning\", \"java.rmi.server.LogStream\"));\\n    }\\n\\n    public void testAfterReturningConversionParam() throws IOException {\\n        String mungerString =\\n            \"afterReturning(): call(int *.*(..)) -> \"\\n                + \"static void Aspect.ajc_afterReturning_fi"
  },
  {
    "method_id": "M3832",
    "name": "AfterThrowingWeaveTestCase",
    "return_type": "",
    "signature": "AfterThrowingWeaveTestCase(String name)",
    "file_id": "F124",
    "start_line": 26,
    "text_preview": "ver.ShadowMunger;\\n\\npublic class AfterThrowingWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic AfterThrowingWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testAfterThrowing() throws IOException {\\n\t\tweaveTest(getStandardTargets(), \"AfterThrowing\", makeAdviceAll(\"afterThrowing\"));\\n\t"
  },
  {
    "method_id": "M3833",
    "name": "testAfterThrowing",
    "return_type": "void",
    "signature": "testAfterThrowing()",
    "file_id": "F124",
    "start_line": 30,
    "text_preview": "stCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic AfterThrowingWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testAfterThrowing() throws IOException {\\n\t\tweaveTest(getStandardTargets(), \"AfterThrowing\", makeAdviceAll(\"afterThrowing\"));\\n\t}\\n\\n\tpublic void testAfterThrowingParam() throws IOException {\\n\t\tBcelWorld "
  },
  {
    "method_id": "M3834",
    "name": "testAfterThrowingParam",
    "return_type": "void",
    "signature": "testAfterThrowingParam()",
    "file_id": "F124",
    "start_line": 34,
    "text_preview": "rows IOException {\\n\t\tweaveTest(getStandardTargets(), \"AfterThrowing\", makeAdviceAll(\"afterThrowing\"));\\n\t}\\n\\n\tpublic void testAfterThrowingParam() throws IOException {\\n\t\tBcelWorld world = new BcelWorld();\\n\\n\t\tShadowMunger myMunger = BcelTestUtils.shadowMunger(world,\\n\t\t\t\t\"afterThrowing(): get(* *.out) -> static void Aspect"
  },
  {
    "method_id": "M3835",
    "name": "AfterWeaveTestCase",
    "return_type": "",
    "signature": "AfterWeaveTestCase(String name)",
    "file_id": "F125",
    "start_line": 23,
    "text_preview": "port java.io.IOException;\\n\\npublic class AfterWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic AfterWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testAfter() throws IOException {\\n\t\tweaveTest(getStandardTargets(), \"After\", makeAdviceAll(\"after\"));\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3836",
    "name": "testAfter",
    "return_type": "void",
    "signature": "testAfter()",
    "file_id": "F125",
    "start_line": 28,
    "text_preview": "WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic AfterWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testAfter() throws IOException {\\n\t\tweaveTest(getStandardTargets(), \"After\", makeAdviceAll(\"after\"));\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3837",
    "name": "ArgsWeaveTestCase",
    "return_type": "",
    "signature": "ArgsWeaveTestCase(String name)",
    "file_id": "F126",
    "start_line": 39,
    "text_preview": "r.UnresolvedType;\\n\\n/**.\\n */\\npublic class ArgsWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic ArgsWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n    public void testAfterReturningArgs() throws IOException {\\n        weaveTest(\"HelloWorld\", \"ArgsAfterReturningHelloWorld\", makeArgsMunger(\"after"
  },
  {
    "method_id": "M3838",
    "name": "testAfterReturningArgs",
    "return_type": "void",
    "signature": "testAfterReturningArgs()",
    "file_id": "F126",
    "start_line": 44,
    "text_preview": "aveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic ArgsWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n    public void testAfterReturningArgs() throws IOException {\\n        weaveTest(\"HelloWorld\", \"ArgsAfterReturningHelloWorld\", makeArgsMunger(\"afterReturning\"));\\n    }\\n\\n\\n    public void testFancyAfterReturningArgs() t"
  },
  {
    "method_id": "M3839",
    "name": "testFancyAfterReturningArgs",
    "return_type": "void",
    "signature": "testFancyAfterReturningArgs()",
    "file_id": "F126",
    "start_line": 49,
    "text_preview": "     weaveTest(\"HelloWorld\", \"ArgsAfterReturningHelloWorld\", makeArgsMunger(\"afterReturning\"));\\n    }\\n\\n\\n    public void testFancyAfterReturningArgs() throws IOException {\\n        weaveTest(\"FancyHelloWorld\", \"ArgsAfterReturningFancyHelloWorld\", makeArgsMunger(\"afterReturning\"));\\n    }\\n\\n    public void testThrowing() th"
  },
  {
    "method_id": "M3840",
    "name": "testThrowing",
    "return_type": "void",
    "signature": "testThrowing()",
    "file_id": "F126",
    "start_line": 53,
    "text_preview": "eTest(\"FancyHelloWorld\", \"ArgsAfterReturningFancyHelloWorld\", makeArgsMunger(\"afterReturning\"));\\n    }\\n\\n    public void testThrowing() throws IOException {\\n        weaveTest(\"HelloWorld\", \"ArgsAfterThrowingHelloWorld\", makeArgsMunger(\"afterThrowing\"));\\n    }\\n\\n    public void testLots() throws IOException {\\n        List"
  },
  {
    "method_id": "M3841",
    "name": "testLots",
    "return_type": "void",
    "signature": "testLots()",
    "file_id": "F126",
    "start_line": 57,
    "text_preview": "        weaveTest(\"HelloWorld\", \"ArgsAfterThrowingHelloWorld\", makeArgsMunger(\"afterThrowing\"));\\n    }\\n\\n    public void testLots() throws IOException {\\n        List<ShadowMunger> l = new ArrayList<>();\\n\\n        BcelAdvice p1 =\\n            makeArgsMunger(\"before\");\\n\\n        BcelAdvice p2 =\\n            makeArgsMunger(\"af"
  },
  {
    "method_id": "M3842",
    "name": "getArgsAdviceTag",
    "return_type": "InstructionList",
    "signature": "getArgsAdviceTag(BcelShadow shadow, String where)",
    "file_id": "F126",
    "start_line": 76,
    "text_preview": "        weaveTest(\"HelloWorld\", \"ArgsBeforeAfterHelloWorld\", addLexicalOrder(l));\\n    }\\n\\n\t/* private */ InstructionList getArgsAdviceTag(BcelShadow shadow, String where) {\\n\t\tString methodName =\\n\t\t\t\"ajc_\" + where + \"_\" + shadow.getKind().toLegalJavaIdentifier();\\n\t\tInstructionFactory fact = shadow.getFactory();\\n\t\tInstruc"
  },
  {
    "method_id": "M3843",
    "name": "makeArgsMunger",
    "return_type": "BcelAdvice",
    "signature": "makeArgsMunger(final String kindx)",
    "file_id": "F126",
    "start_line": 45,
    "text_preview": "blic void testAfterReturningArgs() throws IOException {\\n        weaveTest(\"HelloWorld\", \"ArgsAfterReturningHelloWorld\", makeArgsMunger(\"afterReturning\"));\\n    }\\n\\n\\n    public void testFancyAfterReturningArgs() throws IOException {\\n        weaveTest(\"FancyHelloWorld\", \"ArgsAfterReturningFancyHelloWorld\", makeArgsMunger(\""
  },
  {
    "method_id": "M3844",
    "name": "specializeOn",
    "return_type": "void",
    "signature": "specializeOn(Shadow shadow)",
    "file_id": "F126",
    "start_line": 108,
    "text_preview": "solvedType.forName(\"Aspect\"), 0, \"foo\", \"()V\"), 0, -1, -1, null,\\n        \t\t\trtx) {\\n            @Override\\n\t\t\tpublic void specializeOn(Shadow shadow) {\\n                super.specializeOn(shadow);\\n                shadow.getArgVar(0);\\n            }\\n            @Override\\n\t\t\tpublic InstructionList getAdviceInstructions(BcelS"
  },
  {
    "method_id": "M3845",
    "name": "getAdviceInstructions",
    "return_type": "InstructionList",
    "signature": "getAdviceInstructions(BcelShadow shadow, BcelVar extraVar, InstructionHandle fk)",
    "file_id": "F126",
    "start_line": 113,
    "text_preview": "pecializeOn(shadow);\\n                shadow.getArgVar(0);\\n            }\\n            @Override\\n\t\t\tpublic InstructionList getAdviceInstructions(BcelShadow shadow, BcelVar extraVar, InstructionHandle fk) {\\n                return getArgsAdviceTag(shadow, kindx);\\n            }\\n        };\\n    }\\n\\n}\\n"
  },
  {
    "method_id": "M3846",
    "name": "AroundArgsWeaveTestCase",
    "return_type": "",
    "signature": "AroundArgsWeaveTestCase(String name)",
    "file_id": "F127",
    "start_line": 25,
    "text_preview": "weaver.ShadowMunger;\\n\\npublic class AroundArgsWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic AroundArgsWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n    public void testWeave() throws IOException\\n    {\\n    \tString label = \"AroundArgs\";\\n    \tShadowMunger p =\\n                makeConcreteAdvic"
  },
  {
    "method_id": "M3847",
    "name": "testWeave",
    "return_type": "void",
    "signature": "testWeave()",
    "file_id": "F127",
    "start_line": 29,
    "text_preview": "stCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic AroundArgsWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n    public void testWeave() throws IOException\\n    {\\n    \tString label = \"AroundArgs\";\\n    \tShadowMunger p =\\n                makeConcreteAdvice(\\n\t\t\t\t\t\"around(list) : \"\\n\t\t\t\t\t+ \"(call(public * add(..)) && target(list))"
  },
  {
    "method_id": "M3848",
    "name": "AroundWeaveTestCase",
    "return_type": "",
    "signature": "AroundWeaveTestCase(String name)",
    "file_id": "F128",
    "start_line": 33,
    "text_preview": "j.weaver.UnresolvedType;\\n\\npublic class AroundWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic AroundWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testAround() throws IOException {\\n\t\taroundTest(\"Around\", true);\\n\t}\\n\\n\tpublic void testAroundAll() throws IOException {\\n\t\taroundTest(\"A"
  },
  {
    "method_id": "M3849",
    "name": "testAround",
    "return_type": "void",
    "signature": "testAround()",
    "file_id": "F128",
    "start_line": 37,
    "text_preview": "WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic AroundWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testAround() throws IOException {\\n\t\taroundTest(\"Around\", true);\\n\t}\\n\\n\tpublic void testAroundAll() throws IOException {\\n\t\taroundTest(\"AroundAll\", false);\\n\t}\\n\\n    public void testAroundAndOthers() throws"
  },
  {
    "method_id": "M3850",
    "name": "testAroundAll",
    "return_type": "void",
    "signature": "testAroundAll()",
    "file_id": "F128",
    "start_line": 41,
    "text_preview": "ame) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testAround() throws IOException {\\n\t\taroundTest(\"Around\", true);\\n\t}\\n\\n\tpublic void testAroundAll() throws IOException {\\n\t\taroundTest(\"AroundAll\", false);\\n\t}\\n\\n    public void testAroundAndOthers() throws IOException {\\n    \taroundTestAndOthers(\"AroundAndOthers\", true);\\n    }\\n\\n    publ"
  },
  {
    "method_id": "M3851",
    "name": "testAroundAndOthers",
    "return_type": "void",
    "signature": "testAroundAndOthers()",
    "file_id": "F128",
    "start_line": 45,
    "text_preview": "nd\", true);\\n\t}\\n\\n\tpublic void testAroundAll() throws IOException {\\n\t\taroundTest(\"AroundAll\", false);\\n\t}\\n\\n    public void testAroundAndOthers() throws IOException {\\n    \taroundTestAndOthers(\"AroundAndOthers\", true);\\n    }\\n\\n    public void testAroundAllAndOthers() throws IOException {\\n    \taroundTestAndOthers(\"AroundAllAn"
  },
  {
    "method_id": "M3852",
    "name": "testAroundAllAndOthers",
    "return_type": "void",
    "signature": "testAroundAllAndOthers()",
    "file_id": "F128",
    "start_line": 49,
    "text_preview": "id testAroundAndOthers() throws IOException {\\n    \taroundTestAndOthers(\"AroundAndOthers\", true);\\n    }\\n\\n    public void testAroundAllAndOthers() throws IOException {\\n    \taroundTestAndOthers(\"AroundAllAndOthers\", false);\\n    }\\n\\n\\n    private BcelAdvice makeAroundMunger(final boolean matchOnlyPrintln) {\\n        BcelWorld"
  },
  {
    "method_id": "M3853",
    "name": "makeAroundMunger",
    "return_type": "BcelAdvice",
    "signature": "makeAroundMunger(final boolean matchOnlyPrintln)",
    "file_id": "F128",
    "start_line": 54,
    "text_preview": "lAndOthers() throws IOException {\\n    \taroundTestAndOthers(\"AroundAllAndOthers\", false);\\n    }\\n\\n\\n    private BcelAdvice makeAroundMunger(final boolean matchOnlyPrintln) {\\n        BcelWorld world = super.world;\\n        final Member sig =\\n            MemberImpl.method(\\n                UnresolvedType.forName(\"Aspect\"),\\n  "
  },
  {
    "method_id": "M3854",
    "name": "specializeOn",
    "return_type": "void",
    "signature": "specializeOn(Shadow s)",
    "file_id": "F128",
    "start_line": 69,
    "text_preview": "     sig, 0, -1, -1, null, UnresolvedType.forName(\"Aspect\").resolve(world))\\n\t    {\\n            @Override\\n\t\t\tpublic void specializeOn(Shadow s) {\\n            \tsuper.specializeOn(s);\\n                ((BcelShadow) s).initializeForAroundClosure();\\n            }\\n        };\\n    }\\n\\n\tprivate void aroundTest(String outName, fin"
  },
  {
    "method_id": "M3855",
    "name": "aroundTest",
    "return_type": "void",
    "signature": "aroundTest(String outName, final boolean matchOnlyPrintln)",
    "file_id": "F128",
    "start_line": 38,
    "text_preview": "lse;\\n\t}\\n\\n\tpublic AroundWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testAround() throws IOException {\\n\t\taroundTest(\"Around\", true);\\n\t}\\n\\n\tpublic void testAroundAll() throws IOException {\\n\t\taroundTest(\"AroundAll\", false);\\n\t}\\n\\n    public void testAroundAndOthers() throws IOException {\\n    \taroundTestAndOth"
  },
  {
    "method_id": "M3856",
    "name": "aroundTestAndOthers",
    "return_type": "void",
    "signature": "aroundTestAndOthers(String outName, final boolean matchOnlyPrintln)",
    "file_id": "F128",
    "start_line": 46,
    "text_preview": "ows IOException {\\n\t\taroundTest(\"AroundAll\", false);\\n\t}\\n\\n    public void testAroundAndOthers() throws IOException {\\n    \taroundTestAndOthers(\"AroundAndOthers\", true);\\n    }\\n\\n    public void testAroundAllAndOthers() throws IOException {\\n    \taroundTestAndOthers(\"AroundAllAndOthers\", false);\\n    }\\n\\n\\n    private BcelAdvice"
  },
  {
    "method_id": "M3857",
    "name": "getGenericClassTypeSignature",
    "return_type": "ClassSignature",
    "signature": "getGenericClassTypeSignature(JavaClass jClass)",
    "file_id": "F129",
    "start_line": 33,
    "text_preview": "\\n */\\npublic class BcelGenericSignatureToTypeXTestCase extends TestCase {\\n\\n\tpublic final GenericSignature.ClassSignature getGenericClassTypeSignature(JavaClass jClass) {\\n\t\tSignature sig = jClass.getSignatureAttribute();\\n\t\tif (sig != null) {\\n\t\t\tGenericSignatureParser parser = new GenericSignatureParser();\\n\t\t\tClassSignatu"
  },
  {
    "method_id": "M3858",
    "name": "if",
    "return_type": "",
    "signature": "if(sig != null)",
    "file_id": "F129",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3859",
    "name": "testEnumFromHell",
    "return_type": "void",
    "signature": "testEnumFromHell()",
    "file_id": "F129",
    "start_line": 43,
    "text_preview": "re classSig = parser.parseAsClassSignature(sig.getSignature());\\n\t\t\treturn classSig;\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tpublic void testEnumFromHell() throws Exception {\\n\t\tBcelWorld world = new BcelWorld();\\n\t\tJavaClass javaLangEnum = Repository.lookupClass(\"java/lang/Enum\");\\n\t\tGenericSignature.ClassSignature cSig = getGenericClass"
  },
  {
    "method_id": "M3860",
    "name": "testColonColon",
    "return_type": "void",
    "signature": "testColonColon()",
    "file_id": "F129",
    "start_line": 66,
    "text_preview": "g.formalTypeParameters, world);\\n\t\tassertEquals(\"Ljava/io/Serializable;\", serializable.getSignature());\\n\t}\\n\\n\tpublic void testColonColon() throws Exception {\\n\t\tBcelWorld world = new BcelWorld();\\n\t\tGenericSignature.ClassSignature cSig = new GenericSignatureParser()\\n\t\t\t\t.parseAsClassSignature(\"<T::Ljava/io/Serializable;>Lj"
  },
  {
    "method_id": "M3861",
    "name": "shadowMunger",
    "return_type": "Advice",
    "signature": "shadowMunger(World w, String str, int extraFlag)",
    "file_id": "F130",
    "start_line": 38,
    "text_preview": "pre>\\n\t * Kind ( Id , ... ) : Pointcut -&gt; MethodSignature\\n\t * </pre>\\n\t *\\n\t * </blockquote>\\n\t */\\n\tpublic static Advice shadowMunger(World w, String str, int extraFlag) {\\n\t\tstr = str.trim();\\n\t\tint start = 0;\\n\t\tint i = str.indexOf('(');\\n\t\tAdviceKind kind = AdviceKind.stringToKind(str.substring(start, i));\\n\t\tstart = ++i;"
  },
  {
    "method_id": "M3862",
    "name": "for",
    "return_type": "",
    "signature": "for(int j = 0, len = ids.length; j < len; j++)",
    "file_id": "F130",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3863",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F131",
    "start_line": 19,
    "text_preview": "rt org.aspectj.weaver.World;\\n\\npublic class BcelWorldReferenceTypeTest extends CommonReferenceTypeTests {\\n\\n\tpublic World getWorld() {\\n\t\treturn new BcelWorld();\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3864",
    "name": "BeforeWeaveTestCase",
    "return_type": "",
    "signature": "BeforeWeaveTestCase(String name)",
    "file_id": "F132",
    "start_line": 23,
    "text_preview": "ort java.io.IOException;\\n\\npublic class BeforeWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic BeforeWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testBefore() throws IOException {\\n\t\tweaveTest(getStandardTargets(), \"Before\", makeAdviceAll(\"before\"));\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3865",
    "name": "testBefore",
    "return_type": "void",
    "signature": "testBefore()",
    "file_id": "F132",
    "start_line": 28,
    "text_preview": "eaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic BeforeWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testBefore() throws IOException {\\n\t\tweaveTest(getStandardTargets(), \"Before\", makeAdviceAll(\"before\"));\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3866",
    "name": "CheckerTestCase",
    "return_type": "",
    "signature": "CheckerTestCase(String name)",
    "file_id": "F133",
    "start_line": 28,
    "text_preview": "terns.DeclareErrorOrWarning;\\n\\npublic class CheckerTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic CheckerTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n    public void testStaticTjp() throws IOException {\\n    \tChecker checker = new Checker(\\n    \t\tnew DeclareErrorOrWarning(true, makePointcutPrintln(),"
  },
  {
    "method_id": "M3867",
    "name": "testStaticTjp",
    "return_type": "void",
    "signature": "testStaticTjp()",
    "file_id": "F133",
    "start_line": 33,
    "text_preview": "WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic CheckerTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n    public void testStaticTjp() throws IOException {\\n    \tChecker checker = new Checker(\\n    \t\tnew DeclareErrorOrWarning(true, makePointcutPrintln(), \"hey, we found a println\"));\\n\\n    \tMessageHandler handler = new Me"
  },
  {
    "method_id": "M3868",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F134",
    "start_line": 37,
    "text_preview": " extends TestCase {\\n\tprivate File f;\\n\tprivate ZipFile zf;\\n\tprivate Enumeration entries;\\n\tprivate Map map;\\n\\n\tpublic void setUp() throws Exception {\\n    \tf = new File(\"../lib/aspectj/lib/aspectjtools.jar\");\\n\t\tassertTrue(\"Couldn't find aspectjtools to test.  Tried: \"+f.getAbsolutePath(),f.exists());\\n\t\tzf = new ZipFile(f);"
  },
  {
    "method_id": "M3869",
    "name": "tearDown",
    "return_type": "void",
    "signature": "tearDown()",
    "file_id": "F134",
    "start_line": 46,
    "text_preview": "= zf.entries();\\n//\t\tClassLoaderRepository.sharedCacheCompactFrequency = 16384;\\n\t\tmap = getSharedMap();\\n\t}\\n\\n\tpublic void tearDown() {\\n\t\t new ClassLoaderRepository((ClassLoader) null).reset();\\n\t}\\n\\n\tprivate ClassLoaderRepository setupRepository() throws Exception {\\n    \tClassLoader cl = Thread.currentThread().getContextCl"
  },
  {
    "method_id": "M3870",
    "name": "setupRepository",
    "return_type": "ClassLoaderRepository",
    "signature": "setupRepository()",
    "file_id": "F134",
    "start_line": 50,
    "text_preview": "\\n\tpublic void tearDown() {\\n\t\t new ClassLoaderRepository((ClassLoader) null).reset();\\n\t}\\n\\n\tprivate ClassLoaderRepository setupRepository() throws Exception {\\n    \tClassLoader cl = Thread.currentThread().getContextClassLoader();\\n\t\tClassLoader res = new URLClassLoader(new URL[]{f.toURI().toURL()},cl);\\n\t\tClassLoaderReposit"
  },
  {
    "method_id": "M3871",
    "name": "compareTwoRepositories",
    "return_type": "void",
    "signature": "compareTwoRepositories()",
    "file_id": "F134",
    "start_line": 57,
    "text_preview": "{f.toURI().toURL()},cl);\\n\t\tClassLoaderRepository rep = new ClassLoaderRepository(res);\\n\t\treturn rep;\\n\t}\\n\\n\t private void compareTwoRepositories() throws Exception {\\n\t\tClassLoaderRepository rep1 = setupRepository();\\n\t\tClassLoaderRepository rep2 = setupRepository();\\n\t\tint i = 0;\\n\t\twhile (entries.hasMoreElements()) {\\n\t\t\tZi"
  },
  {
    "method_id": "M3872",
    "name": "loadOnce",
    "return_type": "void",
    "signature": "loadOnce()",
    "file_id": "F134",
    "start_line": 80,
    "text_preview": "ed \"+i+\" entries!!\");\\n\t\tSystem.err.println(rep1.report());\\n\t\tSystem.err.println(rep2.report());\\n    }\\n\\n//\t private void loadOnce() throws Exception {\\n//\t\tClassLoaderRepository rep = setupRepository();\\n//\t\twhile (entries.hasMoreElements()) {\\n//\t\t\tZipEntry zfe = (ZipEntry) entries.nextElement();\\n//\t\t\tString classfileName"
  },
  {
    "method_id": "M3873",
    "name": "testMultiThreaded",
    "return_type": "void",
    "signature": "testMultiThreaded()",
    "file_id": "F134",
    "start_line": 94,
    "text_preview": "\t\t\t\t\tclassfileName.length() - 6).replace('/', '.');\\n//\\n//\t\t\t\trep.loadClass(clazzname);\\n//\t\t\t}\\n//\t\t}\\n//\t}\\n\\n\t public void testMultiThreaded() throws Throwable {\\n\t\t ClassLoaderRepository.useSharedCache=true;\\n//\t\t ClassLoaderRepository.sharedCacheCompactFrequency = 200;\\n\t\t //loadOnce();\\n\t\t TestThread threads[] = new TestTh"
  },
  {
    "method_id": "M3874",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0; i<threads.length; i++)",
    "file_id": "F134",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3875",
    "name": "for",
    "return_type": "",
    "signature": "for(TestThread thread : threads)",
    "file_id": "F134",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3876",
    "name": "TestThread",
    "return_type": "",
    "signature": "TestThread(int skip)",
    "file_id": "F134",
    "start_line": 100,
    "text_preview": "loadOnce();\\n\t\t TestThread threads[] = new TestThread[6];\\n\t\t for (int i=0; i<threads.length; i++) {\\n\t\t\t threads[i] = new TestThread((i%3)*1000);\\n\t\t\t threads[i].start();\\n\t\t }\\n\t\t for (TestThread thread : threads) {\\n\t\t\t thread.join();\\n\t\t\t if (thread.getFailure() != null) {\\n\t\t\t\t throw thread.getFailure();\\n\t\t\t }\\n\t\t }\\n\t }\\n\\n\t "
  },
  {
    "method_id": "M3877",
    "name": "run",
    "return_type": "void",
    "signature": "run()",
    "file_id": "F134",
    "start_line": 123,
    "text_preview": "es();\\n\t\t\tfor (int i=0; i<skip && entries.hasMoreElements(); i++) {\\n\t\t\t\tentries.nextElement();\\n\t\t\t}\\n\t\t }\\n\\n\t\t public void run() {\\n\t\t\t try {\\n\t\t\t\tClassLoaderRepository rep = setupRepository();\\n\t\t\t\tint i = 0;\\n\t\t\t\twhile (entries.hasMoreElements()) {\\n\t\t\t\t\tZipEntry zfe = (ZipEntry)entries.nextElement();\\n\t\t\t\t\tString classfileNa"
  },
  {
    "method_id": "M3878",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Throwable t)",
    "file_id": "F134",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3879",
    "name": "getFailure",
    "return_type": "Throwable",
    "signature": "getFailure()",
    "file_id": "F134",
    "start_line": 105,
    "text_preview": "read((i%3)*1000);\\n\t\t\t threads[i].start();\\n\t\t }\\n\t\t for (TestThread thread : threads) {\\n\t\t\t thread.join();\\n\t\t\t if (thread.getFailure() != null) {\\n\t\t\t\t throw thread.getFailure();\\n\t\t\t }\\n\t\t }\\n\t }\\n\\n\t private class TestThread extends Thread {\\n\t\t public Throwable failure = null;\\n\t\t Enumeration entries;\\n\\n\t\t // ensure the thread"
  },
  {
    "method_id": "M3880",
    "name": "testNotSharedRepository",
    "return_type": "void",
    "signature": "testNotSharedRepository()",
    "file_id": "F134",
    "start_line": 147,
    "text_preview": "Throwable t) {\\n\t\t\t\t failure = t;\\n\t\t\t }\\n\t \t}\\n\t\tpublic Throwable getFailure() {\\n\t\t\treturn failure;\\n\t\t}\\n\t }\\n\\n\t public void testNotSharedRepository() throws  Exception {\\n    \tClassLoaderRepository.useSharedCache=false;\\n    \tcompareTwoRepositories();\\n\t }\\n\\n\t public void testSharedUrlRepository() throws  Exception {\\n\t\tClassLo"
  },
  {
    "method_id": "M3881",
    "name": "testSharedUrlRepository",
    "return_type": "void",
    "signature": "testSharedUrlRepository()",
    "file_id": "F134",
    "start_line": 152,
    "text_preview": " throws  Exception {\\n    \tClassLoaderRepository.useSharedCache=false;\\n    \tcompareTwoRepositories();\\n\t }\\n\\n\t public void testSharedUrlRepository() throws  Exception {\\n\t\tClassLoaderRepository.useSharedCache=true;\\n\t\tcompareTwoRepositories();\\n//\t\tClassLoaderRepository.compactSharedCache();\\n    }\\n\\n\tpublic void testPurgeUrlR"
  },
  {
    "method_id": "M3882",
    "name": "testPurgeUrlRepository",
    "return_type": "void",
    "signature": "testPurgeUrlRepository()",
    "file_id": "F134",
    "start_line": 158,
    "text_preview": "ry.useSharedCache=true;\\n\t\tcompareTwoRepositories();\\n//\t\tClassLoaderRepository.compactSharedCache();\\n    }\\n\\n\tpublic void testPurgeUrlRepository() throws  Exception {\\n\t\tClassLoaderRepository.useSharedCache = true;\\n\t\tClassLoaderRepository rep = setupRepository();\\n\t\tReference ref = null;\\n\\n\t\twhile (ref==null && entries.hasM"
  },
  {
    "method_id": "M3883",
    "name": "testAutoPurgeUrlRepository",
    "return_type": "void",
    "signature": "testAutoPurgeUrlRepository()",
    "file_id": "F134",
    "start_line": 180,
    "text_preview": ");//force purge\\n\t\t\t}\\n\t\t}\\n\t\tassertEquals(\"expected empty shared URL cache \"+map.size(), 0, map.size());\\n\t}\\n\\n\tpublic void testAutoPurgeUrlRepository() throws  Exception {\\n\t\tClassLoaderRepository.useSharedCache = true;\\n\t\tassertEquals(\"expected empty shared URL cache \"+map.size(), 0, map.size());\\n\t\tClassLoaderRepository re"
  },
  {
    "method_id": "M3884",
    "name": "getSharedMapField",
    "return_type": "Field",
    "signature": "getSharedMapField()",
    "file_id": "F134",
    "start_line": 203,
    "text_preview": "ue();\\n\t\t\t\ti++;\\n\t\t\t}\\n\t\t}\\n\t\tassertTrue(\"expected smaller shared URL cache \"+map.size(), map.size()<3);\\n\t}\\n\\n\tprivate Field getSharedMapField() throws Exception {\\n\t\tField field = ClassLoaderRepository.class.getDeclaredField(\"sharedCache\");\\n\t\tfield.setAccessible(true);\\n\t\treturn field;\\n\t}\\n\\n\tprivate Map getSharedMap() throws "
  },
  {
    "method_id": "M3885",
    "name": "getSharedMap",
    "return_type": "Map",
    "signature": "getSharedMap()",
    "file_id": "F134",
    "start_line": 43,
    "text_preview": "\t\tzf = new ZipFile(f);\\n\t\tentries = zf.entries();\\n//\t\tClassLoaderRepository.sharedCacheCompactFrequency = 16384;\\n\t\tmap = getSharedMap();\\n\t}\\n\\n\tpublic void tearDown() {\\n\t\t new ClassLoaderRepository((ClassLoader) null).reset();\\n\t}\\n\\n\tprivate ClassLoaderRepository setupRepository() throws Exception {\\n    \tClassLoader cl = Th"
  },
  {
    "method_id": "M3886",
    "name": "findJvm",
    "return_type": "String",
    "signature": "findJvm(String pattern, String jar)",
    "file_id": "F135",
    "start_line": 42,
    "text_preview": "ase extends TestCase {\\n\\n\t// Works on my machine where all jvms under ~/jvms\\n\tprivate static final String java18_rtjar = findJvm(\"j.*18.*\", \"rt.jar\");\\n\tprivate static final String java9_jrtfsjar = findJvm(\"j.*9.*\", \"jrt-fs.jar\");\\n\tprivate static final String java11_jrtfsjar = findJvm(\"j.*11.*\", \"jrt-fs.jar\");\\n\\n\tprivate "
  },
  {
    "method_id": "M3887",
    "name": "if",
    "return_type": "",
    "signature": "if(result != null)",
    "file_id": "F135",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3888",
    "name": "walk",
    "return_type": "File",
    "signature": "walk(File dir, String jar)",
    "file_id": "F135",
    "start_line": 51,
    "text_preview": "(new File(start).listFiles())) {\\n\t\t\t\tif (f.isDirectory() && Pattern.matches(pattern, f.getName())) {\\n\t\t\t\t\tFile result = walk(f, jar);\\n\t\t\t\t\tif (result != null) {\\n\t\t\t\t\t\tSystem.out.println(\"For \" + pattern + \" found \" + result.getAbsolutePath());\\n\t\t\t\t\t\treturn result.getAbsolutePath();\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\treturn null;\\n"
  },
  {
    "method_id": "M3889",
    "name": "if",
    "return_type": "",
    "signature": "if(fs != null)",
    "file_id": "F135",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3890",
    "name": "for",
    "return_type": "",
    "signature": "for(File f : fs)",
    "file_id": "F135",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3891",
    "name": "testInstructions",
    "return_type": "void",
    "signature": "testInstructions()",
    "file_id": "F135",
    "start_line": 78,
    "text_preview": "ory()) {\\n\t\t\t\t\tFile s = walk(f, jar);\\n\t\t\t\t\tif (s != null)\\n\t\t\t\t\t\treturn s;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tpublic void testInstructions() {\\n\t\tSystem.out.println(\\n\t\t\t\"This test is mostly for stand-alone usage (rename 'xtest*' to 'test*'), \" +\\n\t\t\t\t\"as it needs execution on multiple JDK levels\"\\n\t\t);\\n\t}\\n\\n\t/**\\n\t * See <a h"
  },
  {
    "method_id": "M3892",
    "name": "testUnfoundClassPerformance",
    "return_type": "void",
    "signature": "testUnfoundClassPerformance()",
    "file_id": "F135",
    "start_line": 88,
    "text_preview": "\t}\\n\\n\t/**\\n\t * See <a href=\"https://github.com/eclipse-aspectj/aspectj/issues/306\">GitHub issue 306</a>\\n\t */\\n\tpublic void testUnfoundClassPerformance() {\\n\t\tfinal int ROUNDS = 10_000;\\n\t\tfinal int MAX_TIME = 500;\\n\\n\t\tList<String> classPath = Arrays.asList(System.getProperty(\"java.class.path\").split(File.pathSeparator));\\n\t\t/"
  },
  {
    "method_id": "M3893",
    "name": "xtestSanity18accessing18RTJAR",
    "return_type": "void",
    "signature": "xtestSanity18accessing18RTJAR()",
    "file_id": "F135",
    "start_line": 108,
    "text_preview": " %d rounds should be < %d ms, but was %d ms\", ROUNDS, MAX_TIME, duration),\\n\t\t\tduration < MAX_TIME\\n\t\t);\\n\t}\\n\\n\tpublic void xtestSanity18accessing18RTJAR() {\\n\t\tif (LangUtil.getVmVersion() > 8)\\n\t\t\tfail(\"Must be Java 8\");\\n\t\tList<String> classpath = new ArrayList<>();\\n\t\tclasspath.add(java18_rtjar);\\n\t\tClassPathManager cpm = ne"
  },
  {
    "method_id": "M3894",
    "name": "xtestJava18accessing11JRT",
    "return_type": "void",
    "signature": "xtestJava18accessing11JRT()",
    "file_id": "F135",
    "start_line": 118,
    "text_preview": "H());\\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/Object;\"));\\n\t\tassertNotNull(t);\\n\t}\\n\\n\tpublic void xtestJava18accessing11JRT() throws ClassFormatException, IOException {\\n\t\tif (LangUtil.getVmVersion() > 8)\\n\t\t\tfail(\"Must be Java 8\");\\n\t\tList<String> classpath = new ArrayList<>();\\n\t\tclasspath.add(java1"
  },
  {
    "method_id": "M3895",
    "name": "xtestJava18accessing19JRT",
    "return_type": "void",
    "signature": "xtestJava18accessing19JRT()",
    "file_id": "F135",
    "start_line": 133,
    "text_preview": "s.stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\\n\t\tassertEquals(1, c);\\n\t}\\n\\n\tpublic void xtestJava18accessing19JRT() throws ClassFormatException, IOException {\\n\t\tif (LangUtil.getVmVersion() > 8)\\n\t\t\tfail(\"Must be Java 8\");\\n\t\tList<String> classpath = new ArrayList<>();\\n\t\tclasspath.add(java9"
  },
  {
    "method_id": "M3896",
    "name": "xtestSanity19accessing18RTJAR",
    "return_type": "void",
    "signature": "xtestSanity19accessing18RTJAR()",
    "file_id": "F135",
    "start_line": 149,
    "text_preview": ".stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\\n\t\tassertEquals(0, c);\\n\t}\\n\\n\\n\tpublic void xtestSanity19accessing18RTJAR() {\\n\t\tassertEquals(9.0, LangUtil.getVmVersion());\\n\t\tList<String> classpath = new ArrayList<>();\\n\t\tclasspath.add(java18_rtjar);\\n\t\tClassPathManager cpm = new ClassPathManag"
  },
  {
    "method_id": "M3897",
    "name": "xtestJava19accessing11JRT",
    "return_type": "void",
    "signature": "xtestJava19accessing11JRT()",
    "file_id": "F135",
    "start_line": 158,
    "text_preview": "H());\\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/Object;\"));\\n\t\tassertNotNull(t);\\n\t}\\n\\n\tpublic void xtestJava19accessing11JRT() throws ClassFormatException, IOException {\\n\t\tassertEquals(9.0, LangUtil.getVmVersion());\\n\t\tList<String> classpath = new ArrayList<>();\\n\t\tclasspath.add(java11_jrtfsjar);\\n\t\tC"
  },
  {
    "method_id": "M3898",
    "name": "xtestJava19accessing19JRT",
    "return_type": "void",
    "signature": "xtestJava19accessing19JRT()",
    "file_id": "F135",
    "start_line": 172,
    "text_preview": "s.stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\\n\t\tassertEquals(1, c);\\n\t}\\n\\n\tpublic void xtestJava19accessing19JRT() throws ClassFormatException, IOException {\\n\t\tassertEquals(9.0, LangUtil.getVmVersion());\\n\t\tList<String> classpath = new ArrayList<>();\\n\t\tclasspath.add(java9_jrtfsjar);\\n\t\tCl"
  },
  {
    "method_id": "M3899",
    "name": "xtestSanity11accessing18RTJAR",
    "return_type": "void",
    "signature": "xtestSanity11accessing18RTJAR()",
    "file_id": "F135",
    "start_line": 186,
    "text_preview": "s.stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\\n\t\tassertEquals(0, c);\\n\t}\\n\\n\tpublic void xtestSanity11accessing18RTJAR() {\\n\t\tassertEquals(11.0, LangUtil.getVmVersion());\\n\t\tList<String> classpath = new ArrayList<>();\\n\t\tclasspath.add(java18_rtjar);\\n\t\tClassPathManager cpm = new ClassPathMana"
  },
  {
    "method_id": "M3900",
    "name": "xtestJava11accessing11JRT",
    "return_type": "void",
    "signature": "xtestJava11accessing11JRT()",
    "file_id": "F135",
    "start_line": 195,
    "text_preview": "H());\\n\t\tClassFile t = cpm.find(UnresolvedType.forSignature(\"Ljava/lang/Object;\"));\\n\t\tassertNotNull(t);\\n\t}\\n\\n\tpublic void xtestJava11accessing11JRT() throws ClassFormatException, IOException {\\n\t\tassertEquals(11.0, LangUtil.getVmVersion());\\n\t\tList<String> classpath = new ArrayList<>();\\n\t\tclasspath.add(java11_jrtfsjar);\\n\t\t"
  },
  {
    "method_id": "M3901",
    "name": "xtestJava11accessing19JRT",
    "return_type": "void",
    "signature": "xtestJava11accessing19JRT()",
    "file_id": "F135",
    "start_line": 209,
    "text_preview": "s.stream(clazz.getMethods()).filter(m -> m.getName().equals(\"isBlank\")).count();\\n\t\tassertEquals(1, c);\\n\t}\\n\\n\tpublic void xtestJava11accessing19JRT() throws ClassFormatException, IOException {\\n\t\tassertEquals(11.0, LangUtil.getVmVersion());\\n\t\tList<String> classpath = new ArrayList<>();\\n\t\tclasspath.add(java9_jrtfsjar);\\n\t\tC"
  },
  {
    "method_id": "M3902",
    "name": "handleMessage",
    "return_type": "boolean",
    "signature": "handleMessage(IMessage message)",
    "file_id": "F135",
    "start_line": 226,
    "text_preview": "Blank\")).count();\\n\t\tassertEquals(0, c);\\n\t}\\n\\n\tstatic class MH implements IMessageHandler {\\n\\n\t\t@Override\\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\\n\t\t\tSystem.out.println(message);\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean isIgnoring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tp"
  },
  {
    "method_id": "M3903",
    "name": "isIgnoring",
    "return_type": "boolean",
    "signature": "isIgnoring(Kind kind)",
    "file_id": "F135",
    "start_line": 232,
    "text_preview": "age message) throws AbortException {\\n\t\t\tSystem.out.println(message);\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean isIgnoring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void dontIgnore(Kind kind) {}\\n\\n\t\t@Override\\n\t\tpublic void ignore(Kind kind) {}\\n\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3904",
    "name": "dontIgnore",
    "return_type": "void",
    "signature": "dontIgnore(Kind kind)",
    "file_id": "F135",
    "start_line": 237,
    "text_preview": "return false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean isIgnoring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void dontIgnore(Kind kind) {}\\n\\n\t\t@Override\\n\t\tpublic void ignore(Kind kind) {}\\n\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3905",
    "name": "ignore",
    "return_type": "void",
    "signature": "ignore(Kind kind)",
    "file_id": "F135",
    "start_line": 240,
    "text_preview": "noring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void dontIgnore(Kind kind) {}\\n\\n\t\t@Override\\n\t\tpublic void ignore(Kind kind) {}\\n\\n\t}\\n}\\n"
  },
  {
    "method_id": "M3906",
    "name": "testClassNotFoundExceptionHasRootCauseOnIOException",
    "return_type": "void",
    "signature": "testClassNotFoundExceptionHasRootCauseOnIOException()",
    "file_id": "F136",
    "start_line": 23,
    "text_preview": "ssion test for <a href=\"https://github.com/eclipse-aspectj/aspectj/issues/266\">GitHub issue 266</a>\\n   */\\n  public void testClassNotFoundExceptionHasRootCauseOnIOException() throws URISyntaxException, MalformedURLException {\\n    ExtensibleURLClassLoader extensibleURLClassLoader = new MockExtensibleURLClassLoader(\\n     "
  },
  {
    "method_id": "M3907",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException e)",
    "file_id": "F136",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3908",
    "name": "MockExtensibleURLClassLoader",
    "return_type": "",
    "signature": "MockExtensibleURLClassLoader(URL[] urls, ClassLoader parent)",
    "file_id": "F136",
    "start_line": 24,
    "text_preview": "eption() throws URISyntaxException, MalformedURLException {\\n    ExtensibleURLClassLoader extensibleURLClassLoader = new MockExtensibleURLClassLoader(\\n      new URL[] { new URI(\"file://dummy\").toURL() },\\n      null\\n    );\\n    ClassNotFoundException classNotFoundException = null;\\n    try {\\n      extensibleURLClassLoader."
  },
  {
    "method_id": "M3909",
    "name": "getBytes",
    "return_type": "byte[]",
    "signature": "getBytes(String name)",
    "file_id": "F136",
    "start_line": 47,
    "text_preview": "leURLClassLoader(URL[] urls, ClassLoader parent) {\\n      super(urls, parent);\\n    }\\n\\n    @Override\\n    protected byte[] getBytes(String name) throws IOException {\\n      throw new IOException(\"uh-oh\");\\n    }\\n  }\\n}\\n"
  },
  {
    "method_id": "M3910",
    "name": "FieldSetTestCase",
    "return_type": "",
    "signature": "FieldSetTestCase(String name)",
    "file_id": "F137",
    "start_line": 23,
    "text_preview": "IOException;\\n\\npublic class FieldSetTestCase extends WeaveTestCase {\\n    {\\n        regenerate = false;\\n    }\\n\\n    public FieldSetTestCase(String name) {\\n        super(name);\\n    }\\n\\n    public void testBefore() throws IOException {\\n        weaveTest(\\n\t\t\t\"FieldyHelloWorld\",\\n            \"FieldSet\",\\n           makeAdviceAll"
  },
  {
    "method_id": "M3911",
    "name": "testBefore",
    "return_type": "void",
    "signature": "testBefore()",
    "file_id": "F137",
    "start_line": 27,
    "text_preview": "      regenerate = false;\\n    }\\n\\n    public FieldSetTestCase(String name) {\\n        super(name);\\n    }\\n\\n    public void testBefore() throws IOException {\\n        weaveTest(\\n\t\t\t\"FieldyHelloWorld\",\\n            \"FieldSet\",\\n           makeAdviceAll(\"before\")\\n            );\\n    }\\n}\\n"
  },
  {
    "method_id": "M3912",
    "name": "HierarchyDependsTestCase",
    "return_type": "",
    "signature": "HierarchyDependsTestCase(String arg0)",
    "file_id": "F138",
    "start_line": 21,
    "text_preview": "ectj.weaver.bcel;\\n\\nimport junit.framework.TestCase;\\n\\n\\npublic class HierarchyDependsTestCase extends TestCase {\\n\\n\tpublic HierarchyDependsTestCase(String arg0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic void testToDo() {}\\n\\n\t/**\\n\t * XXX not currently used, fix tests when using\\n\tpublic void testHierarchyDepends() {\\n\t\tBcelWorld world = n"
  },
  {
    "method_id": "M3913",
    "name": "testToDo",
    "return_type": "void",
    "signature": "testToDo()",
    "file_id": "F138",
    "start_line": 25,
    "text_preview": "rchyDependsTestCase extends TestCase {\\n\\n\tpublic HierarchyDependsTestCase(String arg0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic void testToDo() {}\\n\\n\t/**\\n\t * XXX not currently used, fix tests when using\\n\tpublic void testHierarchyDepends() {\\n\t\tBcelWorld world = new BcelWorld();\\n\t\tTypePatternQuestions questions = new TypePatternQuesti"
  },
  {
    "method_id": "M3914",
    "name": "testHierarchyDepends",
    "return_type": "void",
    "signature": "testHierarchyDepends()",
    "file_id": "F138",
    "start_line": 29,
    "text_preview": "g0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic void testToDo() {}\\n\\n\t/**\\n\t * XXX not currently used, fix tests when using\\n\tpublic void testHierarchyDepends() {\\n\t\tBcelWorld world = new BcelWorld();\\n\t\tTypePatternQuestions questions = new TypePatternQuestions();\\n\t\tResolvedType runnableType = world.resolve(\"java.lang.Runnable\");\\n\t\tResolv"
  },
  {
    "method_id": "M3915",
    "name": "IdWeaveTestCase",
    "return_type": "",
    "signature": "IdWeaveTestCase(String name)",
    "file_id": "F139",
    "start_line": 28,
    "text_preview": "tj.weaver.patterns.Pointcut;\\n\\npublic class IdWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic IdWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testFancyId() throws IOException {\\n\t\tfinal List l = new ArrayList();\\n\t\tPointcut pointcut2 = makePointcutAll();\\n\t\tBcelAdvice p = new BcelA"
  },
  {
    "method_id": "M3916",
    "name": "testFancyId",
    "return_type": "void",
    "signature": "testFancyId()",
    "file_id": "F139",
    "start_line": 32,
    "text_preview": "nds WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic IdWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testFancyId() throws IOException {\\n\t\tfinal List l = new ArrayList();\\n\t\tPointcut pointcut2 = makePointcutAll();\\n\t\tBcelAdvice p = new BcelAdvice(null, pointcut2, null, 0, -1, -1, null, null) {\\n\t\t\tpublic"
  },
  {
    "method_id": "M3917",
    "name": "BcelAdvice",
    "return_type": "new",
    "signature": "BcelAdvice(null, pointcut2, null, 0, -1, -1, null, null)",
    "file_id": "F139",
    "start_line": 35,
    "text_preview": ") throws IOException {\\n\t\tfinal List l = new ArrayList();\\n\t\tPointcut pointcut2 = makePointcutAll();\\n\t\tBcelAdvice p = new BcelAdvice(null, pointcut2, null, 0, -1, -1, null, null) {\\n\t\t\tpublic boolean match(Shadow shadow, World world) {\\n\t\t\t\tif (super.match(shadow, world)) {\\n\t\t\t\t\tl.add(shadow);\\n\t\t\t\t}\\n\t\t\t\treturn false;\\n\t\t\t}\\n"
  },
  {
    "method_id": "M3918",
    "name": "match",
    "return_type": "boolean",
    "signature": "match(Shadow shadow, World world)",
    "file_id": "F139",
    "start_line": 36,
    "text_preview": " = makePointcutAll();\\n\t\tBcelAdvice p = new BcelAdvice(null, pointcut2, null, 0, -1, -1, null, null) {\\n\t\t\tpublic boolean match(Shadow shadow, World world) {\\n\t\t\t\tif (super.match(shadow, world)) {\\n\t\t\t\t\tl.add(shadow);\\n\t\t\t\t}\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t};\\n\t\tweaveTest(new String[] { \"FancyHelloWorld\" }, \"Id2\", p);\\n\\n\t\tcheckShado"
  },
  {
    "method_id": "M3919",
    "name": "testId",
    "return_type": "void",
    "signature": "testId()",
    "file_id": "F139",
    "start_line": 57,
    "text_preview": "elloWorld.<init>())\",\\n\t\t\t\t\"constructor-call(void java.lang.StringBuffer.<init>(java.lang.String))\" });\\n\t}\\n\\n\tpublic void testId() throws IOException {\\n\t\tfinal List l = new ArrayList();\\n\t\tBcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\\n\t\t\tpublic boolean implementOn(Shadow shadow) {\\n\t"
  },
  {
    "method_id": "M3920",
    "name": "implementOn",
    "return_type": "boolean",
    "signature": "implementOn(Shadow shadow)",
    "file_id": "F139",
    "start_line": 60,
    "text_preview": " ArrayList();\\n\t\tBcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\\n\t\t\tpublic boolean implementOn(Shadow shadow) {\\n\t\t\t\tl.add(shadow);\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t};\\n\t\tweaveTest(new String[] { \"HelloWorld\" }, \"Id2\", p);\\n\\n\t\tcheckShadowSet(l, new String[] { \"method-execution(void HelloWorld.m"
  },
  {
    "method_id": "M3921",
    "name": "testTraceId",
    "return_type": "void",
    "signature": "testTraceId()",
    "file_id": "F139",
    "start_line": 73,
    "text_preview": "<init>())\", });\\n\t}\\n\\n\t// this test requires that Trace has been unzipped and placed in the correct place\\n\t// public void testTraceId() throws IOException {\\n\t// String saveClassDir = classDir;\\n\t// try {\\n\t// classDir = \"testdata/dummyAspect.jar\";\\n\t//\\n\t//\\n\t//\\n\t// final List l = new ArrayList();\\n\t// BcelAdvice p = new BcelA"
  },
  {
    "method_id": "M3922",
    "name": "implementOn",
    "return_type": "void",
    "signature": "implementOn(Shadow shadow)",
    "file_id": "F139",
    "start_line": 60,
    "text_preview": " ArrayList();\\n\t\tBcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\\n\t\t\tpublic boolean implementOn(Shadow shadow) {\\n\t\t\t\tl.add(shadow);\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t};\\n\t\tweaveTest(new String[] { \"HelloWorld\" }, \"Id2\", p);\\n\\n\t\tcheckShadowSet(l, new String[] { \"method-execution(void HelloWorld.m"
  },
  {
    "method_id": "M3923",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F140",
    "start_line": 45,
    "text_preview": "r}.\\n *\\n * @author Andy Clement\\n */\\npublic class JImageTestCase extends TestCase {\\n\\n\tClassPathManager cpm;\\n\\n\tpublic void setUp() throws Exception {\\n\t\tList<String> paths = new ArrayList<>();\\n\t\tpaths.add(LangUtil.getJrtFsFilePath());\\n\t\tcpm = new ClassPathManager(paths,new TestMessageHandler());\\n\t}\\n\\n\tpublic void testOnJava"
  },
  {
    "method_id": "M3924",
    "name": "testOnJava9",
    "return_type": "void",
    "signature": "testOnJava9()",
    "file_id": "F140",
    "start_line": 51,
    "text_preview": "\tpaths.add(LangUtil.getJrtFsFilePath());\\n\t\tcpm = new ClassPathManager(paths,new TestMessageHandler());\\n\t}\\n\\n\tpublic void testOnJava9() {\\n\t\tif (!LangUtil.isVMGreaterOrEqual(9)) {\\n\t\t\tSystem.out.println(\"SKIPPING JIMAGE TESTS AS NOT ON 1.9 OR LATER\");\\n\t\t}\\n\t}\\n\\n\tpublic void testBasicStructureAndCapabilities() {\\n\t\tif (!LangUt"
  },
  {
    "method_id": "M3925",
    "name": "testBasicStructureAndCapabilities",
    "return_type": "void",
    "signature": "testBasicStructureAndCapabilities()",
    "file_id": "F140",
    "start_line": 57,
    "text_preview": "il.isVMGreaterOrEqual(9)) {\\n\t\t\tSystem.out.println(\"SKIPPING JIMAGE TESTS AS NOT ON 1.9 OR LATER\");\\n\t\t}\\n\t}\\n\\n\tpublic void testBasicStructureAndCapabilities() {\\n\t\tif (!LangUtil.isVMGreaterOrEqual(9)) return;\\n\t\t// Should be one entry for finding JRT contents\\n\t\tList<Entry> entries = cpm.getEntries();\\n\t\tassertEquals(1,entrie"
  },
  {
    "method_id": "M3926",
    "name": "testBehaviour",
    "return_type": "void",
    "signature": "testBehaviour()",
    "file_id": "F140",
    "start_line": 69,
    "text_preview": "\\n\t\tassertNotNull(stringClassFile);\\n\t\tassertEquals(\"java/lang/String.class\",stringClassFile.getPath());\\n\t}\\n\\n\tpublic void testBehaviour() throws Exception {\\n\t\tif (!LangUtil.isVMGreaterOrEqual(9)) return;\\n\t\tJImageEntry jie = getJImageEntry();\\n\\n\t\tMap<String, Path> packageCache = jie.getPackageCache();\\n\t\tassertTrue(packageC"
  },
  {
    "method_id": "M3927",
    "name": "handleMessage",
    "return_type": "boolean",
    "signature": "handleMessage(IMessage message)",
    "file_id": "F140",
    "start_line": 90,
    "text_preview": "tion of SoftReferences\\n\t}\\n\\n\\n\tstatic class TestMessageHandler implements IMessageHandler {\\n\\n\t\t@Override\\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean isIgnoring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void dontIgnore(Kind kind)"
  },
  {
    "method_id": "M3928",
    "name": "isIgnoring",
    "return_type": "boolean",
    "signature": "isIgnoring(Kind kind)",
    "file_id": "F140",
    "start_line": 95,
    "text_preview": "blic boolean handleMessage(IMessage message) throws AbortException {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean isIgnoring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void dontIgnore(Kind kind) {\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void ignore(Kind kind) {\\n\t\t}\\n\\n\t}\\n\\n\t// ---\\n\\n\tprivate JImageEntry getJImageEntry"
  },
  {
    "method_id": "M3929",
    "name": "dontIgnore",
    "return_type": "void",
    "signature": "dontIgnore(Kind kind)",
    "file_id": "F140",
    "start_line": 100,
    "text_preview": "return false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic boolean isIgnoring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void dontIgnore(Kind kind) {\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void ignore(Kind kind) {\\n\t\t}\\n\\n\t}\\n\\n\t// ---\\n\\n\tprivate JImageEntry getJImageEntry() {\\n\t\treturn (JImageEntry) cpm.getEntries().get(0);\\n\t}\\n\\n\tpublic List<St"
  },
  {
    "method_id": "M3930",
    "name": "ignore",
    "return_type": "void",
    "signature": "ignore(Kind kind)",
    "file_id": "F140",
    "start_line": 104,
    "text_preview": "ing(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void dontIgnore(Kind kind) {\\n\t\t}\\n\\n\t\t@Override\\n\t\tpublic void ignore(Kind kind) {\\n\t\t}\\n\\n\t}\\n\\n\t// ---\\n\\n\tprivate JImageEntry getJImageEntry() {\\n\t\treturn (JImageEntry) cpm.getEntries().get(0);\\n\t}\\n\\n\tpublic List<String> getAllTheClasses() {\\n\t\tfinal List<String> result "
  },
  {
    "method_id": "M3931",
    "name": "getJImageEntry",
    "return_type": "JImageEntry",
    "signature": "getJImageEntry()",
    "file_id": "F140",
    "start_line": 71,
    "text_preview": "\\n\t}\\n\\n\tpublic void testBehaviour() throws Exception {\\n\t\tif (!LangUtil.isVMGreaterOrEqual(9)) return;\\n\t\tJImageEntry jie = getJImageEntry();\\n\\n\t\tMap<String, Path> packageCache = jie.getPackageCache();\\n\t\tassertTrue(packageCache.size()>0);\\n\t\t// Note: seems to be about 1625 entries in it for Java9\\n\t\tPath path = packageCache.g"
  },
  {
    "method_id": "M3932",
    "name": "getAllTheClasses",
    "return_type": "List<String>",
    "signature": "getAllTheClasses()",
    "file_id": "F140",
    "start_line": 115,
    "text_preview": "/ ---\\n\\n\tprivate JImageEntry getJImageEntry() {\\n\t\treturn (JImageEntry) cpm.getEntries().get(0);\\n\t}\\n\\n\tpublic List<String> getAllTheClasses() {\\n\t\tfinal List<String> result = new ArrayList<>();\\n\t\tURI JRT_URI = URI.create(\"jrt:/\"); //$NON-NLS-1$\\n\t\tFileSystem fs = FileSystems.getFileSystem(JRT_URI);\\n\t\tIterable<java.nio.file."
  },
  {
    "method_id": "M3933",
    "name": "for",
    "return_type": "",
    "signature": "for(java.nio.file.Path path : roots)",
    "file_id": "F140",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3934",
    "name": "walkFileTree",
    "return_type": "",
    "signature": "walkFileTree(path, new SimpleFileVisitor<Path>()",
    "file_id": "F140",
    "start_line": 122,
    "text_preview": "rable<java.nio.file.Path> roots = fs.getRootDirectories();\\n\t\ttry {\\n\t\t\tfor (java.nio.file.Path path : roots) {\\n\t\t\t\tFiles.walkFileTree(path, new SimpleFileVisitor<Path>() {\\n\t\t\t\t\t@Override\\n\t\t\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\\n\t\t\t\t\t\tif (file.getNameCount()>3 && fi"
  },
  {
    "method_id": "M3935",
    "name": "visitFile",
    "return_type": "FileVisitResult",
    "signature": "visitFile(Path file, BasicFileAttributes attrs)",
    "file_id": "F140",
    "start_line": 124,
    "text_preview": "path : roots) {\\n\t\t\t\tFiles.walkFileTree(path, new SimpleFileVisitor<Path>() {\\n\t\t\t\t\t@Override\\n\t\t\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\\n\t\t\t\t\t\tif (file.getNameCount()>3 && file.toString().endsWith(\".class\")) {\\n\t\t\t\t\t\t\tString withClassSuffix = file.subpath(2, file.getNa"
  },
  {
    "method_id": "M3936",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F140",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M3937",
    "name": "MegaZipTestCase",
    "return_type": "",
    "signature": "MegaZipTestCase(String arg0)",
    "file_id": "F141",
    "start_line": 33,
    "text_preview": "rg.aspectj.weaver.WeaverTestCase;\\n\\npublic class MegaZipTestCase extends WeaveTestCase {\\n\\n\tprivate File outDir;\\n\\n\tpublic MegaZipTestCase(String arg0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\toutDir = WeaverTestCase.getOutdir();\\n\t}\\n\\n\tpublic void tearDown() throws Exception {\\n\t\tsuper"
  },
  {
    "method_id": "M3938",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F141",
    "start_line": 37,
    "text_preview": " extends WeaveTestCase {\\n\\n\tprivate File outDir;\\n\\n\tpublic MegaZipTestCase(String arg0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\toutDir = WeaverTestCase.getOutdir();\\n\t}\\n\\n\tpublic void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\t\tWeaverTestCase.removeOutDir();\\n\t\toutDir = null;\\n"
  },
  {
    "method_id": "M3939",
    "name": "tearDown",
    "return_type": "void",
    "signature": "tearDown()",
    "file_id": "F141",
    "start_line": 42,
    "text_preview": ");\\n\t}\\n\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\toutDir = WeaverTestCase.getOutdir();\\n\t}\\n\\n\tpublic void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\t\tWeaverTestCase.removeOutDir();\\n\t\toutDir = null;\\n\t}\\n\\n\tprivate BcelAdvice makeAroundMunger(final boolean matchOnlyPrintln) {\\n\t\t// BcelWorld world = ne"
  },
  {
    "method_id": "M3940",
    "name": "makeAroundMunger",
    "return_type": "BcelAdvice",
    "signature": "makeAroundMunger(final boolean matchOnlyPrintln)",
    "file_id": "F141",
    "start_line": 48,
    "text_preview": "Down() throws Exception {\\n\t\tsuper.tearDown();\\n\t\tWeaverTestCase.removeOutDir();\\n\t\toutDir = null;\\n\t}\\n\\n\tprivate BcelAdvice makeAroundMunger(final boolean matchOnlyPrintln) {\\n\t\t// BcelWorld world = new BcelWorld();\\n\t\tfinal Member sig = MemberImpl.method(UnresolvedType.forName(\"fluffy.Aspect\"), Modifier.STATIC, \"aroundFun\","
  },
  {
    "method_id": "M3941",
    "name": "specializeOn",
    "return_type": "void",
    "signature": "specializeOn(Shadow s)",
    "file_id": "F141",
    "start_line": 55,
    "text_preview": "round\"), matchOnlyPrintln ? makePointcutPrintln() : makePointcutAll(), sig,\\n\t\t\t\t0, -1, -1, null, null) {\\n\t\t\tpublic void specializeOn(Shadow s) {\\n\t\t\t\tsuper.specializeOn(s);\\n\t\t\t\t((BcelShadow) s).initializeForAroundClosure();\\n\t\t\t}\\n\t\t};\\n\t}\\n\\n\tpublic List<ShadowMunger> getShadowMungers() {\\n\t\tList<ShadowMunger> ret = new Arra"
  },
  {
    "method_id": "M3942",
    "name": "getShadowMungers",
    "return_type": "List<ShadowMunger>",
    "signature": "getShadowMungers()",
    "file_id": "F141",
    "start_line": 62,
    "text_preview": "\\n\t\t\t\tsuper.specializeOn(s);\\n\t\t\t\t((BcelShadow) s).initializeForAroundClosure();\\n\t\t\t}\\n\t\t};\\n\t}\\n\\n\tpublic List<ShadowMunger> getShadowMungers() {\\n\t\tList<ShadowMunger> ret = new ArrayList<>();\\n\t\tret.add(makeConcreteAdvice(\"before\" + \"(): call(* *.println(..)) -> static void fluffy.Aspect.before_method_call()\"));\\n\t\tret.add(ma"
  },
  {
    "method_id": "M3943",
    "name": "zipTest",
    "return_type": "void",
    "signature": "zipTest(String fileName)",
    "file_id": "F141",
    "start_line": 80,
    "text_preview": "*.*(..)) -> static void fluffy.Aspect.ignoreMe()\"));\\n\\n\t\tret.add(makeAroundMunger(true));\\n\t\treturn ret;\\n\t}\\n\\n\tpublic void zipTest(String fileName) throws IOException {\\n\t\tlong startTime = System.currentTimeMillis();\\n\t\tFile inFile = new File(WeaverTestCase.TESTDATA_PATH, fileName);\\n\t\tFile outFile = new File(outDir, fileNam"
  },
  {
    "method_id": "M3944",
    "name": "testEmptyForAntJUnit",
    "return_type": "void",
    "signature": "testEmptyForAntJUnit()",
    "file_id": "F141",
    "start_line": 97,
    "text_preview": "ShadowMungers());\\n\\n\t\tweaver.weave(weaver1, outFile);\\n\t\tassertTrue(outFile.lastModified() > startTime);\\n\t}\\n\\n\tpublic void testEmptyForAntJUnit() {\\n\t}\\n\\n\t// this is something we test every now and again.\\n\t// to try, rename as testBig and put aspectjtools.jar in testdata\\n\tpublic void trytestBig() throws IOException {\\n\t\tSyst"
  },
  {
    "method_id": "M3945",
    "name": "trytestBig",
    "return_type": "void",
    "signature": "trytestBig()",
    "file_id": "F141",
    "start_line": 102,
    "text_preview": " something we test every now and again.\\n\t// to try, rename as testBig and put aspectjtools.jar in testdata\\n\tpublic void trytestBig() throws IOException {\\n\t\tSystem.out.println(\"could take 80 seconds...\");\\n\t\tzipTest(\"aspectjtools.jar\");\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M3946",
    "name": "MoveInstructionsWeaveTestCase",
    "return_type": "",
    "signature": "MoveInstructionsWeaveTestCase(String name)",
    "file_id": "F142",
    "start_line": 27,
    "text_preview": "weaver.Shadow;\\n\\npublic class MoveInstructionsWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic MoveInstructionsWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testHello() throws IOException {\\n\t\tBcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\\n\t\t"
  },
  {
    "method_id": "M3947",
    "name": "testHello",
    "return_type": "void",
    "signature": "testHello()",
    "file_id": "F142",
    "start_line": 31,
    "text_preview": "ase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic MoveInstructionsWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testHello() throws IOException {\\n\t\tBcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\\n\t\t\tpublic void specializeOn(Shadow s) {\\n\t\t\t\tsuper.specializeOn(s);\\n\t\t\t\t((BcelSh"
  },
  {
    "method_id": "M3948",
    "name": "specializeOn",
    "return_type": "void",
    "signature": "specializeOn(Shadow s)",
    "file_id": "F142",
    "start_line": 33,
    "text_preview": "ws IOException {\\n\t\tBcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\\n\t\t\tpublic void specializeOn(Shadow s) {\\n\t\t\t\tsuper.specializeOn(s);\\n\t\t\t\t((BcelShadow) s).initializeForAroundClosure();\\n\t\t\t}\\n\\n\t\t\tpublic boolean implementOn(Shadow s) {\\n\t\t\t\tBcelShadow shadow = (BcelShadow) s;\\n\t\t\t\tLazyM"
  },
  {
    "method_id": "M3949",
    "name": "implementOn",
    "return_type": "boolean",
    "signature": "implementOn(Shadow s)",
    "file_id": "F142",
    "start_line": 38,
    "text_preview": "izeOn(Shadow s) {\\n\t\t\t\tsuper.specializeOn(s);\\n\t\t\t\t((BcelShadow) s).initializeForAroundClosure();\\n\t\t\t}\\n\\n\t\t\tpublic boolean implementOn(Shadow s) {\\n\t\t\t\tBcelShadow shadow = (BcelShadow) s;\\n\t\t\t\tLazyMethodGen newMethod = shadow.extractShadowInstructionsIntoNewMethod(NameMangler.getExtractableName(shadow\\n\t\t\t\t\t\t.getSignature())"
  },
  {
    "method_id": "M3950",
    "name": "testFancyHello",
    "return_type": "void",
    "signature": "testFancyHello()",
    "file_id": "F142",
    "start_line": 57,
    "text_preview": "return true;\\n\t\t\t}\\n\t\t};\\n\\n\t\tweaveTest(\"HelloWorld\", \"ExtractedHelloWorld\", p);\\n\t}\\n\\n\tstatic int counter = 0;\\n\\n\tpublic void testFancyHello() throws IOException {\\n\t\t// Reset counter, just in case this test runs multiple times in one JVM. This can happen e.g. due to \"run all tests\"\\n\t\t// in IntelliJ IDEA, which directly runs "
  },
  {
    "method_id": "M3951",
    "name": "specializeOn",
    "return_type": "void",
    "signature": "specializeOn(Shadow s)",
    "file_id": "F142",
    "start_line": 33,
    "text_preview": "ws IOException {\\n\t\tBcelAdvice p = new BcelAdvice(null, makePointcutAll(), null, 0, -1, -1, null, null) {\\n\t\t\tpublic void specializeOn(Shadow s) {\\n\t\t\t\tsuper.specializeOn(s);\\n\t\t\t\t((BcelShadow) s).initializeForAroundClosure();\\n\t\t\t}\\n\\n\t\t\tpublic boolean implementOn(Shadow s) {\\n\t\t\t\tBcelShadow shadow = (BcelShadow) s;\\n\t\t\t\tLazyM"
  },
  {
    "method_id": "M3952",
    "name": "implementOn",
    "return_type": "boolean",
    "signature": "implementOn(Shadow s)",
    "file_id": "F142",
    "start_line": 38,
    "text_preview": "izeOn(Shadow s) {\\n\t\t\t\tsuper.specializeOn(s);\\n\t\t\t\t((BcelShadow) s).initializeForAroundClosure();\\n\t\t\t}\\n\\n\t\t\tpublic boolean implementOn(Shadow s) {\\n\t\t\t\tBcelShadow shadow = (BcelShadow) s;\\n\t\t\t\tLazyMethodGen newMethod = shadow.extractShadowInstructionsIntoNewMethod(NameMangler.getExtractableName(shadow\\n\t\t\t\t\t\t.getSignature())"
  },
  {
    "method_id": "M3953",
    "name": "NonstaticWeaveTestCase",
    "return_type": "",
    "signature": "NonstaticWeaveTestCase(String name)",
    "file_id": "F143",
    "start_line": 31,
    "text_preview": "r.patterns.TestScope;\\n\\npublic class NonstaticWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic NonstaticWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testBefore() throws IOException {\\n\t\tString s = \"before(): get(* *.*) -> void Aspect.ajc_before()\";\\n\t\tPerClause per = new PerSingl"
  },
  {
    "method_id": "M3954",
    "name": "testBefore",
    "return_type": "void",
    "signature": "testBefore()",
    "file_id": "F143",
    "start_line": 36,
    "text_preview": "eTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic NonstaticWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testBefore() throws IOException {\\n\t\tString s = \"before(): get(* *.*) -> void Aspect.ajc_before()\";\\n\t\tPerClause per = new PerSingleton();\\n\t\tper = per.concretize(world.resolve(\"Aspect\"));\\n\\n        Shado"
  },
  {
    "method_id": "M3955",
    "name": "testBeforeCflow",
    "return_type": "void",
    "signature": "testBeforeCflow()",
    "file_id": "F143",
    "start_line": 46,
    "text_preview": "= this.makeConcreteAdvice(s, 0, per);\\n\\n\t\tweaveTest(getStandardTargets(), \"NonStaticBefore\", myMunger);\\n\t}\\n\\n\tpublic void testBeforeCflow() throws IOException {\\n\t\tString s = \"before(): get(* *.*) -> void Aspect.ajc_before()\";\\n\t\tPerClause per = new PatternParser(\"percflow(execution(void main(..)))\").maybeParsePerClause();"
  },
  {
    "method_id": "M3956",
    "name": "testBeforePerThis",
    "return_type": "void",
    "signature": "testBeforePerThis()",
    "file_id": "F143",
    "start_line": 65,
    "text_preview": "unger(myMunger);\\n\\n\\n\t\tweaveTest(getStandardTargets(), \"CflowNonStaticBefore\", xcut.getShadowMungers());\\n\t}\\n\\n\tpublic void testBeforePerThis() throws IOException {\\n\t\tString s = \"before(): call(* println(..)) -> void Aspect.ajc_before()\";\\n\t\tPerClause per = new PatternParser(\"pertarget(call(* println(..)))\").maybeParsePerCl"
  },
  {
    "method_id": "M3957",
    "name": "PatternWeaveTestCase",
    "return_type": "",
    "signature": "PatternWeaveTestCase(String name)",
    "file_id": "F144",
    "start_line": 35,
    "text_preview": "r.patterns.SimpleScope;\\n\\npublic class PatternWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic PatternWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tString[] none = new String[0];\\n\\n\t// XXX this test is incompatible with optimizations made to weaver\\n\\n\tpublic void testPublic() throws IOExceptio"
  },
  {
    "method_id": "M3958",
    "name": "testPublic",
    "return_type": "void",
    "signature": "testPublic()",
    "file_id": "F144",
    "start_line": 43,
    "text_preview": "\\n\t}\\n\\n\tString[] none = new String[0];\\n\\n\t// XXX this test is incompatible with optimizations made to weaver\\n\\n\tpublic void testPublic() throws IOException {\\n\t\tString[] publicHello = new String[] { \"method-execution(void HelloWorld.main(java.lang.String[]))\", };\\n\t\tString[] publicFancyHello = new String[] { \"method-executio"
  },
  {
    "method_id": "M3959",
    "name": "testPrintln",
    "return_type": "void",
    "signature": "testPrintln()",
    "file_id": "F144",
    "start_line": 51,
    "text_preview": "ld.getName())\", };\\n\t\tcheckPointcut(\"execution(public * *(..))\", publicHello, publicFancyHello);\\n\t}\\n\\n\t//\\n\t// public void testPrintln() throws IOException {\\n\t// String[] callPrintlnHello = new String[] {\\n\t// \"method-call(void java.io.PrintStream.println(java.lang.String))\",\\n\t// };\\n\t// String[] callPrintlnFancyHello = new"
  },
  {
    "method_id": "M3960",
    "name": "testMumble",
    "return_type": "void",
    "signature": "testMumble()",
    "file_id": "F144",
    "start_line": 63,
    "text_preview": "))\",\\n\t// };\\n\t// checkPointcut(\"call(* println(*))\", callPrintlnHello, callPrintlnFancyHello);\\n\t// }\\n\t//\\n\t// public void testMumble() throws IOException {\\n\t// checkPointcut(\"call(* mumble(*))\", none, none);\\n\t// }\\n\t//\\n\t// public void testFooBar() throws IOException {\\n\t// checkPointcut(\"call(FooBar *(..))\", none, none);\\n\t"
  },
  {
    "method_id": "M3961",
    "name": "testFooBar",
    "return_type": "void",
    "signature": "testFooBar()",
    "file_id": "F144",
    "start_line": 67,
    "text_preview": "ic void testMumble() throws IOException {\\n\t// checkPointcut(\"call(* mumble(*))\", none, none);\\n\t// }\\n\t//\\n\t// public void testFooBar() throws IOException {\\n\t// checkPointcut(\"call(FooBar *(..))\", none, none);\\n\t// }\\n\t//\\n\t// public void testGetOut() throws IOException {\\n\t// String[] getOutHello = new String[] {\\n\t// \"field-"
  },
  {
    "method_id": "M3962",
    "name": "testGetOut",
    "return_type": "void",
    "signature": "testGetOut()",
    "file_id": "F144",
    "start_line": 71,
    "text_preview": "c void testFooBar() throws IOException {\\n\t// checkPointcut(\"call(FooBar *(..))\", none, none);\\n\t// }\\n\t//\\n\t// public void testGetOut() throws IOException {\\n\t// String[] getOutHello = new String[] {\\n\t// \"field-get(java.io.PrintStream java.lang.System.out)\",\\n\t// };\\n\t//\\n\t// checkPointcut(\"get(* java.lang.System.out)\", getOu"
  },
  {
    "method_id": "M3963",
    "name": "makePointcut",
    "return_type": "Pointcut",
    "signature": "makePointcut(String s)",
    "file_id": "F144",
    "start_line": 79,
    "text_preview": "// };\\n\t//\\n\t// checkPointcut(\"get(* java.lang.System.out)\", getOutHello, getOutHello);\\n\t// }\\n\t//\\n\t// // private Pointcut makePointcut(String s) {\\n\t// // return new PatternParser(s).parsePointcut();\\n\t// // }\\n\t//\\n\tprivate void checkPointcut(String pointcutSource, String[] expectedHelloShadows, String[] expectedFancyShadow"
  },
  {
    "method_id": "M3964",
    "name": "checkPointcut",
    "return_type": "void",
    "signature": "checkPointcut(String pointcutSource, String[] expectedHelloShadows, String[] expectedFancyShadows)",
    "file_id": "F144",
    "start_line": 47,
    "text_preview": "id FancyHelloWorld.main(java.lang.String[]))\",\\n\t\t\t\t\"method-execution(java.lang.String FancyHelloWorld.getName())\", };\\n\t\tcheckPointcut(\"execution(public * *(..))\", publicHello, publicFancyHello);\\n\t}\\n\\n\t//\\n\t// public void testPrintln() throws IOException {\\n\t// String[] callPrintlnHello = new String[] {\\n\t// \"method-call(vo"
  },
  {
    "method_id": "M3965",
    "name": "BcelAdvice",
    "return_type": "new",
    "signature": "BcelAdvice(null, cp, null, 0, -1, -1, null, null)",
    "file_id": "F144",
    "start_line": 90,
    "text_preview": "= rp.concretize(ResolvedType.MISSING, ResolvedType.MISSING, 0);\\n\\n\t\tfinal List l = new ArrayList();\\n\t\tBcelAdvice p = new BcelAdvice(null, cp, null, 0, -1, -1, null, null) {\\n\t\t\tpublic boolean implementOn(Shadow shadow) {\\n\t\t\t\tl.add(shadow);\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t};\\n\t\tweaveTest(new String[] { \"HelloWorld\" }, \"PatternWeav"
  },
  {
    "method_id": "M3966",
    "name": "implementOn",
    "return_type": "boolean",
    "signature": "implementOn(Shadow shadow)",
    "file_id": "F144",
    "start_line": 91,
    "text_preview": "al List l = new ArrayList();\\n\t\tBcelAdvice p = new BcelAdvice(null, cp, null, 0, -1, -1, null, null) {\\n\t\t\tpublic boolean implementOn(Shadow shadow) {\\n\t\t\t\tl.add(shadow);\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t};\\n\t\tweaveTest(new String[] { \"HelloWorld\" }, \"PatternWeave\", p);\\n\\n\t\tcheckShadowSet(l, expectedHelloShadows);\\n\\n\t\tl.clear();\\n\t\twe"
  },
  {
    "method_id": "M3967",
    "name": "checkSerialize",
    "return_type": "void",
    "signature": "checkSerialize(Pointcut p)",
    "file_id": "F144",
    "start_line": 105,
    "text_preview": "r();\\n\t\tweaveTest(new String[] { \"FancyHelloWorld\" }, \"PatternWeave\", p);\\n\\n\t\tcheckShadowSet(l, expectedFancyShadows);\\n\\n\t\tcheckSerialize(rp);\\n\t}\\n\\n\tpublic void checkSerialize(Pointcut p) throws IOException {\\n\t\tByteArrayOutputStream bo = new ByteArrayOutputStream();\\n\t\tConstantPoolSimulator cps = new ConstantPoolSimulator()"
  },
  {
    "method_id": "M3968",
    "name": "PointcutResidueTestCase",
    "return_type": "",
    "signature": "PointcutResidueTestCase(String name)",
    "file_id": "F145",
    "start_line": 39,
    "text_preview": "atterns.SimpleScope;\\n\\npublic class PointcutResidueTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic PointcutResidueTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tString[] none = new String[0];\\n\\n\t// -----\\n\\n\t// ----\\n\\n\tpublic void testArgResidue1() throws IOException {\\n\t\tcheckMultiArgWeave(\"StringResidue1"
  },
  {
    "method_id": "M3969",
    "name": "testArgResidue1",
    "return_type": "void",
    "signature": "testArgResidue1()",
    "file_id": "F145",
    "start_line": 49,
    "text_preview": "cutResidueTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tString[] none = new String[0];\\n\\n\t// -----\\n\\n\t// ----\\n\\n\tpublic void testArgResidue1() throws IOException {\\n\t\tcheckMultiArgWeave(\"StringResidue1\",\\n\t\t\t\t\"call(* *(java.lang.Object, java.lang.Object)) && args(java.lang.String, java.lang.String)\");\\n\t}\\n\\n\tpublic void testArg"
  },
  {
    "method_id": "M3970",
    "name": "testArgResidue2",
    "return_type": "void",
    "signature": "testArgResidue2()",
    "file_id": "F145",
    "start_line": 54,
    "text_preview": "e1\",\\n\t\t\t\t\"call(* *(java.lang.Object, java.lang.Object)) && args(java.lang.String, java.lang.String)\");\\n\t}\\n\\n\tpublic void testArgResidue2() throws IOException {\\n\t\tcheckMultiArgWeave(\"StringResidue2\", \"call(* *(java.lang.Object, java.lang.Object)) && args(.., java.lang.String)\");\\n\t}\\n\\n\tpublic void testArgResidue3() throws "
  },
  {
    "method_id": "M3971",
    "name": "testArgResidue3",
    "return_type": "void",
    "signature": "testArgResidue3()",
    "file_id": "F145",
    "start_line": 58,
    "text_preview": "eave(\"StringResidue2\", \"call(* *(java.lang.Object, java.lang.Object)) && args(.., java.lang.String)\");\\n\t}\\n\\n\tpublic void testArgResidue3() throws IOException {\\n\t\tcheckMultiArgWeave(\"StringResidue3\", \"call(* *(java.lang.Object, java.lang.Object)) && args(java.lang.String, ..)\");\\n\t}\\n\\n\t// BETAX this is a beta feature.\\n\t// "
  },
  {
    "method_id": "M3972",
    "name": "testArgResidue4",
    "return_type": "void",
    "signature": "testArgResidue4()",
    "file_id": "F145",
    "start_line": 63,
    "text_preview": ".lang.Object, java.lang.Object)) && args(java.lang.String, ..)\");\\n\t}\\n\\n\t// BETAX this is a beta feature.\\n\t// public void testArgResidue4() throws IOException {\\n\t// checkMultiArgWeave(\\n\t// \"StringResidue4\",\\n\t// \"call(* *(java.lang.Object, java.lang.Object)) && args(.., java.lang.String, ..)\");\\n\t// }\\n\\n\tpublic void testMul"
  },
  {
    "method_id": "M3973",
    "name": "testMultiArgState",
    "return_type": "void",
    "signature": "testMultiArgState()",
    "file_id": "F145",
    "start_line": 69,
    "text_preview": "gResidue4\",\\n\t// \"call(* *(java.lang.Object, java.lang.Object)) && args(.., java.lang.String, ..)\");\\n\t// }\\n\\n\tpublic void testMultiArgState() throws IOException {\\n\t\tcheckWeave(\"StateResidue\", \"MultiArgHelloWorld\", \"call(* *(java.lang.Object, java.lang.Object)) && args(s, ..)\",\\n\t\t\t\tnew String[] { \"java.lang.String\" }, new"
  },
  {
    "method_id": "M3974",
    "name": "testAdd",
    "return_type": "void",
    "signature": "testAdd()",
    "file_id": "F145",
    "start_line": 76,
    "text_preview": "ct, java.lang.Object)) && args(s, *)\",\\n\t\t\t\tnew String[] { \"java.lang.String\" }, new String[] { \"s\" });\\n\t}\\n\\n\tpublic void testAdd() throws IOException {\\n\t\tcheckDynamicWeave(\"AddResidue\", \"call(public * add(..)) && target(java.util.ArrayList)\");\\n\t\tcheckDynamicWeave(\"AddResidue\", \"call(public * add(..)) && (target(java.uti"
  },
  {
    "method_id": "M3975",
    "name": "testNot",
    "return_type": "void",
    "signature": "testNot()",
    "file_id": "F145",
    "start_line": 83,
    "text_preview": "* add(..)) && this(java.io.Serializable) && target(java.util.ArrayList) && !this(java.lang.Integer)\");\\n\t}\\n\\n\tpublic void testNot() throws IOException {\\n\t\tcheckDynamicWeave(\"AddNotResidue\", \"call(public * add(..)) && !target(java.util.ArrayList)\");\\n\t\tcheckDynamicWeave(\"AddNotResidue\", \"call(public * add(..)) && !(target("
  },
  {
    "method_id": "M3976",
    "name": "testState",
    "return_type": "void",
    "signature": "testState()",
    "file_id": "F145",
    "start_line": 89,
    "text_preview": "AddNotResidue\", \"call(public * add(..)) && target(java.lang.Object) && !target(java.util.ArrayList)\");\\n\t}\\n\\n\tpublic void testState() throws IOException {\\n\t\tcheckWeave(\"AddStateResidue\", \"DynamicHelloWorld\", \"call(public * add(..)) && target(list)\",\\n\t\t\t\tnew String[] { \"java.util.ArrayList\" }, new String[] { \"list\" });\\n\t\t"
  },
  {
    "method_id": "M3977",
    "name": "testNoResidueArgs",
    "return_type": "void",
    "signature": "testNoResidueArgs()",
    "file_id": "F145",
    "start_line": 99,
    "text_preview": "* add(..)) && this(java.io.Serializable) && target(java.util.ArrayList) && !this(java.lang.Integer)\");\\n\t}\\n\\n\tpublic void testNoResidueArgs() throws IOException {\\n\t\tcheckDynamicWeave(\"NoResidue\", \"call(public * add(..)) && args(java.lang.Object)\");\\n\t\tcheckDynamicWeave(\"NoResidue\", \"call(public * add(..)) && args(*)\");\\n\t\t"
  },
  {
    "method_id": "M3978",
    "name": "testCflowState",
    "return_type": "void",
    "signature": "testCflowState()",
    "file_id": "F145",
    "start_line": 107,
    "text_preview": "d(..)) && args(*)\");\\n\t\tcheckDynamicWeave(\"NoResidue\", \"call(public * add(..))\");\\n\t}\\n\\n\t// ---- cflow tests\\n\\n\tpublic void testCflowState() throws IOException {\\n\t\tcheckWeave(\"CflowStateResidue\", \"DynamicHelloWorld\",\\n\t\t\t\t\"cflow(call(public * add(..)) && target(list)) && execution(public void main(..))\",\\n\t\t\t\tnew String[] { "
  },
  {
    "method_id": "M3979",
    "name": "checkDynamicWeave",
    "return_type": "void",
    "signature": "checkDynamicWeave(String label, String pointcutSource)",
    "file_id": "F145",
    "start_line": 77,
    "text_preview": " *)\",\\n\t\t\t\tnew String[] { \"java.lang.String\" }, new String[] { \"s\" });\\n\t}\\n\\n\tpublic void testAdd() throws IOException {\\n\t\tcheckDynamicWeave(\"AddResidue\", \"call(public * add(..)) && target(java.util.ArrayList)\");\\n\t\tcheckDynamicWeave(\"AddResidue\", \"call(public * add(..)) && (target(java.util.ArrayList) || target(java.lang."
  },
  {
    "method_id": "M3980",
    "name": "checkMultiArgWeave",
    "return_type": "void",
    "signature": "checkMultiArgWeave(String label, String pointcutSource)",
    "file_id": "F145",
    "start_line": 50,
    "text_preview": "(name);\\n\t}\\n\\n\tString[] none = new String[0];\\n\\n\t// -----\\n\\n\t// ----\\n\\n\tpublic void testArgResidue1() throws IOException {\\n\t\tcheckMultiArgWeave(\"StringResidue1\",\\n\t\t\t\t\"call(* *(java.lang.Object, java.lang.Object)) && args(java.lang.String, java.lang.String)\");\\n\t}\\n\\n\tpublic void testArgResidue2() throws IOException {\\n\t\tcheckMu"
  },
  {
    "method_id": "M3981",
    "name": "checkWeave",
    "return_type": "void",
    "signature": "checkWeave(String label, String filename, String pointcutSource, String[] formalTypes, String[] formalNames)",
    "file_id": "F145",
    "start_line": 70,
    "text_preview": " java.lang.Object)) && args(.., java.lang.String, ..)\");\\n\t// }\\n\\n\tpublic void testMultiArgState() throws IOException {\\n\t\tcheckWeave(\"StateResidue\", \"MultiArgHelloWorld\", \"call(* *(java.lang.Object, java.lang.Object)) && args(s, ..)\",\\n\t\t\t\tnew String[] { \"java.lang.String\" }, new String[] { \"s\" });\\n\t\tcheckWeave(\"StateResi"
  },
  {
    "method_id": "M3982",
    "name": "weaveTest",
    "return_type": "void",
    "signature": "weaveTest(String name, String outName, ShadowMunger planner)",
    "file_id": "F145",
    "start_line": 164,
    "text_preview": "\t// List advice = new ArrayList();\\n\t\t// advice.add(cp);\\n\t\t// advice.addAll(inAspect.getExtraConcreteShadowMungers());\\n\t\tweaveTest(new String[] { filename }, label, xcut.getShadowMungers());\\n\\n\t\tcheckSerialize(rp);\\n\t}\\n\\n\tpublic void weaveTest(String name, String outName, ShadowMunger planner) throws IOException {\\n\t\tList<S"
  },
  {
    "method_id": "M3983",
    "name": "checkSerialize",
    "return_type": "void",
    "signature": "checkSerialize(Pointcut p)",
    "file_id": "F145",
    "start_line": 166,
    "text_preview": "l(inAspect.getExtraConcreteShadowMungers());\\n\t\tweaveTest(new String[] { filename }, label, xcut.getShadowMungers());\\n\\n\t\tcheckSerialize(rp);\\n\t}\\n\\n\tpublic void weaveTest(String name, String outName, ShadowMunger planner) throws IOException {\\n\t\tList<ShadowMunger> l = Collections.singletonList(planner);\\n\t\tweaveTest(name, ou"
  },
  {
    "method_id": "M3984",
    "name": "TjpWeaveTestCase",
    "return_type": "",
    "signature": "TjpWeaveTestCase(String name)",
    "file_id": "F146",
    "start_line": 30,
    "text_preview": "ectj.weaver.UnresolvedType;\\n\\npublic class TjpWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic TjpWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tbehave15 = true;\\n\t}\\n\\n\tpublic void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\t\tbeha"
  },
  {
    "method_id": "M3985",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F146",
    "start_line": 34,
    "text_preview": "ds WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic TjpWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tbehave15 = true;\\n\t}\\n\\n\tpublic void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\t\tbehave15 = false;\\n\t}\\n\\n\tpublic void testStaticTjp() throws IOExceptio"
  },
  {
    "method_id": "M3986",
    "name": "tearDown",
    "return_type": "void",
    "signature": "tearDown()",
    "file_id": "F146",
    "start_line": 39,
    "text_preview": "name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tbehave15 = true;\\n\t}\\n\\n\tpublic void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\t\tbehave15 = false;\\n\t}\\n\\n\tpublic void testStaticTjp() throws IOException {\\n\t\tBcelAdvice munger = new BcelAdvice(AdviceKind.stringToKind(\"before\"), make"
  },
  {
    "method_id": "M3987",
    "name": "testStaticTjp",
    "return_type": "void",
    "signature": "testStaticTjp()",
    "file_id": "F146",
    "start_line": 44,
    "text_preview": "ehave15 = true;\\n\t}\\n\\n\tpublic void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\t\tbehave15 = false;\\n\t}\\n\\n\tpublic void testStaticTjp() throws IOException {\\n\t\tBcelAdvice munger = new BcelAdvice(AdviceKind.stringToKind(\"before\"), makePointcutAll(),\\n\t\t\t\tTestUtils.methodFromString(\"static void Aspect.ajc_before(org.aspect"
  },
  {
    "method_id": "M3988",
    "name": "testEnclosingStaticTjp",
    "return_type": "void",
    "signature": "testEnclosingStaticTjp()",
    "file_id": "F146",
    "start_line": 52,
    "text_preview": "PointStaticPart, -1, -1, null, null);\\n\\n\t\tweaveTest(\"HelloWorld\", \"StaticTjpBeforeHelloWorld\", munger);\\n\t}\\n\\n\tpublic void testEnclosingStaticTjp() throws IOException {\\n\t\tBcelAdvice munger = new BcelAdvice(AdviceKind.stringToKind(\"before\"), makePointcutAll(),\\n\t\t\t\tTestUtils.methodFromString(\"static void Aspect.ajc_before(o"
  },
  {
    "method_id": "M3989",
    "name": "testTjp",
    "return_type": "void",
    "signature": "testTjp()",
    "file_id": "F146",
    "start_line": 60,
    "text_preview": "icPart, -1, -1, null, null);\\n\\n\t\tweaveTest(\"HelloWorld\", \"StaticEnclosingTjpBeforeHelloWorld\", munger);\\n\t}\\n\\n\tpublic void testTjp() throws IOException {\\n\t\tBcelAdvice munger = new BcelAdvice(AdviceKind.stringToKind(\"before\"), makePointcutAll(),\\n\t\t\t\tTestUtils.methodFromString(\"static void Aspect.ajc_before(org.aspectj.lang"
  },
  {
    "method_id": "M3990",
    "name": "testAroundTjp",
    "return_type": "void",
    "signature": "testAroundTjp()",
    "file_id": "F146",
    "start_line": 68,
    "text_preview": "ice.ThisJoinPoint, -1,\\n\t\t\t\t-1, null, null);\\n\\n\t\tweaveTest(\"HelloWorld\", \"TjpBeforeHelloWorld\", munger);\\n\t}\\n\\n\tpublic void testAroundTjp() throws IOException {\\n\t\tBcelAdvice munger = new BcelAdvice(\\n\t\t\t\tAdviceKind.stringToKind(\"around\"),\\n\t\t\t\tmakePointcutAll(),\\n\t\t\t\tTestUtils\\n\t\t\t\t\t\t.methodFromString(\"static java.lang.Object "
  },
  {
    "method_id": "M3991",
    "name": "testAround2Tjp",
    "return_type": "void",
    "signature": "testAround2Tjp()",
    "file_id": "F146",
    "start_line": 79,
    "text_preview": " Advice.ExtraArgument, -1, -1, null, null);\\n\\n\t\tweaveTest(\"HelloWorld\", \"TjpAroundHelloWorld\", munger);\\n\t}\\n\\n\tpublic void testAround2Tjp() throws IOException {\\n\t\tResolvedType rtx = world.resolve(UnresolvedType.forName(\"Aspect\"), true);\\n\t\tassertTrue(\"Couldnt find type Aspect\", !rtx.isMissing());\\n\t\tBcelAdvice munger1 = new"
  },
  {
    "method_id": "M3992",
    "name": "TraceJarWeaveTestCase",
    "return_type": "",
    "signature": "TraceJarWeaveTestCase(String name)",
    "file_id": "F147",
    "start_line": 23,
    "text_preview": "t java.io.IOException;\\n\\npublic class TraceJarWeaveTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic TraceJarWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testTraceJar() throws IOException {\\n\t\tworld = new BcelWorld(getTraceJar());\\n\t\tBcelWeaver weaver = new BcelWeaver(world);\\n\t\tweaver."
  },
  {
    "method_id": "M3993",
    "name": "testTraceJar",
    "return_type": "void",
    "signature": "testTraceJar()",
    "file_id": "F147",
    "start_line": 28,
    "text_preview": "veTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic TraceJarWeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testTraceJar() throws IOException {\\n\t\tworld = new BcelWorld(getTraceJar());\\n\t\tBcelWeaver weaver = new BcelWeaver(world);\\n\t\tweaver.addLibraryAspect(\"MyTrace\");\\n\t\tUnwovenClassFile classFile\\n            "
  },
  {
    "method_id": "M3994",
    "name": "UtilityTestCase",
    "return_type": "",
    "signature": "UtilityTestCase(String name)",
    "file_id": "F148",
    "start_line": 21,
    "text_preview": "ort java.io.IOException;\\n\\nimport junit.framework.TestCase;\\n\\npublic class UtilityTestCase extends TestCase {\\n\\n    public UtilityTestCase(String name) {\\n        super(name);\\n    }\\n\\n    public void disassembleTest(String name) throws IOException {\\n        BcelWorld world = new BcelWorld(\"../weaver/bin\");\\n//        world.s"
  },
  {
    "method_id": "M3995",
    "name": "disassembleTest",
    "return_type": "void",
    "signature": "disassembleTest(String name)",
    "file_id": "F148",
    "start_line": 25,
    "text_preview": "ilityTestCase extends TestCase {\\n\\n    public UtilityTestCase(String name) {\\n        super(name);\\n    }\\n\\n    public void disassembleTest(String name) throws IOException {\\n        BcelWorld world = new BcelWorld(\"../weaver/bin\");\\n//        world.setFastDelegateSupport(false);\\n        world.addPath(WeaveTestCase.classDir)"
  },
  {
    "method_id": "M3996",
    "name": "testHelloWorld",
    "return_type": "void",
    "signature": "testHelloWorld()",
    "file_id": "F148",
    "start_line": 36,
    "text_preview": "d.getBcelObjectType(world.resolve(name)));\\n        clazz.print();\\n        System.out.println();\\n    }\\n\\n\\n    public void testHelloWorld() throws IOException {\\n        disassembleTest(\"Test\");\\n    }\\n    public void testFancyHelloWorld() throws IOException {\\n        disassembleTest(\"FancyHelloWorld\");\\n    }\\n//    public v"
  },
  {
    "method_id": "M3997",
    "name": "testFancyHelloWorld",
    "return_type": "void",
    "signature": "testFancyHelloWorld()",
    "file_id": "F148",
    "start_line": 39,
    "text_preview": ");\\n    }\\n\\n\\n    public void testHelloWorld() throws IOException {\\n        disassembleTest(\"Test\");\\n    }\\n    public void testFancyHelloWorld() throws IOException {\\n        disassembleTest(\"FancyHelloWorld\");\\n    }\\n//    public void testSwitchy() throws IOException {\\n//        disassembleTest(\"TestSwitchy\");\\n//    }\\n\\n   "
  },
  {
    "method_id": "M3998",
    "name": "testSwitchy",
    "return_type": "void",
    "signature": "testSwitchy()",
    "file_id": "F148",
    "start_line": 42,
    "text_preview": "lic void testFancyHelloWorld() throws IOException {\\n        disassembleTest(\"FancyHelloWorld\");\\n    }\\n//    public void testSwitchy() throws IOException {\\n//        disassembleTest(\"TestSwitchy\");\\n//    }\\n\\n    public static void main(String[] args) throws IOException {\\n    \tBcelWorld world = new BcelWorld();\\n        La"
  },
  {
    "method_id": "M3999",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] args)",
    "file_id": "F148",
    "start_line": 46,
    "text_preview": "ublic void testSwitchy() throws IOException {\\n//        disassembleTest(\"TestSwitchy\");\\n//    }\\n\\n    public static void main(String[] args) throws IOException {\\n    \tBcelWorld world = new BcelWorld();\\n        LazyClassGen clazz = new LazyClassGen(BcelWorld.getBcelObjectType(world.resolve(args[0])));\\n        clazz.print"
  },
  {
    "method_id": "M4000",
    "name": "WeaveOrderTestCase",
    "return_type": "",
    "signature": "WeaveOrderTestCase(String name)",
    "file_id": "F149",
    "start_line": 32,
    "text_preview": "s.PatternParser;\\n\\n/**.\\n */\\npublic class WeaveOrderTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic WeaveOrderTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testLexicalOrder() {\\n\t\tAdvice a1 =\\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);\\n\t\tAdvic"
  },
  {
    "method_id": "M4001",
    "name": "testLexicalOrder",
    "return_type": "void",
    "signature": "testLexicalOrder()",
    "file_id": "F149",
    "start_line": 37,
    "text_preview": "WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic WeaveOrderTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testLexicalOrder() {\\n\t\tAdvice a1 =\\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);\\n\t\tAdvice a2 =\\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJE"
  },
  {
    "method_id": "M4002",
    "name": "testLexicalOrderWithAfter",
    "return_type": "void",
    "signature": "testLexicalOrderWithAfter()",
    "file_id": "F149",
    "start_line": 47,
    "text_preview": "solvedType.THROWABLE, 2);\\n\\n\t\tassertEquals(-1, a2.compareTo(a1));\\n\t\tassertEquals(+1, a1.compareTo(a2));\\n\t}\\n\\n\tpublic void testLexicalOrderWithAfter() {\\n\t\tAdvice a1 =\\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);\\n\t\tAdvice a2 =\\n\t\t\tmakeConcreteAdvice(AdviceKind.After, UnresolvedT"
  },
  {
    "method_id": "M4003",
    "name": "testSubtypes",
    "return_type": "void",
    "signature": "testSubtypes()",
    "file_id": "F149",
    "start_line": 65,
    "text_preview": "solvedType.THROWABLE, 2);\\n\\n\t\tassertEquals(+1, a2.compareTo(a1));\\n\t\tassertEquals(-1, a1.compareTo(a2));\\n\t}\\n\\n\tpublic void testSubtypes() {\\n\t\tAdvice a1 =\\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);\\n\t\tAdvice a2 =\\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.THROWABL"
  },
  {
    "method_id": "M4004",
    "name": "testDominates",
    "return_type": "void",
    "signature": "testDominates()",
    "file_id": "F149",
    "start_line": 84,
    "text_preview": "als(-1, a1.compareTo(a3));\\n\\n\t\tassertEquals(0, a3.compareTo(a2));\\n\t\tassertEquals(0, a2.compareTo(a3));\\n\t}\\n\\n\\n\tpublic void testDominates() {\\n\t\tDeclare dom =\\n\t\t\tnew PatternParser(\"declare precedence: java.lang.String, java.lang.Throwable\").parseDeclare();\\n\t\t//??? concretize dom\\n\t\tResolvedType aType =  world.resolve(\"Aspect"
  },
  {
    "method_id": "M4005",
    "name": "testDominatesHarder",
    "return_type": "void",
    "signature": "testDominatesHarder()",
    "file_id": "F149",
    "start_line": 112,
    "text_preview": "s(+1, a1.compareTo(a3));\\n\\n\\n\t\tassertEquals(+1, a3.compareTo(a2));\\n\t\tassertEquals(-1, a2.compareTo(a3));\\n\t}\\n\\n\tpublic void testDominatesHarder() {\\n\t\tDeclare dom =\\n\t\t\tnew PatternParser(\"declare precedence: *, java.lang.String, java.lang.Throwable\").parseDeclare();\\n\t\t//??? concretize dom\\n\t\tResolvedType aType =  world.resolv"
  },
  {
    "method_id": "M4006",
    "name": "makeConcreteAdvice",
    "return_type": "Advice",
    "signature": "makeConcreteAdvice(AdviceKind kind, UnresolvedType declaringAspect,\n\t\t\t\tUnresolvedType concreteAspect, int lexicalPosition)",
    "file_id": "F149",
    "start_line": 39,
    "text_preview": "e;\\n\t}\\n\\n\tpublic WeaveOrderTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\\n\tpublic void testLexicalOrder() {\\n\t\tAdvice a1 =\\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);\\n\t\tAdvice a2 =\\n\t\t\tmakeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.THROWABLE, 2);\\n\\n\t\ta"
  },
  {
    "method_id": "M4007",
    "name": "WeaveTestCase",
    "return_type": "",
    "signature": "WeaveTestCase(String name)",
    "file_id": "F150",
    "start_line": 60,
    "text_preview": "This switch ensures we\\n\t\t// continue to use BCEL for these tests.\\n\t\t// world.setFastDelegateSupport(false);\\n\t}\\n\\n\tpublic WeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\t@Override\\n\tpublic void setUp() throws Exception {\\n\t\toutDir = WeaverTestCase.getOutdir();\\n\t\toutDirPath = outDir.getAbsolutePath();\\n\t}\\n\\n\t@Override\\n\tpubli"
  },
  {
    "method_id": "M4008",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F150",
    "start_line": 65,
    "text_preview": "orld.setFastDelegateSupport(false);\\n\t}\\n\\n\tpublic WeaveTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\t@Override\\n\tpublic void setUp() throws Exception {\\n\t\toutDir = WeaverTestCase.getOutdir();\\n\t\toutDirPath = outDir.getAbsolutePath();\\n\t}\\n\\n\t@Override\\n\tpublic void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\t\tWeaverTestCas"
  },
  {
    "method_id": "M4009",
    "name": "tearDown",
    "return_type": "void",
    "signature": "tearDown()",
    "file_id": "F150",
    "start_line": 71,
    "text_preview": "Exception {\\n\t\toutDir = WeaverTestCase.getOutdir();\\n\t\toutDirPath = outDir.getAbsolutePath();\\n\t}\\n\\n\t@Override\\n\tpublic void tearDown() throws Exception {\\n\t\tsuper.tearDown();\\n\t\tWeaverTestCase.removeOutDir();\\n\t\toutDir = null;\\n\t\toutDirPath = null;\\n\t}\\n\\n\tpublic static InstructionList getAdviceTag(BcelShadow shadow, String where"
  },
  {
    "method_id": "M4010",
    "name": "getAdviceTag",
    "return_type": "InstructionList",
    "signature": "getAdviceTag(BcelShadow shadow, String where)",
    "file_id": "F150",
    "start_line": 78,
    "text_preview": "r.tearDown();\\n\t\tWeaverTestCase.removeOutDir();\\n\t\toutDir = null;\\n\t\toutDirPath = null;\\n\t}\\n\\n\tpublic static InstructionList getAdviceTag(BcelShadow shadow, String where) {\\n\t\tString methodName = \"ajc_\" + where + \"_\" + shadow.getKind().toLegalJavaIdentifier();\\n\\n\t\tInstructionFactory fact = shadow.getFactory();\\n\t\tInvokeInstruc"
  },
  {
    "method_id": "M4011",
    "name": "weaveTest",
    "return_type": "void",
    "signature": "weaveTest(String name, String outName, ShadowMunger planner)",
    "file_id": "F150",
    "start_line": 86,
    "text_preview": "ect\", methodName, Type.VOID, new Type[] {}, Constants.INVOKESTATIC);\\n\t\treturn new InstructionList(il);\\n\t}\\n\\n\tpublic void weaveTest(String name, String outName, ShadowMunger planner) throws IOException {\\n\t\tList<ShadowMunger> l = new ArrayList<>(1);\\n\t\tl.add(planner);\\n\t\tweaveTest(name, outName, l);\\n\t}\\n\\n\t// static String cl"
  },
  {
    "method_id": "M4012",
    "name": "weaveTest",
    "return_type": "void",
    "signature": "weaveTest(String name, String outName, List<ShadowMunger> planners)",
    "file_id": "F150",
    "start_line": 86,
    "text_preview": "ect\", methodName, Type.VOID, new Type[] {}, Constants.INVOKESTATIC);\\n\t\treturn new InstructionList(il);\\n\t}\\n\\n\tpublic void weaveTest(String name, String outName, ShadowMunger planner) throws IOException {\\n\t\tList<ShadowMunger> l = new ArrayList<>(1);\\n\t\tl.add(planner);\\n\t\tweaveTest(name, outName, l);\\n\t}\\n\\n\t// static String cl"
  },
  {
    "method_id": "M4013",
    "name": "weaveTestInner",
    "return_type": "void",
    "signature": "weaveTestInner(BcelWeaver weaver, UnwovenClassFile classFile, String name, String outName)",
    "file_id": "F150",
    "start_line": 105,
    "text_preview": "ssFile(classDir, name, outDirPath);\\n\\n\t\t\tweaver.addClassFile(classFile, false);\\n\t\t\tweaver.setShadowMungers(planners);\\n\t\t\tweaveTestInner(weaver, classFile, name, outName);\\n\t\t} finally {\\n\t\t\tif (behave15)\\n\t\t\t\tworld.setBehaveInJava5Way(false);\\n\t\t}\\n\t}\\n\\n\tprotected void weaveTestInner(BcelWeaver weaver, UnwovenClassFile classF"
  },
  {
    "method_id": "M4014",
    "name": "if",
    "return_type": "",
    "signature": "if(gen == null)",
    "file_id": "F150",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4015",
    "name": "if",
    "return_type": "",
    "signature": "if(runTests)",
    "file_id": "F150",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4016",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Error e)",
    "file_id": "F150",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4017",
    "name": "catch",
    "return_type": "",
    "signature": "catch(RuntimeException e)",
    "file_id": "F150",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4018",
    "name": "findMostRelevantFile",
    "return_type": "String",
    "signature": "findMostRelevantFile(String name)",
    "file_id": "F150",
    "start_line": 121,
    "text_preview": " gen anyway\\n\t\t\tgen = classType.getLazyClassGen(); // new LazyClassGen(classType);\\n\t\t}\\n\t\ttry {\\n\t\t\tString filenameToUse = findMostRelevantFile(outName);\\n\t\t\tcheckClass(gen, outDirPath, filenameToUse);\\n\t\t\tif (runTests) {\\n\t\t\t\tSystem.out.println(\"*******RUNNING: \" + outName + \"  \" + name + \" *******\");\\n\t\t\t\tTestUtil.runMain(m"
  },
  {
    "method_id": "M4019",
    "name": "while",
    "return_type": "",
    "signature": "while(version > 0)",
    "file_id": "F150",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4020",
    "name": "makeClassPath",
    "return_type": "String",
    "signature": "makeClassPath(String outDir)",
    "file_id": "F150",
    "start_line": 125,
    "text_preview": "\t\tif (runTests) {\\n\t\t\t\tSystem.out.println(\"*******RUNNING: \" + outName + \"  \" + name + \" *******\");\\n\t\t\t\tTestUtil.runMain(makeClassPath(outDirPath), name);\\n\t\t\t}\\n\t\t} catch (Error e) {\\n\t\t\tSystem.err.println(\"Comparing to \" + outName + \".txt\");\\n\t\t\tgen.print(System.err);\\n\t\t\tthrow e;\\n\t\t} catch (RuntimeException e) {\\n\t\t\tgen.pr"
  },
  {
    "method_id": "M4021",
    "name": "makeUnwovenClassFile",
    "return_type": "UnwovenClassFile",
    "signature": "makeUnwovenClassFile(String classDir, String name, String outDir)",
    "file_id": "F150",
    "start_line": 101,
    "text_preview": "= new BcelWeaver(world);\\n\t\ttry {\\n\t\t\tif (behave15)\\n\t\t\t\tworld.setBehaveInJava5Way(true);\\n\\n\t\t\tUnwovenClassFile classFile = makeUnwovenClassFile(classDir, name, outDirPath);\\n\\n\t\t\tweaver.addClassFile(classFile, false);\\n\t\t\tweaver.setShadowMungers(planners);\\n\t\t\tweaveTestInner(weaver, classFile, name, outName);\\n\t\t} finally {\\n\t\t"
  },
  {
    "method_id": "M4022",
    "name": "checkClass",
    "return_type": "void",
    "signature": "checkClass(LazyClassGen gen, String outDir, String expectedFile)",
    "file_id": "F150",
    "start_line": 122,
    "text_preview": "LazyClassGen(); // new LazyClassGen(classType);\\n\t\t}\\n\t\ttry {\\n\t\t\tString filenameToUse = findMostRelevantFile(outName);\\n\t\t\tcheckClass(gen, outDirPath, filenameToUse);\\n\t\t\tif (runTests) {\\n\t\t\t\tSystem.out.println(\"*******RUNNING: \" + outName + \"  \" + name + \" *******\");\\n\t\t\t\tTestUtil.runMain(makeClassPath(outDirPath), name);\\n\t"
  },
  {
    "method_id": "M4023",
    "name": "genClass",
    "return_type": "void",
    "signature": "genClass(LazyClassGen gen, String outDir, String expectedFile)",
    "file_id": "F150",
    "start_line": 173,
    "text_preview": "\tpublic void checkClass(LazyClassGen gen, String outDir, String expectedFile) throws IOException {\\n\t\tif (regenerate)\\n\t\t\tgenClass(gen, outDir, expectedFile);\\n\t\telse\\n\t\t\trealCheckClass(gen, outDir, expectedFile);\\n\t}\\n\\n\tstatic final File TESTDATA_DIR = new File(WeaverTestCase.TESTDATA_PATH);\\n\\n\tvoid genClass(LazyClassGen gen"
  },
  {
    "method_id": "M4024",
    "name": "realCheckClass",
    "return_type": "void",
    "signature": "realCheckClass(LazyClassGen gen, String outDir, String expectedFile)",
    "file_id": "F150",
    "start_line": 175,
    "text_preview": "g outDir, String expectedFile) throws IOException {\\n\t\tif (regenerate)\\n\t\t\tgenClass(gen, outDir, expectedFile);\\n\t\telse\\n\t\t\trealCheckClass(gen, outDir, expectedFile);\\n\t}\\n\\n\tstatic final File TESTDATA_DIR = new File(WeaverTestCase.TESTDATA_PATH);\\n\\n\tvoid genClass(LazyClassGen gen, String outDir, String expectedFile) throws IO"
  },
  {
    "method_id": "M4025",
    "name": "makeConcreteAdvice",
    "return_type": "ShadowMunger",
    "signature": "makeConcreteAdvice(String mungerString)",
    "file_id": "F150",
    "start_line": 195,
    "text_preview": "\t\t\t\tFileUtil.readAsString(new File(TESTDATA_DIR, expectedFile)), gen.toLongString());\\n\t}\\n\\n\t// ----\\n\tpublic ShadowMunger makeConcreteAdvice(String mungerString) {\\n\t\treturn makeConcreteAdvice(mungerString, 0, null);\\n\t}\\n\\n\tpublic ShadowMunger makeConcreteAdvice(String mungerString, int extraArgFlag) {\\n\t\treturn makeConcrete"
  },
  {
    "method_id": "M4026",
    "name": "makeConcreteAdvice",
    "return_type": "ShadowMunger",
    "signature": "makeConcreteAdvice(String mungerString, int extraArgFlag)",
    "file_id": "F150",
    "start_line": 195,
    "text_preview": "\t\t\t\tFileUtil.readAsString(new File(TESTDATA_DIR, expectedFile)), gen.toLongString());\\n\t}\\n\\n\t// ----\\n\tpublic ShadowMunger makeConcreteAdvice(String mungerString) {\\n\t\treturn makeConcreteAdvice(mungerString, 0, null);\\n\t}\\n\\n\tpublic ShadowMunger makeConcreteAdvice(String mungerString, int extraArgFlag) {\\n\t\treturn makeConcrete"
  },
  {
    "method_id": "M4027",
    "name": "makeConcreteAdvice",
    "return_type": "ShadowMunger",
    "signature": "makeConcreteAdvice(String mungerString, int extraArgFlag, PerClause perClause)",
    "file_id": "F150",
    "start_line": 195,
    "text_preview": "\t\t\t\tFileUtil.readAsString(new File(TESTDATA_DIR, expectedFile)), gen.toLongString());\\n\t}\\n\\n\t// ----\\n\tpublic ShadowMunger makeConcreteAdvice(String mungerString) {\\n\t\treturn makeConcreteAdvice(mungerString, 0, null);\\n\t}\\n\\n\tpublic ShadowMunger makeConcreteAdvice(String mungerString, int extraArgFlag) {\\n\t\treturn makeConcrete"
  },
  {
    "method_id": "M4028",
    "name": "makeAdviceField",
    "return_type": "ShadowMunger",
    "signature": "makeAdviceField(String kind, String extraArgType)",
    "file_id": "F150",
    "start_line": 213,
    "text_preview": "unger.concretize(myMunger.getDeclaringAspect().resolve(world), world, perClause);\\n\t\treturn cm;\\n\t}\\n\\n\tpublic ShadowMunger makeAdviceField(String kind, String extraArgType) {\\n\t\treturn makeConcreteAdvice(kind + \"(): get(* *.*) -> static void Aspect.ajc_\" + kind + \"_field_get(\" + extraArgType + \")\", 1);\\n\t}\\n\\n\tpublic List<Sha"
  },
  {
    "method_id": "M4029",
    "name": "makeAdviceAll",
    "return_type": "List<ShadowMunger>",
    "signature": "makeAdviceAll(String kind, boolean matchOnlyPrintln)",
    "file_id": "F150",
    "start_line": 217,
    "text_preview": " get(* *.*) -> static void Aspect.ajc_\" + kind + \"_field_get(\" + extraArgType + \")\", 1);\\n\t}\\n\\n\tpublic List<ShadowMunger> makeAdviceAll(String kind, boolean matchOnlyPrintln) {\\n\t\tList<ShadowMunger> ret = new ArrayList<>();\\n\t\tif (matchOnlyPrintln) {\\n\t\t\tret.add(makeConcreteAdvice(kind + \"(): call(* *.println(..)) -> static"
  },
  {
    "method_id": "M4030",
    "name": "if",
    "return_type": "",
    "signature": "if(matchOnlyPrintln)",
    "file_id": "F150",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4031",
    "name": "makeAdviceAll",
    "return_type": "List<ShadowMunger>",
    "signature": "makeAdviceAll(final String kind)",
    "file_id": "F150",
    "start_line": 217,
    "text_preview": " get(* *.*) -> static void Aspect.ajc_\" + kind + \"_field_get(\" + extraArgType + \")\", 1);\\n\t}\\n\\n\tpublic List<ShadowMunger> makeAdviceAll(String kind, boolean matchOnlyPrintln) {\\n\t\tList<ShadowMunger> ret = new ArrayList<>();\\n\t\tif (matchOnlyPrintln) {\\n\t\t\tret.add(makeConcreteAdvice(kind + \"(): call(* *.println(..)) -> static"
  },
  {
    "method_id": "M4032",
    "name": "makePointcutAll",
    "return_type": "Pointcut",
    "signature": "makePointcutAll()",
    "file_id": "F150",
    "start_line": 246,
    "text_preview": "\tpublic List<ShadowMunger> makeAdviceAll(final String kind) {\\n\t\treturn makeAdviceAll(kind, false);\\n\t}\\n\\n\tpublic Pointcut makePointcutAll() {\\n\t\treturn makeConcretePointcut(\"get(* *.*) || call(* *.*(..)) || execution(* *.*(..)) || call(*.new(..)) || execution(*.new(..))\");\\n\t}\\n\\n\tpublic Pointcut makePointcutNoZeroArg() {\\n\t\t"
  },
  {
    "method_id": "M4033",
    "name": "makePointcutNoZeroArg",
    "return_type": "Pointcut",
    "signature": "makePointcutNoZeroArg()",
    "file_id": "F150",
    "start_line": 250,
    "text_preview": "et(* *.*) || call(* *.*(..)) || execution(* *.*(..)) || call(*.new(..)) || execution(*.new(..))\");\\n\t}\\n\\n\tpublic Pointcut makePointcutNoZeroArg() {\\n\t\treturn makeConcretePointcut(\"call(* *.*(*, ..)) || execution(* *.*(*, ..)) || call(*.new(*, ..)) || execution(*.new(*, ..))\");\\n\t}\\n\\n\tpublic Pointcut makePointcutPrintln() {\\n"
  },
  {
    "method_id": "M4034",
    "name": "makePointcutPrintln",
    "return_type": "Pointcut",
    "signature": "makePointcutPrintln()",
    "file_id": "F150",
    "start_line": 254,
    "text_preview": "\"call(* *.*(*, ..)) || execution(* *.*(*, ..)) || call(*.new(*, ..)) || execution(*.new(*, ..))\");\\n\t}\\n\\n\tpublic Pointcut makePointcutPrintln() {\\n\t\treturn makeConcretePointcut(\"call(* *.println(..))\");\\n\t}\\n\\n\tpublic Pointcut makeConcretePointcut(String s) {\\n\t\treturn makeResolvedPointcut(s).concretize(null, null, 0);\\n\t}\\n\\n\tp"
  },
  {
    "method_id": "M4035",
    "name": "makeConcretePointcut",
    "return_type": "Pointcut",
    "signature": "makeConcretePointcut(String s)",
    "file_id": "F150",
    "start_line": 247,
    "text_preview": "keAdviceAll(final String kind) {\\n\t\treturn makeAdviceAll(kind, false);\\n\t}\\n\\n\tpublic Pointcut makePointcutAll() {\\n\t\treturn makeConcretePointcut(\"get(* *.*) || call(* *.*(..)) || execution(* *.*(..)) || call(*.new(..)) || execution(*.new(..))\");\\n\t}\\n\\n\tpublic Pointcut makePointcutNoZeroArg() {\\n\t\treturn makeConcretePointcut(\""
  },
  {
    "method_id": "M4036",
    "name": "makeResolvedPointcut",
    "return_type": "Pointcut",
    "signature": "makeResolvedPointcut(String s)",
    "file_id": "F150",
    "start_line": 259,
    "text_preview": "\\n\t\treturn makeConcretePointcut(\"call(* *.println(..))\");\\n\t}\\n\\n\tpublic Pointcut makeConcretePointcut(String s) {\\n\t\treturn makeResolvedPointcut(s).concretize(null, null, 0);\\n\t}\\n\\n\tpublic Pointcut makeResolvedPointcut(String s) {\\n\t\tPointcut pointcut0 = Pointcut.fromString(s);\\n\t\treturn pointcut0.resolve(new SimpleScope(world"
  },
  {
    "method_id": "M4037",
    "name": "getStandardTargets",
    "return_type": "String[]",
    "signature": "getStandardTargets()",
    "file_id": "F150",
    "start_line": 269,
    "text_preview": "t.fromString(s);\\n\t\treturn pointcut0.resolve(new SimpleScope(world, FormalBinding.NONE));\\n\t}\\n\\n\t// ----\\n\\n\tpublic String[] getStandardTargets() {\\n\t\treturn new String[] { \"HelloWorld\", \"FancyHelloWorld\" };\\n\t}\\n\\n\tpublic String getTraceJar() {\\n\t\treturn WeaverTestCase.TESTDATA_PATH + \"/tracing.jar\";\\n\t}\\n\\n\t// ----\\n\\n\tprotected vo"
  },
  {
    "method_id": "M4038",
    "name": "getTraceJar",
    "return_type": "String",
    "signature": "getTraceJar()",
    "file_id": "F150",
    "start_line": 151,
    "text_preview": "ard file\\n\t\treturn name+\".txt\";\\n\t}\\n\\n\tpublic String makeClassPath(String outDir) {\\n\t\treturn outDir + File.pathSeparator + getTraceJar() + File.pathSeparator + classDir + File.pathSeparator\\n\t\t\t\t+ System.getProperty(\"java.class.path\");\\n\t}\\n\\n\t/**\\n\t * '/' in the name indicates the location of the class\\n\t */\\n\tpublic static Unw"
  },
  {
    "method_id": "M4039",
    "name": "weaveTest",
    "return_type": "void",
    "signature": "weaveTest(String[] inClassNames, String outKind, ShadowMunger patternMunger)",
    "file_id": "F150",
    "start_line": 86,
    "text_preview": "ect\", methodName, Type.VOID, new Type[] {}, Constants.INVOKESTATIC);\\n\t\treturn new InstructionList(il);\\n\t}\\n\\n\tpublic void weaveTest(String name, String outName, ShadowMunger planner) throws IOException {\\n\t\tList<ShadowMunger> l = new ArrayList<>(1);\\n\t\tl.add(planner);\\n\t\tweaveTest(name, outName, l);\\n\t}\\n\\n\t// static String cl"
  },
  {
    "method_id": "M4040",
    "name": "for",
    "return_type": "",
    "signature": "for(String inFileName : inClassNames)",
    "file_id": "F150",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4041",
    "name": "weaveTest",
    "return_type": "void",
    "signature": "weaveTest(String[] inClassNames, String outKind, List<ShadowMunger> patternMungers)",
    "file_id": "F150",
    "start_line": 86,
    "text_preview": "ect\", methodName, Type.VOID, new Type[] {}, Constants.INVOKESTATIC);\\n\t\treturn new InstructionList(il);\\n\t}\\n\\n\tpublic void weaveTest(String name, String outName, ShadowMunger planner) throws IOException {\\n\t\tList<ShadowMunger> l = new ArrayList<>(1);\\n\t\tl.add(planner);\\n\t\tweaveTest(name, outName, l);\\n\t}\\n\\n\t// static String cl"
  },
  {
    "method_id": "M4042",
    "name": "for",
    "return_type": "",
    "signature": "for(String inFileName : inClassNames)",
    "file_id": "F150",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4043",
    "name": "addLexicalOrder",
    "return_type": "List<ShadowMunger>",
    "signature": "addLexicalOrder(List<ShadowMunger> l)",
    "file_id": "F150",
    "start_line": 291,
    "text_preview": ": inClassNames) {\\n\t\t\tweaveTest(inFileName, outKind + inFileName, patternMungers);\\n\t\t}\\n\t}\\n\\n\tprotected List<ShadowMunger> addLexicalOrder(List<ShadowMunger> l) {\\n\t\tint i = 10;\\n\t\tfor (ShadowMunger element: l) {\\n\t\t\t((Advice)element).setLexicalPosition(i += 10);\\n\t\t}\\n\t\treturn l;\\n\t}\\n\\n\t// XXX cut-and-paster from IdWeaveTestCas"
  },
  {
    "method_id": "M4044",
    "name": "for",
    "return_type": "",
    "signature": "for(ShadowMunger element: l)",
    "file_id": "F150",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4045",
    "name": "checkShadowSet",
    "return_type": "void",
    "signature": "checkShadowSet(List l, String[] ss)",
    "file_id": "F150",
    "start_line": 300,
    "text_preview": "vice)element).setLexicalPosition(i += 10);\\n\t\t}\\n\t\treturn l;\\n\t}\\n\\n\t// XXX cut-and-paster from IdWeaveTestCase\\n\tpublic void checkShadowSet(List l, String[] ss) {\\n\t\touter:\\n\t\tfor (String s : ss) {\\n\t\t\t// inner:\\n\t\t\tfor (Iterator j = l.iterator(); j.hasNext(); ) {\\n\t\t\t\tBcelShadow shadow = (BcelShadow) j.next();\\n\t\t\t\tString shadow"
  },
  {
    "method_id": "M4046",
    "name": "for",
    "return_type": "",
    "signature": "for(String s : ss)",
    "file_id": "F150",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4047",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F151",
    "start_line": 36,
    "text_preview": "sts {\\n\\n\tprivate final BcelWorld world = new BcelWorld(WeaverTestCase.TESTDATA_PATH + \"/tracing.jar\");\\n\\n\tprotected World getWorld() {\\n\t\treturn world;\\n\t}\\n\\n\tprotected boolean getSupportsAutoboxing() {\\n\t\treturn true;\\n\t}\\n\\n\t// XXX fix the various XXXs before expecting this test to work\\n\tpublic void xtestTraceJar() {\\n\t\tResolv"
  },
  {
    "method_id": "M4048",
    "name": "getSupportsAutoboxing",
    "return_type": "boolean",
    "signature": "getSupportsAutoboxing()",
    "file_id": "F151",
    "start_line": 40,
    "text_preview": "d(WeaverTestCase.TESTDATA_PATH + \"/tracing.jar\");\\n\\n\tprotected World getWorld() {\\n\t\treturn world;\\n\t}\\n\\n\tprotected boolean getSupportsAutoboxing() {\\n\t\treturn true;\\n\t}\\n\\n\t// XXX fix the various XXXs before expecting this test to work\\n\tpublic void xtestTraceJar() {\\n\t\tResolvedType trace = world.resolve(UnresolvedType.forName("
  },
  {
    "method_id": "M4049",
    "name": "xtestTraceJar",
    "return_type": "void",
    "signature": "xtestTraceJar()",
    "file_id": "F151",
    "start_line": 45,
    "text_preview": "tSupportsAutoboxing() {\\n\t\treturn true;\\n\t}\\n\\n\t// XXX fix the various XXXs before expecting this test to work\\n\tpublic void xtestTraceJar() {\\n\t\tResolvedType trace = world.resolve(UnresolvedType.forName(\"Trace\"), true);\\n\t\tassertTrue(\"Couldnt find type Trace\", !trace.isMissing());\\n\t\tfieldsTest(trace, Member.NONE);\\n\t\t/* Membe"
  },
  {
    "method_id": "M4050",
    "name": "testIterator",
    "return_type": "void",
    "signature": "testIterator()",
    "file_id": "F151",
    "start_line": 105,
    "text_preview": "), Modifier.PUBLIC);\\n\\n\t\t// this tests for declared mungers\\n\t\tmungersTest(myTrace, ShadowMunger.NONE);\\n\\n\t}\\n\\n\tpublic void testIterator() {\\n\t\tint abstractPublic = Modifier.ABSTRACT | Modifier.PUBLIC;\\n\t\tResolvedType iter = world.getCoreType(UnresolvedType.forRawTypeName(\"java.util.Iterator\"));\\n\\n\t\tmodifiersTest(iter, abstra"
  },
  {
    "method_id": "M4051",
    "name": "forEachRemaining",
    "return_type": "void",
    "signature": "forEachRemaining(Consumer<? super E> action)",
    "file_id": "F151",
    "start_line": 116,
    "text_preview": "ng/Object;\"),\\n\t\t\t\tMemberImpl.method(iter, 0, \"forEachRemaining\", \"(Ljava/util/function/Consumer;)V\")\\n//\t\t\t\tdefault void forEachRemaining(Consumer<? super E> action) {\\n//\t\t\t        Objects.requireNonNull(action);\\n//\t\t\t        while (hasNext())\\n//\t\t\t            action.accept(next());\\n//\t\t\t    }\\n\t\t\t\t});\\n\t\tResolvedMember r"
  },
  {
    "method_id": "M4052",
    "name": "testObjectCoersion",
    "return_type": "void",
    "signature": "testObjectCoersion()",
    "file_id": "F151",
    "start_line": 143,
    "text_preview": "wMunger.NONE);\\n\t\tisInterfaceTest(iter, true);\\n\t\tisClassTest(iter, false);\\n\t\tisAspectTest(iter, false);\\n\t}\\n\\n\tpublic void testObjectCoersion() {\\n\t\tassertCouldBeCoercibleFrom(\"java.lang.Object\", \"java.lang.String\");\\n\t\tassertCouldBeCoercibleFrom(\"java.lang.Integer\", \"java.lang.Object\");\\n\t\tassertCouldBeCoercibleFrom(\"java.i"
  },
  {
    "method_id": "M4053",
    "name": "assertCouldBeCoercibleFrom",
    "return_type": "void",
    "signature": "assertCouldBeCoercibleFrom(String a, String b)",
    "file_id": "F151",
    "start_line": 144,
    "text_preview": "aceTest(iter, true);\\n\t\tisClassTest(iter, false);\\n\t\tisAspectTest(iter, false);\\n\t}\\n\\n\tpublic void testObjectCoersion() {\\n\t\tassertCouldBeCoercibleFrom(\"java.lang.Object\", \"java.lang.String\");\\n\t\tassertCouldBeCoercibleFrom(\"java.lang.Integer\", \"java.lang.Object\");\\n\t\tassertCouldBeCoercibleFrom(\"java.io.Serializable\", \"java.la"
  },
  {
    "method_id": "M4054",
    "name": "assertCouldNotBeCoercibleFrom",
    "return_type": "void",
    "signature": "assertCouldNotBeCoercibleFrom(String a, String b)",
    "file_id": "F151",
    "start_line": 148,
    "text_preview": "\"java.io.Serializable\", \"java.lang.Runnable\");\\n\t\tassertCouldBeCoercibleFrom(\"java.util.Stack\", \"java.lang.Runnable\");\\n\t\tassertCouldNotBeCoercibleFrom(\"java.lang.Runnable\", \"java.lang.Integer\");\\n\t\tassertCouldNotBeCoercibleFrom(\"java.lang.Integer\", \"java.lang.String\");\\n\t\tassertCouldNotBeCoercibleFrom(\"java.lang.Integer\","
  },
  {
    "method_id": "M4055",
    "name": "ZipFileWeaver",
    "return_type": "",
    "signature": "ZipFileWeaver(File inFile)",
    "file_id": "F152",
    "start_line": 23,
    "text_preview": "t java.io.File;\\nimport java.io.IOException;\\n\\n\\n//XXX delete very soon\\npublic class ZipFileWeaver {\\n\tFile inFile;\\n\tpublic ZipFileWeaver(File inFile) {\\n\t\tsuper();\\n\t\tthis.inFile = inFile;\\n\t}\\n\\n\tpublic void weave(BcelWeaver weaver, File outFile) throws IOException {\\n\t\tint count = 0;\\n\t\tlong startTime = System.currentTimeMilli"
  },
  {
    "method_id": "M4056",
    "name": "weave",
    "return_type": "void",
    "signature": "weave(BcelWeaver weaver, File outFile)",
    "file_id": "F152",
    "start_line": 28,
    "text_preview": " ZipFileWeaver {\\n\tFile inFile;\\n\tpublic ZipFileWeaver(File inFile) {\\n\t\tsuper();\\n\t\tthis.inFile = inFile;\\n\t}\\n\\n\tpublic void weave(BcelWeaver weaver, File outFile) throws IOException {\\n\t\tint count = 0;\\n\t\tlong startTime = System.currentTimeMillis();\\n\t\tweaver.addJarFile(inFile, new File(\".\"),false);\\n\t\tweaver.weave(outFile);\\n\t"
  },
  {
    "method_id": "M4057",
    "name": "ZipTestCase",
    "return_type": "",
    "signature": "ZipTestCase(String arg0)",
    "file_id": "F153",
    "start_line": 32,
    "text_preview": "s ZipTestCase extends TestCase {\\n\\n\tFile outDir;\\n\\n\t/**\\n\t * Constructor for ZipTestCase.\\n\t *\\n\t * @param arg0\\n\t */\\n\tpublic ZipTestCase(String arg0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic void setUp() {\\n\t\toutDir = WeaverTestCase.getOutdir();\\n\t}\\n\\n\tpublic void tearDown() {\\n\t\tWeaverTestCase.removeOutDir();\\n\t\toutDir = null;\\n\t}\\n\\n\tpublic "
  },
  {
    "method_id": "M4058",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F153",
    "start_line": 36,
    "text_preview": "onstructor for ZipTestCase.\\n\t *\\n\t * @param arg0\\n\t */\\n\tpublic ZipTestCase(String arg0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic void setUp() {\\n\t\toutDir = WeaverTestCase.getOutdir();\\n\t}\\n\\n\tpublic void tearDown() {\\n\t\tWeaverTestCase.removeOutDir();\\n\t\toutDir = null;\\n\t}\\n\\n\tpublic void zipTest(String fileName, String aspectjar) throws IOEx"
  },
  {
    "method_id": "M4059",
    "name": "tearDown",
    "return_type": "void",
    "signature": "tearDown()",
    "file_id": "F153",
    "start_line": 40,
    "text_preview": "stCase(String arg0) {\\n\t\tsuper(arg0);\\n\t}\\n\\n\tpublic void setUp() {\\n\t\toutDir = WeaverTestCase.getOutdir();\\n\t}\\n\\n\tpublic void tearDown() {\\n\t\tWeaverTestCase.removeOutDir();\\n\t\toutDir = null;\\n\t}\\n\\n\tpublic void zipTest(String fileName, String aspectjar) throws IOException {\\n\t\tzipTest(fileName, aspectjar, false);\\n\t}\\n\\n\tpublic void "
  },
  {
    "method_id": "M4060",
    "name": "zipTest",
    "return_type": "void",
    "signature": "zipTest(String fileName, String aspectjar)",
    "file_id": "F153",
    "start_line": 45,
    "text_preview": "rTestCase.getOutdir();\\n\t}\\n\\n\tpublic void tearDown() {\\n\t\tWeaverTestCase.removeOutDir();\\n\t\toutDir = null;\\n\t}\\n\\n\tpublic void zipTest(String fileName, String aspectjar) throws IOException {\\n\t\tzipTest(fileName, aspectjar, false);\\n\t}\\n\\n\tpublic void zipTest(String fileName, String aspectjar, boolean isInJar) throws IOException {"
  },
  {
    "method_id": "M4061",
    "name": "zipTest",
    "return_type": "void",
    "signature": "zipTest(String fileName, String aspectjar, boolean isInJar)",
    "file_id": "F153",
    "start_line": 45,
    "text_preview": "rTestCase.getOutdir();\\n\t}\\n\\n\tpublic void tearDown() {\\n\t\tWeaverTestCase.removeOutDir();\\n\t\toutDir = null;\\n\t}\\n\\n\tpublic void zipTest(String fileName, String aspectjar) throws IOException {\\n\t\tzipTest(fileName, aspectjar, false);\\n\t}\\n\\n\tpublic void zipTest(String fileName, String aspectjar, boolean isInJar) throws IOException {"
  },
  {
    "method_id": "M4062",
    "name": "catch",
    "return_type": "",
    "signature": "catch(InterruptedException e)",
    "file_id": "F153",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4063",
    "name": "if",
    "return_type": "",
    "signature": "if(aspectjar != null)",
    "file_id": "F153",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4064",
    "name": "if",
    "return_type": "",
    "signature": "if(isInJar)",
    "file_id": "F153",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4065",
    "name": "testSmall",
    "return_type": "void",
    "signature": "testSmall()",
    "file_id": "F153",
    "start_line": 86,
    "text_preview": "art of the test, hence the 1000ms delay added above.\\n\t\tassertTrue(outFile.lastModified() > startTime);\\n\t}\\n\\n\tpublic void testSmall() throws IOException {\\n\t\tzipTest(WeaverTestCase.TESTDATA_PATH + \"/Regex.jar\", null);\\n\t}\\n\\n\tpublic void testSmallWithAspects() throws IOException {\\n\t\tSystem.out.println(\"could take 4 seconds.."
  },
  {
    "method_id": "M4066",
    "name": "testSmallWithAspects",
    "return_type": "void",
    "signature": "testSmallWithAspects()",
    "file_id": "F153",
    "start_line": 90,
    "text_preview": "ic void testSmall() throws IOException {\\n\t\tzipTest(WeaverTestCase.TESTDATA_PATH + \"/Regex.jar\", null);\\n\t}\\n\\n\tpublic void testSmallWithAspects() throws IOException {\\n\t\tSystem.out.println(\"could take 4 seconds...\");\\n\t\tzipTest(WeaverTestCase.TESTDATA_PATH + \"/Regex.jar\", WeaverTestCase.TESTDATA_PATH + \"/megatrace.jar\");\\n\t}"
  },
  {
    "method_id": "M4067",
    "name": "testSmallWithAspectsNoWeave",
    "return_type": "void",
    "signature": "testSmallWithAspectsNoWeave()",
    "file_id": "F153",
    "start_line": 95,
    "text_preview": "zipTest(WeaverTestCase.TESTDATA_PATH + \"/Regex.jar\", WeaverTestCase.TESTDATA_PATH + \"/megatrace.jar\");\\n\t}\\n\\n\tpublic void testSmallWithAspectsNoWeave() throws IOException {\\n\t\tSystem.out.println(\"could take 4 seconds...\");\\n\t\tzipTest(WeaverTestCase.TESTDATA_PATH + \"/Regex.jar\", WeaverTestCase.TESTDATA_PATH + \"/megatraceNow"
  },
  {
    "method_id": "M4068",
    "name": "testBig",
    "return_type": "void",
    "signature": "testBig()",
    "file_id": "F153",
    "start_line": 100,
    "text_preview": "rTestCase.TESTDATA_PATH + \"/Regex.jar\", WeaverTestCase.TESTDATA_PATH + \"/megatraceNoweave.jar\", true);\\n\t}\\n\\n\tpublic void testBig() throws IOException {\\n\t\tSystem.out.println(\"could take 4 seconds...\");\\n\t\t// Weave a big JAR file. This is unrelated to Ant, i.e. the JAR can be replaced by another one for this test.\\n\t\tzipTes"
  },
  {
    "method_id": "M4069",
    "name": "testBigWithEasyNoTrace",
    "return_type": "void",
    "signature": "testBigWithEasyNoTrace()",
    "file_id": "F153",
    "start_line": 106,
    "text_preview": " i.e. the JAR can be replaced by another one for this test.\\n\t\tzipTest(\"../lib/ant/lib/ant.jar\", null);\\n\t}\\n\\n\tpublic void testBigWithEasyNoTrace() throws IOException {\\n\t\tSystem.out.println(\"could take 4 seconds...\");\\n\t\t// Weave a big JAR file. This is unrelated to Ant, i.e. the JAR can be replaced by another one for this"
  },
  {
    "method_id": "M4070",
    "name": "xtestBigWithHardNoTrace",
    "return_type": "void",
    "signature": "xtestBigWithHardNoTrace()",
    "file_id": "F153",
    "start_line": 113,
    "text_preview": "verTestCase.TESTDATA_PATH + \"/megatrace0easy.jar\");\\n\t}\\n\\n\t// this is something we test every now and again.\\n\tpublic void xtestBigWithHardNoTrace() throws IOException {\\n\t\tSystem.out.println(\"could take 24 seconds...\");\\n\t\t// Weave a big JAR file. This is unrelated to Ant, i.e. the JAR can be replaced by another one for th"
  },
  {
    "method_id": "M4071",
    "name": "xtestBigWithAspects",
    "return_type": "void",
    "signature": "xtestBigWithAspects()",
    "file_id": "F153",
    "start_line": 119,
    "text_preview": " this test.\\n\t\tzipTest(\"../lib/ant/lib/ant.jar\", WeaverTestCase.TESTDATA_PATH + \"/megatrace0hard.jar\");\\n\t}\\n\\n\tpublic void xtestBigWithAspects() throws IOException {\\n\t\tSystem.out.println(\"could take 40 seconds...\");\\n\t\t// Weave a big JAR file. This is unrelated to Ant, i.e. the JAR can be replaced by another one for this t"
  },
  {
    "method_id": "M4072",
    "name": "m1",
    "return_type": "void",
    "signature": "m1()",
    "file_id": "F154",
    "start_line": 37,
    "text_preview": "ort p.SimpleAnnotation;\\n\\n @SimpleAnnotation(id=2)\\n public class AnnotatedClass {\\n\\n @SimpleAnnotation(id=3)\\n public void m1() { }\\n\\n @SimpleAnnotation(id=4)\\n int i;\\n }\\n\\n * with SimpleAnnotation defined as:\\n\\n package p;\\n import java.lang.annotation.*;\\n\\n @Retention(RetentionPolicy.RUNTIME)\\n public @interface SimpleAnnotati"
  },
  {
    "method_id": "M4073",
    "name": "loadType",
    "return_type": "ResolvedType",
    "signature": "loadType(String name)",
    "file_id": "F154",
    "start_line": 64,
    "text_preview": " TestCase {\\n\\n\tprivate BcelWorld world;\\n\tprivate AnnotationTypePattern fooTP, simpleAnnotationTP;\\n\\n\tprivate ResolvedType loadType(String name) {\\n\t\tif (world == null) {\\n\t\t\tworld = new BcelWorld(WeaverTestCase.TESTDATA_PATH + \"/testcode.jar\");\\n\t\t\tworld.setBehaveInJava5Way(true);\\n\t\t}\\n\t\treturn world.resolve(name);\\n\t}\\n\\n\tpriv"
  },
  {
    "method_id": "M4074",
    "name": "if",
    "return_type": "",
    "signature": "if(world == null)",
    "file_id": "F154",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4075",
    "name": "initAnnotationTypePatterns",
    "return_type": "void",
    "signature": "initAnnotationTypePatterns()",
    "file_id": "F154",
    "start_line": 72,
    "text_preview": "STDATA_PATH + \"/testcode.jar\");\\n\t\t\tworld.setBehaveInJava5Way(true);\\n\t\t}\\n\t\treturn world.resolve(name);\\n\t}\\n\\n\tprivate void initAnnotationTypePatterns() {\\n\t\tPatternParser p = new PatternParser(\"@Foo\");\\n\t\tfooTP = p.maybeParseAnnotationPattern();\\n\t\tfooTP = fooTP.resolveBindings(makeSimpleScope(), new Bindings(3), true);\\n\\n\t\tp"
  },
  {
    "method_id": "M4076",
    "name": "testAnnotationPatternMatchingOnTypes",
    "return_type": "void",
    "signature": "testAnnotationPatternMatchingOnTypes()",
    "file_id": "F154",
    "start_line": 82,
    "text_preview": ";\\n\t\tsimpleAnnotationTP = simpleAnnotationTP.resolveBindings(makeSimpleScope(), new Bindings(3), true);\\n\t}\\n\\n\tpublic void testAnnotationPatternMatchingOnTypes() {\\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\\n\t\tinitAnnotationTypePatterns();\\n\\n\t\t// One should match\\n\t\tassertTrue(\"@Foo should not match on the AnnotatedCla"
  },
  {
    "method_id": "M4077",
    "name": "handleMessage",
    "return_type": "boolean",
    "signature": "handleMessage(IMessage message)",
    "file_id": "F154",
    "start_line": 95,
    "text_preview": "s MyMessageHandler implements IMessageHandler {\\n\t\tpublic List<IMessage> messages = new ArrayList<>();\\n\\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\\n\t\t\tmessages.add(message);\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tpublic boolean isIgnoring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(IMessage"
  },
  {
    "method_id": "M4078",
    "name": "isIgnoring",
    "return_type": "boolean",
    "signature": "isIgnoring(Kind kind)",
    "file_id": "F154",
    "start_line": 100,
    "text_preview": "andleMessage(IMessage message) throws AbortException {\\n\t\t\tmessages.add(message);\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tpublic boolean isIgnoring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\\n\t\t}\\n\\n\t\tpublic void ignore(Kind kind) {\\n\t\t}\\n\t}\\n\\n\tpublic void testReferenceToNonAnnotationType() {\\n\t\t// Resol"
  },
  {
    "method_id": "M4079",
    "name": "dontIgnore",
    "return_type": "void",
    "signature": "dontIgnore(IMessage.Kind kind)",
    "file_id": "F154",
    "start_line": 104,
    "text_preview": "ssages.add(message);\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tpublic boolean isIgnoring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\\n\t\t}\\n\\n\t\tpublic void ignore(Kind kind) {\\n\t\t}\\n\t}\\n\\n\tpublic void testReferenceToNonAnnotationType() {\\n\t\t// ResolvedType rtx =\\n\t\tloadType(\"AnnotatedClass\"); // inits the wor"
  },
  {
    "method_id": "M4080",
    "name": "ignore",
    "return_type": "void",
    "signature": "ignore(Kind kind)",
    "file_id": "F154",
    "start_line": 107,
    "text_preview": "boolean isIgnoring(Kind kind) {\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\\n\t\t}\\n\\n\t\tpublic void ignore(Kind kind) {\\n\t\t}\\n\t}\\n\\n\tpublic void testReferenceToNonAnnotationType() {\\n\t\t// ResolvedType rtx =\\n\t\tloadType(\"AnnotatedClass\"); // inits the world\\n\t\tPatternParser p = new PatternParser(\"@java.lang"
  },
  {
    "method_id": "M4081",
    "name": "testReferenceToNonAnnotationType",
    "return_type": "void",
    "signature": "testReferenceToNonAnnotationType()",
    "file_id": "F154",
    "start_line": 111,
    "text_preview": " false;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\\n\t\t}\\n\\n\t\tpublic void ignore(Kind kind) {\\n\t\t}\\n\t}\\n\\n\tpublic void testReferenceToNonAnnotationType() {\\n\t\t// ResolvedType rtx =\\n\t\tloadType(\"AnnotatedClass\"); // inits the world\\n\t\tPatternParser p = new PatternParser(\"@java.lang.String\");\\n\\n\t\tMyMessageHandler mh = new M"
  },
  {
    "method_id": "M4082",
    "name": "testReferenceViaFormalToNonAnnotationType",
    "return_type": "void",
    "signature": "testReferenceViaFormalToNonAnnotationType()",
    "file_id": "F154",
    "start_line": 128,
    "text_preview": "get(0)).toString();\\n\t\tassertTrue(\"Expected: \" + expected + \" but got \" + msg, msg.contains(expected));\\n\t}\\n\\n\tpublic void testReferenceViaFormalToNonAnnotationType() {\\n\t\t// ResolvedType rtx =\\n\t\tloadType(\"AnnotatedClass\"); // inits the world\\n\t\tPatternParser p = new PatternParser(\"a\");\\n\\n\t\tMyMessageHandler mh = new MyMessag"
  },
  {
    "method_id": "M4083",
    "name": "makeSimpleScope",
    "return_type": "TestScope",
    "signature": "makeSimpleScope()",
    "file_id": "F154",
    "start_line": 75,
    "text_preview": "PatternParser p = new PatternParser(\"@Foo\");\\n\t\tfooTP = p.maybeParseAnnotationPattern();\\n\t\tfooTP = fooTP.resolveBindings(makeSimpleScope(), new Bindings(3), true);\\n\\n\t\tp = new PatternParser(\"@p.SimpleAnnotation\");\\n\t\tsimpleAnnotationTP = p.maybeParseAnnotationPattern();\\n\t\tsimpleAnnotationTP = simpleAnnotationTP.resolveBin"
  },
  {
    "method_id": "M4084",
    "name": "testUnresolvedAnnotationTypes",
    "return_type": "void",
    "signature": "testUnresolvedAnnotationTypes()",
    "file_id": "F154",
    "start_line": 153,
    "text_preview": "\\n\t\treturn new TestScope(new String[] { \"int\", \"java.lang.String\" }, new String[] { \"a\", \"b\" }, world);\\n\t}\\n\\n\tpublic void testUnresolvedAnnotationTypes() {\\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\\n\\n\t\tPatternParser p = new PatternParser(\"@Foo\");\\n\t\tAnnotationTypePattern fooTP = p.maybeParseAnnotationPattern();\\n\t\ttr"
  },
  {
    "method_id": "M4085",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IllegalStateException ise)",
    "file_id": "F154",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4086",
    "name": "testAnnotationPatternMatchingOnMethods",
    "return_type": "void",
    "signature": "testAnnotationPatternMatchingOnMethods()",
    "file_id": "F154",
    "start_line": 166,
    "text_preview": "l state exception, fooTP is not resolved\");\\n\t\t} catch (IllegalStateException ise) {\\n\t\t\t// Correct!\\n\t\t}\\n\t}\\n\\n\tpublic void testAnnotationPatternMatchingOnMethods() {\\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\\n\t\tResolvedMember aMethod = rtx.getDeclaredMethods()[1];\\n\\n\t\tassertTrue(\"Haven't got the right method, I'm loo"
  },
  {
    "method_id": "M4087",
    "name": "testAnnotationPatternMatchingOnFields",
    "return_type": "void",
    "signature": "testAnnotationPatternMatchingOnFields()",
    "file_id": "F154",
    "start_line": 180,
    "text_preview": "ould match on the AnnotatedClass.m1() method\", simpleAnnotationTP.matches(aMethod)\\n\t\t\t\t.alwaysTrue());\\n\t}\\n\\n\tpublic void testAnnotationPatternMatchingOnFields() {\\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\\n\t\tResolvedMember aField = rtx.getDeclaredFields()[0];\\n\\n\t\tassertTrue(\"Haven't got the right field, I'm looking"
  },
  {
    "method_id": "M4088",
    "name": "testAnnotationTypeResolutionOnTypes",
    "return_type": "void",
    "signature": "testAnnotationTypeResolutionOnTypes()",
    "file_id": "F154",
    "start_line": 195,
    "text_preview": "n should match on the AnnotatedClass.i field\", simpleAnnotationTP.matches(aField)\\n\t\t\t\t.alwaysTrue());\\n\\n\t}\\n\\n\tpublic void testAnnotationTypeResolutionOnTypes() {\\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\\n\t\tResolvedType[] types = rtx.getAnnotationTypes();\\n\t\tassertTrue(\"Did not expect null\", types != null);\\n\t\tassert"
  },
  {
    "method_id": "M4089",
    "name": "testAnnotationTypeResolutionOnMethods",
    "return_type": "void",
    "signature": "testAnnotationTypeResolutionOnMethods()",
    "file_id": "F154",
    "start_line": 203,
    "text_preview": "ld be 'p.SimpleAnnotation' but is \" + types[0], types[0].equals(world.resolve(\"p.SimpleAnnotation\")));\\n\t}\\n\\n\tpublic void testAnnotationTypeResolutionOnMethods() {\\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\\n\\n\t\tResolvedMember aMethod = rtx.getDeclaredMethods()[1];\\n\t\tassertTrue(\"Haven't got the right method, I'm look"
  },
  {
    "method_id": "M4090",
    "name": "testAnnotationTypeResolutionOnFields",
    "return_type": "void",
    "signature": "testAnnotationTypeResolutionOnFields()",
    "file_id": "F154",
    "start_line": 215,
    "text_preview": "ld be 'p.SimpleAnnotation' but is \" + types[0], types[0].equals(world.resolve(\"p.SimpleAnnotation\")));\\n\t}\\n\\n\tpublic void testAnnotationTypeResolutionOnFields() {\\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\\n\\n\t\tResolvedMember aField = rtx.getDeclaredFields()[0];\\n\\n\t\tassertTrue(\"Haven't got the right field, I'm looking"
  },
  {
    "method_id": "M4091",
    "name": "testWildPatternMatchingOnTypes",
    "return_type": "void",
    "signature": "testWildPatternMatchingOnTypes()",
    "file_id": "F154",
    "start_line": 228,
    "text_preview": "ld be 'p.SimpleAnnotation' but is \" + types[0], types[0].equals(world.resolve(\"p.SimpleAnnotation\")));\\n\t}\\n\\n\tpublic void testWildPatternMatchingOnTypes() {\\n\\n\t\tResolvedType rtx = loadType(\"AnnotatedClass\");\\n\t\tinitAnnotationTypePatterns();\\n\\n\t\t// Let's create something wild\\n\t\tPatternParser p = new PatternParser(\"@(Foo || B"
  },
  {
    "method_id": "M4092",
    "name": "testParseSimpleAnnotationPattern",
    "return_type": "void",
    "signature": "testParseSimpleAnnotationPattern()",
    "file_id": "F155",
    "start_line": 24,
    "text_preview": "l.BcelWorld;\\n\\nimport junit.framework.TestCase;\\n\\npublic class AnnotationPatternTestCase extends TestCase {\\n\\n\tpublic void testParseSimpleAnnotationPattern() {\\n\t\tPatternParser p = new PatternParser(\"@Foo\");\\n\t\tAnnotationTypePattern foo = p.maybeParseAnnotationPattern();\\n\t\tfoo = foo.resolveBindings(makeSimpleScope(), new Bi"
  },
  {
    "method_id": "M4093",
    "name": "testParseAndAnnotationPattern",
    "return_type": "void",
    "signature": "testParseAndAnnotationPattern()",
    "file_id": "F155",
    "start_line": 32,
    "text_preview": "quals(\"Foo\", UnresolvedType.forSignature(\"LFoo;\"), ((ExactAnnotationTypePattern) foo).annotationType);\\n\t}\\n\\n\tpublic void testParseAndAnnotationPattern() {\\n\t\tPatternParser p = new PatternParser(\"@Foo @Goo\");\\n\t\tAnnotationTypePattern fooAndGoo = p.maybeParseAnnotationPattern();\\n\t\tassertTrue(\"AndAnnotationTypePattern\", fooA"
  },
  {
    "method_id": "M4094",
    "name": "testParseOrAnnotationPattern",
    "return_type": "void",
    "signature": "testParseOrAnnotationPattern()",
    "file_id": "F155",
    "start_line": 46,
    "text_preview": "o\", UnresolvedType.forSignature(\"LGoo;\"), ((ExactAnnotationTypePattern) right).annotationType);\\n\t}\\n\\n\t//\\n\t// public void testParseOrAnnotationPattern() {\\n\t// PatternParser p = new PatternParser(\"@Foo || @Goo\");\\n\t// AnnotationTypePattern fooOrGoo = p.parseAnnotationTypePattern();\\n\t// assertTrue(\"OrAnnotationTypePattern\","
  },
  {
    "method_id": "M4095",
    "name": "testParseNotAnnotationPattern",
    "return_type": "void",
    "signature": "testParseNotAnnotationPattern()",
    "file_id": "F155",
    "start_line": 62,
    "text_preview": "ls(\"Goo\",UnresolvedType.forName(\"Goo\"),((\\n\t// ExactAnnotationTypePattern)right).annotationType);\\n\t// }\\n\t//\\n\tpublic void testParseNotAnnotationPattern() {\\n\t\tPatternParser p = new PatternParser(\"!@Foo\");\\n\t\tAnnotationTypePattern notFoo = p.maybeParseAnnotationPattern();\\n\t\tassertTrue(\"NotAnnotationTypePattern\", notFoo inst"
  },
  {
    "method_id": "M4096",
    "name": "testParseBracketedAnnotationPattern",
    "return_type": "void",
    "signature": "testParseBracketedAnnotationPattern()",
    "file_id": "F155",
    "start_line": 72,
    "text_preview": "ssertEquals(\"Foo\", UnresolvedType.forName(\"Foo\"), ((ExactAnnotationTypePattern) body).annotationType);\\n\t}\\n\\n\tpublic void testParseBracketedAnnotationPattern() {\\n\t\tPatternParser p = new PatternParser(\"(@Foo)\");\\n\t\tAnnotationTypePattern foo = p.maybeParseAnnotationPattern();\\n\t\t// cannot start with ( so, we get ANY\\n\t\tassert"
  },
  {
    "method_id": "M4097",
    "name": "testParseFQAnnPattern",
    "return_type": "void",
    "signature": "testParseFQAnnPattern()",
    "file_id": "F155",
    "start_line": 79,
    "text_preview": "tern();\\n\t\t// cannot start with ( so, we get ANY\\n\t\tassertEquals(\"ANY\", AnnotationTypePattern.ANY, foo);\\n\t}\\n\\n\tpublic void testParseFQAnnPattern() {\\n\t\tPatternParser p = new PatternParser(\"@org.aspectj.Foo\");\\n\t\tAnnotationTypePattern foo = p.maybeParseAnnotationPattern();\\n\t\tassertEquals(\"@(org.aspectj.Foo)\", foo.toString())"
  },
  {
    "method_id": "M4098",
    "name": "testParseComboPattern",
    "return_type": "void",
    "signature": "testParseComboPattern()",
    "file_id": "F155",
    "start_line": 85,
    "text_preview": "pePattern foo = p.maybeParseAnnotationPattern();\\n\t\tassertEquals(\"@(org.aspectj.Foo)\", foo.toString());\\n\t}\\n\\n\tpublic void testParseComboPattern() {\\n\t\t// PatternParser p = new PatternParser(\"!((@Foo || @Goo) && !@Boo)\");\\n\t\tPatternParser p = new PatternParser(\"@(Foo || Goo)!@Boo\");\\n\t\tAnnotationTypePattern ap = p.maybeParse"
  },
  {
    "method_id": "M4099",
    "name": "testParseAndOrPattern",
    "return_type": "void",
    "signature": "testParseAndOrPattern()",
    "file_id": "F155",
    "start_line": 99,
    "text_preview": " = (AnnotationTypePattern)\\n\t\tatp.getLeft();\\n\t\tassertEquals(\"@((Foo || Goo)) !@Boo\", ap.toString());\\n\t}\\n\\n\t// public void testParseAndOrPattern() {\\n\t// PatternParser p = new PatternParser(\"@Foo && @Boo || @Goo\");\\n\t// AnnotationTypePattern andOr = p.parseAnnotationTypePattern();\\n\t// assertTrue(\"Should be or pattern\",andOr"
  },
  {
    "method_id": "M4100",
    "name": "testParseBadPattern",
    "return_type": "void",
    "signature": "testParseBadPattern()",
    "file_id": "F155",
    "start_line": 106,
    "text_preview": "ePattern();\\n\t// assertTrue(\"Should be or pattern\",andOr instanceof\\n\t// OrAnnotationTypePattern);\\n\t// }\\n\t//\\n\tpublic void testParseBadPattern() {\\n\t\tPatternParser p = new PatternParser(\"@@Foo\");\\n\t\ttry {\\n\t\t\tp.maybeParseAnnotationPattern();\\n\t\t\tfail(\"ParserException expected\");\\n\t\t} catch (ParserException pEx) {\\n\t\t\tassertEqua"
  },
  {
    "method_id": "M4101",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ParserException pEx)",
    "file_id": "F155",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4102",
    "name": "testParseBadPattern2",
    "return_type": "void",
    "signature": "testParseBadPattern2()",
    "file_id": "F155",
    "start_line": 116,
    "text_preview": "n expected\");\\n\t\t} catch (ParserException pEx) {\\n\t\t\tassertEquals(\"name pattern\", pEx.getMessage());\\n\t\t}\\n\t}\\n\\n\tpublic void testParseBadPattern2() {\\n\t\tPatternParser p = new PatternParser(\"Foo\");\\n\t\tAnnotationTypePattern bad = p.maybeParseAnnotationPattern();\\n\t\tassertEquals(\"ANY\", AnnotationTypePattern.ANY, bad);\\n\t}\\n\\n\tpublic"
  },
  {
    "method_id": "M4103",
    "name": "testParseNameOrVarAnnotationPattern",
    "return_type": "void",
    "signature": "testParseNameOrVarAnnotationPattern()",
    "file_id": "F155",
    "start_line": 122,
    "text_preview": "ePattern bad = p.maybeParseAnnotationPattern();\\n\t\tassertEquals(\"ANY\", AnnotationTypePattern.ANY, bad);\\n\t}\\n\\n\tpublic void testParseNameOrVarAnnotationPattern() {\\n\t\tPatternParser p = new PatternParser(\"Foo\");\\n\t\tAnnotationTypePattern foo = p.parseAnnotationNameOrVarTypePattern();\\n\t\tassertTrue(\"ExactAnnotationTypePattern ex"
  },
  {
    "method_id": "M4104",
    "name": "testParseNameOrVarAnnotationPatternWithNot",
    "return_type": "void",
    "signature": "testParseNameOrVarAnnotationPatternWithNot()",
    "file_id": "F155",
    "start_line": 129,
    "text_preview": "assertEquals(\"Foo\", UnresolvedType.forName(\"Foo\"), ((ExactAnnotationTypePattern) foo).annotationType);\\n\t}\\n\\n\tpublic void testParseNameOrVarAnnotationPatternWithNot() {\\n\t\tPatternParser p = new PatternParser(\"!@Foo\");\\n\t\ttry {\\n\t\t\t// AnnotationTypePattern bad =\\n\t\t\tp.parseAnnotationNameOrVarTypePattern();\\n\t\t\tfail(\"ParserExce"
  },
  {
    "method_id": "M4105",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ParserException pEx)",
    "file_id": "F155",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4106",
    "name": "testParseNameOrVarAnnotationPatternWithOr",
    "return_type": "void",
    "signature": "testParseNameOrVarAnnotationPatternWithOr()",
    "file_id": "F155",
    "start_line": 140,
    "text_preview": "ion expected\");\\n\t\t} catch (ParserException pEx) {\\n\t\t\tassertEquals(\"identifier\", pEx.getMessage());\\n\t\t}\\n\t}\\n\\n\tpublic void testParseNameOrVarAnnotationPatternWithOr() {\\n\t\tPatternParser p = new PatternParser(\"Foo || Boo\");\\n\t\tAnnotationTypePattern foo = p.parseAnnotationNameOrVarTypePattern();\\n\t\t// rest of pattern not consu"
  },
  {
    "method_id": "M4107",
    "name": "testParseNameOrVarAnnotationWithBinding",
    "return_type": "void",
    "signature": "testParseNameOrVarAnnotationWithBinding()",
    "file_id": "F155",
    "start_line": 148,
    "text_preview": "assertEquals(\"Foo\", UnresolvedType.forName(\"Foo\"), ((ExactAnnotationTypePattern) foo).annotationType);\\n\t}\\n\\n\tpublic void testParseNameOrVarAnnotationWithBinding() {\\n\t\tPatternParser p = new PatternParser(\"foo\");\\n\t\tAnnotationTypePattern foo = p.parseAnnotationNameOrVarTypePattern();\\n\t\tassertTrue(\"ExactAnnotationTypePatter"
  },
  {
    "method_id": "M4108",
    "name": "testParseNameOrVarAnnotationPatternWithAnd",
    "return_type": "void",
    "signature": "testParseNameOrVarAnnotationPatternWithAnd()",
    "file_id": "F155",
    "start_line": 155,
    "text_preview": "of ExactAnnotationTypePattern);\\n\t\tassertEquals(\"@foo\", ((ExactAnnotationTypePattern) foo).toString());\\n\t}\\n\\n\tpublic void testParseNameOrVarAnnotationPatternWithAnd() {\\n\t\tPatternParser p = new PatternParser(\"Foo Boo\");\\n\t\tAnnotationTypePattern foo = p.parseAnnotationNameOrVarTypePattern();\\n\t\t// rest of pattern not consume"
  },
  {
    "method_id": "M4109",
    "name": "testMaybeParseAnnotationPattern",
    "return_type": "void",
    "signature": "testMaybeParseAnnotationPattern()",
    "file_id": "F155",
    "start_line": 162,
    "text_preview": "onNameOrVarTypePattern();\\n\t\t// rest of pattern not consumed...\\n\t\tassertEquals(\"@Foo\", foo.toString());\\n\t}\\n\\n\tpublic void testMaybeParseAnnotationPattern() {\\n\t\tPatternParser p = new PatternParser(\"@Foo\");\\n\t\tAnnotationTypePattern a = p.maybeParseAnnotationPattern();\\n\t\tassertNotNull(\"Should find annotation pattern\", a);\\n\t\t"
  },
  {
    "method_id": "M4110",
    "name": "testParseTypePatternsWithAnnotations",
    "return_type": "void",
    "signature": "testParseTypePatternsWithAnnotations()",
    "file_id": "F155",
    "start_line": 171,
    "text_preview": "ationPattern();\\n\t\tassertEquals(\"Should be ANY pattern for a non-match\", AnnotationTypePattern.ANY, a);\\n\t}\\n\\n\tpublic void testParseTypePatternsWithAnnotations() {\\n\t\tPatternParser p = new PatternParser(\"@Foo *\");\\n\t\tTypePattern t = p.parseTypePattern();\\n\t\tassertTrue(\"AnyWithAnnotationTypePattern\", t instanceof AnyWithAnnot"
  },
  {
    "method_id": "M4111",
    "name": "testParseTypePatternsWithAnnotationsComplex",
    "return_type": "void",
    "signature": "testParseTypePatternsWithAnnotationsComplex()",
    "file_id": "F155",
    "start_line": 180,
    "text_preview": "notationPattern;\\n\t\tassertEquals(\"@(Foo)\", atp.toString());\\n\t\tassertEquals(\"(@(Foo) *)\", t.toString());\\n\t}\\n\\n\tpublic void testParseTypePatternsWithAnnotationsComplex() {\\n\t\tPatternParser p = new PatternParser(\"(@(Foo || Boo) (Foo || Boo))\");\\n\t\tTypePattern t = p.parseTypePattern();\\n\t\tassertTrue(\"OrTypePattern\", t instanceo"
  },
  {
    "method_id": "M4112",
    "name": "testNotSyntax",
    "return_type": "void",
    "signature": "testNotSyntax()",
    "file_id": "F155",
    "start_line": 187,
    "text_preview": "ceof OrTypePattern);\\n\t\tassertEquals(\"((@((Foo || Boo)) Foo) || (@((Foo || Boo)) Boo))\", t.toString());\\n\t}\\n\\n\tpublic void testNotSyntax() {\\n\t\tPatternParser p = new PatternParser(\"!@Foo (Foo || Boo))\");\\n\t\tTypePattern t = p.parseTypePattern();\\n\t\tassertTrue(\"OrTypePattern\", t instanceof OrTypePattern);\\n\t\tassertEquals(\"((!@("
  },
  {
    "method_id": "M4113",
    "name": "testParseMethodOrConstructorSigNoAP",
    "return_type": "void",
    "signature": "testParseMethodOrConstructorSigNoAP()",
    "file_id": "F155",
    "start_line": 194,
    "text_preview": "ttern\", t instanceof OrTypePattern);\\n\t\tassertEquals(\"((!@(Foo) Foo) || (!@(Foo) Boo))\", t.toString());\\n\t}\\n\\n\tpublic void testParseMethodOrConstructorSigNoAP() {\\n\t\tPatternParser p = new PatternParser(\"* *.*(..)\");\\n\t\tSignaturePattern s = p.parseMethodOrConstructorSignaturePattern();\\n\t\tassertEquals(\"Any annotation\", Annota"
  },
  {
    "method_id": "M4114",
    "name": "testParseMethodOrConstructorSigSimpleAP",
    "return_type": "void",
    "signature": "testParseMethodOrConstructorSigSimpleAP()",
    "file_id": "F155",
    "start_line": 204,
    "text_preview": ");\\n\t\tassertEquals(\"Any name\", \"*\", s.getName().toString());\\n\t\tassertEquals(\"* *.*(..)\", s.toString());\\n\t}\\n\\n\tpublic void testParseMethodOrConstructorSigSimpleAP() {\\n\t\tPatternParser p = new PatternParser(\"@Foo * *.*(..)\");\\n\t\tSignaturePattern s = p.parseMethodOrConstructorSignaturePattern();\\n\t\tassertEquals(\"@(Foo) annotat"
  },
  {
    "method_id": "M4115",
    "name": "testParseMethodOrConstructorSigComplexAP",
    "return_type": "void",
    "signature": "testParseMethodOrConstructorSigComplexAP()",
    "file_id": "F155",
    "start_line": 214,
    "text_preview": "sertEquals(\"Any name\", \"*\", s.getName().toString());\\n\t\tassertEquals(\"@(Foo) * *.*(..)\", s.toString());\\n\t}\\n\\n\tpublic void testParseMethodOrConstructorSigComplexAP() {\\n\t\tPatternParser p = new PatternParser(\"!@(Foo || Goo) * *.*(..)\");\\n\t\tSignaturePattern s = p.parseMethodOrConstructorSignaturePattern();\\n\t\tassertEquals(\"com"
  },
  {
    "method_id": "M4116",
    "name": "testParseMethodFieldSigNoAP",
    "return_type": "void",
    "signature": "testParseMethodFieldSigNoAP()",
    "file_id": "F155",
    "start_line": 224,
    "text_preview": "(\"Any name\", \"*\", s.getName().toString());\\n\t\tassertEquals(\"!@((Foo || Goo)) * *.*(..)\", s.toString());\\n\t}\\n\\n\tpublic void testParseMethodFieldSigNoAP() {\\n\t\tPatternParser p = new PatternParser(\"* *.*\");\\n\t\tSignaturePattern s = p.parseFieldSignaturePattern();\\n\t\tassertEquals(\"Any annotation\", AnnotationTypePattern.ANY, s.get"
  },
  {
    "method_id": "M4117",
    "name": "testParseFieldSigSimpleAP",
    "return_type": "void",
    "signature": "testParseFieldSigSimpleAP()",
    "file_id": "F155",
    "start_line": 234,
    "text_preview": "ng());\\n\t\tassertEquals(\"Any name\", \"*\", s.getName().toString());\\n\t\tassertEquals(\"* *.*\", s.toString());\\n\t}\\n\\n\tpublic void testParseFieldSigSimpleAP() {\\n\t\tPatternParser p = new PatternParser(\"@Foo * *.*\");\\n\t\tSignaturePattern s = p.parseFieldSignaturePattern();\\n\t\tassertEquals(\"@Foo annotation\", \"@(Foo)\", s.getAnnotationPat"
  },
  {
    "method_id": "M4118",
    "name": "testParseFieldSigComplexAP",
    "return_type": "void",
    "signature": "testParseFieldSigComplexAP()",
    "file_id": "F155",
    "start_line": 244,
    "text_preview": "\t\tassertEquals(\"Any name\", \"*\", s.getName().toString());\\n\t\tassertEquals(\"@(Foo) * *.*\", s.toString());\\n\t}\\n\\n\tpublic void testParseFieldSigComplexAP() {\\n\t\tPatternParser p = new PatternParser(\"!@(Foo || Goo) * *.*\");\\n\t\tSignaturePattern s = p.parseFieldSignaturePattern();\\n\t\tassertEquals(\"complex annotation\", \"!@((Foo || Go"
  },
  {
    "method_id": "M4119",
    "name": "testExactAnnotationPatternMatching",
    "return_type": "void",
    "signature": "testExactAnnotationPatternMatching()",
    "file_id": "F155",
    "start_line": 254,
    "text_preview": "uals(\"Any name\", \"*\", s.getName().toString());\\n\t\tassertEquals(\"!@((Foo || Goo)) * *.*\", s.toString());\\n\t}\\n\\n\tpublic void testExactAnnotationPatternMatching() {\\n\t\tPatternParser p = new PatternParser(\"@Foo\");\\n\t\tAnnotationTypePattern ap = p.maybeParseAnnotationPattern();\\n\t\tap = ap.resolveBindings(makeSimpleScope(), new Bin"
  },
  {
    "method_id": "M4120",
    "name": "testBindingAnnotationPatternMatching",
    "return_type": "void",
    "signature": "testBindingAnnotationPatternMatching()",
    "file_id": "F155",
    "start_line": 264,
    "text_preview": "w String[] { \"Boo\" });\\n\t\tassertTrue(\"does not match element with Boo\", ap.matches(ae2).alwaysFalse());\\n\t}\\n\\n\tpublic void testBindingAnnotationPatternMatching() {\\n\t\tPatternParser p = new PatternParser(\"foo\");\\n\t\tAnnotationTypePattern ap = p.parseAnnotationNameOrVarTypePattern();\\n\t\ttry {\\n\t\t\tap = ap.resolveBindings(makeSimp"
  },
  {
    "method_id": "M4121",
    "name": "catch",
    "return_type": "",
    "signature": "catch(AbortException abEx)",
    "file_id": "F155",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4122",
    "name": "testAndAnnotationPatternMatching",
    "return_type": "void",
    "signature": "testAndAnnotationPatternMatching()",
    "file_id": "F155",
    "start_line": 283,
    "text_preview": "ing[]{\"Boo\"});\\n\t\t// assertTrue(\"does not match element with Boo\",ap.matches(ae2).\\n\t\t// alwaysFalse());\\n\t}\\n\\n\tpublic void testAndAnnotationPatternMatching() {\\n\t\tPatternParser p = new PatternParser(\"@Foo @Boo\");\\n\t\tAnnotationTypePattern ap = p.maybeParseAnnotationPattern();\\n\t\tap = ap.resolveBindings(makeSimpleScope(), new "
  },
  {
    "method_id": "M4123",
    "name": "testOrAnnotationPatternMatching",
    "return_type": "void",
    "signature": "testOrAnnotationPatternMatching()",
    "file_id": "F155",
    "start_line": 298,
    "text_preview": "Impl(new String[] { \"Goo\" });\\n\t\tassertTrue(\"does not match goo\", ap.matches(ae).alwaysFalse());\\n\t}\\n\\n\t//\\n\t// public void testOrAnnotationPatternMatching() {\\n\t// PatternParser p = new PatternParser(\"@Foo || @Boo\");\\n\t// AnnotationTypePattern ap = p.parseAnnotationTypePattern();\\n\t// ap = ap.resolveBindings(makeSimpleScope("
  },
  {
    "method_id": "M4124",
    "name": "testNotAnnotationPatternMatching",
    "return_type": "void",
    "signature": "testNotAnnotationPatternMatching()",
    "file_id": "F155",
    "start_line": 313,
    "text_preview": "ntImpl(new String[] {\"Goo\"});\\n\t// assertTrue(\"does not match goo\",ap.matches(ae).alwaysFalse());\\n\t// }\\n\t//\\n\tpublic void testNotAnnotationPatternMatching() {\\n\t\tPatternParser p = new PatternParser(\"!@Foo\");\\n\t\tAnnotationTypePattern ap = p.maybeParseAnnotationPattern();\\n\t\tap = ap.resolveBindings(makeSimpleScope(), new Bind"
  },
  {
    "method_id": "M4125",
    "name": "testAnyAnnotationPatternMatching",
    "return_type": "void",
    "signature": "testAnyAnnotationPatternMatching()",
    "file_id": "F155",
    "start_line": 323,
    "text_preview": "nnotatedElementImpl(new String[] { \"Boo\" });\\n\t\tassertTrue(\"matches boo\", ap.matches(ae).alwaysTrue());\\n\t}\\n\\n\tpublic void testAnyAnnotationPatternMatching() {\\n\t\tAnnotatedElementImpl ae = new AnnotatedElementImpl(new String[] { \"Foo\", \"Boo\" });\\n\t\tassertTrue(\"always matches\", AnnotationTypePattern.ANY.matches(ae).alwaysTru"
  },
  {
    "method_id": "M4126",
    "name": "makeSimpleScope",
    "return_type": "TestScope",
    "signature": "makeSimpleScope()",
    "file_id": "F155",
    "start_line": 27,
    "text_preview": "= new PatternParser(\"@Foo\");\\n\t\tAnnotationTypePattern foo = p.maybeParseAnnotationPattern();\\n\t\tfoo = foo.resolveBindings(makeSimpleScope(), new Bindings(3), true);\\n\t\tassertTrue(\"ExactAnnotationTypePattern\", foo instanceof ExactAnnotationTypePattern);\\n\t\tassertEquals(\"Foo\", UnresolvedType.forSignature(\"LFoo;\"), ((ExactAnn"
  },
  {
    "method_id": "M4127",
    "name": "AnnotatedElementImpl",
    "return_type": "",
    "signature": "AnnotatedElementImpl(String[] annotationTypes)",
    "file_id": "F155",
    "start_line": 258,
    "text_preview": "notationPattern();\\n\t\tap = ap.resolveBindings(makeSimpleScope(), new Bindings(3), true);\\n\t\tAnnotatedElementImpl ae = new AnnotatedElementImpl(new String[] { \"Foo\" });\\n\t\tassertTrue(\"matches element with Foo\", ap.matches(ae).alwaysTrue());\\n\t\tAnnotatedElementImpl ae2 = new AnnotatedElementImpl(new String[] { \"Boo\" });\\n\t\tas"
  },
  {
    "method_id": "M4128",
    "name": "hasAnnotation",
    "return_type": "boolean",
    "signature": "hasAnnotation(UnresolvedType ofType)",
    "file_id": "F155",
    "start_line": 348,
    "text_preview": "ublic AnnotatedElementImpl(String[] annotationTypes) {\\n\t\t\tthis.annotationTypes = annotationTypes;\\n\t\t}\\n\\n\t\tpublic boolean hasAnnotation(UnresolvedType ofType) {\\n\t\t\tfor (String annotationType : annotationTypes) {\\n\t\t\t\tif (annotationType.equals(ofType.getName())) {\\n\t\t\t\t\treturn true;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t/*\\n\t\t "
  },
  {
    "method_id": "M4129",
    "name": "for",
    "return_type": "",
    "signature": "for(String annotationType : annotationTypes)",
    "file_id": "F155",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4130",
    "name": "getAnnotationTypes",
    "return_type": "ResolvedType[]",
    "signature": "getAnnotationTypes()",
    "file_id": "F155",
    "start_line": 360,
    "text_preview": "eturn true;\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\t/*\\n\t\t * (non-Javadoc)\\n\t\t *\\n\t\t * @see org.aspectj.weaver.AnnotatedElement#getAnnotationTypes()\\n\t\t */\\n\t\tpublic ResolvedType[] getAnnotationTypes() {\\n\t\t\t// TODO Auto-generated method stub\\n\t\t\treturn null;\\n\t\t}\\n\\n\t\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {\\n"
  },
  {
    "method_id": "M4131",
    "name": "getAnnotationOfType",
    "return_type": "AnnotationAJ",
    "signature": "getAnnotationOfType(UnresolvedType ofType)",
    "file_id": "F155",
    "start_line": 367,
    "text_preview": " ResolvedType[] getAnnotationTypes() {\\n\t\t\t// TODO Auto-generated method stub\\n\t\t\treturn null;\\n\t\t}\\n\\n\t\tpublic AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {\\n\t\t\t// TODO Auto-generated method stub\\n\t\t\treturn null;\\n\t\t}\\n\\n\t}\\n}\\n"
  },
  {
    "method_id": "M4132",
    "name": "ConcretizationTestCase",
    "return_type": "",
    "signature": "ConcretizationTestCase(String name)",
    "file_id": "F156",
    "start_line": 23,
    "text_preview": "r.bcel.WeaveTestCase;\\n\\npublic class ConcretizationTestCase extends WeaveTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic ConcretizationTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testNothingForAntJUnit() {\\n\t}\\n\\n\t// String[] none = new String[0];\\n\\n\t/*\\n\t * XXX temporarily skipping public void testCflowResidual("
  },
  {
    "method_id": "M4133",
    "name": "testNothingForAntJUnit",
    "return_type": "void",
    "signature": "testNothingForAntJUnit()",
    "file_id": "F156",
    "start_line": 27,
    "text_preview": "veTestCase {\\n\t{\\n\t\tregenerate = false;\\n\t}\\n\\n\tpublic ConcretizationTestCase(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\tpublic void testNothingForAntJUnit() {\\n\t}\\n\\n\t// String[] none = new String[0];\\n\\n\t/*\\n\t * XXX temporarily skipping public void testCflowResidual() throws IOException {\\n\t *\\n\t * BcelAdvice a = (BcelAdvice) makeConcret"
  },
  {
    "method_id": "M4134",
    "name": "testCflowResidual",
    "return_type": "void",
    "signature": "testCflowResidual()",
    "file_id": "F156",
    "start_line": 33,
    "text_preview": "ic void testNothingForAntJUnit() {\\n\t}\\n\\n\t// String[] none = new String[0];\\n\\n\t/*\\n\t * XXX temporarily skipping public void testCflowResidual() throws IOException {\\n\t *\\n\t * BcelAdvice a = (BcelAdvice) makeConcreteTestAdviceEntryPart();\\n\t *\\n\t * TestShadow shadow = new TestShadow(Shadow.MethodCall, Member.methodFromString(\"i"
  },
  {
    "method_id": "M4135",
    "name": "makeConcreteTestAdviceEntryPart",
    "return_type": "Advice",
    "signature": "makeConcreteTestAdviceEntryPart()",
    "file_id": "F156",
    "start_line": 35,
    "text_preview": "*\\n\t * XXX temporarily skipping public void testCflowResidual() throws IOException {\\n\t *\\n\t * BcelAdvice a = (BcelAdvice) makeConcreteTestAdviceEntryPart();\\n\t *\\n\t * TestShadow shadow = new TestShadow(Shadow.MethodCall, Member.methodFromString(\"int Aspect.i(int x)\"), UnresolvedType.OBJECT,\\n\t * world);\\n\t *\\n\t * ExposedState"
  },
  {
    "method_id": "M4136",
    "name": "XtestCflow",
    "return_type": "void",
    "signature": "XtestCflow()",
    "file_id": "F156",
    "start_line": 77,
    "text_preview": "ut.getCflowEntries(); //target.getExtraConcreteShadowMungers();\\n\t *\\n\t * return (Advice) c.get(0); }\\n\t *\\n\t * public void XtestCflow() throws IOException { Pointcut in =\\n\t * createResolvedPointcut(\"cflow(foo(a)) && (args(b) && !cflow(foo(int)))\", new String[] {\"b\", \"a\"}, new String[] {\"float\",\\n\t * \"int\"} );\\n\t *\\n\t * Resol"
  },
  {
    "method_id": "M4137",
    "name": "checkConcr",
    "return_type": "void",
    "signature": "checkConcr(Pointcut in, ResolvedPointcutDefinition referredTo, List expectedSlots)",
    "file_id": "F156",
    "start_line": 86,
    "text_preview": "t expectedSlots = new ArrayList(); expectedSlots.add(new ConcreteCflowPointcut.Slot(1, UnresolvedType.INT, 0));\\n\t *\\n\t * checkConcr(in, ref, expectedSlots); }\\n\t *\\n\t * public void checkConcr( Pointcut in, ResolvedPointcutDefinition referredTo, List expectedSlots) throws IOException {\\n\t *\\n\t * BcelObjectType target = (Bcel"
  },
  {
    "method_id": "M4138",
    "name": "createResolvedPointcut",
    "return_type": "Pointcut",
    "signature": "createResolvedPointcut(String pointcutSource, String[] formalNames, String[] formalTypes)",
    "file_id": "F156",
    "start_line": 56,
    "text_preview": "X copied from below, refactor later\\n\t *\\n\t *\\n\t * // returns the advice for the entry part of cflow(foo(a)) Pointcut in = createResolvedPointcut(\\n\t * \"cflow(foo(a)) && (args(b) && !cflow(foo(int)))\", new String[] { \"b\", \"a\" }, new String[] { \"float\", \"int\" });\\n\t *\\n\t * ResolvedPointcutDefinition ref = new ResolvedPointcut"
  },
  {
    "method_id": "M4139",
    "name": "testSimpleFoo",
    "return_type": "void",
    "signature": "testSimpleFoo()",
    "file_id": "F157",
    "start_line": 47,
    "text_preview": "n namePatterns={Foo} resolveBindings resolves Foo to RT(Foo\\n\t * - raw) return ExactTypePattern(LFoo;)\\n\t */\\n\tpublic void testSimpleFoo() {\\n\t\tTypePattern rtp = resolveWildTypePattern(\"List\", false);\\n\\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\\n\t\tUnresolvedType exactType = rtp.getExactType();\\n"
  },
  {
    "method_id": "M4140",
    "name": "testParameterized",
    "return_type": "void",
    "signature": "testParameterized()",
    "file_id": "F157",
    "start_line": 79,
    "text_preview": "pePattern(String) resolves Foo to RT(Foo)\\n\t * returns ExactTypePattern(PFoo<String>; - parameterized)\\n\t */\\n\tpublic void testParameterized() {\\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<String>\", false);\\n\\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\\n\t\tUnresolvedType exactType = rtp.getE"
  },
  {
    "method_id": "M4141",
    "name": "testParameterizedWildCard",
    "return_type": "void",
    "signature": "testParameterizedWildCard()",
    "file_id": "F157",
    "start_line": 115,
    "text_preview": "es Foo to RT(Foo) returns WildTypePattern(name = Foo,\\n\t * typeParameters = WTP{Str*} isGeneric=false)\\n\t */\\n\tpublic void testParameterizedWildCard() {\\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<Str*>\", false);\\n\\n\t\tassertTrue(\"resolves to WildTypePattern\", rtp instanceof WildTypePattern);\\n\t\tassertTrue(\"one type para"
  },
  {
    "method_id": "M4142",
    "name": "testWildcardParameterized",
    "return_type": "void",
    "signature": "testWildcardParameterized()",
    "file_id": "F157",
    "start_line": 139,
    "text_preview": "ters to ETP{String} returns WildTypePattern(name = Fo*, typeParameters = ETP{String} isGeneric=false)\\n\t */\\n\tpublic void testWildcardParameterized() {\\n\t\tTypePattern rtp = resolveWildTypePattern(\"Li*<String>\", false);\\n\\n\t\tassertTrue(\"resolves to WildTypePattern\", rtp instanceof WildTypePattern);\\n\t\tassertTrue(\"one type par"
  },
  {
    "method_id": "M4143",
    "name": "testSomething",
    "return_type": "void",
    "signature": "testSomething()",
    "file_id": "F157",
    "start_line": 161,
    "text_preview": "ot match String\", wtp.matches(javaLangString, TypePattern.STATIC).alwaysFalse());\\n\t}\\n\\n\t/**\\n\t * Foo<?>\\n\t */\\n\tpublic void testSomething() {\\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<?>\", false);\\n\\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\\n\t\tUnresolvedType exactType = rtp.getExactType("
  },
  {
    "method_id": "M4144",
    "name": "testSomethingExtends",
    "return_type": "void",
    "signature": "testSomethingExtends()",
    "file_id": "F157",
    "start_line": 187,
    "text_preview": "atches(javaUtilListOfSomething, TypePattern.STATIC).alwaysTrue());\\n\t}\\n\\n\t/**\\n\t * Foo<? extends Number>\\n\t */\\n\tpublic void testSomethingExtends() {\\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<? extends Number>\", false);\\n\\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\\n\t\tUnresolvedType exactTy"
  },
  {
    "method_id": "M4145",
    "name": "testSomethingExtendsPattern",
    "return_type": "void",
    "signature": "testSomethingExtendsPattern()",
    "file_id": "F157",
    "start_line": 231,
    "text_preview": ".matches(listOfExtendsNumber, TypePattern.STATIC).alwaysTrue());\\n\\n\t}\\n\\n\t/**\\n\t * Foo<? extends Number+>\\n\t */\\n\tpublic void testSomethingExtendsPattern() {\\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<? extends Number+>\", false);\\n\\n\t\tassertTrue(\"resolves to wild type pattern\", rtp instanceof WildTypePattern);\\n\t\tassertEq"
  },
  {
    "method_id": "M4146",
    "name": "testSomethingExtendsPatternv2",
    "return_type": "void",
    "signature": "testSomethingExtendsPatternv2()",
    "file_id": "F157",
    "start_line": 284,
    "text_preview": "wtp.matches(listOfExtendsDouble, TypePattern.STATIC).alwaysTrue());\\n\\n\t}\\n\\n\t/**\\n\t * Foo<? extends Num*>\\n\t */\\n\tpublic void testSomethingExtendsPatternv2() {\\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<? extends Num*>\", false);\\n\\n\t\tassertTrue(\"resolves to wild type pattern\", rtp instanceof WildTypePattern);\\n\t\tassertEqu"
  },
  {
    "method_id": "M4147",
    "name": "testSomethingSuper",
    "return_type": "void",
    "signature": "testSomethingSuper()",
    "file_id": "F157",
    "start_line": 337,
    "text_preview": ".matches(listOfExtendsDouble, TypePattern.STATIC).alwaysTrue());\\n\t}\\n\\n\t/**\\n\t * Foo<? super Number>\\n\t *\\n\t */\\n\tpublic void testSomethingSuper() {\\n\t\tTypePattern rtp = resolveWildTypePattern(\"List<? super Double>\", false);\\n\\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\\n\t\tUnresolvedType exactType ="
  },
  {
    "method_id": "M4148",
    "name": "resolveWildTypePattern",
    "return_type": "TypePattern",
    "signature": "resolveWildTypePattern(String source, boolean requireExact)",
    "file_id": "F157",
    "start_line": 48,
    "text_preview": "esolves Foo to RT(Foo\\n\t * - raw) return ExactTypePattern(LFoo;)\\n\t */\\n\tpublic void testSimpleFoo() {\\n\t\tTypePattern rtp = resolveWildTypePattern(\"List\", false);\\n\\n\t\tassertTrue(\"resolves to exact type\", rtp instanceof ExactTypePattern);\\n\t\tUnresolvedType exactType = rtp.getExactType();\\n\t\tassertTrue(exactType.isRawType());\\n\t"
  },
  {
    "method_id": "M4149",
    "name": "makeWildTypePattern",
    "return_type": "WildTypePattern",
    "signature": "makeWildTypePattern(String source)",
    "file_id": "F157",
    "start_line": 378,
    "text_preview": "True());\\n\t}\\n\\n\tprivate TypePattern resolveWildTypePattern(String source, boolean requireExact) {\\n\t\tWildTypePattern wtp = makeWildTypePattern(source);\\n\t\treturn wtp.resolveBindings(scope, bindings, false, requireExact);\\n\t}\\n\\n\tprivate WildTypePattern makeWildTypePattern(String source) {\\n\t\tPatternParser parser = new PatternP"
  },
  {
    "method_id": "M4150",
    "name": "writeAndRead",
    "return_type": "TypePattern",
    "signature": "writeAndRead(TypePattern etp)",
    "file_id": "F157",
    "start_line": 59,
    "text_preview": "uals(\"Ljava/util/List;\", rt.getSignature());\\n\t\tassertTrue(rt.isRawType());\\n\\n\t\tExactTypePattern etp = (ExactTypePattern) writeAndRead(rtp);\\n\t\texactType = etp.getExactType();\\n\\n\t\tassertEquals(\"Ljava/util/List;\", exactType.getSignature());\\n\\n\t\trt = exactType.resolve(world);\\n\t\tassertEquals(\"Ljava/util/List;\", rt.getSignature"
  },
  {
    "method_id": "M4151",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException ioEx)",
    "file_id": "F157",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4152",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F157",
    "start_line": 406,
    "text_preview": ";\\n\t\t} catch (IOException ioEx) {\\n\t\t\tfail(ioEx + \" thrown during serialization\");\\n\t\t}\\n\t\treturn null;\\n\t}\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tthis.world = new BcelWorld();\\n\t\tthis.world.setBehaveInJava5Way(true);\\n\t\tthis.bindings = new Bindings(0);\\n\t\tthis.scope = new SimpleScope(world, new FormalB"
  },
  {
    "method_id": "M4153",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F158",
    "start_line": 20,
    "text_preview": ".aspectj.weaver.patterns.AndOrNotTestCase;\\n\\npublic class BcelAndOrNotTestCase extends AndOrNotTestCase {\\n\\n\tpublic World getWorld() {\\n\t\treturn new BcelWorld();\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4154",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F159",
    "start_line": 20,
    "text_preview": "org.aspectj.weaver.patterns.BindingTestCase;\\n\\npublic class BcelBindingTestCase extends BindingTestCase {\\n\\n\tpublic World getWorld() {\\n\t\treturn new BcelWorld();\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4155",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F160",
    "start_line": 20,
    "text_preview": ".ModifiersPatternTestCase;\\n\\npublic class BcelModifiersPatternTestCase extends ModifiersPatternTestCase {\\n\\n\tpublic World getWorld() {\\n\t\treturn new BcelWorld();\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4156",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F161",
    "start_line": 21,
    "text_preview": "rt org.aspectj.weaver.patterns.ParserTestCase;\\n\\npublic class BcelParserTestCase extends ParserTestCase {\\n\\n\tpublic World getWorld() {\\n\t\treturn new BcelWorld(WeaverTestCase.TESTDATA_PATH + \"/testcode.jar\");\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4157",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F162",
    "start_line": 20,
    "text_preview": ".SignaturePatternTestCase;\\n\\npublic class BcelSignaturePatternTestCase extends SignaturePatternTestCase {\\n\\n\tpublic World getWorld() {\\n\t\treturn new BcelWorld();\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4158",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F163",
    "start_line": 20,
    "text_preview": "rns.TypePatternListTestCase;\\n\\npublic class BcelTypePatternListTestCase extends TypePatternListTestCase {\\n\\n\tpublic World getWorld() {\\n\t\treturn new BcelWorld();\\n\t}\\n}\\n"
  },
  {
    "method_id": "M4159",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F164",
    "start_line": 20,
    "text_preview": "weaver.patterns.TypePatternTestCase;\\n\\npublic class BcelTypePatternTestCase extends TypePatternTestCase {\\n\\n\tpublic World getWorld() {\\n\t\treturn new BcelWorld();\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4160",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F165",
    "start_line": 20,
    "text_preview": "rt org.aspectj.weaver.patterns.WithinTestCase;\\n\\npublic class BcelWithinTestCase extends WithinTestCase {\\n\\n\tpublic World getWorld() {\\n\t\treturn new BcelWorld();\\n\t}\\n}\\n"
  },
  {
    "method_id": "M4161",
    "name": "testIsAspect",
    "return_type": "void",
    "signature": "testIsAspect()",
    "file_id": "F166",
    "start_line": 33,
    "text_preview": "e {\\n\\n\tprotected ReflectionWorld world;\\n\tprivate ResolvedType objectType;\\n\tprivate ResolvedType classType;\\n\\n\tpublic void testIsAspect() {\\n\t\tassertFalse(objectType.isAspect());\\n\t}\\n\\n\tpublic void testIsAnnotationStyleAspect() {\\n\t\tassertFalse(objectType.isAnnotationStyleAspect());\\n\t}\\n\\n\tpublic void testIsInterface() {\\n\t\tasse"
  },
  {
    "method_id": "M4162",
    "name": "testIsAnnotationStyleAspect",
    "return_type": "void",
    "signature": "testIsAnnotationStyleAspect()",
    "file_id": "F166",
    "start_line": 37,
    "text_preview": "\\n\tprivate ResolvedType classType;\\n\\n\tpublic void testIsAspect() {\\n\t\tassertFalse(objectType.isAspect());\\n\t}\\n\\n\tpublic void testIsAnnotationStyleAspect() {\\n\t\tassertFalse(objectType.isAnnotationStyleAspect());\\n\t}\\n\\n\tpublic void testIsInterface() {\\n\t\tassertFalse(objectType.isInterface());\\n\t\tassertTrue(world.resolve(\"java.io.S"
  },
  {
    "method_id": "M4163",
    "name": "testIsInterface",
    "return_type": "void",
    "signature": "testIsInterface()",
    "file_id": "F166",
    "start_line": 41,
    "text_preview": "\\n\t}\\n\\n\tpublic void testIsAnnotationStyleAspect() {\\n\t\tassertFalse(objectType.isAnnotationStyleAspect());\\n\t}\\n\\n\tpublic void testIsInterface() {\\n\t\tassertFalse(objectType.isInterface());\\n\t\tassertTrue(world.resolve(\"java.io.Serializable\").isInterface());\\n\t}\\n\\n\tpublic void testIsEnum() {\\n\t\tassertFalse(objectType.isEnum());\\n\t}\\n\\n"
  },
  {
    "method_id": "M4164",
    "name": "testIsEnum",
    "return_type": "void",
    "signature": "testIsEnum()",
    "file_id": "F166",
    "start_line": 46,
    "text_preview": "ertFalse(objectType.isInterface());\\n\t\tassertTrue(world.resolve(\"java.io.Serializable\").isInterface());\\n\t}\\n\\n\tpublic void testIsEnum() {\\n\t\tassertFalse(objectType.isEnum());\\n\t}\\n\\n\tpublic void testIsAnnotation() {\\n\t\tassertFalse(objectType.isAnnotation());\\n\t}\\n\\n\tpublic void testIsAnnotationWithRuntimeRetention() {\\n\t\tassertFal"
  },
  {
    "method_id": "M4165",
    "name": "testIsAnnotation",
    "return_type": "void",
    "signature": "testIsAnnotation()",
    "file_id": "F166",
    "start_line": 50,
    "text_preview": ".io.Serializable\").isInterface());\\n\t}\\n\\n\tpublic void testIsEnum() {\\n\t\tassertFalse(objectType.isEnum());\\n\t}\\n\\n\tpublic void testIsAnnotation() {\\n\t\tassertFalse(objectType.isAnnotation());\\n\t}\\n\\n\tpublic void testIsAnnotationWithRuntimeRetention() {\\n\t\tassertFalse(objectType.isAnnotationWithRuntimeRetention());\\n\t}\\n\\n\tpublic void "
  },
  {
    "method_id": "M4166",
    "name": "testIsAnnotationWithRuntimeRetention",
    "return_type": "void",
    "signature": "testIsAnnotationWithRuntimeRetention()",
    "file_id": "F166",
    "start_line": 54,
    "text_preview": "(objectType.isEnum());\\n\t}\\n\\n\tpublic void testIsAnnotation() {\\n\t\tassertFalse(objectType.isAnnotation());\\n\t}\\n\\n\tpublic void testIsAnnotationWithRuntimeRetention() {\\n\t\tassertFalse(objectType.isAnnotationWithRuntimeRetention());\\n\t}\\n\\n\tpublic void testIsClass() {\\n\t\tassertTrue(objectType.isClass());\\n\t\tassertFalse(world.resolve("
  },
  {
    "method_id": "M4167",
    "name": "testIsClass",
    "return_type": "void",
    "signature": "testIsClass()",
    "file_id": "F166",
    "start_line": 58,
    "text_preview": "testIsAnnotationWithRuntimeRetention() {\\n\t\tassertFalse(objectType.isAnnotationWithRuntimeRetention());\\n\t}\\n\\n\tpublic void testIsClass() {\\n\t\tassertTrue(objectType.isClass());\\n\t\tassertFalse(world.resolve(\"java.io.Serializable\").isClass());\\n\t}\\n\\n\tpublic void testIsGeneric() {\\n\t\tassertFalse(objectType.isGenericType());\\n\t}\\n\\n\tp"
  },
  {
    "method_id": "M4168",
    "name": "testIsGeneric",
    "return_type": "void",
    "signature": "testIsGeneric()",
    "file_id": "F166",
    "start_line": 63,
    "text_preview": " {\\n\t\tassertTrue(objectType.isClass());\\n\t\tassertFalse(world.resolve(\"java.io.Serializable\").isClass());\\n\t}\\n\\n\tpublic void testIsGeneric() {\\n\t\tassertFalse(objectType.isGenericType());\\n\t}\\n\\n\tpublic void testIsExposedToWeaver() {\\n\t\tassertFalse(objectType.isExposedToWeaver());\\n\t}\\n\\n\tpublic void testHasAnnotation() {\\n\t\tassertFa"
  },
  {
    "method_id": "M4169",
    "name": "testIsExposedToWeaver",
    "return_type": "void",
    "signature": "testIsExposedToWeaver()",
    "file_id": "F166",
    "start_line": 67,
    "text_preview": "rializable\").isClass());\\n\t}\\n\\n\tpublic void testIsGeneric() {\\n\t\tassertFalse(objectType.isGenericType());\\n\t}\\n\\n\tpublic void testIsExposedToWeaver() {\\n\t\tassertFalse(objectType.isExposedToWeaver());\\n\t}\\n\\n\tpublic void testHasAnnotation() {\\n\t\tassertFalse(objectType.hasAnnotation(UnresolvedType.forName(\"Foo\")));\\n\t}\\n\\n\tpublic void"
  },
  {
    "method_id": "M4170",
    "name": "testHasAnnotation",
    "return_type": "void",
    "signature": "testHasAnnotation()",
    "file_id": "F166",
    "start_line": 71,
    "text_preview": "ericType());\\n\t}\\n\\n\tpublic void testIsExposedToWeaver() {\\n\t\tassertFalse(objectType.isExposedToWeaver());\\n\t}\\n\\n\tpublic void testHasAnnotation() {\\n\t\tassertFalse(objectType.hasAnnotation(UnresolvedType.forName(\"Foo\")));\\n\t}\\n\\n\tpublic void testGetAnnotations() {\\n\t\tassertEquals(\"no entries\", 0, objectType.getAnnotations().length"
  },
  {
    "method_id": "M4171",
    "name": "testGetAnnotations",
    "return_type": "void",
    "signature": "testGetAnnotations()",
    "file_id": "F166",
    "start_line": 75,
    "text_preview": "lic void testHasAnnotation() {\\n\t\tassertFalse(objectType.hasAnnotation(UnresolvedType.forName(\"Foo\")));\\n\t}\\n\\n\tpublic void testGetAnnotations() {\\n\t\tassertEquals(\"no entries\", 0, objectType.getAnnotations().length);\\n\t}\\n\\n\tpublic void testGetAnnotationTypes() {\\n\t\tassertEquals(\"no entries\", 0, objectType.getAnnotationTypes()."
  },
  {
    "method_id": "M4172",
    "name": "testGetAnnotationTypes",
    "return_type": "void",
    "signature": "testGetAnnotationTypes()",
    "file_id": "F166",
    "start_line": 79,
    "text_preview": "ublic void testGetAnnotations() {\\n\t\tassertEquals(\"no entries\", 0, objectType.getAnnotations().length);\\n\t}\\n\\n\tpublic void testGetAnnotationTypes() {\\n\t\tassertEquals(\"no entries\", 0, objectType.getAnnotationTypes().length);\\n\t}\\n\\n\tpublic void testGetTypeVariables() {\\n\t\tassertEquals(\"no entries\", 0, objectType.getTypeVariable"
  },
  {
    "method_id": "M4173",
    "name": "testGetTypeVariables",
    "return_type": "void",
    "signature": "testGetTypeVariables()",
    "file_id": "F166",
    "start_line": 83,
    "text_preview": "id testGetAnnotationTypes() {\\n\t\tassertEquals(\"no entries\", 0, objectType.getAnnotationTypes().length);\\n\t}\\n\\n\tpublic void testGetTypeVariables() {\\n\t\tassertEquals(\"no entries\", 0, objectType.getTypeVariables().length);\\n\t}\\n\\n\tpublic void testGetPerClause() {\\n\t\tassertNull(objectType.getPerClause());\\n\t}\\n\\n\tpublic void testGetM"
  },
  {
    "method_id": "M4174",
    "name": "testGetPerClause",
    "return_type": "void",
    "signature": "testGetPerClause()",
    "file_id": "F166",
    "start_line": 87,
    "text_preview": "c void testGetTypeVariables() {\\n\t\tassertEquals(\"no entries\", 0, objectType.getTypeVariables().length);\\n\t}\\n\\n\tpublic void testGetPerClause() {\\n\t\tassertNull(objectType.getPerClause());\\n\t}\\n\\n\tpublic void testGetModifiers() {\\n\t\tassertEquals(Object.class.getModifiers(), objectType.getModifiers());\\n\t}\\n\\n\tpublic void testGetSupe"
  },
  {
    "method_id": "M4175",
    "name": "testGetModifiers",
    "return_type": "void",
    "signature": "testGetModifiers()",
    "file_id": "F166",
    "start_line": 91,
    "text_preview": "ypeVariables().length);\\n\t}\\n\\n\tpublic void testGetPerClause() {\\n\t\tassertNull(objectType.getPerClause());\\n\t}\\n\\n\tpublic void testGetModifiers() {\\n\t\tassertEquals(Object.class.getModifiers(), objectType.getModifiers());\\n\t}\\n\\n\tpublic void testGetSuperclass() {\\n\t\tassertTrue(\"Superclass of object should be null, but it is: \" + ob"
  },
  {
    "method_id": "M4176",
    "name": "testGetSuperclass",
    "return_type": "void",
    "signature": "testGetSuperclass()",
    "file_id": "F166",
    "start_line": 95,
    "text_preview": "blic void testGetModifiers() {\\n\t\tassertEquals(Object.class.getModifiers(), objectType.getModifiers());\\n\t}\\n\\n\tpublic void testGetSuperclass() {\\n\t\tassertTrue(\"Superclass of object should be null, but it is: \" + objectType.getSuperclass(),\\n\t\t\t\tobjectType.getSuperclass() == null);\\n\t\tassertEquals(objectType, world.resolve(\"j"
  },
  {
    "method_id": "M4177",
    "name": "findMethod",
    "return_type": "int",
    "signature": "findMethod(String name, ResolvedMember[] methods)",
    "file_id": "F166",
    "start_line": 103,
    "text_preview": "rld.resolve(\"reflect.tests.D\");\\n\t\tassertEquals(world.resolve(\"reflect.tests.C\"), d.getSuperclass());\\n\t}\\n\\n\tprotected int findMethod(String name, ResolvedMember[] methods) {\\n\t\tfor (int i = 0; i < methods.length; i++) {\\n\t\t\tif (name.equals(methods[i].getName())) {\\n\t\t\t\treturn i;\\n\t\t\t}\\n\t\t}\\n\t\treturn -1;\\n\t}\\n\\n\tprotected int find"
  },
  {
    "method_id": "M4178",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < methods.length; i++)",
    "file_id": "F166",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4179",
    "name": "findMethod",
    "return_type": "int",
    "signature": "findMethod(String name, int numArgs, ResolvedMember[] methods)",
    "file_id": "F166",
    "start_line": 103,
    "text_preview": "rld.resolve(\"reflect.tests.D\");\\n\t\tassertEquals(world.resolve(\"reflect.tests.C\"), d.getSuperclass());\\n\t}\\n\\n\tprotected int findMethod(String name, ResolvedMember[] methods) {\\n\t\tfor (int i = 0; i < methods.length; i++) {\\n\t\t\tif (name.equals(methods[i].getName())) {\\n\t\t\t\treturn i;\\n\t\t\t}\\n\t\t}\\n\t\treturn -1;\\n\t}\\n\\n\tprotected int find"
  },
  {
    "method_id": "M4180",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < methods.length; i++)",
    "file_id": "F166",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4181",
    "name": "testGetDeclaredMethods",
    "return_type": "void",
    "signature": "testGetDeclaredMethods()",
    "file_id": "F166",
    "start_line": 121,
    "text_preview": "etName()) && (methods[i].getParameterTypes().length == numArgs)) {\\n\t\t\t\treturn i;\\n\t\t\t}\\n\t\t}\\n\t\treturn -1;\\n\t}\\n\\n\tpublic void testGetDeclaredMethods() {\\n\t\tResolvedMember[] methods = objectType.getDeclaredMethods();\\n\t\tassertEquals(Object.class.getDeclaredMethods().length + Object.class.getDeclaredConstructors().length, method"
  },
  {
    "method_id": "M4182",
    "name": "testGetDeclaredFields",
    "return_type": "void",
    "signature": "testGetDeclaredFields()",
    "file_id": "F166",
    "start_line": 151,
    "text_preview": "ass.class.getDeclaredMethods().length + Class.class.getDeclaredConstructors().length, methods.length);\\n\t}\\n\\n\tpublic void testGetDeclaredFields() {\\n\t\tResolvedMember[] fields = objectType.getDeclaredFields();\\n\t\tassertEquals(0, fields.length);\\n\\n\t\tResolvedType c = world.resolve(\"reflect.tests.C\");\\n\t\tfields = c.getDeclaredFi"
  },
  {
    "method_id": "M4183",
    "name": "testGetDeclaredInterfaces",
    "return_type": "void",
    "signature": "testGetDeclaredInterfaces()",
    "file_id": "F166",
    "start_line": 165,
    "text_preview": "lds[0].getReturnType());\\n\t\tassertEquals(world.resolve(\"java.lang.String\"), fields[1].getReturnType());\\n\t}\\n\\n\tpublic void testGetDeclaredInterfaces() {\\n\t\tResolvedType[] interfaces = objectType.getDeclaredInterfaces();\\n\t\tassertEquals(0, interfaces.length);\\n\\n\t\tResolvedType d = world.resolve(\"reflect.tests.D\");\\n\t\tinterfaces"
  },
  {
    "method_id": "M4184",
    "name": "testGetDeclaredPointcuts",
    "return_type": "void",
    "signature": "testGetDeclaredPointcuts()",
    "file_id": "F166",
    "start_line": 175,
    "text_preview": "ertEquals(1, interfaces.length);\\n\t\tassertEquals(world.resolve(\"java.io.Serializable\"), interfaces[0]);\\n\t}\\n\\n\tpublic void testGetDeclaredPointcuts() {\\n\t\tResolvedMember[] pointcuts = objectType.getDeclaredPointcuts();\\n\t\tassertEquals(0, pointcuts.length);\\n\t}\\n\\n\tpublic void testSerializableSuperclass() {\\n\t\tResolvedType seria"
  },
  {
    "method_id": "M4185",
    "name": "testSerializableSuperclass",
    "return_type": "void",
    "signature": "testSerializableSuperclass()",
    "file_id": "F166",
    "start_line": 180,
    "text_preview": "\t\tResolvedMember[] pointcuts = objectType.getDeclaredPointcuts();\\n\t\tassertEquals(0, pointcuts.length);\\n\t}\\n\\n\tpublic void testSerializableSuperclass() {\\n\t\tResolvedType serializableType = world.resolve(\"java.io.Serializable\");\\n\t\tResolvedType superType = serializableType.getSuperclass();\\n\t\tassertTrue(\"Superclass of seriali"
  },
  {
    "method_id": "M4186",
    "name": "testSubinterfaceSuperclass",
    "return_type": "void",
    "signature": "testSubinterfaceSuperclass()",
    "file_id": "F166",
    "start_line": 191,
    "text_preview": ";\\n\t\tassertTrue(\"Should be null but is \" + bcelSupertype, bcelSupertype.equals(UnresolvedType.OBJECT));\\n\t}\\n\\n\tpublic void testSubinterfaceSuperclass() {\\n\t\tResolvedType ifaceType = world.resolve(\"java.security.Key\");\\n\t\tResolvedType superType = ifaceType.getSuperclass();\\n\t\tassertTrue(\"Superclass should be Object but was \" "
  },
  {
    "method_id": "M4187",
    "name": "testVoidSuperclass",
    "return_type": "void",
    "signature": "testVoidSuperclass()",
    "file_id": "F166",
    "start_line": 202,
    "text_preview": ";\\n\t\tassertTrue(\"Should be null but is \" + bcelSupertype, bcelSupertype.equals(UnresolvedType.OBJECT));\\n\t}\\n\\n\tpublic void testVoidSuperclass() {\\n\t\tResolvedType voidType = world.resolve(Void.TYPE);\\n\t\tResolvedType superType = voidType.getSuperclass();\\n\t\tassertNull(superType);\\n\\n\t\tBcelWorld bcelworld = new BcelWorld();\\n\t\tbce"
  },
  {
    "method_id": "M4188",
    "name": "testIntSuperclass",
    "return_type": "void",
    "signature": "testIntSuperclass()",
    "file_id": "F166",
    "start_line": 213,
    "text_preview": "void\").getSuperclass();\\n\t\tassertTrue(\"Should be null but is \" + bcelSupertype, bcelSupertype == null);\\n\t}\\n\\n\tpublic void testIntSuperclass() {\\n\t\tResolvedType voidType = world.resolve(Integer.TYPE);\\n\t\tResolvedType superType = voidType.getSuperclass();\\n\t\tassertNull(superType);\\n\\n\t\tBcelWorld bcelworld = new BcelWorld();\\n\t\tb"
  },
  {
    "method_id": "M4189",
    "name": "testGenericInterfaceSuperclass_BcelWorldResolution",
    "return_type": "void",
    "signature": "testGenericInterfaceSuperclass_BcelWorldResolution()",
    "file_id": "F166",
    "start_line": 224,
    "text_preview": "\"int\").getSuperclass();\\n\t\tassertTrue(\"Should be null but is \" + bcelSupertype, bcelSupertype == null);\\n\t}\\n\\n\tpublic void testGenericInterfaceSuperclass_BcelWorldResolution() {\\n\t\tBcelWorld bcelworld = new BcelWorld();\\n\t\tbcelworld.setBehaveInJava5Way(true);\\n\\n\t\tUnresolvedType javaUtilMap = UnresolvedType.forName(\"java.util"
  },
  {
    "method_id": "M4190",
    "name": "testCompareSubclassDelegates",
    "return_type": "void",
    "signature": "testCompareSubclassDelegates()",
    "file_id": "F166",
    "start_line": 245,
    "text_preview": "st of methods returned doesn't include <clinit> (the static initializer) ... is that really\\n\t// a problem.\\n\tpublic void testCompareSubclassDelegates() {\\n\\n\t\tboolean barfIfClinitMissing = false;\\n\t\tworld.setBehaveInJava5Way(true);\\n\\n\t\tBcelWorld bcelWorld = new BcelWorld(getClass().getClassLoader(), IMessageHandler.THROW, n"
  },
  {
    "method_id": "M4191",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember item : rms1)",
    "file_id": "F166",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4192",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember value : rms2)",
    "file_id": "F166",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4193",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember member : rms2)",
    "file_id": "F166",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4194",
    "name": "for",
    "return_type": "",
    "signature": "for(ResolvedMember resolvedMember : rms1)",
    "file_id": "F166",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4195",
    "name": "if",
    "return_type": "",
    "signature": "if(barfIfClinitMissing)",
    "file_id": "F166",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4196",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < rms1.length; i++)",
    "file_id": "F166",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4197",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < rms2.length; i++)",
    "file_id": "F166",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4198",
    "name": "testArrayArgsSig",
    "return_type": "void",
    "signature": "testArrayArgsSig()",
    "file_id": "F166",
    "start_line": 302,
    "text_preview": " case, but bcel=\" + rms1.length + \" reflect=\" + rms2.length,\\n\t\t\t\t\trms1.length == rms2.length + 1);\\n\t\t}\\n\t}\\n\\n\tpublic void testArrayArgsSig() throws Exception {\\n\t\tMethod invokeMethod = Method.class.getMethod(\"invoke\", new Class[] { Object.class, Object[].class });\\n\t\tResolvedMember reflectionMethod = ReflectionBasedReferen"
  },
  {
    "method_id": "M4199",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F166",
    "start_line": 312,
    "text_preview": "onMethod.getSignature(), reflectionMethod.getSignature()\\n\t\t\t\t.equals(exp));\\n\t}\\n\\n\t// todo: array of int\\n\\n\tprotected void setUp() throws Exception {\\n\t\tworld = new ReflectionWorld(getClass().getClassLoader());\\n\t\tobjectType = world.resolve(\"java.lang.Object\");\\n\t}\\n}\\n"
  },
  {
    "method_id": "M4200",
    "name": "getSupportsAutoboxing",
    "return_type": "boolean",
    "signature": "getSupportsAutoboxing()",
    "file_id": "F167",
    "start_line": 19,
    "text_preview": "ctj.weaver.World;\\n\\npublic class ReflectionWorldReferenceTypeTest extends CommonReferenceTypeTests {\\n\\n\tprotected boolean getSupportsAutoboxing() {\\n\t\treturn true;\\n\t}\\n\\n\tpublic World getWorld() {\\n\t\treturn new ReflectionWorld(false, getClass().getClassLoader());\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4201",
    "name": "getWorld",
    "return_type": "World",
    "signature": "getWorld()",
    "file_id": "F167",
    "start_line": 23,
    "text_preview": "eTest extends CommonReferenceTypeTests {\\n\\n\tprotected boolean getSupportsAutoboxing() {\\n\t\treturn true;\\n\t}\\n\\n\tpublic World getWorld() {\\n\t\treturn new ReflectionWorld(false, getClass().getClassLoader());\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4202",
    "name": "testDelegateCreation",
    "return_type": "void",
    "signature": "testDelegateCreation()",
    "file_id": "F168",
    "start_line": 36,
    "text_preview": "\\n * @author Andy Clement\\n * @author Adrian Colyer\\n */\\npublic class ReflectionWorldTest extends TestCase {\\n\\n\tpublic void testDelegateCreation() {\\n\t\tWorld world = new ReflectionWorld(getClass().getClassLoader());\\n\t\tResolvedType rt = world.resolve(\"java.lang.Object\");\\n\t\tassertNotNull(rt);\\n\t\tassertEquals(\"Ljava/lang/Object"
  },
  {
    "method_id": "M4203",
    "name": "xtestReflectionWorldFactory",
    "return_type": "void",
    "signature": "xtestReflectionWorldFactory()",
    "file_id": "F168",
    "start_line": 45,
    "text_preview": "customized by introducing new\\n\t// PCD handlers. It means more thought needs to be put into reusing worlds.\\n\tpublic void xtestReflectionWorldFactory() throws Exception {\\n\t\tClassLoader parent = getClass().getClassLoader();\\n\t\tClassLoader cl1 = new URLClassLoader(new URL[] {}, parent);\\n\t\tClassLoader cl2 = new URLClassLoade"
  },
  {
    "method_id": "M4204",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0;i<100;i++)",
    "file_id": "F168",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4205",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0;i<100;i++)",
    "file_id": "F168",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4206",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0;i<100;i++)",
    "file_id": "F168",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4207",
    "name": "testArrayTypes",
    "return_type": "void",
    "signature": "testArrayTypes()",
    "file_id": "F168",
    "start_line": 103,
    "text_preview": "\t\tassertEquals(1, worlds.size());\\n\t\tReflectionWorld.cleanUpWorlds();\\n\t\tassertEquals(0, worlds.size());\\n\t}\\n\\n\tpublic void testArrayTypes() {\\n\t\tIReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\\n\t\tString[] strArray = new String[1];\\n\t\tResolvedType rt = world.resolve(strArray.getClass());\\n\t\tassertTru"
  },
  {
    "method_id": "M4208",
    "name": "testPrimitiveTypes",
    "return_type": "void",
    "signature": "testPrimitiveTypes()",
    "file_id": "F168",
    "start_line": 110,
    "text_preview": "y = new String[1];\\n\t\tResolvedType rt = world.resolve(strArray.getClass());\\n\t\tassertTrue(rt.isArray());\\n\t}\\n\\n\tpublic void testPrimitiveTypes() {\\n\t\tIReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\\n\t\tassertEquals(\"int\", UnresolvedType.INT, world.resolve(int.class));\\n\t\tassertEquals(\"void\", Unresolv"
  },
  {
    "method_id": "M4209",
    "name": "testGenerics",
    "return_type": "void",
    "signature": "testGenerics()",
    "file_id": "F168",
    "start_line": 130,
    "text_preview": " ConcreteClass extends AbstractTestClass<List<TestType>> {\\n\t}\\n\\n\tstatic class Bar extends ConcreteClass {}\\n\\n\tpublic void testGenerics() {\\n\t\tReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\\n//\t\tworld.lookupOrCreateName(UnresolvedType.forName(AbstractTestClass.class.getName()));\\n//\t\tResolvedType r"
  },
  {
    "method_id": "M4210",
    "name": "xtestTypeConversions_509327",
    "return_type": "void",
    "signature": "xtestTypeConversions_509327()",
    "file_id": "F168",
    "start_line": 138,
    "text_preview": "oResolvedTypeConverter(world);\\n\t\tResolvedType resolvedType2 = converter.fromType(ConcreteClass.class);\\n\t}\\n\\n\tpublic void xtestTypeConversions_509327() throws Exception {\\n\t\tReflectionWorld rWorld = new ReflectionWorld(getClass().getClassLoader());\\n\t\tJavaLangTypeToResolvedTypeConverter converter = new JavaLangTypeToResolv"
  },
  {
    "method_id": "M4211",
    "name": "m",
    "return_type": "String",
    "signature": "m()",
    "file_id": "F168",
    "start_line": 149,
    "text_preview": " = converter.fromType(stringType);\\n\t\tassertEquals(\"java.lang.String\",stringResolvedType.getName());\\n\\n\t\t// public String m() { return \"\"; }\\n\t\tmethod = TestClass2.class.getDeclaredMethod(\"m\");\\n\t\tstringType = method.getGenericReturnType();\\n\t\tassertEquals(\"java.lang.String\",stringType.getTypeName());\\n\t\tstringResolvedType ="
  },
  {
    "method_id": "M4212",
    "name": "m2",
    "return_type": "Inner",
    "signature": "m2()",
    "file_id": "F168",
    "start_line": 159,
    "text_preview": " same thing as the bcel unpacking\\n\\n\t\t// Here the return type is a non-static inner of a generic class\\n\t\t// public Inner m2() { return null; }\\n\t\tmethod = TestClass2.class.getDeclaredMethod(\"m2\");\\n\t\tType innerType = method.getGenericReturnType();\\n\t\tassertEquals(\"org.aspectj.weaver.reflect.ReflectionWorldTest.org.aspectj."
  },
  {
    "method_id": "M4213",
    "name": "xtestTypeConversions_509327_2",
    "return_type": "void",
    "signature": "xtestTypeConversions_509327_2()",
    "file_id": "F168",
    "start_line": 190,
    "text_preview": "),rType_Inner.getSignature());\\n\t\tassertEquals(bType_Outer.getSignature(),rType_Outer.getSignature());\\n\t}\\n\\n\\n\tpublic void xtestTypeConversions_509327_2() throws Exception {\\n\t\tReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\\n\t\tJavaLangTypeToResolvedTypeConverter converter = new JavaLangTypeToResol"
  },
  {
    "method_id": "M4214",
    "name": "m3",
    "return_type": "Inner",
    "signature": "m3()",
    "file_id": "F168",
    "start_line": 199,
    "text_preview": " now the method is returning a parameterized form of the outer\\n\t\t// generic class\\n\\n\t\t// public TestClass2<String>.Inner m3() { return new TestClass2<String>.Inner(\"Foo\"); }\\n\t\tMethod method = TestClass2.class.getDeclaredMethod(\"m3\");\\n\t\tType type_ParameterizedInner = method.getGenericReturnType();\\n\t\tassertEquals(\"org.asp"
  },
  {
    "method_id": "M4215",
    "name": "testbar",
    "return_type": "void",
    "signature": "testbar()",
    "file_id": "F168",
    "start_line": 227,
    "text_preview": "ystem.out.println(bField_f.getSignature());\\n//\t\tSystem.out.println(bField_f.getGenericReturnType());\\n\t}\\n\\n//\tpublic void testbar() throws Exception {\\n//\t\tReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\\n//\t\tJavaLangTypeToResolvedTypeConverter converter = new JavaLangTypeToResolvedTypeConverter(w"
  },
  {
    "method_id": "M4216",
    "name": "m3",
    "return_type": "Inner",
    "signature": "m3()",
    "file_id": "F168",
    "start_line": 199,
    "text_preview": " now the method is returning a parameterized form of the outer\\n\t\t// generic class\\n\\n\t\t// public TestClass2<String>.Inner m3() { return new TestClass2<String>.Inner(\"Foo\"); }\\n\t\tMethod method = TestClass2.class.getDeclaredMethod(\"m3\");\\n\t\tType type_ParameterizedInner = method.getGenericReturnType();\\n\t\tassertEquals(\"org.asp"
  },
  {
    "method_id": "M4217",
    "name": "testfoo",
    "return_type": "void",
    "signature": "testfoo()",
    "file_id": "F168",
    "start_line": 240,
    "text_preview": "rintln(rType_ParameterizedInner);\\n//\t\tSystem.out.println(type_ParameterizedInner.getTypeName());\\n//\t}\\n//\\n//\tpublic void testfoo() {\\n//\t\tReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());\\n//\t\tJavaLangTypeToResolvedTypeConverter converter = new JavaLangTypeToResolvedTypeConverter(world);\\n//\t\tBcelWo"
  },
  {
    "method_id": "M4218",
    "name": "m",
    "return_type": "String",
    "signature": "m()",
    "file_id": "F168",
    "start_line": 149,
    "text_preview": " = converter.fromType(stringType);\\n\t\tassertEquals(\"java.lang.String\",stringResolvedType.getName());\\n\\n\t\t// public String m() { return \"\"; }\\n\t\tmethod = TestClass2.class.getDeclaredMethod(\"m\");\\n\t\tstringType = method.getGenericReturnType();\\n\t\tassertEquals(\"java.lang.String\",stringType.getTypeName());\\n\t\tstringResolvedType ="
  },
  {
    "method_id": "M4219",
    "name": "Inner",
    "return_type": "",
    "signature": "Inner(T t)",
    "file_id": "F168",
    "start_line": 199,
    "text_preview": "terized form of the outer\\n\t\t// generic class\\n\\n\t\t// public TestClass2<String>.Inner m3() { return new TestClass2<String>.Inner(\"Foo\"); }\\n\t\tMethod method = TestClass2.class.getDeclaredMethod(\"m3\");\\n\t\tType type_ParameterizedInner = method.getGenericReturnType();\\n\t\tassertEquals(\"org.aspectj.weaver.reflect.ReflectionWorldTe"
  },
  {
    "method_id": "M4220",
    "name": "m",
    "return_type": "String",
    "signature": "m()",
    "file_id": "F168",
    "start_line": 149,
    "text_preview": " = converter.fromType(stringType);\\n\t\tassertEquals(\"java.lang.String\",stringResolvedType.getName());\\n\\n\t\t// public String m() { return \"\"; }\\n\t\tmethod = TestClass2.class.getDeclaredMethod(\"m\");\\n\t\tstringType = method.getGenericReturnType();\\n\t\tassertEquals(\"java.lang.String\",stringType.getTypeName());\\n\t\tstringResolvedType ="
  },
  {
    "method_id": "M4221",
    "name": "m2",
    "return_type": "Inner",
    "signature": "m2()",
    "file_id": "F168",
    "start_line": 159,
    "text_preview": " same thing as the bcel unpacking\\n\\n\t\t// Here the return type is a non-static inner of a generic class\\n\t\t// public Inner m2() { return null; }\\n\t\tmethod = TestClass2.class.getDeclaredMethod(\"m2\");\\n\t\tType innerType = method.getGenericReturnType();\\n\t\tassertEquals(\"org.aspectj.weaver.reflect.ReflectionWorldTest.org.aspectj."
  },
  {
    "method_id": "M4222",
    "name": "m3",
    "return_type": "Inner",
    "signature": "m3()",
    "file_id": "F168",
    "start_line": 199,
    "text_preview": " now the method is returning a parameterized form of the outer\\n\t\t// generic class\\n\\n\t\t// public TestClass2<String>.Inner m3() { return new TestClass2<String>.Inner(\"Foo\"); }\\n\t\tMethod method = TestClass2.class.getDeclaredMethod(\"m3\");\\n\t\tType type_ParameterizedInner = method.getGenericReturnType();\\n\t\tassertEquals(\"org.asp"
  },
  {
    "method_id": "M4223",
    "name": "findMethod",
    "return_type": "ResolvedMember",
    "signature": "findMethod(ResolvedType resolvedType, String methodName)",
    "file_id": "F168",
    "start_line": 178,
    "text_preview": "resolvedType.forName(TestClass2.class.getName()));\\n\t\tassertNotNull(bResolved_TestClass2);\\n\t\tResolvedMember bMethod_m2 = findMethod(bResolved_TestClass2,\"m2\");\\n\t\tResolvedType bType_Inner = (ResolvedType) bMethod_m2.getReturnType();\\n\t\tassertEquals(\"Lorg/aspectj/weaver/reflect/ReflectionWorldTest$TestClass2$Inner;\",bType_"
  },
  {
    "method_id": "M4224",
    "name": "findField",
    "return_type": "ResolvedMember",
    "signature": "findField(ResolvedType resolvedType, String fieldName)",
    "file_id": "F168",
    "start_line": 218,
    "text_preview": "Class();\\n\\n\t\t// Fields seem to lose it too, although the backinggenericmember has the info\\n//\t\tResolvedMember bField_f = findField(bResolved_TestClass2,\"f\");\\n//\t\tResolvedMember backingGenericMember = bField_f.getBackingGenericMember();\\n//\t\tSystem.out.println(backingGenericMember);\\n//\t\tSystem.out.println(backingGenericMe"
  },
  {
    "method_id": "M4225",
    "name": "suite",
    "return_type": "Test",
    "signature": "suite()",
    "file_id": "F169",
    "start_line": 53,
    "text_preview": "parameter annotation matching.\\n *\\n */\\npublic class Java15PointcutExpressionTest extends TestCase {\\n\\n\tpublic static Test suite() {\\n\t\tTestSuite suite = new TestSuite(\"Java15PointcutExpressionTest\");\\n\t\tsuite.addTestSuite(Java15PointcutExpressionTest.class);\\n\t\treturn suite;\\n\t}\\n\\n\tprivate PointcutParser parser;\\n\tprivate Meth"
  },
  {
    "method_id": "M4226",
    "name": "testParseParameterAnnotationExpressions",
    "return_type": "void",
    "signature": "testParseParameterAnnotationExpressions()",
    "file_id": "F169",
    "start_line": 69,
    "text_preview": "ter annotations and parameter type annotations correctly.\\n\t * Buckle up, this will get complicated ;)\\n\t */\\n\tpublic void testParseParameterAnnotationExpressions() {\\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());\\n\t\tP"
  },
  {
    "method_id": "M4227",
    "name": "testMatchingAnnotationValueExpressions",
    "return_type": "void",
    "signature": "testMatchingAnnotationValueExpressions()",
    "file_id": "F169",
    "start_line": 101,
    "text_preview": "s(pexpr,1,null,\"@MC\",\"exact[@MC:t]\");\\n\t\tcheckParameterAnnotations(pexpr,2,\"@MD\",null,\"exact[@MD:p]\");\\n\\n\t}\\n\\n\tpublic void testMatchingAnnotationValueExpressions() throws SecurityException, NoSuchMethodException {\\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForRe"
  },
  {
    "method_id": "M4228",
    "name": "testPerformanceOfPointcutParsing",
    "return_type": "void",
    "signature": "testPerformanceOfPointcutParsing()",
    "file_id": "F169",
    "start_line": 157,
    "text_preview": "VES.add(PointcutPrimitive.AT_ARGS);\\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_TARGET);\\n\t }\\n\\n\tpublic void testPerformanceOfPointcutParsing() {\\n\t\tString expression = \"execution(public * rewards.internal.*.*Repository+.*(..))\";\\n\t\tlong stime1 = System.currentTimeMillis();\\n\t\tPointcutParser parser = PointcutPa"
  },
  {
    "method_id": "M4229",
    "name": "testPerformanceOfPointcutParsingWithBean",
    "return_type": "void",
    "signature": "testPerformanceOfPointcutParsingWithBean()",
    "file_id": "F169",
    "start_line": 169,
    "text_preview": "stime2-stime1)+\"ms\");\\n\t\tSystem.out.println(\"Time taken to parse expression is \"+(etime-stime2)+\"ms\");\\n\t}\\n\\n\\n\tpublic void testPerformanceOfPointcutParsingWithBean() {\\n\t\tString expression = \"execution(public * rewards.internal.*.*Repository+.*(..))\";\\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingAllP"
  },
  {
    "method_id": "M4230",
    "name": "getDesignatorName",
    "return_type": "String",
    "signature": "getDesignatorName()",
    "file_id": "F169",
    "start_line": 185,
    "text_preview": "ntcutDesignatorHandler {\\n\\n\t\tprivate String askedToParse;\\n\t\tpublic boolean simulateDynamicTest = false;\\n\\n\t\tpublic String getDesignatorName() {\\n\t\t\treturn \"bean\";\\n\t\t}\\n\\n\t\t/* (non-Javadoc)\\n\t\t * @see org.aspectj.weaver.tools.PointcutDesignatorHandler#parse(java.lang.String)\\n\t\t */\\n\t\tpublic ContextBasedMatcher parse(String exp"
  },
  {
    "method_id": "M4231",
    "name": "parse",
    "return_type": "ContextBasedMatcher",
    "signature": "parse(String expression)",
    "file_id": "F169",
    "start_line": 190,
    "text_preview": "signatorName() {\\n\t\t\treturn \"bean\";\\n\t\t}\\n\\n\t\t/* (non-Javadoc)\\n\t\t * @see org.aspectj.weaver.tools.PointcutDesignatorHandler#parse(java.lang.String)\\n\t\t */\\n\t\tpublic ContextBasedMatcher parse(String expression) {\\n\t\t\tthis.askedToParse = expression;\\n\t\t\treturn null;\\n//\t\t\treturn new BeanPointcutExpression(expression,this.simulate"
  },
  {
    "method_id": "M4232",
    "name": "getExpressionLastAskedToParse",
    "return_type": "String",
    "signature": "getExpressionLastAskedToParse()",
    "file_id": "F169",
    "start_line": 198,
    "text_preview": "sion;\\n\t\t\treturn null;\\n//\t\t\treturn new BeanPointcutExpression(expression,this.simulateDynamicTest);\\n\t\t}\\n\\n\t\tpublic String getExpressionLastAskedToParse() {\\n\t\t\treturn this.askedToParse;\\n\t\t}\\n\t}\\n\\n\\n\t/**\\n\t * Test matching of pointcuts against expressions.  A reflection world is being used on the backend here (not a Bcel one)."
  },
  {
    "method_id": "M4233",
    "name": "testMatchingParameterAnnotationExpressions",
    "return_type": "void",
    "signature": "testMatchingParameterAnnotationExpressions()",
    "file_id": "F169",
    "start_line": 207,
    "text_preview": "ointcuts against expressions.  A reflection world is being used on the backend here (not a Bcel one).\\n\t */\\n\tpublic void testMatchingParameterAnnotationExpressions() throws SecurityException, NoSuchMethodException {\\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderF"
  },
  {
    "method_id": "M4234",
    "name": "a",
    "return_type": "void",
    "signature": "a(String s)",
    "file_id": "F169",
    "start_line": 212,
    "text_preview": "dowMatch match = null;\\n\\n\t\tMethod a = test.A.class.getMethod(\"a\",new Class[] {String.class});             // public void a(String s) {}\\n\t\tMethod b = test.A.class.getMethod(\"b\",new Class[] {String.class});             // public void b(@A1 String s) {}\\n\t\tMethod c = test.A.class.getMethod(\"c\",new Class[] {String.class});  "
  },
  {
    "method_id": "M4235",
    "name": "b",
    "return_type": "void",
    "signature": "b(@A1 String s)",
    "file_id": "F169",
    "start_line": 213,
    "text_preview": "lic void a(String s) {}\\n\t\tMethod b = test.A.class.getMethod(\"b\",new Class[] {String.class});             // public void b(@A1 String s) {}\\n\t\tMethod c = test.A.class.getMethod(\"c\",new Class[] {String.class});             // public void c(@A1 @A2 String s) {}\\n//\t\tMethod d = test.A.class.getMethod(\"d\",new Class[] {String."
  },
  {
    "method_id": "M4236",
    "name": "c",
    "return_type": "void",
    "signature": "c(@A1 @A2 String s)",
    "file_id": "F169",
    "start_line": 214,
    "text_preview": "void b(@A1 String s) {}\\n\t\tMethod c = test.A.class.getMethod(\"c\",new Class[] {String.class});             // public void c(@A1 @A2 String s) {}\\n//\t\tMethod d = test.A.class.getMethod(\"d\",new Class[] {String.class,String.class});// public void d(@A1 String s,@A2 String t) {}\\n\\n\t\tMethod e = test.A.class.getMethod(\"e\",new Cl"
  },
  {
    "method_id": "M4237",
    "name": "d",
    "return_type": "void",
    "signature": "d(@A1 String s,@A2 String t)",
    "file_id": "F169",
    "start_line": 106,
    "text_preview": "ssLoader());\\n\t\tPointcutExpression pexpr = null;\\n\t\tShadowMatch match = null;\\n\\n\t\tMethod n = test.AnnoValues.class.getMethod(\"none\");\\n\t\tMethod r = test.AnnoValues.class.getMethod(\"redMethod\");\\n\t\tMethod g = test.AnnoValues.class.getMethod(\"greenMethod\");\\n\t\tMethod b = test.AnnoValues.class.getMethod(\"blueMethod\");\\n\t\tMethod "
  },
  {
    "method_id": "M4238",
    "name": "e",
    "return_type": "void",
    "signature": "e(A1AnnotatedType s)",
    "file_id": "F169",
    "start_line": 53,
    "text_preview": "meter annotation matching.\\n *\\n */\\npublic class Java15PointcutExpressionTest extends TestCase {\\n\\n\tpublic static Test suite() {\\n\t\tTestSuite suite = new TestSuite(\"Java15PointcutExpressionTest\");\\n\t\tsuite.addTestSuite(Java15PointcutExpressionTest.class);\\n\t\treturn suite;\\n\t}\\n\\n\tprivate PointcutParser parser;\\n\tprivate Method a"
  },
  {
    "method_id": "M4239",
    "name": "f",
    "return_type": "void",
    "signature": "f(A2AnnotatedType s)",
    "file_id": "F169",
    "start_line": 218,
    "text_preview": "e(A1AnnotatedType s) {}\\n\t\tMethod f = test.A.class.getMethod(\"f\",new Class[] {A2AnnotatedType.class});    // public void f(A2AnnotatedType s) {}\\n\t\tMethod g = test.A.class.getMethod(\"g\",new Class[] {A1AnnotatedType.class});    // public void g(@A2 A1AnnotatedType s) {}\\n\t\tMethod h = test.A.class.getMethod(\"h\",new Class[] "
  },
  {
    "method_id": "M4240",
    "name": "g",
    "return_type": "void",
    "signature": "g(@A2 A1AnnotatedType s)",
    "file_id": "F169",
    "start_line": 157,
    "text_preview": "GS);\\n\t  DEFAULT_SUPPORTED_PRIMITIVES.add(PointcutPrimitive.AT_TARGET);\\n\t }\\n\\n\tpublic void testPerformanceOfPointcutParsing() {\\n\t\tString expression = \"execution(public * rewards.internal.*.*Repository+.*(..))\";\\n\t\tlong stime1 = System.currentTimeMillis();\\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportin"
  },
  {
    "method_id": "M4241",
    "name": "h",
    "return_type": "void",
    "signature": "h(@A1 A1AnnotatedType s)",
    "file_id": "F169",
    "start_line": 220,
    "text_preview": "2 A1AnnotatedType s) {}\\n\t\tMethod h = test.A.class.getMethod(\"h\",new Class[] {A1AnnotatedType.class});    // public void h(@A1 A1AnnotatedType s) {}\\n//\t\tMethod i = test.A.class.getMethod(\"i\",new Class[] {A1AnnotatedType.class,String.class});    // public void i(A1AnnotatedType s,@A2 String t) {}\\n//\t\tMethod j = test.A.cl"
  },
  {
    "method_id": "M4242",
    "name": "i",
    "return_type": "void",
    "signature": "i(A1AnnotatedType s,@A2 String t)",
    "file_id": "F169",
    "start_line": 221,
    "text_preview": "pe s) {}\\n//\t\tMethod i = test.A.class.getMethod(\"i\",new Class[] {A1AnnotatedType.class,String.class});    // public void i(A1AnnotatedType s,@A2 String t) {}\\n//\t\tMethod j = test.A.class.getMethod(\"j\",new Class[] {String.class});             // public void j(@A1 @A2 String s) {}\\n\\n\t\tpexpr = p.parsePointcutExpression(\"exec"
  },
  {
    "method_id": "M4243",
    "name": "j",
    "return_type": "void",
    "signature": "j(@A1 @A2 String s)",
    "file_id": "F169",
    "start_line": 222,
    "text_preview": "pe s,@A2 String t) {}\\n//\t\tMethod j = test.A.class.getMethod(\"j\",new Class[] {String.class});             // public void j(@A1 @A2 String s) {}\\n\\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void *(@test.A1 *))\");\\n\t\tassertTrue(\"Should not match\", pexpr.matchesMethodExecution(a).neverMatches());\\n\t\tassertTrue(\"Sho"
  },
  {
    "method_id": "M4244",
    "name": "checkParameterAnnotations",
    "return_type": "void",
    "signature": "checkParameterAnnotations(PointcutExpression pe,int parameterNumber,String expectedParameterAnnotations,String expectedParameterTypeAnnotations,String expectedNodeStructure)",
    "file_id": "F169",
    "start_line": 74,
    "text_preview": "der());\\n\t\tPointcutExpression pexpr = null;\\n\\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA *))\");\\n\t\tcheckParameterAnnotations(pexpr,0,null,\"@MA\",\"exact[@MA:t]\");\\n\\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA (*)))\");\\n\t\tcheckParameterAnnotations(pexpr,0,\"@MA\",null,\"exact[@MA:p]\""
  },
  {
    "method_id": "M4245",
    "name": "if",
    "return_type": "",
    "signature": "if(expectedNodeStructure==null)",
    "file_id": "F169",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4246",
    "name": "for",
    "return_type": "",
    "signature": "for(String string : expected)",
    "file_id": "F169",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4247",
    "name": "for",
    "return_type": "",
    "signature": "for(String string : expected)",
    "file_id": "F169",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4248",
    "name": "getStringRepresentation",
    "return_type": "String",
    "signature": "getStringRepresentation()",
    "file_id": "F169",
    "start_line": 278,
    "text_preview": ",null);\\n\\n\t  if (expectedNodeStructure==null) {\\n\t\t  // The caller hasn't worked it out yet!!\\n\t\t  System.out.println(mpnv.getStringRepresentation());\\n\t  } else if (!mpnv.getStringRepresentation().equals(expectedNodeStructure)) {\\n\t\t  System.out.println(mpnv.getStringRepresentation());\\n\t\t  fail(\"Expected annotation pattern"
  },
  {
    "method_id": "M4249",
    "name": "getParameterAnnotations",
    "return_type": "List<String>",
    "signature": "getParameterAnnotations()",
    "file_id": "F169",
    "start_line": 306,
    "text_preview": " type annotations \"+excessTokens.toString());\\n\t  }\\n\\n\t  // parameter annotation checking\\n\t\texpected = new HashSet<>(mpnv.getParameterAnnotations());\\n\\n\t  st = new StringTokenizer(expectedParameterAnnotations==null?\"\":expectedParameterAnnotations);\\n\t  while (st.hasMoreTokens()) {\\n\t\t  String nextToken = st.nextToken();\\n\t\t "
  },
  {
    "method_id": "M4250",
    "name": "getParameterTypeAnnotations",
    "return_type": "List<String>",
    "signature": "getParameterTypeAnnotations()",
    "file_id": "F169",
    "start_line": 288,
    "text_preview": "etAnnotationPattern().toString();\\n\\n\t  // parameter type annotation checking\\n\t\tSet<String> expected = new HashSet<>(mpnv.getParameterTypeAnnotations());\\n\\n\t  StringTokenizer st = new StringTokenizer(expectedParameterTypeAnnotations==null?\"\":expectedParameterTypeAnnotations);\\n\t  while (st.hasMoreTokens()) {\\n\t\t  String nex"
  },
  {
    "method_id": "M4251",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(AndAnnotationTypePattern node, Object data)",
    "file_id": "F169",
    "start_line": 334,
    "text_preview": "nnotations; }\\n\t\tpublic List<String> getParameterTypeAnnotations() { return parameterTypeAnnotations; }\\n\\n\t\tpublic Object visit(AndAnnotationTypePattern node, Object data) {\\n\t\t\tstringRep.append(\"(\");\\n\t\t\tnode.getLeft().accept(this, data);\\n\t\t\tstringRep.append(\" and \");\\n\t\t\tnode.getRight().accept(this, data);\\n\t\t\tstringRep.ap"
  },
  {
    "method_id": "M4252",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(AnyAnnotationTypePattern node, Object data)",
    "file_id": "F169",
    "start_line": 334,
    "text_preview": "nnotations; }\\n\t\tpublic List<String> getParameterTypeAnnotations() { return parameterTypeAnnotations; }\\n\\n\t\tpublic Object visit(AndAnnotationTypePattern node, Object data) {\\n\t\t\tstringRep.append(\"(\");\\n\t\t\tnode.getLeft().accept(this, data);\\n\t\t\tstringRep.append(\" and \");\\n\t\t\tnode.getRight().accept(this, data);\\n\t\t\tstringRep.ap"
  },
  {
    "method_id": "M4253",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(ExactAnnotationTypePattern node, Object data)",
    "file_id": "F169",
    "start_line": 334,
    "text_preview": "nnotations; }\\n\t\tpublic List<String> getParameterTypeAnnotations() { return parameterTypeAnnotations; }\\n\\n\t\tpublic Object visit(AndAnnotationTypePattern node, Object data) {\\n\t\t\tstringRep.append(\"(\");\\n\t\t\tnode.getLeft().accept(this, data);\\n\t\t\tstringRep.append(\" and \");\\n\t\t\tnode.getRight().accept(this, data);\\n\t\t\tstringRep.ap"
  },
  {
    "method_id": "M4254",
    "name": "stringify",
    "return_type": "String",
    "signature": "stringify(ResolvedType resolvedAnnotationType)",
    "file_id": "F169",
    "start_line": 347,
    "text_preview": "n node;\\n\t    }\\n\t    public Object visit(ExactAnnotationTypePattern node, Object data) {\\n\t    \tstringRep.append(\"exact[\"+stringify(node.getResolvedAnnotationType())+\":\"+(node.isForParameterAnnotationMatch()?\"p\":\"t\")+\"]\");\\n\t    \tif (node.isForParameterAnnotationMatch()) {\\n\t    \t\tparameterAnnotations.add(stringify(node.ge"
  },
  {
    "method_id": "M4255",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(BindingAnnotationTypePattern node, Object data)",
    "file_id": "F169",
    "start_line": 334,
    "text_preview": "nnotations; }\\n\t\tpublic List<String> getParameterTypeAnnotations() { return parameterTypeAnnotations; }\\n\\n\t\tpublic Object visit(AndAnnotationTypePattern node, Object data) {\\n\t\t\tstringRep.append(\"(\");\\n\t\t\tnode.getLeft().accept(this, data);\\n\t\t\tstringRep.append(\" and \");\\n\t\t\tnode.getRight().accept(this, data);\\n\t\t\tstringRep.ap"
  },
  {
    "method_id": "M4256",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(NotAnnotationTypePattern node, Object data)",
    "file_id": "F169",
    "start_line": 334,
    "text_preview": "nnotations; }\\n\t\tpublic List<String> getParameterTypeAnnotations() { return parameterTypeAnnotations; }\\n\\n\t\tpublic Object visit(AndAnnotationTypePattern node, Object data) {\\n\t\t\tstringRep.append(\"(\");\\n\t\t\tnode.getLeft().accept(this, data);\\n\t\t\tstringRep.append(\" and \");\\n\t\t\tnode.getRight().accept(this, data);\\n\t\t\tstringRep.ap"
  },
  {
    "method_id": "M4257",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(OrAnnotationTypePattern node, Object data)",
    "file_id": "F169",
    "start_line": 334,
    "text_preview": "nnotations; }\\n\t\tpublic List<String> getParameterTypeAnnotations() { return parameterTypeAnnotations; }\\n\\n\t\tpublic Object visit(AndAnnotationTypePattern node, Object data) {\\n\t\t\tstringRep.append(\"(\");\\n\t\t\tnode.getLeft().accept(this, data);\\n\t\t\tstringRep.append(\" and \");\\n\t\t\tnode.getRight().accept(this, data);\\n\t\t\tstringRep.ap"
  },
  {
    "method_id": "M4258",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(WildAnnotationTypePattern node, Object data)",
    "file_id": "F169",
    "start_line": 334,
    "text_preview": "nnotations; }\\n\t\tpublic List<String> getParameterTypeAnnotations() { return parameterTypeAnnotations; }\\n\\n\t\tpublic Object visit(AndAnnotationTypePattern node, Object data) {\\n\t\t\tstringRep.append(\"(\");\\n\t\t\tnode.getLeft().accept(this, data);\\n\t\t\tstringRep.append(\" and \");\\n\t\t\tnode.getRight().accept(this, data);\\n\t\t\tstringRep.ap"
  },
  {
    "method_id": "M4259",
    "name": "visit",
    "return_type": "Object",
    "signature": "visit(AnnotationPatternList node, Object data)",
    "file_id": "F169",
    "start_line": 334,
    "text_preview": "nnotations; }\\n\t\tpublic List<String> getParameterTypeAnnotations() { return parameterTypeAnnotations; }\\n\\n\t\tpublic Object visit(AndAnnotationTypePattern node, Object data) {\\n\t\t\tstringRep.append(\"(\");\\n\t\t\tnode.getLeft().accept(this, data);\\n\t\t\tstringRep.append(\" and \");\\n\t\t\tnode.getRight().accept(this, data);\\n\t\t\tstringRep.ap"
  },
  {
    "method_id": "M4260",
    "name": "testAtThis",
    "return_type": "void",
    "signature": "testAtThis()",
    "file_id": "F169",
    "start_line": 393,
    "text_preview": "it(AnnotationPatternList node, Object data) {\\n\t\t\tstringRep.append(\"list\");\\n\\n\t\t\treturn node;\\n\t    }\\n\\n\\n\t}\\n\\n\\n\\n\tpublic void testAtThis() {\\n\t\tPointcutExpression atThis = parser.parsePointcutExpression(\"@this(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\\n\t\tShadowMatch sMatch1 = atThis.matchesMethodEx"
  },
  {
    "method_id": "M4261",
    "name": "testAtTarget",
    "return_type": "void",
    "signature": "testAtTarget()",
    "file_id": "F169",
    "start_line": 405,
    "text_preview": "p2 = sMatch2.matchesJoinPoint(new B(), new B(), new Object[0]);\\n\t\tassertTrue(\"matches\",jp2.matches());\\n\t}\\n\\n\tpublic void testAtTarget() {\\n\t\tPointcutExpression atTarget = parser.parsePointcutExpression(\"@target(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\\n\t\tShadowMatch sMatch1 = atTarget.matches"
  },
  {
    "method_id": "M4262",
    "name": "testAtThisWithBinding",
    "return_type": "void",
    "signature": "testAtThisWithBinding()",
    "file_id": "F169",
    "start_line": 417,
    "text_preview": "p2 = sMatch2.matchesJoinPoint(new B(), new B(), new Object[0]);\\n\t\tassertTrue(\"matches\",jp2.matches());\\n\t}\\n\\n\tpublic void testAtThisWithBinding() {\\n\t\tPointcutParameter param = parser.createPointcutParameter(\"a\",MyAnnotation.class);\\n\t\tB myB = new B();\\n\t\tMyAnnotation bAnnotation = B.class.getAnnotation(MyAnnotation.class);"
  },
  {
    "method_id": "M4263",
    "name": "testAtTargetWithBinding",
    "return_type": "void",
    "signature": "testAtTargetWithBinding()",
    "file_id": "F169",
    "start_line": 434,
    "text_preview": ";\\n\t\tassertEquals(\"should be myB's annotation\",bAnnotation,jp2.getParameterBindings()[0].getBinding());\\n\t}\\n\\n\tpublic void testAtTargetWithBinding() {\\n\t\tPointcutParameter param = parser.createPointcutParameter(\"a\",MyAnnotation.class);\\n\t\tB myB = new B();\\n\t\tMyAnnotation bAnnotation = B.class.getAnnotation(MyAnnotation.class"
  },
  {
    "method_id": "M4264",
    "name": "testAtArgs",
    "return_type": "void",
    "signature": "testAtArgs()",
    "file_id": "F169",
    "start_line": 451,
    "text_preview": ";\\n\t\tassertEquals(\"should be myB's annotation\",bAnnotation,jp2.getParameterBindings()[0].getBinding());\\n\t}\\n\\n\tpublic void testAtArgs() {\\n\t\tPointcutExpression atArgs = parser.parsePointcutExpression(\"@args(..,org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\\n\t\tShadowMatch sMatch1 = atArgs.matchesMetho"
  },
  {
    "method_id": "M4265",
    "name": "testAtArgs2",
    "return_type": "void",
    "signature": "testAtArgs2()",
    "file_id": "F169",
    "start_line": 471,
    "text_preview": "hesJoinPoint(new B(), new B(), new Object[] {new B(),new B()});\\n\t\tassertTrue(\"matches\",jp2.matches());\\n\t}\\n\\n\tpublic void testAtArgs2() {\\n\t\tPointcutExpression atArgs = parser.parsePointcutExpression(\"@args(*, org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\\n\t\tShadowMatch sMatch1 = atArgs.matchesMeth"
  },
  {
    "method_id": "M4266",
    "name": "testAtArgsWithBinding",
    "return_type": "void",
    "signature": "testAtArgsWithBinding()",
    "file_id": "F169",
    "start_line": 483,
    "text_preview": "oint(new B(), new B(), new Object[] {new A(),new A()});\\n\t\tassertFalse(\"does not match\",jp2.matches());\\n\t}\\n\\n\tpublic void testAtArgsWithBinding() {\\n\t\tPointcutParameter p1 = parser.createPointcutParameter(\"a\",MyAnnotation.class);\\n\t\tPointcutParameter p2 = parser.createPointcutParameter(\"b\", MyAnnotation.class);\\n\t\tPointcutE"
  },
  {
    "method_id": "M4267",
    "name": "testAtWithin",
    "return_type": "void",
    "signature": "testAtWithin()",
    "file_id": "F169",
    "start_line": 505,
    "text_preview": "tBinding());\\n\t\tassertEquals(\"annotation on B\",bAnnotation,jp2.getParameterBindings()[1].getBinding());\\n\t}\\n\\n\tpublic void testAtWithin() {\\n\t\tPointcutExpression atWithin = parser.parsePointcutExpression(\"@within(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\\n\t\tShadowMatch sMatch1 = atWithin.matches"
  },
  {
    "method_id": "M4268",
    "name": "testAtWithinWithBinding",
    "return_type": "void",
    "signature": "testAtWithinWithBinding()",
    "file_id": "F169",
    "start_line": 513,
    "text_preview": "ertTrue(\"does not match a\",sMatch1.neverMatches());\\n\t\tassertTrue(\"matches b\",sMatch2.alwaysMatches());\\n\t}\\n\\n\tpublic void testAtWithinWithBinding() {\\n\t\tPointcutParameter p1 = parser.createPointcutParameter(\"x\",MyAnnotation.class);\\n\t\tPointcutExpression atWithin = parser.parsePointcutExpression(\"@within(x)\",B.class,new Poi"
  },
  {
    "method_id": "M4269",
    "name": "testAtWithinCode",
    "return_type": "void",
    "signature": "testAtWithinCode()",
    "file_id": "F169",
    "start_line": 527,
    "text_preview": "tion.class);\\n\t\tassertEquals(\"annotation on B\",bAnnotation,jpm.getParameterBindings()[0].getBinding());\\n\t}\\n\\n\tpublic void testAtWithinCode() {\\n\t\tPointcutExpression atWithinCode = parser.parsePointcutExpression(\"@withincode(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\\n\t\tShadowMatch sMatch1 = atWi"
  },
  {
    "method_id": "M4270",
    "name": "testAtWithinCodeWithBinding",
    "return_type": "void",
    "signature": "testAtWithinCodeWithBinding()",
    "file_id": "F169",
    "start_line": 535,
    "text_preview": "oes not match from b\",sMatch1.neverMatches());\\n\t\tassertTrue(\"matches from a\",sMatch2.alwaysMatches());\\n\t}\\n\\n\tpublic void testAtWithinCodeWithBinding() {\\n\t\tPointcutParameter p1 = parser.createPointcutParameter(\"x\",MyAnnotation.class);\\n\t\tPointcutExpression atWithinCode = parser.parsePointcutExpression(\"@withincode(x)\",A.c"
  },
  {
    "method_id": "M4271",
    "name": "testAtAnnotation",
    "return_type": "void",
    "signature": "testAtAnnotation()",
    "file_id": "F169",
    "start_line": 546,
    "text_preview": "otation.class);\\n\t\tassertEquals(\"MyAnnotation on a\",annOna,jpm.getParameterBindings()[0].getBinding());\\n\t}\\n\\n\tpublic void testAtAnnotation() {\\n\t\tPointcutExpression atAnnotation = parser.parsePointcutExpression(\"@annotation(org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation)\");\\n\t\tShadowMatch sMatch1 = atAn"
  },
  {
    "method_id": "M4272",
    "name": "testAtAnnotationWithBinding",
    "return_type": "void",
    "signature": "testAtAnnotationWithBinding()",
    "file_id": "F169",
    "start_line": 554,
    "text_preview": "t match call to b\",sMatch1.neverMatches());\\n\t\tassertTrue(\"matches call to a\",sMatch2.alwaysMatches());\\n\t}\\n\\n\tpublic void testAtAnnotationWithBinding() {\\n\t\tPointcutParameter p1 = parser.createPointcutParameter(\"x\",MyAnnotation.class);\\n\t\tPointcutExpression atAnnotation = parser.parsePointcutExpression(\"@annotation(x)\",A.c"
  },
  {
    "method_id": "M4273",
    "name": "testReferencePointcutNoParams",
    "return_type": "void",
    "signature": "testReferencePointcutNoParams()",
    "file_id": "F169",
    "start_line": 566,
    "text_preview": "otation.class);\\n\t\tassertEquals(\"MyAnnotation on a\",annOna,jpm.getParameterBindings()[0].getBinding());\\n\t}\\n\\n\tpublic void testReferencePointcutNoParams() {\\n\t\tPointcutExpression pc = parser.parsePointcutExpression(\"foo()\",C.class,new PointcutParameter[0]);\\n\t\tShadowMatch sMatch1 = pc.matchesMethodCall(a,b);\\n\t\tShadowMatch s"
  },
  {
    "method_id": "M4274",
    "name": "testReferencePointcutParams",
    "return_type": "void",
    "signature": "testReferencePointcutParams()",
    "file_id": "F169",
    "start_line": 580,
    "text_preview": "no match on call\",sMatch1.neverMatches());\\n\t\tassertTrue(\"match on execution\",sMatch2.alwaysMatches());\\n\t}\\n\\n\tpublic void testReferencePointcutParams() {\\n\t\tPointcutParameter p1 = parser.createPointcutParameter(\"x\",A.class);\\n\t\tPointcutExpression pc = parser.parsePointcutExpression(\"goo(x)\",C.class,new PointcutParameter[] "
  },
  {
    "method_id": "M4275",
    "name": "testExecutionWithClassFileRetentionAnnotation",
    "return_type": "void",
    "signature": "testExecutionWithClassFileRetentionAnnotation()",
    "file_id": "F169",
    "start_line": 595,
    "text_preview": ".matches());\\n\t\tassertEquals(\"should be bound to anA\",anA,jpm.getParameterBindings()[0].getBinding());\\n\\n\t}\\n\\n\tpublic void testExecutionWithClassFileRetentionAnnotation() {\\n\t\tPointcutExpression pc1 = parser.parsePointcutExpression(\"execution(@org.aspectj.weaver.tools.Java15PointcutExpressionTest.MyAnnotation * *(..))\");\\n\t"
  },
  {
    "method_id": "M4276",
    "name": "testGenericMethodSignatures",
    "return_type": "void",
    "signature": "testGenericMethodSignatures()",
    "file_id": "F169",
    "start_line": 608,
    "text_preview": "rMatches());\\n\t\tsMatch = pc2.matchesMethodExecution(b);\\n\t\tassertTrue(\"matches\",sMatch.alwaysMatches());\\n\t}\\n\\n\tpublic void testGenericMethodSignatures() throws Exception{\\n\t\tPointcutExpression ex = parser.parsePointcutExpression(\"execution(* set*(java.util.List<org.aspectj.weaver.tools.Java15PointcutExpressionTest.C>))\");\\n"
  },
  {
    "method_id": "M4277",
    "name": "testAnnotationInExecution",
    "return_type": "void",
    "signature": "testAnnotationInExecution()",
    "file_id": "F169",
    "start_line": 615,
    "text_preview": "ss);\\n\t\tShadowMatch sm = ex.matchesMethodExecution(m);\\n\t\tassertTrue(\"should match\",sm.alwaysMatches());\\n\t}\\n\\n\tpublic void testAnnotationInExecution() throws Exception {\\n\t\tparser.parsePointcutExpression(\"execution(@(org.springframework..*) * *(..))\");\\n\t}\\n\\n\tpublic void testVarArgsMatching() throws Exception {\\n\t\tPointcutExp"
  },
  {
    "method_id": "M4278",
    "name": "testVarArgsMatching",
    "return_type": "void",
    "signature": "testVarArgsMatching()",
    "file_id": "F169",
    "start_line": 619,
    "text_preview": ") throws Exception {\\n\t\tparser.parsePointcutExpression(\"execution(@(org.springframework..*) * *(..))\");\\n\t}\\n\\n\tpublic void testVarArgsMatching() throws Exception {\\n\t\tPointcutExpression ex = parser.parsePointcutExpression(\"execution(* *(String...))\");\\n\t\tMethod usesVarArgs = D.class.getMethod(\"varArgs\",String[].class);\\n\t\tMe"
  },
  {
    "method_id": "M4279",
    "name": "testJavaLangMatching",
    "return_type": "void",
    "signature": "testJavaLangMatching()",
    "file_id": "F169",
    "start_line": 629,
    "text_preview": "tch sm2 = ex.matchesMethodExecution(noVarArgs);\\n\t\tassertFalse(\"should not match\",sm2.alwaysMatches());\\n\t}\\n\\n\tpublic void testJavaLangMatching() throws Exception {\\n\t\tPointcutExpression ex = parser.parsePointcutExpression(\"@within(java.lang.Deprecated)\");\\n\t\tMethod foo = GoldenOldie.class.getMethod(\"foo\");\\n\t\tShadowMatch sm"
  },
  {
    "method_id": "M4280",
    "name": "testReferencePCsInSameType",
    "return_type": "void",
    "signature": "testReferencePCsInSameType()",
    "file_id": "F169",
    "start_line": 636,
    "text_preview": "\\n\t\tShadowMatch sm1 = ex.matchesMethodExecution(foo);\\n\t\tassertTrue(\"should match\",sm1.alwaysMatches());\\n\t}\\n\\n\tpublic void testReferencePCsInSameType() throws Exception {\\n\t\tPointcutExpression ex = parser.parsePointcutExpression(\"org.aspectj.weaver.tools.Java15PointcutExpressionTest.NamedPointcutResolution.c()\",NamedPointc"
  },
  {
    "method_id": "M4281",
    "name": "testReferencePCsInOtherType",
    "return_type": "void",
    "signature": "testReferencePCsInOtherType()",
    "file_id": "F169",
    "start_line": 644,
    "text_preview": "waysMatches());\\n\t\tsm = ex.matchesMethodExecution(b);\\n\t\tassertTrue(\"does not match\",sm.neverMatches());\\n\t}\\n\\n\tpublic void testReferencePCsInOtherType() throws Exception {\\n\t\tPointcutExpression ex = parser.parsePointcutExpression(\"org.aspectj.weaver.tools.Java15PointcutExpressionTest.ExternalReferrer.d()\",ExternalReferrer."
  },
  {
    "method_id": "M4282",
    "name": "testArrayTypeInArgs",
    "return_type": "void",
    "signature": "testArrayTypeInArgs()",
    "file_id": "F169",
    "start_line": 652,
    "text_preview": "waysMatches());\\n\t\tsm = ex.matchesMethodExecution(b);\\n\t\tassertTrue(\"does not match\",sm.neverMatches());\\n\t}\\n\\n\tpublic void testArrayTypeInArgs() throws Exception {\\n\t\tPointcutParameter[] params = new PointcutParameter[3];\\n\t\tparams[0] = parser.createPointcutParameter(\"d\", Date.class);\\n\t\tparams[1] = parser.createPointcutPara"
  },
  {
    "method_id": "M4283",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F169",
    "start_line": 660,
    "text_preview": ".aspectj.weaver.tools.Java15PointcutExpressionTest.UsesArrays.pc(d,s,ss)\",UsesArrays.class,params);\\n\t}\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tparser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());\\n\t\ta = A.class"
  },
  {
    "method_id": "M4284",
    "name": "a",
    "return_type": "void",
    "signature": "a()",
    "file_id": "F169",
    "start_line": 212,
    "text_preview": "dowMatch match = null;\\n\\n\t\tMethod a = test.A.class.getMethod(\"a\",new Class[] {String.class});             // public void a(String s) {}\\n\t\tMethod b = test.A.class.getMethod(\"b\",new Class[] {String.class});             // public void b(@A1 String s) {}\\n\t\tMethod c = test.A.class.getMethod(\"c\",new Class[] {String.class});  "
  },
  {
    "method_id": "M4285",
    "name": "b",
    "return_type": "void",
    "signature": "b()",
    "file_id": "F169",
    "start_line": 213,
    "text_preview": "lic void a(String s) {}\\n\t\tMethod b = test.A.class.getMethod(\"b\",new Class[] {String.class});             // public void b(@A1 String s) {}\\n\t\tMethod c = test.A.class.getMethod(\"c\",new Class[] {String.class});             // public void c(@A1 @A2 String s) {}\\n//\t\tMethod d = test.A.class.getMethod(\"d\",new Class[] {String."
  },
  {
    "method_id": "M4286",
    "name": "c",
    "return_type": "void",
    "signature": "c(A anA, B aB)",
    "file_id": "F169",
    "start_line": 214,
    "text_preview": "void b(@A1 String s) {}\\n\t\tMethod c = test.A.class.getMethod(\"c\",new Class[] {String.class});             // public void c(@A1 @A2 String s) {}\\n//\t\tMethod d = test.A.class.getMethod(\"d\",new Class[] {String.class,String.class});// public void d(@A1 String s,@A2 String t) {}\\n\\n\t\tMethod e = test.A.class.getMethod(\"e\",new Cl"
  },
  {
    "method_id": "M4287",
    "name": "d",
    "return_type": "void",
    "signature": "d(A anA, A anotherA)",
    "file_id": "F169",
    "start_line": 106,
    "text_preview": "ssLoader());\\n\t\tPointcutExpression pexpr = null;\\n\t\tShadowMatch match = null;\\n\\n\t\tMethod n = test.AnnoValues.class.getMethod(\"none\");\\n\t\tMethod r = test.AnnoValues.class.getMethod(\"redMethod\");\\n\t\tMethod g = test.AnnoValues.class.getMethod(\"greenMethod\");\\n\t\tMethod b = test.AnnoValues.class.getMethod(\"blueMethod\");\\n\t\tMethod "
  },
  {
    "method_id": "M4288",
    "name": "foo",
    "return_type": "void",
    "signature": "foo()",
    "file_id": "F169",
    "start_line": 73,
    "text_preview": "ass().getClassLoader());\\n\t\tPointcutExpression pexpr = null;\\n\\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA *))\");\\n\t\tcheckParameterAnnotations(pexpr,0,null,\"@MA\",\"exact[@MA:t]\");\\n\\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA (*)))\");\\n\t\tcheckParameterAnnotations(pexpr,0,\"@MA\",nu"
  },
  {
    "method_id": "M4289",
    "name": "goo",
    "return_type": "void",
    "signature": "goo(A x)",
    "file_id": "F169",
    "start_line": 582,
    "text_preview": "utParameter p1 = parser.createPointcutParameter(\"x\",A.class);\\n\t\tPointcutExpression pc = parser.parsePointcutExpression(\"goo(x)\",C.class,new PointcutParameter[] {p1});\\n\\n\t\tShadowMatch sMatch1 = pc.matchesMethodCall(a,b);\\n\t\tShadowMatch sMatch2 = pc.matchesMethodExecution(a);\\n\t\tassertTrue(\"no match on call\",sMatch1.neverMa"
  },
  {
    "method_id": "M4290",
    "name": "nonVarArgs",
    "return_type": "void",
    "signature": "nonVarArgs(String[] strings)",
    "file_id": "F169",
    "start_line": 697,
    "text_preview": "e=\"execution(* *(..)) && this(x)\", argNames=\"x\")\\n\t\tpublic void goo(A x) {}\\n\t}\\n\\n\tprivate static class D {\\n\\n\t\tpublic void nonVarArgs(String[] strings) {};\\n\\n\t\tpublic void varArgs(String... strings) {};\\n\\n\t}\\n\\n\tstatic class TestBean {\\n\t\tpublic void setFriends(List<C> friends) {}\\n\t}\\n\\n\t@Deprecated\\n\tstatic class GoldenOldie {\\n\t"
  },
  {
    "method_id": "M4291",
    "name": "varArgs",
    "return_type": "void",
    "signature": "varArgs(String... strings)",
    "file_id": "F169",
    "start_line": 699,
    "text_preview": "\\n\t\tpublic void goo(A x) {}\\n\t}\\n\\n\tprivate static class D {\\n\\n\t\tpublic void nonVarArgs(String[] strings) {};\\n\\n\t\tpublic void varArgs(String... strings) {};\\n\\n\t}\\n\\n\tstatic class TestBean {\\n\t\tpublic void setFriends(List<C> friends) {}\\n\t}\\n\\n\t@Deprecated\\n\tstatic class GoldenOldie {\\n\t\tpublic void foo() {}\\n\t}\\n\\n\tprivate static class "
  },
  {
    "method_id": "M4292",
    "name": "setFriends",
    "return_type": "void",
    "signature": "setFriends(List<C> friends)",
    "file_id": "F169",
    "start_line": 704,
    "text_preview": "VarArgs(String[] strings) {};\\n\\n\t\tpublic void varArgs(String... strings) {};\\n\\n\t}\\n\\n\tstatic class TestBean {\\n\t\tpublic void setFriends(List<C> friends) {}\\n\t}\\n\\n\t@Deprecated\\n\tstatic class GoldenOldie {\\n\t\tpublic void foo() {}\\n\t}\\n\\n\tprivate static class NamedPointcutResolution {\\n\\n\t\t@Pointcut(\"execution(* *(..))\")\\n\t\tpublic void "
  },
  {
    "method_id": "M4293",
    "name": "foo",
    "return_type": "void",
    "signature": "foo()",
    "file_id": "F169",
    "start_line": 73,
    "text_preview": "ass().getClassLoader());\\n\t\tPointcutExpression pexpr = null;\\n\\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA *))\");\\n\t\tcheckParameterAnnotations(pexpr,0,null,\"@MA\",\"exact[@MA:t]\");\\n\\n\t\tpexpr = p.parsePointcutExpression(\"execution(public void foo(@MA (*)))\");\\n\t\tcheckParameterAnnotations(pexpr,0,\"@MA\",nu"
  },
  {
    "method_id": "M4294",
    "name": "a",
    "return_type": "void",
    "signature": "a()",
    "file_id": "F169",
    "start_line": 212,
    "text_preview": "dowMatch match = null;\\n\\n\t\tMethod a = test.A.class.getMethod(\"a\",new Class[] {String.class});             // public void a(String s) {}\\n\t\tMethod b = test.A.class.getMethod(\"b\",new Class[] {String.class});             // public void b(@A1 String s) {}\\n\t\tMethod c = test.A.class.getMethod(\"c\",new Class[] {String.class});  "
  },
  {
    "method_id": "M4295",
    "name": "b",
    "return_type": "void",
    "signature": "b()",
    "file_id": "F169",
    "start_line": 213,
    "text_preview": "lic void a(String s) {}\\n\t\tMethod b = test.A.class.getMethod(\"b\",new Class[] {String.class});             // public void b(@A1 String s) {}\\n\t\tMethod c = test.A.class.getMethod(\"c\",new Class[] {String.class});             // public void c(@A1 @A2 String s) {}\\n//\t\tMethod d = test.A.class.getMethod(\"d\",new Class[] {String."
  },
  {
    "method_id": "M4296",
    "name": "c",
    "return_type": "void",
    "signature": "c()",
    "file_id": "F169",
    "start_line": 214,
    "text_preview": "void b(@A1 String s) {}\\n\t\tMethod c = test.A.class.getMethod(\"c\",new Class[] {String.class});             // public void c(@A1 @A2 String s) {}\\n//\t\tMethod d = test.A.class.getMethod(\"d\",new Class[] {String.class,String.class});// public void d(@A1 String s,@A2 String t) {}\\n\\n\t\tMethod e = test.A.class.getMethod(\"e\",new Cl"
  },
  {
    "method_id": "M4297",
    "name": "d",
    "return_type": "void",
    "signature": "d()",
    "file_id": "F169",
    "start_line": 106,
    "text_preview": "ssLoader());\\n\t\tPointcutExpression pexpr = null;\\n\t\tShadowMatch match = null;\\n\\n\t\tMethod n = test.AnnoValues.class.getMethod(\"none\");\\n\t\tMethod r = test.AnnoValues.class.getMethod(\"redMethod\");\\n\t\tMethod g = test.AnnoValues.class.getMethod(\"greenMethod\");\\n\t\tMethod b = test.AnnoValues.class.getMethod(\"blueMethod\");\\n\t\tMethod "
  },
  {
    "method_id": "M4298",
    "name": "pc",
    "return_type": "void",
    "signature": "pc(Date d, String s, String[] ss)",
    "file_id": "F169",
    "start_line": 657,
    "text_preview": "s\", String[].class);\\n\t\tparser.parsePointcutExpression(\"org.aspectj.weaver.tools.Java15PointcutExpressionTest.UsesArrays.pc(d,s,ss)\",UsesArrays.class,params);\\n\t}\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tparser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForR"
  },
  {
    "method_id": "M4299",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F170",
    "start_line": 24,
    "text_preview": "yer\\n *\\n */\\npublic class PointcutDesignatorHandlerTest extends TestCase {\\n\\n\tboolean needToSkip = false;\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tneedToSkip = needToSkipPointcutParserTests();\\n\t}\\n\\n\t/** this condition can occur on the build machine only, and is way too complex to fix right now... */\\n\t"
  },
  {
    "method_id": "M4300",
    "name": "needToSkipPointcutParserTests",
    "return_type": "boolean",
    "signature": "needToSkipPointcutParserTests()",
    "file_id": "F170",
    "start_line": 26,
    "text_preview": "ds TestCase {\\n\\n\tboolean needToSkip = false;\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tneedToSkip = needToSkipPointcutParserTests();\\n\t}\\n\\n\t/** this condition can occur on the build machine only, and is way too complex to fix right now... */\\n\tprivate boolean needToSkipPointcutParserTests() {\\n\t\ttry {\\n\t"
  },
  {
    "method_id": "M4301",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException cnfEx)",
    "file_id": "F170",
    "start_line": 46,
    "text_preview": "solution()\\n\t\t\t  .parsePointcutExpression(\"bean(service.*\");\\n\t\t\tfail(\"should not be able to parse bean(service.*)\");\\n\t\t} catch(IllegalArgumentException ex) {\\n\t\t\tassertTrue(\"contains bean\", ex.getMessage().contains(\"bean\"));\\n\t\t}\\n\t}\\n\\n\tpublic void testParseWithHandler() {\\n\t\tif (needToSkip) return;\\n\t\tPointcutParser parser ="
  },
  {
    "method_id": "M4302",
    "name": "testParseWithoutHandler",
    "return_type": "void",
    "signature": "testParseWithoutHandler()",
    "file_id": "F170",
    "start_line": 39,
    "text_preview": "lass.getClassLoader());\\n\t\t} catch (ClassNotFoundException cnfEx) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\tpublic void testParseWithoutHandler() {\\n\t\tif (needToSkip) return;\\n\t\ttry {\\n\t\t\tPointcutParser\\n\t\t\t  .getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution()\\n\t\t\t  .parsePointcutExpression(\"b"
  },
  {
    "method_id": "M4303",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IllegalArgumentException ex)",
    "file_id": "F170",
    "start_line": 46,
    "text_preview": "solution()\\n\t\t\t  .parsePointcutExpression(\"bean(service.*\");\\n\t\t\tfail(\"should not be able to parse bean(service.*)\");\\n\t\t} catch(IllegalArgumentException ex) {\\n\t\t\tassertTrue(\"contains bean\", ex.getMessage().contains(\"bean\"));\\n\t\t}\\n\t}\\n\\n\tpublic void testParseWithHandler() {\\n\t\tif (needToSkip) return;\\n\t\tPointcutParser parser ="
  },
  {
    "method_id": "M4304",
    "name": "testParseWithHandler",
    "return_type": "void",
    "signature": "testParseWithHandler()",
    "file_id": "F170",
    "start_line": 51,
    "text_preview": "h(IllegalArgumentException ex) {\\n\t\t\tassertTrue(\"contains bean\", ex.getMessage().contains(\"bean\"));\\n\t\t}\\n\t}\\n\\n\tpublic void testParseWithHandler() {\\n\t\tif (needToSkip) return;\\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\\n\t\tBeanDesignatorHandler b"
  },
  {
    "method_id": "M4305",
    "name": "testParsingBeanInReferencePointcut01",
    "return_type": "void",
    "signature": "testParsingBeanInReferencePointcut01()",
    "file_id": "F170",
    "start_line": 66,
    "text_preview": "ide the Java15ReflectionBasedReferenceTypeDelegate code. First test checks\\n     * parsing is OK\\n     */\\n    public void testParsingBeanInReferencePointcut01() throws Exception {\\n        if (needToSkip) return;\\n        PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloa"
  },
  {
    "method_id": "M4306",
    "name": "testBean1SetAge",
    "return_type": "void",
    "signature": "testBean1SetAge()",
    "file_id": "F170",
    "start_line": 74,
    "text_preview": "t look as follows:\\n        //\\n        // @Pointcut(\"execution(* setAge(..)) && bean(testBean1)\")\\n        // public void testBean1SetAge() { }\\n\\n        // This should be found and resolved\\n//        PointcutExpression pc =\\n        \tparser.parsePointcutExpression(\"CounterAspect.testBean1SetAge()\");\\n\\n    }\\n\\n    /*\\n     * "
  },
  {
    "method_id": "M4307",
    "name": "testParsingBeanInReferencePointcut02",
    "return_type": "void",
    "signature": "testParsingBeanInReferencePointcut02()",
    "file_id": "F170",
    "start_line": 87,
    "text_preview": "e Java15ReflectionBasedReferenceTypeDelegate code. This test checks the\\n     * actual matching.\\n     */\\n    public void testParsingBeanInReferencePointcut02() throws Exception {\\n        if (needToSkip) return;\\n        PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloa"
  },
  {
    "method_id": "M4308",
    "name": "testBean1toString",
    "return_type": "void",
    "signature": "testBean1toString()",
    "file_id": "F170",
    "start_line": 95,
    "text_preview": "look as follows:\\n        //\\n        // @Pointcut(\"execution(* toString(..)) && bean(testBean1)\")\\n        // public void testBean1toString() { }\\n\\n        // This should be found and resolved\\n        PointcutExpression pc = parser.parsePointcutExpression(\"CounterAspect.testBean1toString()\");\\n\\n        DefaultMatchingConte"
  },
  {
    "method_id": "M4309",
    "name": "testParseWithHandlerAndMultipleSegments",
    "return_type": "void",
    "signature": "testParseWithHandlerAndMultipleSegments()",
    "file_id": "F170",
    "start_line": 116,
    "text_preview": "cution(Object.class.getMethod(\"toString\", new Class[0]));\\n        assertTrue(sm.neverMatches());\\n    }\\n\\n    public void testParseWithHandlerAndMultipleSegments() {\\n        if (needToSkip) return;\\n        PointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResoluti"
  },
  {
    "method_id": "M4310",
    "name": "testStaticMatch",
    "return_type": "void",
    "signature": "testStaticMatch()",
    "file_id": "F170",
    "start_line": 125,
    "text_preview": "g.xyz.someapp..*)\");\\n\t\tassertEquals(\"org.xyz.someapp..*\",beanHandler.getExpressionLastAskedToParse());\\n\t}\\n\\n\tpublic void testStaticMatch() throws Exception {\\n\t\tif (needToSkip) return;\\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\\n\t\tBeanDesigna"
  },
  {
    "method_id": "M4311",
    "name": "testDynamicMatch",
    "return_type": "void",
    "signature": "testDynamicMatch()",
    "file_id": "F170",
    "start_line": 141,
    "text_preview": "chesMethodExecution(Object.class.getMethod(\"toString\",new Class[0]));\\n\t\tassertTrue(sm.neverMatches());\\n\t}\\n\\n\tpublic void testDynamicMatch() throws Exception {\\n\t\tif (needToSkip) return;\\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\\n\t\tBeanDesign"
  },
  {
    "method_id": "M4312",
    "name": "testFastMatch",
    "return_type": "void",
    "signature": "testFastMatch()",
    "file_id": "F170",
    "start_line": 160,
    "text_preview": "ntextBinding(\"beanName\", \"notMyBean\");\\n\t\tassertFalse(sm.matchesJoinPoint(null, null, null).matches());\\n\t}\\n\\n\tpublic void testFastMatch() {\\n\t\tif (needToSkip) return;\\n\t\tPointcutParser parser = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution();\\n\t\tBeanDesignatorHandler beanHand"
  },
  {
    "method_id": "M4313",
    "name": "getDesignatorName",
    "return_type": "String",
    "signature": "getDesignatorName()",
    "file_id": "F170",
    "start_line": 179,
    "text_preview": "ntcutDesignatorHandler {\\n\\n\t\tprivate String askedToParse;\\n\t\tpublic boolean simulateDynamicTest = false;\\n\\n\t\tpublic String getDesignatorName() {\\n\t\t\treturn \"bean\";\\n\t\t}\\n\\n\t\t/* (non-Javadoc)\\n\t\t * @see org.aspectj.weaver.tools.PointcutDesignatorHandler#parse(java.lang.String)\\n\t\t */\\n\t\tpublic ContextBasedMatcher parse(String exp"
  },
  {
    "method_id": "M4314",
    "name": "parse",
    "return_type": "ContextBasedMatcher",
    "signature": "parse(String expression)",
    "file_id": "F170",
    "start_line": 184,
    "text_preview": "signatorName() {\\n\t\t\treturn \"bean\";\\n\t\t}\\n\\n\t\t/* (non-Javadoc)\\n\t\t * @see org.aspectj.weaver.tools.PointcutDesignatorHandler#parse(java.lang.String)\\n\t\t */\\n\t\tpublic ContextBasedMatcher parse(String expression) {\\n\t\t\tthis.askedToParse = expression;\\n\t\t\treturn new BeanPointcutExpression(expression,this.simulateDynamicTest);\\n\t\t}\\n"
  },
  {
    "method_id": "M4315",
    "name": "getExpressionLastAskedToParse",
    "return_type": "String",
    "signature": "getExpressionLastAskedToParse()",
    "file_id": "F170",
    "start_line": 57,
    "text_preview": "gnatorHandler(beanHandler);\\n\t\tparser.parsePointcutExpression(\"bean(service.*)\");\\n\t\tassertEquals(\"service.*\",beanHandler.getExpressionLastAskedToParse());\\n\t}\\n\\n\\n\t/*\\n     * Bug 205907 - the registered pointcut designator does not also get registered with the\\n     * InternalUseOnlyPointcutParser inside the Java15Reflection"
  },
  {
    "method_id": "M4316",
    "name": "BeanPointcutExpression",
    "return_type": "",
    "signature": "BeanPointcutExpression(String beanNamePattern, boolean simulateDynamicTest)",
    "file_id": "F170",
    "start_line": 188,
    "text_preview": ".String)\\n\t\t */\\n\t\tpublic ContextBasedMatcher parse(String expression) {\\n\t\t\tthis.askedToParse = expression;\\n\t\t\treturn new BeanPointcutExpression(expression,this.simulateDynamicTest);\\n\t\t}\\n\\n\t\tpublic String getExpressionLastAskedToParse() {\\n\t\t\treturn this.askedToParse;\\n\t\t}\\n\t}\\n\\n\tprivate class BeanPointcutExpression implement"
  },
  {
    "method_id": "M4317",
    "name": "couldMatchJoinPointsInType",
    "return_type": "boolean",
    "signature": "couldMatchJoinPointsInType(Class aClass)",
    "file_id": "F170",
    "start_line": 169,
    "text_preview": "tMatchingContext();\\n\t\tcontext.addContextBinding(\"beanName\",\"myBean\");\\n\t\tpc.setMatchingContext(context);\\n\t\tassertTrue(pc.couldMatchJoinPointsInType(String.class));\\n\t\tcontext.addContextBinding(\"beanName\",\"yourBean\");\\n\t\tassertFalse(pc.couldMatchJoinPointsInType(String.class));\\n\t}\\n\\n\tprivate class BeanDesignatorHandler impl"
  },
  {
    "method_id": "M4318",
    "name": "couldMatchJoinPointsInType",
    "return_type": "boolean",
    "signature": "couldMatchJoinPointsInType(Class aClass, MatchingContext context)",
    "file_id": "F170",
    "start_line": 169,
    "text_preview": "tMatchingContext();\\n\t\tcontext.addContextBinding(\"beanName\",\"myBean\");\\n\t\tpc.setMatchingContext(context);\\n\t\tassertTrue(pc.couldMatchJoinPointsInType(String.class));\\n\t\tcontext.addContextBinding(\"beanName\",\"yourBean\");\\n\t\tassertFalse(pc.couldMatchJoinPointsInType(String.class));\\n\t}\\n\\n\tprivate class BeanDesignatorHandler impl"
  },
  {
    "method_id": "M4319",
    "name": "mayNeedDynamicTest",
    "return_type": "boolean",
    "signature": "mayNeedDynamicTest()",
    "file_id": "F170",
    "start_line": 224,
    "text_preview": "rue;\\n\t\t\t} else {\\n\t\t\t\treturn false;\\n\t\t\t}\\n\t\t}\\n\\n\\n\t\t/* (non-Javadoc)\\n\t\t * @see org.aspectj.weaver.tools.ContextBasedMatcher#mayNeedDynamicTest()\\n\t\t */\\n\t\tpublic boolean mayNeedDynamicTest() {\\n\t\t\treturn this.simulateDynamicTest;\\n\t\t}\\n\\n\\n\t\tpublic FuzzyBoolean matchesStatically(MatchingContext matchContext) {\\n\t\t\tif (this.simulat"
  },
  {
    "method_id": "M4320",
    "name": "matchesStatically",
    "return_type": "FuzzyBoolean",
    "signature": "matchesStatically(MatchingContext matchContext)",
    "file_id": "F170",
    "start_line": 231,
    "text_preview": "micTest()\\n\t\t */\\n\t\tpublic boolean mayNeedDynamicTest() {\\n\t\t\treturn this.simulateDynamicTest;\\n\t\t}\\n\\n\\n\t\tpublic FuzzyBoolean matchesStatically(MatchingContext matchContext) {\\n\t\t\tif (this.simulateDynamicTest) return FuzzyBoolean.MAYBE;\\n\t\t\tif (this.beanNamePattern.equals(matchContext.getBinding(\"beanName\"))) {\\n\t\t\t\treturn Fuzz"
  },
  {
    "method_id": "M4321",
    "name": "matchesDynamically",
    "return_type": "boolean",
    "signature": "matchesDynamically(MatchingContext matchContext)",
    "file_id": "F170",
    "start_line": 242,
    "text_preview": "else {\\n\t\t\t\treturn FuzzyBoolean.NO;\\n\t\t\t}\\n\t\t}\\n\\n\\n\t\t/* (non-Javadoc)\\n\t\t * @see org.aspectj.weaver.tools.ContextBasedMatcher#matchesDynamically(org.aspectj.weaver.tools.MatchingContext)\\n\t\t */\\n\t\tpublic boolean matchesDynamically(MatchingContext matchContext) {\\n\t\t\treturn this.beanNamePattern.equals(matchContext.getBinding(\"be"
  },
  {
    "method_id": "M4322",
    "name": "testMatchesMethodCall",
    "return_type": "void",
    "signature": "testMatchesMethodCall()",
    "file_id": "F171",
    "start_line": 37,
    "text_preview": "\tMethod aa;\\n\tMethod aaa;\\n\tField x;\\n\tField y;\\n\tMethod b;\\n\tMethod bsaa;\\n\tField n;\\n\tMethod foo;\\n\tMethod bar;\\n\\n\tpublic void testMatchesMethodCall() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"call(* *..A.a*(..))\");\\n\t\tassertTrue(\"Should match call to A.a()\", ex.matchesMethodCall(a, a).alwaysMatches());\\n\t\tassertTr"
  },
  {
    "method_id": "M4323",
    "name": "testMatchesMethodExecution",
    "return_type": "void",
    "signature": "testMatchesMethodExecution()",
    "file_id": "F171",
    "start_line": 86,
    "text_preview": ", bsaa).alwaysMatches());\\n\t\tassertTrue(\"Should not match\", ex.matchesMethodCall(b, b).neverMatches());\\n\t}\\n\\n\tpublic void testMatchesMethodExecution() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"execution(* *..A.aa(..))\");\\n\t\tassertTrue(\"Should match execution of A.aa\", ex.matchesMethodExecution(aa).alwaysMatch"
  },
  {
    "method_id": "M4324",
    "name": "testMatchesConstructorCall",
    "return_type": "void",
    "signature": "testMatchesConstructorCall()",
    "file_id": "F171",
    "start_line": 124,
    "text_preview": "withincode(* a*(..))\");\\n\t\tassertTrue(\"Should not match\", ex.matchesMethodExecution(a).neverMatches());\\n\t}\\n\\n\tpublic void testMatchesConstructorCall() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"call(new(String))\");\\n\t\tassertTrue(\"Should match A(String)\", ex.matchesConstructorCall(asCons, b).alwaysMatches());\\n\t"
  },
  {
    "method_id": "M4325",
    "name": "testMatchesConstructorExecution",
    "return_type": "void",
    "signature": "testMatchesConstructorExecution()",
    "file_id": "F171",
    "start_line": 159,
    "text_preview": "waysMatches());\\n\t\tassertTrue(\"Should not match\", ex.matchesConstructorCall(bsCons, b).neverMatches());\\n\t}\\n\\n\tpublic void testMatchesConstructorExecution() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"execution(new(String))\");\\n\t\tassertTrue(\"Should match A(String)\", ex.matchesConstructorExecution(asCons).alwaysM"
  },
  {
    "method_id": "M4326",
    "name": "testMatchesAdviceExecution",
    "return_type": "void",
    "signature": "testMatchesAdviceExecution()",
    "file_id": "F171",
    "start_line": 202,
    "text_preview": "tches());\\n\t\tassertTrue(\"Should not match B()\", ex.matchesConstructorExecution(bsCons).neverMatches());\\n\t}\\n\\n\tpublic void testMatchesAdviceExecution() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"adviceexecution()\");\\n\t\tassertTrue(\"Should match (advice) A.a\", ex.matchesAdviceExecution(a).alwaysMatches());\\n\t\t// t"
  },
  {
    "method_id": "M4327",
    "name": "testMatchesHandler",
    "return_type": "void",
    "signature": "testMatchesHandler()",
    "file_id": "F171",
    "start_line": 237,
    "text_preview": ").alwaysMatches());\\n\t\tassertTrue(\"Should not match A.a\", ex.matchesAdviceExecution(a).neverMatches());\\n\t}\\n\\n\tpublic void testMatchesHandler() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"handler(Exception)\");\\n\t\tassertTrue(\"Should match catch(Exception)\", ex.matchesHandler(Exception.class, Client.class).alwaysM"
  },
  {
    "method_id": "M4328",
    "name": "testMatchesInitialization",
    "return_type": "void",
    "signature": "testMatchesInitialization()",
    "file_id": "F171",
    "start_line": 268,
    "text_preview": "hes());\\n\t\tassertTrue(\"Does not match within b\", ex.matchesHandler(Exception.class, b).neverMatches());\\n\t}\\n\\n\tpublic void testMatchesInitialization() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"initialization(new(String))\");\\n\t\tassertTrue(\"Should match A(String)\", ex.matchesInitialization(asCons).alwaysMatches("
  },
  {
    "method_id": "M4329",
    "name": "testMatchesPreInitialization",
    "return_type": "void",
    "signature": "testMatchesPreInitialization()",
    "file_id": "F171",
    "start_line": 303,
    "text_preview": "waysMatches());\\n\t\tassertTrue(\"Should not match B()\", ex.matchesInitialization(bsCons).neverMatches());\\n\t}\\n\\n\tpublic void testMatchesPreInitialization() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"preinitialization(new(String))\");\\n\t\tassertTrue(\"Should match A(String)\", ex.matchesPreInitialization(asCons).alway"
  },
  {
    "method_id": "M4330",
    "name": "testMatchesStaticInitialization",
    "return_type": "void",
    "signature": "testMatchesStaticInitialization()",
    "file_id": "F171",
    "start_line": 333,
    "text_preview": "sMatches());\\n\t\tassertTrue(\"Should not match B()\", ex.matchesPreInitialization(bsCons).neverMatches());\\n\t}\\n\\n\tpublic void testMatchesStaticInitialization() {\\n\t\t// staticinit\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"staticinitialization(*..A+)\");\\n\t\tassertTrue(\"Matches A\", ex.matchesStaticInitialization(A.class"
  },
  {
    "method_id": "M4331",
    "name": "testMatchesFieldSet",
    "return_type": "void",
    "signature": "testMatchesFieldSet()",
    "file_id": "F171",
    "start_line": 362,
    "text_preview": "e(* a*(..))\");\\n\t\tassertTrue(\"Does not match\", ex.matchesStaticInitialization(A.class).neverMatches());\\n\t}\\n\\n\tpublic void testMatchesFieldSet() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"set(* *..A+.*)\");\\n\t\tassertTrue(\"matches x\", ex.matchesFieldSet(x, a).alwaysMatches());\\n\t\tassertTrue(\"matches y\", ex.matches"
  },
  {
    "method_id": "M4332",
    "name": "testMatchesFieldGet",
    "return_type": "void",
    "signature": "testMatchesFieldGet()",
    "file_id": "F171",
    "start_line": 394,
    "text_preview": "et(x, aa).alwaysMatches());\\n\t\tassertTrue(\"Should not match\", ex.matchesFieldSet(x, b).neverMatches());\\n\t}\\n\\n\tpublic void testMatchesFieldGet() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"get(* *..A+.*)\");\\n\t\tassertTrue(\"matches x\", ex.matchesFieldGet(x, a).alwaysMatches());\\n\t\tassertTrue(\"matches y\", ex.matches"
  },
  {
    "method_id": "M4333",
    "name": "testArgsMatching",
    "return_type": "void",
    "signature": "testArgsMatching()",
    "file_id": "F171",
    "start_line": 424,
    "text_preview": "et(x, aa).alwaysMatches());\\n\t\tassertTrue(\"Should not match\", ex.matchesFieldGet(x, b).neverMatches());\\n\t}\\n\\n\tpublic void testArgsMatching() {\\n\t\t// too few args\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"args(*,*,*,*)\");\\n\t\tassertTrue(\"Too few args\", ex.matchesMethodExecution(foo).neverMatches());\\n\t\tassertTrue(\""
  },
  {
    "method_id": "M4334",
    "name": "testMatchesDynamically",
    "return_type": "void",
    "signature": "testMatchesDynamically()",
    "file_id": "F171",
    "start_line": 452,
    "text_preview": "(String,Integer,Number)\");\\n\t\tassertTrue(\"matches\", ex.matchesMethodExecution(foo).alwaysMatches());\\n\t}\\n\\n\t// public void testMatchesDynamically() {\\n\t// // everything other than this,target,args should just return true\\n\t// PointcutExpression ex = p.parsePointcutExpression(\"call(* *.*(..)) && execution(* *.*(..)) &&\" +\\n\t/"
  },
  {
    "method_id": "M4335",
    "name": "testGetPointcutExpression",
    "return_type": "void",
    "signature": "testGetPointcutExpression()",
    "file_id": "F171",
    "start_line": 497,
    "text_preview": "Number)\");\\n\t// assertFalse(\"Does not match\",ex.matchesDynamically(null,null,new Object[]{a,b,aa}));\\n\t// }\\n\\n\tpublic void testGetPointcutExpression() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"staticinitialization(*..A+)\");\\n\t\tassertEquals(\"staticinitialization(*..A+)\", ex.getPointcutExpression());\\n\t}\\n\\n\tpublic"
  },
  {
    "method_id": "M4336",
    "name": "testCouldMatchJoinPointsInType",
    "return_type": "void",
    "signature": "testCouldMatchJoinPointsInType()",
    "file_id": "F171",
    "start_line": 502,
    "text_preview": "ticinitialization(*..A+)\");\\n\t\tassertEquals(\"staticinitialization(*..A+)\", ex.getPointcutExpression());\\n\t}\\n\\n\tpublic void testCouldMatchJoinPointsInType() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"execution(* org.aspectj.weaver.tools.PointcutExpressionTest.B.*(..))\");\\n\t\tassertFalse(\"Could maybe match String "
  },
  {
    "method_id": "M4337",
    "name": "testMayNeedDynamicTest",
    "return_type": "void",
    "signature": "testMayNeedDynamicTest()",
    "file_id": "F171",
    "start_line": 511,
    "text_preview": "ntsInType(String.class));\\n\t\tassertTrue(\"Will always match B\", ex.couldMatchJoinPointsInType(B.class));\\n\t}\\n\\n\tpublic void testMayNeedDynamicTest() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"execution(* org.aspectj.weaver.tools.PointcutExpressionTest.B.*(..))\");\\n\t\tassertFalse(\"No dynamic test needed\", ex.mayNe"
  },
  {
    "method_id": "M4338",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F171",
    "start_line": 519,
    "text_preview": "er.tools.PointcutExpressionTest.X)\");\\n\t\tassertTrue(\"Dynamic test needed\", ex.mayNeedDynamicTest());\\n\t}\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tp = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass()\\n\t\t\t\t.getClassLoader());\\n\t\tasCons = A."
  },
  {
    "method_id": "M4339",
    "name": "A",
    "return_type": "",
    "signature": "A(String s)",
    "file_id": "F171",
    "start_line": 126,
    "text_preview": "onstructorCall() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"call(new(String))\");\\n\t\tassertTrue(\"Should match A(String)\", ex.matchesConstructorCall(asCons, b).alwaysMatches());\\n\t\tassertTrue(\"Should match B(String)\", ex.matchesConstructorCall(bsStringCons, b).alwaysMatches());\\n\t\tassertTrue(\"Should not match B("
  },
  {
    "method_id": "M4340",
    "name": "a",
    "return_type": "void",
    "signature": "a()",
    "file_id": "F171",
    "start_line": 39,
    "text_preview": "ll() {\\n\t\tPointcutExpression ex = p.parsePointcutExpression(\"call(* *..A.a*(..))\");\\n\t\tassertTrue(\"Should match call to A.a()\", ex.matchesMethodCall(a, a).alwaysMatches());\\n\t\tassertTrue(\"Should match call to A.aaa()\", ex.matchesMethodCall(aaa, a).alwaysMatches());\\n\t\tassertTrue(\"Should match call to B.aa()\", ex.matchesMet"
  },
  {
    "method_id": "M4341",
    "name": "aa",
    "return_type": "void",
    "signature": "aa(int i)",
    "file_id": "F171",
    "start_line": 40,
    "text_preview": "rtTrue(\"Should match call to A.a()\", ex.matchesMethodCall(a, a).alwaysMatches());\\n\t\tassertTrue(\"Should match call to A.aaa()\", ex.matchesMethodCall(aaa, a).alwaysMatches());\\n\t\tassertTrue(\"Should match call to B.aa()\", ex.matchesMethodCall(bsaa, a).alwaysMatches());\\n\t\tassertTrue(\"Should not match call to B.b()\", ex.matc"
  },
  {
    "method_id": "M4342",
    "name": "aaa",
    "return_type": "void",
    "signature": "aaa(String s, int i)",
    "file_id": "F171",
    "start_line": 40,
    "text_preview": "ertTrue(\"Should match call to A.a()\", ex.matchesMethodCall(a, a).alwaysMatches());\\n\t\tassertTrue(\"Should match call to A.aaa()\", ex.matchesMethodCall(aaa, a).alwaysMatches());\\n\t\tassertTrue(\"Should match call to B.aa()\", ex.matchesMethodCall(bsaa, a).alwaysMatches());\\n\t\tassertTrue(\"Should not match call to B.b()\", ex.mat"
  },
  {
    "method_id": "M4343",
    "name": "B",
    "return_type": "",
    "signature": "B()",
    "file_id": "F171",
    "start_line": 127,
    "text_preview": "\tassertTrue(\"Should match A(String)\", ex.matchesConstructorCall(asCons, b).alwaysMatches());\\n\t\tassertTrue(\"Should match B(String)\", ex.matchesConstructorCall(bsStringCons, b).alwaysMatches());\\n\t\tassertTrue(\"Should not match B()\", ex.matchesConstructorCall(bsCons, foo).neverMatches());\\n\t\tex = p.parsePointcutExpression(\""
  },
  {
    "method_id": "M4344",
    "name": "B",
    "return_type": "",
    "signature": "B(String s)",
    "file_id": "F171",
    "start_line": 127,
    "text_preview": "\tassertTrue(\"Should match A(String)\", ex.matchesConstructorCall(asCons, b).alwaysMatches());\\n\t\tassertTrue(\"Should match B(String)\", ex.matchesConstructorCall(bsStringCons, b).alwaysMatches());\\n\t\tassertTrue(\"Should not match B()\", ex.matchesConstructorCall(bsCons, foo).neverMatches());\\n\t\tex = p.parsePointcutExpression(\""
  },
  {
    "method_id": "M4345",
    "name": "b",
    "return_type": "String",
    "signature": "b()",
    "file_id": "F171",
    "start_line": 42,
    "text_preview": "\"Should match call to B.aa()\", ex.matchesMethodCall(bsaa, a).alwaysMatches());\\n\t\tassertTrue(\"Should not match call to B.b()\", ex.matchesMethodCall(b, a).neverMatches());\\n\t\tex = p.parsePointcutExpression(\"call(* *..A.a*(int))\");\\n\t\tassertTrue(\"Should match call to A.aa()\", ex.matchesMethodCall(aa, a).alwaysMatches());\\n\t\t"
  },
  {
    "method_id": "M4346",
    "name": "aa",
    "return_type": "void",
    "signature": "aa(int i)",
    "file_id": "F171",
    "start_line": 40,
    "text_preview": "rtTrue(\"Should match call to A.a()\", ex.matchesMethodCall(a, a).alwaysMatches());\\n\t\tassertTrue(\"Should match call to A.aaa()\", ex.matchesMethodCall(aaa, a).alwaysMatches());\\n\t\tassertTrue(\"Should match call to B.aa()\", ex.matchesMethodCall(bsaa, a).alwaysMatches());\\n\t\tassertTrue(\"Should not match call to B.b()\", ex.matc"
  },
  {
    "method_id": "M4347",
    "name": "Client",
    "return_type": "",
    "signature": "Client()",
    "file_id": "F171",
    "start_line": 575,
    "text_preview": "\\n\t\tpublic String b() {\\n\t\t\treturn null;\\n\t\t}\\n\\n\t\tpublic void aa(int i) {\\n\t\t}\\n\\n\t\tint y;\\n\t}\\n\\n\tstatic class Client {\\n\t\tpublic Client() {\\n\t\t}\\n\\n\t\tNumber n;\\n\\n\t\tpublic void foo(String s, int i, Number n) {\\n\t\t}\\n\\n\t\tpublic void bar(String s, int i, Integer i2, Number n) {\\n\t\t}\\n\t}\\n\\n\tstatic class X {\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4348",
    "name": "foo",
    "return_type": "void",
    "signature": "foo(String s, int i, Number n)",
    "file_id": "F171",
    "start_line": 580,
    "text_preview": "\\n\t\tpublic void aa(int i) {\\n\t\t}\\n\\n\t\tint y;\\n\t}\\n\\n\tstatic class Client {\\n\t\tpublic Client() {\\n\t\t}\\n\\n\t\tNumber n;\\n\\n\t\tpublic void foo(String s, int i, Number n) {\\n\t\t}\\n\\n\t\tpublic void bar(String s, int i, Integer i2, Number n) {\\n\t\t}\\n\t}\\n\\n\tstatic class X {\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4349",
    "name": "bar",
    "return_type": "void",
    "signature": "bar(String s, int i, Integer i2, Number n)",
    "file_id": "F171",
    "start_line": 583,
    "text_preview": " class Client {\\n\t\tpublic Client() {\\n\t\t}\\n\\n\t\tNumber n;\\n\\n\t\tpublic void foo(String s, int i, Number n) {\\n\t\t}\\n\\n\t\tpublic void bar(String s, int i, Integer i2, Number n) {\\n\t\t}\\n\t}\\n\\n\tstatic class X {\\n\t}\\n\\n}\\n"
  },
  {
    "method_id": "M4350",
    "name": "needToSkipPointcutParserTests",
    "return_type": "boolean",
    "signature": "needToSkipPointcutParserTests()",
    "file_id": "F172",
    "start_line": 35,
    "text_preview": "\t/** this condition can occur on the build machine only, and is way too complex to fix right now... */\\n\tprivate boolean needToSkipPointcutParserTests() {\\n\t\ttry {\\n\t\t\tClass.forName(\"org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate\", false, this.getClass()\\n\t\t\t\t\t.getClassLoader());// ReflectionBasedRef"
  },
  {
    "method_id": "M4351",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException cnfEx)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4352",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F172",
    "start_line": 45,
    "text_preview": "s.getClassLoader());\\n\t\t} catch (ClassNotFoundException cnfEx) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tneedToSkip = needToSkipPointcutParserTests();\\n\t}\\n\\n\tpublic void testGetAllSupportedPointcutPrimitives() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tSet<Pointcu"
  },
  {
    "method_id": "M4353",
    "name": "testGetAllSupportedPointcutPrimitives",
    "return_type": "void",
    "signature": "testGetAllSupportedPointcutPrimitives()",
    "file_id": "F172",
    "start_line": 50,
    "text_preview": "ected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tneedToSkip = needToSkipPointcutParserTests();\\n\t}\\n\\n\tpublic void testGetAllSupportedPointcutPrimitives() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tSet<PointcutPrimitive> s = PointcutParser.getAllSupportedPointcutPrimitives();\\n\t\tassertEquals(\"Should be 21 elements in "
  },
  {
    "method_id": "M4354",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4355",
    "name": "testEmptyConstructor",
    "return_type": "void",
    "signature": "testEmptyConstructor()",
    "file_id": "F172",
    "start_line": 62,
    "text_preview": "FLOW));\\n\t\tassertFalse(\"Should not contain cflowbelow pcd\", s.contains(PointcutPrimitive.CFLOW_BELOW));\\n\t}\\n\\n\tpublic void testEmptyConstructor() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tPointcutParser parser = PointcutParser\\n\t\t\t\t.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getCla"
  },
  {
    "method_id": "M4356",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4357",
    "name": "testSetConstructor",
    "return_type": "void",
    "signature": "testSetConstructor()",
    "file_id": "F172",
    "start_line": 76,
    "text_preview": "FLOW));\\n\t\tassertFalse(\"Should not contain cflowbelow pcd\", s.contains(PointcutPrimitive.CFLOW_BELOW));\\n\t}\\n\\n\tpublic void testSetConstructor() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tSet<PointcutPrimitive> p = PointcutParser.getAllSupportedPointcutPrimitives();\\n\t\tPointcutParser parser = PointcutParser\\n\t\t\t\t.getPointcutPar"
  },
  {
    "method_id": "M4358",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4359",
    "name": "testParsePointcutExpression",
    "return_type": "void",
    "signature": "testParsePointcutExpression()",
    "file_id": "F172",
    "start_line": 94,
    "text_preview": "hould only have ARGS pcd\", PointcutPrimitive.ARGS, parser.getSupportedPrimitives().iterator().next());\\n\t}\\n\\n\tpublic void testParsePointcutExpression() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this\\n\t\t\t\t.getC"
  },
  {
    "method_id": "M4360",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4361",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IllegalArgumentException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4362",
    "name": "testParseExceptionErrorMessages",
    "return_type": "void",
    "signature": "testParseExceptionErrorMessages()",
    "file_id": "F172",
    "start_line": 117,
    "text_preview": "-gook()\");\\n\t\t\tfail(\"Expected IllegalArgumentException\");\\n\t\t} catch (IllegalArgumentException ex) {\\n\t\t}\\n\t}\\n\\n\tpublic void testParseExceptionErrorMessages() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this\\n\t\t\t\t."
  },
  {
    "method_id": "M4363",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4364",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IllegalArgumentException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4365",
    "name": "testOperatorPrecedence_319190",
    "return_type": "void",
    "signature": "testOperatorPrecedence_319190()",
    "file_id": "F172",
    "start_line": 133,
    "text_preview": "x.getMessage().startsWith(\"Pointcut is not well-formed: expecting ')' at character position 24\"));\\n\t\t}\\n\t}\\n\\n\tpublic void testOperatorPrecedence_319190() throws Exception {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tString s = null;\\n\t\tPointcut p = null;\\n\\n\t\ts = \"(execution(* A.credit(float)) || execution(* A.debit(float))) && "
  },
  {
    "method_id": "M4366",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4367",
    "name": "testParseIfPCD",
    "return_type": "void",
    "signature": "testParseIfPCD()",
    "file_id": "F172",
    "start_line": 161,
    "text_preview": "toString());\\n\t\tp = new PointcutRewriter().rewrite(p);\\n\t\tAssert.assertEquals(\"if(true)\", p.toString());\\n\t}\\n\\n\tpublic void testParseIfPCD() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this\\n\t\t\t\t.getClass().getCla"
  },
  {
    "method_id": "M4368",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4369",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4370",
    "name": "testParseCflowPCDs",
    "return_type": "void",
    "signature": "testParseCflowPCDs()",
    "file_id": "F172",
    "start_line": 176,
    "text_preview": "x) {\\n\t\t\tassertEquals(\"Should not support IF\", PointcutPrimitive.IF, ex.getUnsupportedPrimitive());\\n\t\t}\\n\t}\\n\\n\tpublic void testParseCflowPCDs() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this\\n\t\t\t\t.getClass().ge"
  },
  {
    "method_id": "M4371",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4372",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4373",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4374",
    "name": "testParseReferencePCDs",
    "return_type": "void",
    "signature": "testParseReferencePCDs()",
    "file_id": "F172",
    "start_line": 197,
    "text_preview": "ls(\"Should not support CFLOW_BELOW\", PointcutPrimitive.CFLOW_BELOW, ex.getUnsupportedPrimitive());\\n\t\t}\\n\t}\\n\\n\tpublic void testParseReferencePCDs() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tSet<PointcutPrimitive> pcKinds = PointcutParser.getAllSupportedPointcutPrimitives();\\n\t\tpcKinds.remove(PointcutPrimitive.REFERENCE);\\n\t\tP"
  },
  {
    "method_id": "M4375",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4376",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4377",
    "name": "testParseUnsupportedPCDs",
    "return_type": "void",
    "signature": "testParseUnsupportedPCDs()",
    "file_id": "F172",
    "start_line": 214,
    "text_preview": "imitiveException ex) {\\n\t\t\tassertTrue(ex.getUnsupportedPrimitive() == PointcutPrimitive.REFERENCE);\\n\t\t}\\n\t}\\n\\n\tpublic void testParseUnsupportedPCDs() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tSet s = new HashSet();\\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoader"
  },
  {
    "method_id": "M4378",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4379",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4380",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4381",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4382",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4383",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4384",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4385",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4386",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4387",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4388",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4389",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4390",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4391",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4392",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4393",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4394",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedPointcutPrimitiveException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4395",
    "name": "testFormals",
    "return_type": "void",
    "signature": "testFormals()",
    "file_id": "F172",
    "start_line": 320,
    "text_preview": "assertEquals(\"Staticinit\", PointcutPrimitive.STATIC_INITIALIZATION, ex.getUnsupportedPrimitive());\\n\t\t}\\n\t}\\n\\n\tpublic void testFormals() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tPointcutParser parser = PointcutParser\\n\t\t\t\t.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getC"
  },
  {
    "method_id": "M4396",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4397",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IllegalArgumentException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4398",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IllegalArgumentException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4399",
    "name": "testXLintConfiguration",
    "return_type": "void",
    "signature": "testXLintConfiguration()",
    "file_id": "F172",
    "start_line": 346,
    "text_preview": "rue(\"no match for type name\", ex.getMessage().contains(\"warning no match for this type name: y\"));\\n\t\t}\\n\t}\\n\\n\tpublic void testXLintConfiguration() {\\n\t\tif (needToSkip) {\\n\t\t\treturn;\\n\t\t}\\n\\n\t\tPointcutParser p = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this\\n\t\t\t\t.getClass("
  },
  {
    "method_id": "M4400",
    "name": "if",
    "return_type": "",
    "signature": "if(needToSkip)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4401",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IllegalArgumentException ex)",
    "file_id": "F172",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4402",
    "name": "handleMessage",
    "return_type": "boolean",
    "signature": "handleMessage(IMessage message)",
    "file_id": "F172",
    "start_line": 366,
    "text_preview": "(\"this(FooBar)\");\\n\t}\\n\\n\tprivate static class IgnoreWarningsMessageHandler implements IMessageHandler {\\n\\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\\n\t\t\tif (message.getKind() != IMessage.WARNING) {\\n\t\t\t\tthrow new RuntimeException(\"unexpected message: \" + message.toString());\\n\t\t\t}\\n\t\t\treturn true"
  },
  {
    "method_id": "M4403",
    "name": "isIgnoring",
    "return_type": "boolean",
    "signature": "isIgnoring(Kind kind)",
    "file_id": "F172",
    "start_line": 373,
    "text_preview": "\t\t\t\tthrow new RuntimeException(\"unexpected message: \" + message.toString());\\n\t\t\t}\\n\t\t\treturn true;\\n\t\t}\\n\\n\t\tpublic boolean isIgnoring(Kind kind) {\\n\t\t\tif (kind != IMessage.ERROR) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(Kind kind) {\\n\t\t}\\n\\n\t\tpublic void ignore(Kind kind) {\\n\t\t}\\n\\n\t}\\n}\\n"
  },
  {
    "method_id": "M4404",
    "name": "if",
    "return_type": "",
    "signature": "if(kind != IMessage.ERROR)",
    "file_id": "F172",
    "start_line": 147,
    "text_preview": "at))) && (this(acc) && args(am))) || (execution(* C.*(Account, float)) && args(acc, am)))\",\\n\t\t\t\tp.toString());\\n\\n\t\ts = \"(if(true) || if(false)) && this(acc) && args(am)  || if(true) && args(acc, am)\";\\n\t\tp = new PatternParser(s).parsePointcut();\\n\t\t// bugged was: ((if(true) || if(false)) && (this(acc) && (args(am) || (if("
  },
  {
    "method_id": "M4405",
    "name": "dontIgnore",
    "return_type": "void",
    "signature": "dontIgnore(Kind kind)",
    "file_id": "F172",
    "start_line": 380,
    "text_preview": "lean isIgnoring(Kind kind) {\\n\t\t\tif (kind != IMessage.ERROR) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(Kind kind) {\\n\t\t}\\n\\n\t\tpublic void ignore(Kind kind) {\\n\t\t}\\n\\n\t}\\n}\\n"
  },
  {
    "method_id": "M4406",
    "name": "ignore",
    "return_type": "void",
    "signature": "ignore(Kind kind)",
    "file_id": "F172",
    "start_line": 383,
    "text_preview": " IMessage.ERROR) {\\n\t\t\t\treturn true;\\n\t\t\t}\\n\t\t\treturn false;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(Kind kind) {\\n\t\t}\\n\\n\t\tpublic void ignore(Kind kind) {\\n\t\t}\\n\\n\t}\\n}\\n"
  },
  {
    "method_id": "M4407",
    "name": "testSkip",
    "return_type": "void",
    "signature": "testSkip()",
    "file_id": "F173",
    "start_line": 30,
    "text_preview": "WeaverStateInfo;\\n\\nimport junit.framework.TestCase;\\n\\npublic class ReadingAttributesTest extends TestCase {\\n\\n\tpublic void testSkip() {} // Review what to do about these tests\\n\\n\tpublic void xtestWeaverStateInfo() throws ClassNotFoundException, IOException {\\n\\n\t\tJavaClass jc = getClassFrom(new File(\"n:/temp\"), \"com.springso"
  },
  {
    "method_id": "M4408",
    "name": "xtestWeaverStateInfo",
    "return_type": "void",
    "signature": "xtestWeaverStateInfo()",
    "file_id": "F173",
    "start_line": 32,
    "text_preview": "adingAttributesTest extends TestCase {\\n\\n\tpublic void testSkip() {} // Review what to do about these tests\\n\\n\tpublic void xtestWeaverStateInfo() throws ClassNotFoundException, IOException {\\n\\n\t\tJavaClass jc = getClassFrom(new File(\"n:/temp\"), \"com.springsource.petclinic.domain.Visit\");\\n\t\tassertNotNull(jc);\\n\t\tAttribute[] a"
  },
  {
    "method_id": "M4409",
    "name": "for",
    "return_type": "",
    "signature": "for(Attribute attr : attrs)",
    "file_id": "F173",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4410",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0; i < meths.length && oneWeWant == null; i++)",
    "file_id": "F173",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4411",
    "name": "createRepos",
    "return_type": "SyntheticRepository",
    "signature": "createRepos(File cpentry)",
    "file_id": "F173",
    "start_line": 57,
    "text_preview": "];\\n\t\t// if (method.getName().equals(\"main\")) {\\n\t\t// oneWeWant = meths[i];\\n\t\t// }\\n\t\t// }\\n\t}\\n\\n\tpublic SyntheticRepository createRepos(File cpentry) {\\n\t\tClassPath cp = new ClassPath(cpentry + File.pathSeparator + System.getProperty(\"java.class.path\"));\\n\t\treturn SyntheticRepository.getInstance(cp);\\n\t}\\n\\n\tprotected JavaClass"
  },
  {
    "method_id": "M4412",
    "name": "getClassFrom",
    "return_type": "JavaClass",
    "signature": "getClassFrom(File where, String clazzname)",
    "file_id": "F173",
    "start_line": 34,
    "text_preview": "o about these tests\\n\\n\tpublic void xtestWeaverStateInfo() throws ClassNotFoundException, IOException {\\n\\n\t\tJavaClass jc = getClassFrom(new File(\"n:/temp\"), \"com.springsource.petclinic.domain.Visit\");\\n\t\tassertNotNull(jc);\\n\t\tAttribute[] attrs = jc.getAttributes();\\n\t\tfor (Attribute attr : attrs) {\\n\t\t\tSystem.out.println(attr"
  },
  {
    "method_id": "M4413",
    "name": "needToSkipPointcutParserTests",
    "return_type": "boolean",
    "signature": "needToSkipPointcutParserTests()",
    "file_id": "F174",
    "start_line": 25,
    "text_preview": "\t/** this condition can occur on the build machine only, and is way too complex to fix right now... */\\n\tprivate boolean needToSkipPointcutParserTests() {\\n\t\ttry {\\n\t\t\tClass.forName(\"org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate\",false,this.getClass().getClassLoader());//ReflectionBasedReferenceTyp"
  },
  {
    "method_id": "M4414",
    "name": "catch",
    "return_type": "",
    "signature": "catch(ClassNotFoundException cnfEx)",
    "file_id": "F174",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4415",
    "name": "testMatching",
    "return_type": "void",
    "signature": "testMatching()",
    "file_id": "F174",
    "start_line": 34,
    "text_preview": "lass.getClassLoader());\\n\t\t} catch (ClassNotFoundException cnfEx) {\\n\t\t\treturn true;\\n\t\t}\\n\t\treturn false;\\n\t}\\n\\n\tpublic void testMatching() {\\n\t\tif (needToSkip) return;\\n\\n\t\tassertTrue(\"Map+ matches Map\",tpm.matches(Map.class));\\n\t\tassertTrue(\"Map+ matches HashMap\",tpm.matches(HashMap.class));\\n\t\tassertFalse(\"Map+ does not match"
  },
  {
    "method_id": "M4416",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F174",
    "start_line": 42,
    "text_preview": "tpm.matches(HashMap.class));\\n\t\tassertFalse(\"Map+ does not match String\",tpm.matches(String.class));\\n\t}\\n\\n\tprotected void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tneedToSkip = needToSkipPointcutParserTests();\\n\t\tif (needToSkip) return;\\n\t\tPointcutParser pp = PointcutParser.getPointcutParserSupportingAllPrimitivesAndUs"
  },
  {
    "method_id": "M4417",
    "name": "AbstractCacheBackingTestSupport",
    "return_type": "",
    "signature": "AbstractCacheBackingTestSupport()",
    "file_id": "F175",
    "start_line": 56,
    "text_preview": "private File\ttestTempFolder;\\n\tprotected File root;\\n\\n\tpublic static final String TEMP_SUBFOLDER_NAME=\"temp\";\\n\\n\tprotected AbstractCacheBackingTestSupport() {\\n\t\tsuper();\\n\t}\\n\\n\tprotected AbstractCacheBackingTestSupport(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\t@Override\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tif"
  },
  {
    "method_id": "M4418",
    "name": "AbstractCacheBackingTestSupport",
    "return_type": "",
    "signature": "AbstractCacheBackingTestSupport(String name)",
    "file_id": "F175",
    "start_line": 56,
    "text_preview": "private File\ttestTempFolder;\\n\tprotected File root;\\n\\n\tpublic static final String TEMP_SUBFOLDER_NAME=\"temp\";\\n\\n\tprotected AbstractCacheBackingTestSupport() {\\n\t\tsuper();\\n\t}\\n\\n\tprotected AbstractCacheBackingTestSupport(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\t@Override\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tif"
  },
  {
    "method_id": "M4419",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F175",
    "start_line": 65,
    "text_preview": ") {\\n\t\tsuper();\\n\t}\\n\\n\tprotected AbstractCacheBackingTestSupport(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n\t@Override\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tif (root == null) {\\n\t\t\troot = createTempFile(\"aspectj\", \"testdir\");\\n\t\t\tFileUtil.deleteContents(root);\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic void tearDown() throws Ex"
  },
  {
    "method_id": "M4420",
    "name": "if",
    "return_type": "",
    "signature": "if(root == null)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4421",
    "name": "tearDown",
    "return_type": "void",
    "signature": "tearDown()",
    "file_id": "F175",
    "start_line": 74,
    "text_preview": "ll) {\\n\t\t\troot = createTempFile(\"aspectj\", \"testdir\");\\n\t\t\tFileUtil.deleteContents(root);\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic void tearDown() throws Exception {\\n\t\tif (root != null) {\\n\t\t\tFileUtil.deleteContents(root);\\n\t\t\troot = null;\\n\t\t}\\n\\n\t\tif (targetFolder != null) {\\n\t\t\tFileUtil.deleteContents(targetFolder);\\n\t\t}\\n\\n\t\tsuper.tearDown"
  },
  {
    "method_id": "M4422",
    "name": "if",
    "return_type": "",
    "signature": "if(root != null)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4423",
    "name": "if",
    "return_type": "",
    "signature": "if(targetFolder != null)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4424",
    "name": "ensureTempFolderExists",
    "return_type": "File",
    "signature": "ensureTempFolderExists()",
    "file_id": "F175",
    "start_line": 121,
    "text_preview": "lder;\\n    }\\n\\n    protected File createTempFile (String prefix, String suffix) throws IOException {\\n    \tFile\tdestFolder=ensureTempFolderExists();\\n    \treturn File.createTempFile(prefix, suffix, destFolder);\\n    }\\n\\n    public static final File ensureFolderExists (File folder) throws IllegalStateException {\\n    \tif (fold"
  },
  {
    "method_id": "M4425",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(TEMP_SUBFOLDER_NAME)",
    "file_id": "F175",
    "start_line": 88,
    "text_preview": "tFolder);\\n\t\t}\\n\\n\t\tsuper.tearDown();\\n\t}\\n\\n    protected File ensureTempFolderExists () throws IllegalStateException {\\n    \tsynchronized(TEMP_SUBFOLDER_NAME) {\\n    \t\tif (testTempFolder == null) {\\n    \t\t\tFile\tparent=detectTargetFolder();\\n    \t\t\ttestTempFolder = new File(parent, TEMP_SUBFOLDER_NAME);\\n    \t\t}\\n    \t}\\n\\n    \tret"
  },
  {
    "method_id": "M4426",
    "name": "if",
    "return_type": "",
    "signature": "if(testTempFolder == null)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4427",
    "name": "detectTargetFolder",
    "return_type": "File",
    "signature": "detectTargetFolder()",
    "file_id": "F175",
    "start_line": 90,
    "text_preview": "IllegalStateException {\\n    \tsynchronized(TEMP_SUBFOLDER_NAME) {\\n    \t\tif (testTempFolder == null) {\\n    \t\t\tFile\tparent=detectTargetFolder();\\n    \t\t\ttestTempFolder = new File(parent, TEMP_SUBFOLDER_NAME);\\n    \t\t}\\n    \t}\\n\\n    \treturn ensureFolderExists(testTempFolder);\\n    }\\n\\n    protected File detectTargetFolder () thr"
  },
  {
    "method_id": "M4428",
    "name": "synchronized",
    "return_type": "",
    "signature": "synchronized(TEMP_SUBFOLDER_NAME)",
    "file_id": "F175",
    "start_line": 88,
    "text_preview": "tFolder);\\n\t\t}\\n\\n\t\tsuper.tearDown();\\n\t}\\n\\n    protected File ensureTempFolderExists () throws IllegalStateException {\\n    \tsynchronized(TEMP_SUBFOLDER_NAME) {\\n    \t\tif (testTempFolder == null) {\\n    \t\t\tFile\tparent=detectTargetFolder();\\n    \t\t\ttestTempFolder = new File(parent, TEMP_SUBFOLDER_NAME);\\n    \t\t}\\n    \t}\\n\\n    \tret"
  },
  {
    "method_id": "M4429",
    "name": "if",
    "return_type": "",
    "signature": "if(targetFolder == null)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4430",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F175",
    "start_line": 184,
    "text_preview": "        URI uri=getClassContainerLocationURI(clazz);\\n            return (uri == null) ? null : new File(uri);\\n        } catch(URISyntaxException e) {\\n            throw new IllegalArgumentException(e.getClass().getSimpleName() + \": \" + e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * @param clazz A {@link Class} obje"
  },
  {
    "method_id": "M4431",
    "name": "createTempFile",
    "return_type": "File",
    "signature": "createTempFile(String prefix, String suffix)",
    "file_id": "F175",
    "start_line": 68,
    "text_preview": "\\n\t\tsuper(name);\\n\t}\\n\\n\t@Override\\n\tpublic void setUp() throws Exception {\\n\t\tsuper.setUp();\\n\t\tif (root == null) {\\n\t\t\troot = createTempFile(\"aspectj\", \"testdir\");\\n\t\t\tFileUtil.deleteContents(root);\\n\t\t}\\n\t}\\n\\n\t@Override\\n\tpublic void tearDown() throws Exception {\\n\t\tif (root != null) {\\n\t\t\tFileUtil.deleteContents(root);\\n\t\t\troot = "
  },
  {
    "method_id": "M4432",
    "name": "ensureFolderExists",
    "return_type": "File",
    "signature": "ensureFolderExists(File folder)",
    "file_id": "F175",
    "start_line": 95,
    "text_preview": "parent=detectTargetFolder();\\n    \t\t\ttestTempFolder = new File(parent, TEMP_SUBFOLDER_NAME);\\n    \t\t}\\n    \t}\\n\\n    \treturn ensureFolderExists(testTempFolder);\\n    }\\n\\n    protected File detectTargetFolder () throws IllegalStateException {\\n    \tsynchronized(TEMP_SUBFOLDER_NAME) {\\n    \t\tif (targetFolder == null) {\\n\t\t\ttry {\\n\t"
  },
  {
    "method_id": "M4433",
    "name": "if",
    "return_type": "",
    "signature": "if(folder == null)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4434",
    "name": "detectTargetFolder",
    "return_type": "File",
    "signature": "detectTargetFolder(Class<?> anchor)",
    "file_id": "F175",
    "start_line": 90,
    "text_preview": "IllegalStateException {\\n    \tsynchronized(TEMP_SUBFOLDER_NAME) {\\n    \t\tif (testTempFolder == null) {\\n    \t\t\tFile\tparent=detectTargetFolder();\\n    \t\t\ttestTempFolder = new File(parent, TEMP_SUBFOLDER_NAME);\\n    \t\t}\\n    \t}\\n\\n    \treturn ensureFolderExists(testTempFolder);\\n    }\\n\\n    protected File detectTargetFolder () thr"
  },
  {
    "method_id": "M4435",
    "name": "detectTargetFolder",
    "return_type": "File",
    "signature": "detectTargetFolder(File anchorFile)",
    "file_id": "F175",
    "start_line": 90,
    "text_preview": "IllegalStateException {\\n    \tsynchronized(TEMP_SUBFOLDER_NAME) {\\n    \t\tif (testTempFolder == null) {\\n    \t\t\tFile\tparent=detectTargetFolder();\\n    \t\t\ttestTempFolder = new File(parent, TEMP_SUBFOLDER_NAME);\\n    \t\t}\\n    \t}\\n\\n    \treturn ensureFolderExists(testTempFolder);\\n    }\\n\\n    protected File detectTargetFolder () thr"
  },
  {
    "method_id": "M4436",
    "name": "getClassContainerLocationFile",
    "return_type": "File",
    "signature": "getClassContainerLocationFile(Class<?> clazz)",
    "file_id": "F175",
    "start_line": 144,
    "text_preview": "Folder(File)\\n     */\\n    public static final File detectTargetFolder (Class<?> anchor) {\\n    \treturn detectTargetFolder(getClassContainerLocationFile(anchor));\\n    }\\n\\n    /**\\n     * @param anchorFile An anchor {@link File) we want to use\\n     * as the starting point for the &quot;target&quot; folder lookup up the\\n     "
  },
  {
    "method_id": "M4437",
    "name": "catch",
    "return_type": "",
    "signature": "catch(URISyntaxException e)",
    "file_id": "F175",
    "start_line": 184,
    "text_preview": "        URI uri=getClassContainerLocationURI(clazz);\\n            return (uri == null) ? null : new File(uri);\\n        } catch(URISyntaxException e) {\\n            throw new IllegalArgumentException(e.getClass().getSimpleName() + \": \" + e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * @param clazz A {@link Class} obje"
  },
  {
    "method_id": "M4438",
    "name": "getClassContainerLocationURI",
    "return_type": "URI",
    "signature": "getClassContainerLocationURI(Class<?> clazz)",
    "file_id": "F175",
    "start_line": 176,
    "text_preview": "e resolved\\n     * @throws IllegalArgumentException If location is not a valid\\n     * {@link File} location\\n     * @see #getClassContainerLocationURI(Class)\\n     * @see File#File(URI)\\n     */\\n    public static File getClassContainerLocationFile (Class<?> clazz)\\n            throws IllegalArgumentException {\\n        try {"
  },
  {
    "method_id": "M4439",
    "name": "getClassContainerLocationURL",
    "return_type": "URL",
    "signature": "getClassContainerLocationURL(Class<?> clazz)",
    "file_id": "F175",
    "start_line": 195,
    "text_preview": "</code> if location could not be resolved\\n     * @throws URISyntaxException if location is not a valid URI\\n     * @see #getClassContainerLocationURL(Class)\\n     */\\n    public static URI getClassContainerLocationURI (Class<?> clazz) throws URISyntaxException {\\n        URL url=getClassContainerLocationURL(clazz);\\n       "
  },
  {
    "method_id": "M4440",
    "name": "if",
    "return_type": "",
    "signature": "if(url == null)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4441",
    "name": "catch",
    "return_type": "",
    "signature": "catch(MalformedURLException e)",
    "file_id": "F175",
    "start_line": 184,
    "text_preview": "        URI uri=getClassContainerLocationURI(clazz);\\n            return (uri == null) ? null : new File(uri);\\n        } catch(URISyntaxException e) {\\n            throw new IllegalArgumentException(e.getClass().getSimpleName() + \": \" + e.getMessage(), e);\\n        }\\n    }\\n\\n    /**\\n     * @param clazz A {@link Class} obje"
  },
  {
    "method_id": "M4442",
    "name": "getDefaultClassLoader",
    "return_type": "ClassLoader",
    "signature": "getDefaultClassLoader(Class<?> anchor)",
    "file_id": "F175",
    "start_line": 213,
    "text_preview": "ource();\\n        URL\t\t\t\t\turl=(cs == null) ? null : cs.getLocation();\\n        if (url == null) {\\n        \tClassLoader\tcl=getDefaultClassLoader(clazz);\\n        \tString\t\tclassName=clazz.getName().replace('.', '/') + \".class\";\\n        \tif ((url=cl.getResource(className)) == null) {\\n        \t\treturn null;\\n        \t}\\n\\n      "
  },
  {
    "method_id": "M4443",
    "name": "if",
    "return_type": "",
    "signature": "if(anchor == null)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4444",
    "name": "if",
    "return_type": "",
    "signature": "if(cl == null)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4445",
    "name": "if",
    "return_type": "",
    "signature": "if(cl == null)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4446",
    "name": "getURLSource",
    "return_type": "String",
    "signature": "getURLSource(File file)",
    "file_id": "F175",
    "start_line": 219,
    "text_preview": "ss\";\\n        \tif ((url=cl.getResource(className)) == null) {\\n        \t\treturn null;\\n        \t}\\n\\n        \tString\tsrcForm=getURLSource(url);\\n        \tif (LangUtil.isEmpty(srcForm)) {\\n        \t\treturn null;\\n        \t}\\n\\n        \ttry {\\n        \t\turl = new URL(srcForm);\\n        \t} catch(MalformedURLException e) {\\n        \t\tt"
  },
  {
    "method_id": "M4447",
    "name": "getURLSource",
    "return_type": "String",
    "signature": "getURLSource(URI uri)",
    "file_id": "F175",
    "start_line": 219,
    "text_preview": "ss\";\\n        \tif ((url=cl.getResource(className)) == null) {\\n        \t\treturn null;\\n        \t}\\n\\n        \tString\tsrcForm=getURLSource(url);\\n        \tif (LangUtil.isEmpty(srcForm)) {\\n        \t\treturn null;\\n        \t}\\n\\n        \ttry {\\n        \t\turl = new URL(srcForm);\\n        \t} catch(MalformedURLException e) {\\n        \t\tt"
  },
  {
    "method_id": "M4448",
    "name": "getURLSource",
    "return_type": "String",
    "signature": "getURLSource(URL url)",
    "file_id": "F175",
    "start_line": 219,
    "text_preview": "ss\";\\n        \tif ((url=cl.getResource(className)) == null) {\\n        \t\treturn null;\\n        \t}\\n\\n        \tString\tsrcForm=getURLSource(url);\\n        \tif (LangUtil.isEmpty(srcForm)) {\\n        \t\treturn null;\\n        \t}\\n\\n        \ttry {\\n        \t\turl = new URL(srcForm);\\n        \t} catch(MalformedURLException e) {\\n        \t\tt"
  },
  {
    "method_id": "M4449",
    "name": "getURLSource",
    "return_type": "String",
    "signature": "getURLSource(String externalForm)",
    "file_id": "F175",
    "start_line": 219,
    "text_preview": "ss\";\\n        \tif ((url=cl.getResource(className)) == null) {\\n        \t\treturn null;\\n        \t}\\n\\n        \tString\tsrcForm=getURLSource(url);\\n        \tif (LangUtil.isEmpty(srcForm)) {\\n        \t\treturn null;\\n        \t}\\n\\n        \ttry {\\n        \t\turl = new URL(srcForm);\\n        \t} catch(MalformedURLException e) {\\n        \t\tt"
  },
  {
    "method_id": "M4450",
    "name": "if",
    "return_type": "",
    "signature": "if(sepPos < 0)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4451",
    "name": "adjustURLPathValue",
    "return_type": "String",
    "signature": "adjustURLPathValue(final String path)",
    "file_id": "F175",
    "start_line": 309,
    "text_preview": "\\n    \t\treturn url;\\n    \t}\\n\\n    \tint\tsepPos=url.indexOf(RESOURCE_SUBPATH_SEPARATOR);\\n    \tif (sepPos < 0) {\\n    \t\treturn adjustURLPathValue(url);\\n    \t} else {\\n    \t\treturn adjustURLPathValue(url.substring(0, sepPos));\\n    \t}\\n    }\\n\\n    /**\\n     * @param path A URL path value\\n     * @return The path after stripping any "
  },
  {
    "method_id": "M4452",
    "name": "adjustURLPathValue",
    "return_type": "String",
    "signature": "adjustURLPathValue(URL url)",
    "file_id": "F175",
    "start_line": 309,
    "text_preview": "\\n    \t\treturn url;\\n    \t}\\n\\n    \tint\tsepPos=url.indexOf(RESOURCE_SUBPATH_SEPARATOR);\\n    \tif (sepPos < 0) {\\n    \t\treturn adjustURLPathValue(url);\\n    \t} else {\\n    \t\treturn adjustURLPathValue(url.substring(0, sepPos));\\n    \t}\\n    }\\n\\n    /**\\n     * @param path A URL path value\\n     * @return The path after stripping any "
  },
  {
    "method_id": "M4453",
    "name": "stripJarURLPrefix",
    "return_type": "String",
    "signature": "stripJarURLPrefix(String externalForm)",
    "file_id": "F175",
    "start_line": 302,
    "text_preview": "tring externalForm) {\\n\t\tString\turl=externalForm;\\n    \tif (LangUtil.isEmpty(url)) {\\n    \t\treturn url;\\n    \t}\\n\\n    \turl = stripJarURLPrefix(externalForm);\\n    \tif (LangUtil.isEmpty(url)){\\n    \t\treturn url;\\n    \t}\\n\\n    \tint\tsepPos=url.indexOf(RESOURCE_SUBPATH_SEPARATOR);\\n    \tif (sepPos < 0) {\\n    \t\treturn adjustURLPathVa"
  },
  {
    "method_id": "M4454",
    "name": "writeIndex",
    "return_type": "void",
    "signature": "writeIndex(File indexFile, IndexEntry ... entries)",
    "file_id": "F175",
    "start_line": 347,
    "text_preview": "l;\\n\t}\\n\\n    protected static final void writeIndex (File indexFile, IndexEntry ... entries) throws IOException {\\n        writeIndex(indexFile, LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));\\n    }\\n\\n    protected static final void writeIndex (File indexFile, Collection<? extends"
  },
  {
    "method_id": "M4455",
    "name": "writeIndex",
    "return_type": "void",
    "signature": "writeIndex(File indexFile, Collection<? extends IndexEntry> entries)",
    "file_id": "F175",
    "start_line": 347,
    "text_preview": "l;\\n\t}\\n\\n    protected static final void writeIndex (File indexFile, IndexEntry ... entries) throws IOException {\\n        writeIndex(indexFile, LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));\\n    }\\n\\n    protected static final void writeIndex (File indexFile, Collection<? extends"
  },
  {
    "method_id": "M4456",
    "name": "assertArrayEquals",
    "return_type": "void",
    "signature": "assertArrayEquals(String msg, byte[] expected, byte[] actual)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4457",
    "name": "for",
    "return_type": "",
    "signature": "for(int\tindex=0; index < eLen; index++)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4458",
    "name": "if",
    "return_type": "",
    "signature": "if(eb != ab)",
    "file_id": "F175",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4459",
    "name": "AsynchronousFileCacheBackingTestSupport",
    "return_type": "",
    "signature": "AsynchronousFileCacheBackingTestSupport()",
    "file_id": "F176",
    "start_line": 37,
    "text_preview": "te[]    bytes=new byte[Byte.MAX_VALUE];\\n    protected final Random    random=new Random(System.nanoTime());\\n\\n\tprotected AsynchronousFileCacheBackingTestSupport() {\\n\t\tsuper();\\n\t}\\n\\n\tprotected AsynchronousFileCacheBackingTestSupport(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n    @Override\\n    public void setUp () throws Exception "
  },
  {
    "method_id": "M4460",
    "name": "AsynchronousFileCacheBackingTestSupport",
    "return_type": "",
    "signature": "AsynchronousFileCacheBackingTestSupport(String name)",
    "file_id": "F176",
    "start_line": 37,
    "text_preview": "te[]    bytes=new byte[Byte.MAX_VALUE];\\n    protected final Random    random=new Random(System.nanoTime());\\n\\n\tprotected AsynchronousFileCacheBackingTestSupport() {\\n\t\tsuper();\\n\t}\\n\\n\tprotected AsynchronousFileCacheBackingTestSupport(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n    @Override\\n    public void setUp () throws Exception "
  },
  {
    "method_id": "M4461",
    "name": "setUp",
    "return_type": "void",
    "signature": "setUp()",
    "file_id": "F176",
    "start_line": 47,
    "text_preview": "ckingTestSupport(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n    @Override\\n    public void setUp () throws Exception {\\n    \tsuper.setUp();\\n    \tcleanupCache();\\n\\n        random.nextBytes(bytes);\\n    }\\n\\n    @Override\\n    public void tearDown () throws Exception {\\n    \tcleanupCache();\\n    \tsuper.tearDown();\\n    }\\n\\n    protected voi"
  },
  {
    "method_id": "M4462",
    "name": "tearDown",
    "return_type": "void",
    "signature": "tearDown()",
    "file_id": "F176",
    "start_line": 56,
    "text_preview": "m.nextBytes(bytes);\\n    }\\n\\n    @Override\\n    public void tearDown () throws Exception {\\n    \tcleanupCache();\\n    \tsuper.tearDown();\\n    }\\n\\n    protected void cleanupCache() {\\n    \tif (indexFile != null) {\\n    \t\tif (FileUtil.deleteContents(indexFile) > 0) {\\n    \t\t\tSystem.out.println(\"Deleted index file: \" + indexFile);\\n"
  },
  {
    "method_id": "M4463",
    "name": "cleanupCache",
    "return_type": "void",
    "signature": "cleanupCache()",
    "file_id": "F176",
    "start_line": 48,
    "text_preview": "rt(String name) {\\n\t\tsuper(name);\\n\t}\\n\\n    @Override\\n    public void setUp () throws Exception {\\n    \tsuper.setUp();\\n    \tcleanupCache();\\n\\n        random.nextBytes(bytes);\\n    }\\n\\n    @Override\\n    public void tearDown () throws Exception {\\n    \tcleanupCache();\\n    \tsuper.tearDown();\\n    }\\n\\n    protected void cleanupCache"
  },
  {
    "method_id": "M4464",
    "name": "if",
    "return_type": "",
    "signature": "if(indexFile != null)",
    "file_id": "F176",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4465",
    "name": "if",
    "return_type": "",
    "signature": "if(cacheDir != null)",
    "file_id": "F176",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4466",
    "name": "getIndexFile",
    "return_type": "File",
    "signature": "getIndexFile()",
    "file_id": "F176",
    "start_line": 103,
    "text_preview": ",\\n                createIndexEntry(\"generated-empty\", true, false, bytes, bytes)\\n            };\\n        File\tcacheIndex=getIndexFile();\\n        writeIndex(cacheIndex, entries);\\n        assertTrue(\"No initial index file available: \" + cacheIndex, cacheIndex.canRead());\\n\\n        AsynchronousFileCacheBacking    cache=crea"
  },
  {
    "method_id": "M4467",
    "name": "if",
    "return_type": "",
    "signature": "if(indexFile == null)",
    "file_id": "F176",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4468",
    "name": "getCacheDir",
    "return_type": "File",
    "signature": "getCacheDir()",
    "file_id": "F176",
    "start_line": 80,
    "text_preview": "  \t\tcacheDir = null;\\n    \t}\\n    }\\n\\n    protected File getIndexFile () {\\n    \tif (indexFile == null) {\\n    \t\tFile\tparent=getCacheDir();\\n    \t\tindexFile=new File(parent, AbstractIndexedFileCacheBacking.INDEX_FILE);\\n    \t}\\n\\n    \treturn indexFile;\\n    }\\n\\n    protected File getCacheDir () {\\n    \tif (cacheDir == null) {\\n    "
  },
  {
    "method_id": "M4469",
    "name": "if",
    "return_type": "",
    "signature": "if(cacheDir == null)",
    "file_id": "F176",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4470",
    "name": "testDeleteIndexFileOnEmptyIndex",
    "return_type": "void",
    "signature": "testDeleteIndexFileOnEmptyIndex()",
    "file_id": "F176",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4471",
    "name": "generateNewBytes",
    "return_type": "long",
    "signature": "generateNewBytes()",
    "file_id": "F176",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4472",
    "name": "createDataFiles",
    "return_type": "File>",
    "signature": "createDataFiles(IndexEntry ... entries)",
    "file_id": "F176",
    "start_line": 135,
    "text_preview": "rc;\\n    }\\n\\n    protected Map<String, File> createDataFiles (IndexEntry ... entries) throws IOException {\\n        return createDataFiles(LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));\\n    }\\n\\n    protected Map<String, File> createDataFiles (Collection<? extends IndexEntry> entr"
  },
  {
    "method_id": "M4473",
    "name": "createDataFiles",
    "return_type": "File>",
    "signature": "createDataFiles(Collection<? extends IndexEntry> entries)",
    "file_id": "F176",
    "start_line": 135,
    "text_preview": "rc;\\n    }\\n\\n    protected Map<String, File> createDataFiles (IndexEntry ... entries) throws IOException {\\n        return createDataFiles(LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));\\n    }\\n\\n    protected Map<String, File> createDataFiles (Collection<? extends IndexEntry> entr"
  },
  {
    "method_id": "M4474",
    "name": "for",
    "return_type": "",
    "signature": "for(IndexEntry entry : entries)",
    "file_id": "F176",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4475",
    "name": "if",
    "return_type": "",
    "signature": "if(file != null)",
    "file_id": "F176",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4476",
    "name": "createDataFile",
    "return_type": "File",
    "signature": "createDataFile(IndexEntry entry)",
    "file_id": "F176",
    "start_line": 145,
    "text_preview": "\\n        Map<String, File>  files= new TreeMap<>();\\n        for (IndexEntry entry : entries) {\\n            File    file=createDataFile(entry);\\n            if (file != null) {\\n                files.put(entry.key, file);\\n            }\\n        }\\n\\n        return files;\\n    }\\n\\n    protected File createDataFile (IndexEntry e"
  },
  {
    "method_id": "M4477",
    "name": "createDataFile",
    "return_type": "File",
    "signature": "createDataFile(IndexEntry entry, byte[] dataBytes)",
    "file_id": "F176",
    "start_line": 145,
    "text_preview": "\\n        Map<String, File>  files= new TreeMap<>();\\n        for (IndexEntry entry : entries) {\\n            File    file=createDataFile(entry);\\n            if (file != null) {\\n                files.put(entry.key, file);\\n            }\\n        }\\n\\n        return files;\\n    }\\n\\n    protected File createDataFile (IndexEntry e"
  },
  {
    "method_id": "M4478",
    "name": "createDataFile",
    "return_type": "File",
    "signature": "createDataFile(String key, byte[] dataBytes)",
    "file_id": "F176",
    "start_line": 145,
    "text_preview": "\\n        Map<String, File>  files= new TreeMap<>();\\n        for (IndexEntry entry : entries) {\\n            File    file=createDataFile(entry);\\n            if (file != null) {\\n                files.put(entry.key, file);\\n            }\\n        }\\n\\n        return files;\\n    }\\n\\n    protected File createDataFile (IndexEntry e"
  },
  {
    "method_id": "M4479",
    "name": "createIgnoredEntry",
    "return_type": "IndexEntry",
    "signature": "createIgnoredEntry(String key)",
    "file_id": "F176",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4480",
    "name": "createIndexEntry",
    "return_type": "IndexEntry",
    "signature": "createIndexEntry(String key, boolean generated, boolean ignored, byte[] bytes, byte[] originalBytes)",
    "file_id": "F176",
    "start_line": 100,
    "text_preview": "    public void testDeleteIndexFileOnEmptyIndex () throws Exception {\\n        IndexEntry[]    entries={\\n                createIndexEntry(\"weaved-empty\", false, false, bytes, bytes),\\n                createIndexEntry(\"generated-empty\", true, false, bytes, bytes)\\n            };\\n        File\tcacheIndex=getIndexFile();\\n    "
  },
  {
    "method_id": "M4481",
    "name": "if",
    "return_type": "",
    "signature": "if(ignored)",
    "file_id": "F176",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4482",
    "name": "BasicTestCL",
    "return_type": "",
    "signature": "BasicTestCL()",
    "file_id": "F177",
    "start_line": 44,
    "text_preview": "\\n\t}\\n\\n\\n\tpublic void testNonURLClassLoaderScope() throws Exception {\\n\t\tString scope = resolver.createClassLoaderScope(new BasicTestCL(), Collections.<String>emptyList());\\n\t\tassertTrue(scope.startsWith(BasicTestCL.class.getSimpleName()));\\n\t}\\n\\n\tpublic void testCreateURLClassLoaderScope() throws Exception {\\n\t\tURL testURLA ="
  },
  {
    "method_id": "M4483",
    "name": "URLTestCL",
    "return_type": "",
    "signature": "URLTestCL(URL... urls)",
    "file_id": "F177",
    "start_line": 37,
    "text_preview": " extends ClassLoader {\\n\t\tpublic BasicTestCL () {\\n\t\t\tsuper();\\n\t\t}\\n\t}\\n\\n\tclass URLTestCL extends URLClassLoader {\\n\t\tpublic URLTestCL(URL... urls) {\\n\t\t\tsuper(urls);\\n\t\t}\\n\t}\\n\\n\\n\tpublic void testNonURLClassLoaderScope() throws Exception {\\n\t\tString scope = resolver.createClassLoaderScope(new BasicTestCL(), Collections.<String>e"
  },
  {
    "method_id": "M4484",
    "name": "testNonURLClassLoaderScope",
    "return_type": "void",
    "signature": "testNonURLClassLoaderScope()",
    "file_id": "F177",
    "start_line": 43,
    "text_preview": "}\\n\t}\\n\\n\tclass URLTestCL extends URLClassLoader {\\n\t\tpublic URLTestCL(URL... urls) {\\n\t\t\tsuper(urls);\\n\t\t}\\n\t}\\n\\n\\n\tpublic void testNonURLClassLoaderScope() throws Exception {\\n\t\tString scope = resolver.createClassLoaderScope(new BasicTestCL(), Collections.<String>emptyList());\\n\t\tassertTrue(scope.startsWith(BasicTestCL.class.ge"
  },
  {
    "method_id": "M4485",
    "name": "testCreateURLClassLoaderScope",
    "return_type": "void",
    "signature": "testCreateURLClassLoaderScope()",
    "file_id": "F177",
    "start_line": 48,
    "text_preview": ", Collections.<String>emptyList());\\n\t\tassertTrue(scope.startsWith(BasicTestCL.class.getSimpleName()));\\n\t}\\n\\n\tpublic void testCreateURLClassLoaderScope() throws Exception {\\n\t\tURL testURLA = new URL(\"https://example.com\");\\n\t\tURL testURLB = new URL(\"file:///tmp\");\\n\t\tURL testURLC = new URL(\"ftp://ftp.example.com\");\\n\t\tURLTes"
  },
  {
    "method_id": "M4486",
    "name": "testCreateGeneratedCacheKey",
    "return_type": "void",
    "signature": "testCreateGeneratedCacheKey()",
    "file_id": "F177",
    "start_line": 80,
    "text_preview": "copeABa2));\\n\t\tassertFalse(scopeBCa.equals(scopeBCa2));\\n\t\tassertFalse(scopeBC2a.equals(scopeBC2a2));\\n\\n\\n\t}\\n\\n\\n\tpublic void testCreateGeneratedCacheKey() throws Exception {\\n\t\tCachedClassReference ref = resolver.generatedKey(FAKE_CLASS);\\n\t\tassertTrue(ref.getKey().startsWith(FAKE_CLASS));\\n\t\tassertTrue(ref.getKey().matches(re"
  },
  {
    "method_id": "M4487",
    "name": "testCreateCacheKey",
    "return_type": "void",
    "signature": "testCreateCacheKey()",
    "file_id": "F177",
    "start_line": 87,
    "text_preview": "matches(resolver.getGeneratedRegex()));\\n\t\tassertEquals(FAKE_CLASS, resolver.keyToClass(ref.getKey()));\\n\t}\\n\\n\tpublic void testCreateCacheKey() throws Exception {\\n\t\t// crc hashing\\n\t\tCachedClassReference ref = resolver.weavedKey(FAKE_CLASS, FAKE_BYTES);\\n\t\tassertTrue(\"key \" + ref.getKey() + \" does not match \" + resolver.get"
  },
  {
    "method_id": "M4488",
    "name": "DefaultFileCacheBackingTest",
    "return_type": "",
    "signature": "DefaultFileCacheBackingTest()",
    "file_id": "F178",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4489",
    "name": "testCreateBacking",
    "return_type": "void",
    "signature": "testCreateBacking()",
    "file_id": "F178",
    "start_line": 35,
    "text_preview": ";\\n\tprivate final String\tfakeKey=fakeRef.getKey();\\n\\n\tpublic DefaultFileCacheBackingTest () {\\n\t\tsuper();\\n\t}\\n\\n\tpublic void testCreateBacking() throws Exception {\\n\t\tCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\\n\t\tassertNotNull(backing);\\n\t\tassertTrue(\"Root folder not created: \" + root, root.exists());\\n"
  },
  {
    "method_id": "M4490",
    "name": "testClear",
    "return_type": "void",
    "signature": "testClear()",
    "file_id": "F178",
    "start_line": 42,
    "text_preview": "d: \" + root, root.exists());\\n\t\tassertTrue(\"Root folder not a directory: \" + root, root.isDirectory());\\n\t}\\n\\n\tpublic void testClear() {\\n\t\tCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\\n\t\tbacking.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED), FAKE_BYTES);\\n\t\tassertNot"
  },
  {
    "method_id": "M4491",
    "name": "createTestEntry",
    "return_type": "CachedClassEntry",
    "signature": "createTestEntry(String key)",
    "file_id": "F178",
    "start_line": 50,
    "text_preview": "fakeRef, FAKE_BYTES));\\n\t\tbacking.clear();\\n\t\tassertNull(backing.get(fakeRef, FAKE_BYTES));\\n\t}\\n\\n\tprivate CachedClassEntry createTestEntry(String key) {\\n\t\treturn new CachedClassEntry(new CachedClassReference(key, key), FAKE_BYTES, CachedClassEntry.EntryType.WEAVED);\\n\t}\\n\\n\tpublic void testGetKeys() throws Exception {\\n\t\tCach"
  },
  {
    "method_id": "M4492",
    "name": "testGetKeys",
    "return_type": "void",
    "signature": "testGetKeys()",
    "file_id": "F178",
    "start_line": 54,
    "text_preview": "w CachedClassEntry(new CachedClassReference(key, key), FAKE_BYTES, CachedClassEntry.EntryType.WEAVED);\\n\t}\\n\\n\tpublic void testGetKeys() throws Exception {\\n\t\tCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\\n\t\tbacking.put(createTestEntry(\"apple\"), FAKE_BYTES);\\n\t\tbacking.put(createTestEntry(\"apply\"), FAKE"
  },
  {
    "method_id": "M4493",
    "name": "testPut",
    "return_type": "void",
    "signature": "testPut()",
    "file_id": "F178",
    "start_line": 66,
    "text_preview": " = backing.getKeys(\"orange\");\\n\t\tassertEquals(1, matches.length);\\n\t\tassertEquals(\"orange\", matches[0]);\\n\t}\\n\\n\tpublic void testPut() throws Exception {\\n\t\tCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\\n\t\tbacking.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED), FAKE_BYTE"
  },
  {
    "method_id": "M4494",
    "name": "testGet",
    "return_type": "void",
    "signature": "testGet()",
    "file_id": "F178",
    "start_line": 75,
    "text_preview": ".exists());\\n\t\tassertTrue(cachedFile.isFile());\\n\t\tassertEquals(FAKE_BYTES.length, cachedFile.length());\\n\t}\\n\\n\tpublic void testGet() throws Exception {\\n\t\tDefaultFileCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\\n\t\tassertNull(backing.get(fakeRef, FAKE_BYTES));\\n\t\tbacking.put(new CachedClassEntry(fakeRef"
  },
  {
    "method_id": "M4495",
    "name": "testRemove",
    "return_type": "void",
    "signature": "testRemove()",
    "file_id": "F178",
    "start_line": 89,
    "text_preview": " entry = backing.get(fakeRef, FAKE_BYTES);\\n\t\tassertEquals(FAKE_BYTES.length, entry.getBytes().length);\\n\t}\\n\\n\tpublic void testRemove() throws Exception {\\n\t\tDefaultFileCacheBacking backing = DefaultFileCacheBacking.createBacking(root);\\n\t\tbacking.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAV"
  },
  {
    "method_id": "M4496",
    "name": "testMultiFile",
    "return_type": "void",
    "signature": "testMultiFile()",
    "file_id": "F178",
    "start_line": 105,
    "text_preview": "rtFalse(\"Cached entry index not removed\", indexEntryExists(backing, fakeKey, expectedCRC.getValue()));\\n\t}\\n\\n\tpublic void testMultiFile() throws Exception {\\n\t\tCachedClassEntry entry;\\n\t\tFile cachedFile;\\n\t\tCRC32 expectedCRC = new CRC32();\\n\t\texpectedCRC.update(FAKE_BYTES);\\n\t\tDefaultFileCacheBacking backing = DefaultFileCach"
  },
  {
    "method_id": "M4497",
    "name": "testOriginalClassBytesChanged",
    "return_type": "void",
    "signature": "testOriginalClassBytesChanged()",
    "file_id": "F178",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4498",
    "name": "for",
    "return_type": "",
    "signature": "for(int index=0; index < FAKE_BYTES.length; index++)",
    "file_id": "F178",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4499",
    "name": "indexEntryExists",
    "return_type": "boolean",
    "signature": "indexEntryExists(AbstractIndexedFileCacheBacking cache, String key, long expectedCRC)",
    "file_id": "F178",
    "start_line": 84,
    "text_preview": "E_BYTES.length, cachedFile.length());\\n\t\tCRC32 expectedCRC = new CRC32();\\n\t\texpectedCRC.update(FAKE_BYTES);\\n\t\tassertTrue(indexEntryExists(backing, fakeKey, expectedCRC.getValue()));\\n\t\tCachedClassEntry entry = backing.get(fakeRef, FAKE_BYTES);\\n\t\tassertEquals(FAKE_BYTES.length, entry.getBytes().length);\\n\t}\\n\\n\tpublic void t"
  },
  {
    "method_id": "M4500",
    "name": "for",
    "return_type": "",
    "signature": "for(IndexEntry ie : index)",
    "file_id": "F178",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4501",
    "name": "if",
    "return_type": "",
    "signature": "if(!ie.ignored)",
    "file_id": "F178",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4502",
    "name": "FlatFileCacheBackingTest",
    "return_type": "",
    "signature": "FlatFileCacheBackingTest()",
    "file_id": "F179",
    "start_line": 29,
    "text_preview": "thor Lyor Goldstein\\n */\\npublic class FlatFileCacheBackingTest extends AsynchronousFileCacheBackingTestSupport {\\n\tpublic FlatFileCacheBackingTest() {\\n\t\tsuper();\\n\t}\\n\\n\t@Override\\n\tprotected FlatFileCacheBacking createFileBacking(File dir) {\\n\t\treturn new FlatFileCacheBacking(dir);\\n\t}\\n\\n\tpublic void testReadIndex() throws IOE"
  },
  {
    "method_id": "M4503",
    "name": "createFileBacking",
    "return_type": "FlatFileCacheBacking",
    "signature": "createFileBacking(File dir)",
    "file_id": "F179",
    "start_line": 34,
    "text_preview": "acheBackingTestSupport {\\n\tpublic FlatFileCacheBackingTest() {\\n\t\tsuper();\\n\t}\\n\\n\t@Override\\n\tprotected FlatFileCacheBacking createFileBacking(File dir) {\\n\t\treturn new FlatFileCacheBacking(dir);\\n\t}\\n\\n\tpublic void testReadIndex() throws IOException {\\n\t\tIndexEntry[] entries = { createIgnoredEntry(\"ignored\"), createIndexEntry(\""
  },
  {
    "method_id": "M4504",
    "name": "testReadIndex",
    "return_type": "void",
    "signature": "testReadIndex()",
    "file_id": "F179",
    "start_line": 38,
    "text_preview": "\\n\tprotected FlatFileCacheBacking createFileBacking(File dir) {\\n\t\treturn new FlatFileCacheBacking(dir);\\n\t}\\n\\n\tpublic void testReadIndex() throws IOException {\\n\t\tIndexEntry[] entries = { createIgnoredEntry(\"ignored\"), createIndexEntry(\"weaved\", false, false, bytes, bytes),\\n\t\t\t\tcreateIndexEntry(\"generated\", true, false, by"
  },
  {
    "method_id": "M4505",
    "name": "for",
    "return_type": "",
    "signature": "for(IndexEntry entry : entries)",
    "file_id": "F179",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4506",
    "name": "if",
    "return_type": "",
    "signature": "if(entry.ignored)",
    "file_id": "F179",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4507",
    "name": "testIgnoredBadCrcDataFiles",
    "return_type": "void",
    "signature": "testIgnoredBadCrcDataFiles()",
    "file_id": "F179",
    "start_line": 65,
    "text_preview": "else {\\n\t\t\t\tassertArrayEquals(\"Mismatched contents for key=\" + key, bytes, bytesMap.get(key));\\n\t\t\t}\\n\t\t}\\n\t}\\n\\n\tpublic void testIgnoredBadCrcDataFiles() throws Exception {\\n\t\tIndexEntry[] entries = { createIndexEntry(\"weaved-goodData\", false, false, bytes, bytes),\\n\t\t\t\tcreateIndexEntry(\"badData-weaved\", false, false, bytes, "
  },
  {
    "method_id": "M4508",
    "name": "for",
    "return_type": "",
    "signature": "for(IndexEntry entry : entries)",
    "file_id": "F179",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4509",
    "name": "testSkipMissingDataFileOnReadIndex",
    "return_type": "void",
    "signature": "testSkipMissingDataFileOnReadIndex()",
    "file_id": "F179",
    "start_line": 111,
    "text_preview": "file = badEntry.getValue();\\n\t\t\tassertFalse(\"Unexpectedly still readable: \" + key, file.canRead());\\n\t\t}\\n\t}\\n\\n\tpublic void testSkipMissingDataFileOnReadIndex() throws IOException {\\n\t\tIndexEntry[] entries = { createIndexEntry(\"weaved-noData\", false, false, null, null),\\n\t\t\t\tcreateIndexEntry(\"withData-weaved\", false, false, "
  },
  {
    "method_id": "M4510",
    "name": "for",
    "return_type": "",
    "signature": "for(IndexEntry entry : entries)",
    "file_id": "F179",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4511",
    "name": "for",
    "return_type": "",
    "signature": "for(IndexEntry entry : entries)",
    "file_id": "F179",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4512",
    "name": "createCache",
    "return_type": "SimpleCache",
    "signature": "createCache()",
    "file_id": "F180",
    "start_line": 26,
    "text_preview": "2, 3, 4, 5, 6, 7, 8, 9, 10 };\\n\tbyte[] FAKE_WOVEN_BYTES_V2 = { 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\\n\\n\tprivate SimpleCache createCache() {\\n\t\treturn new SimpleCache(System.getProperty(\"java.io.tmpdir\"), true);\\n\t}\\n\\n\tpublic void testCache() {\\n\t\tString classA = \"com.generated.A\";\\n\t\tSimpleCache cache = createCache();\\n\t\tcache.p"
  },
  {
    "method_id": "M4513",
    "name": "testCache",
    "return_type": "void",
    "signature": "testCache()",
    "file_id": "F180",
    "start_line": 30,
    "text_preview": "vate SimpleCache createCache() {\\n\t\treturn new SimpleCache(System.getProperty(\"java.io.tmpdir\"), true);\\n\t}\\n\\n\tpublic void testCache() {\\n\t\tString classA = \"com.generated.A\";\\n\t\tSimpleCache cache = createCache();\\n\t\tcache.put(classA, FAKE_BYTES_V1, FAKE_WOVEN_BYTES_V1);\\n\\n\t\t// Returned woven bytes are the original ones\\n\t\tbyte"
  },
  {
    "method_id": "M4514",
    "name": "testDifferentVersionCache",
    "return_type": "void",
    "signature": "testDifferentVersionCache()",
    "file_id": "F180",
    "start_line": 52,
    "text_preview": "d.A-1164760902\");\\n\t\tassertTrue(\\n\t\t\t\"Class should be backed up with CRC 1164760902\",\\n\t\t\tf.exists()\\n\t\t);\\n\t}\\n\\n\tpublic void testDifferentVersionCache() {\\n\t\tString classA = \"com.generated.A\";\\n\t\tSimpleCache cache = createCache();\\n\t\tcache.put(classA, FAKE_BYTES_V1, FAKE_WOVEN_BYTES_V1);\\n\t\tcache.put(classA, FAKE_BYTES_V2, FAKE"
  },
  {
    "method_id": "M4515",
    "name": "testCacheMiss",
    "return_type": "void",
    "signature": "testCacheMiss()",
    "file_id": "F180",
    "start_line": 77,
    "text_preview": "e[\" + i + \"] should be equal to the original woven class\",\\n\t\t\t\tresult[i], FAKE_WOVEN_BYTES_V2[i]\\n\t\t\t);\\n\t}\\n\\n\tpublic void testCacheMiss() {\\n\t\tString classA = \"com.generated.A\";\\n\t\tSimpleCache cache = createCache();\\n\\n\t\t// Woven bytes not found in cache\\n\t\tassertNull(cache.getAndInitialize(classA, FAKE_BYTES_V1, null, null))"
  },
  {
    "method_id": "M4516",
    "name": "testCacheHitUnwoven",
    "return_type": "void",
    "signature": "testCacheHitUnwoven()",
    "file_id": "F180",
    "start_line": 85,
    "text_preview": "oven bytes not found in cache\\n\t\tassertNull(cache.getAndInitialize(classA, FAKE_BYTES_V1, null, null));\\n\t}\\n\\n\tpublic void testCacheHitUnwoven() {\\n\t\tString classA = \"com.generated.A\";\\n\t\tSimpleCache cache = createCache();\\n\t\tcache.put(classA, FAKE_BYTES_V1, SimpleCache.SAME_BYTES);\\n\\n\t\t// Returned woven bytes are null, indic"
  },
  {
    "method_id": "M4517",
    "name": "WeavedClassCacheTest",
    "return_type": "",
    "signature": "WeavedClassCacheTest()",
    "file_id": "F181",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4518",
    "name": "getKeys",
    "return_type": "String[]",
    "signature": "getKeys(String regex)",
    "file_id": "F181",
    "start_line": 38,
    "text_preview": "yCacheBacking implements CacheBacking {\\n\t\tHashMap<String, CachedClassEntry> cache = new HashMap<>();\\n\\n\t\tpublic String[] getKeys(String regex) {\\n\t\t\tSet<String> keys = cache.keySet();\\n\t\t\tList<String> matches = new LinkedList<>();\\n\t\t\tfor (String key : keys) {\\n\t\t\t\tif (key.matches(regex)) {\\n\t\t\t\t\tmatches.add(key);\\n\t\t\t\t}\\n\t\t\t}"
  },
  {
    "method_id": "M4519",
    "name": "for",
    "return_type": "",
    "signature": "for(String key : keys)",
    "file_id": "F181",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4520",
    "name": "remove",
    "return_type": "void",
    "signature": "remove(CachedClassReference ref)",
    "file_id": "F181",
    "start_line": 49,
    "text_preview": "f (key.matches(regex)) {\\n\t\t\t\t\tmatches.add(key);\\n\t\t\t\t}\\n\t\t\t}\\n\t\t\treturn matches.toArray(new String[0]);\\n\t\t}\\n\\n\t\tpublic void remove(CachedClassReference ref) {\\n\t\t\tcache.remove(ref.getKey());\\n\t\t}\\n\\n\t\tpublic void clear() {\\n\t\t\tcache.clear();\\n\t\t}\\n\\n\t\tpublic CachedClassEntry get(CachedClassReference ref, byte[] originalBytes) {\\n\t\t"
  },
  {
    "method_id": "M4521",
    "name": "clear",
    "return_type": "void",
    "signature": "clear()",
    "file_id": "F181",
    "start_line": 53,
    "text_preview": "new String[0]);\\n\t\t}\\n\\n\t\tpublic void remove(CachedClassReference ref) {\\n\t\t\tcache.remove(ref.getKey());\\n\t\t}\\n\\n\t\tpublic void clear() {\\n\t\t\tcache.clear();\\n\t\t}\\n\\n\t\tpublic CachedClassEntry get(CachedClassReference ref, byte[] originalBytes) {\\n\t\t\treturn cache.get(ref.getKey());\\n\t\t}\\n\\n\t\tpublic void put(CachedClassEntry entry, byte["
  },
  {
    "method_id": "M4522",
    "name": "get",
    "return_type": "CachedClassEntry",
    "signature": "get(CachedClassReference ref, byte[] originalBytes)",
    "file_id": "F181",
    "start_line": 57,
    "text_preview": "nce ref) {\\n\t\t\tcache.remove(ref.getKey());\\n\t\t}\\n\\n\t\tpublic void clear() {\\n\t\t\tcache.clear();\\n\t\t}\\n\\n\t\tpublic CachedClassEntry get(CachedClassReference ref, byte[] originalBytes) {\\n\t\t\treturn cache.get(ref.getKey());\\n\t\t}\\n\\n\t\tpublic void put(CachedClassEntry entry, byte[] originalBytes) {\\n\t\t\tassertNotNull(\"put(\" + entry + \") no "
  },
  {
    "method_id": "M4523",
    "name": "put",
    "return_type": "void",
    "signature": "put(CachedClassEntry entry, byte[] originalBytes)",
    "file_id": "F181",
    "start_line": 61,
    "text_preview": "dClassEntry get(CachedClassReference ref, byte[] originalBytes) {\\n\t\t\treturn cache.get(ref.getKey());\\n\t\t}\\n\\n\t\tpublic void put(CachedClassEntry entry, byte[] originalBytes) {\\n\t\t\tassertNotNull(\"put(\" + entry + \") no original bytes\", originalBytes);\\n\t\t\tcache.put(entry.getKey(), entry);\\n\t\t}\\n\t}\\n\\n\tMemoryCacheBacking memoryBack"
  },
  {
    "method_id": "M4524",
    "name": "IMessageHandler",
    "return_type": "new",
    "signature": "IMessageHandler()",
    "file_id": "F181",
    "start_line": 69,
    "text_preview": "), entry);\\n\t\t}\\n\t}\\n\\n\tMemoryCacheBacking memoryBacking = new MemoryCacheBacking();\\n\\n\tIMessageHandler messageHandler = new IMessageHandler() {\\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\\n\t\t\treturn true;\\n\t\t}\\n\\n\t\tpublic boolean isIgnoring(IMessage.Kind kind) {\\n\t\t\treturn true;\\n\t\t}\\n\\n\t\tpublic void d"
  },
  {
    "method_id": "M4525",
    "name": "handleMessage",
    "return_type": "boolean",
    "signature": "handleMessage(IMessage message)",
    "file_id": "F181",
    "start_line": 70,
    "text_preview": "g memoryBacking = new MemoryCacheBacking();\\n\\n\tIMessageHandler messageHandler = new IMessageHandler() {\\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\\n\t\t\treturn true;\\n\t\t}\\n\\n\t\tpublic boolean isIgnoring(IMessage.Kind kind) {\\n\t\t\treturn true;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\\n\t\t\t//"
  },
  {
    "method_id": "M4526",
    "name": "isIgnoring",
    "return_type": "boolean",
    "signature": "isIgnoring(IMessage.Kind kind)",
    "file_id": "F181",
    "start_line": 74,
    "text_preview": "dler() {\\n\t\tpublic boolean handleMessage(IMessage message) throws AbortException {\\n\t\t\treturn true;\\n\t\t}\\n\\n\t\tpublic boolean isIgnoring(IMessage.Kind kind) {\\n\t\t\treturn true;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\\n\t\t\t// do nothing\\n\t\t}\\n\\n\t\tpublic void ignore(IMessage.Kind kind) {\\n\t\t\t// do nothing\\n\t\t}\\n\t};\\n\\n\tpublic "
  },
  {
    "method_id": "M4527",
    "name": "dontIgnore",
    "return_type": "void",
    "signature": "dontIgnore(IMessage.Kind kind)",
    "file_id": "F181",
    "start_line": 78,
    "text_preview": "rtException {\\n\t\t\treturn true;\\n\t\t}\\n\\n\t\tpublic boolean isIgnoring(IMessage.Kind kind) {\\n\t\t\treturn true;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\\n\t\t\t// do nothing\\n\t\t}\\n\\n\t\tpublic void ignore(IMessage.Kind kind) {\\n\t\t\t// do nothing\\n\t\t}\\n\t};\\n\\n\tpublic class TestGeneratedClassHandler implements GeneratedClassHandler {\\n\t"
  },
  {
    "method_id": "M4528",
    "name": "ignore",
    "return_type": "void",
    "signature": "ignore(IMessage.Kind kind)",
    "file_id": "F181",
    "start_line": 82,
    "text_preview": "ge.Kind kind) {\\n\t\t\treturn true;\\n\t\t}\\n\\n\t\tpublic void dontIgnore(IMessage.Kind kind) {\\n\t\t\t// do nothing\\n\t\t}\\n\\n\t\tpublic void ignore(IMessage.Kind kind) {\\n\t\t\t// do nothing\\n\t\t}\\n\t};\\n\\n\tpublic class TestGeneratedClassHandler implements GeneratedClassHandler {\\n\t\tpublic int accepts = 0;\\n\t\tpublic List<String> classesISaw = new Link"
  },
  {
    "method_id": "M4529",
    "name": "acceptClass",
    "return_type": "void",
    "signature": "acceptClass(String name, byte[] originalBytes, byte[] wovenBytes)",
    "file_id": "F181",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4530",
    "name": "createCache",
    "return_type": "WeavedClassCache",
    "signature": "createCache()",
    "file_id": "F181",
    "start_line": 101,
    "text_preview": "ew TestGeneratedClassHandler();\\n\\n\tCacheKeyResolver resolver = new DefaultCacheKeyResolver();\\n\\n\tprivate WeavedClassCache createCache() throws Exception {\\n\t\treturn new WeavedClassCache(generatedClassHandler, messageHandler, \"test\", memoryBacking, resolver);\\n\t}\\n\\n\tprivate void reset() throws Exception {\\n\t\tmemoryBacking.cac"
  },
  {
    "method_id": "M4531",
    "name": "reset",
    "return_type": "void",
    "signature": "reset()",
    "file_id": "F181",
    "start_line": 105,
    "text_preview": "\treturn new WeavedClassCache(generatedClassHandler, messageHandler, \"test\", memoryBacking, resolver);\\n\t}\\n\\n\tprivate void reset() throws Exception {\\n\t\tmemoryBacking.cache.clear();\\n\t\tgeneratedClassHandler.accepts = 0;\\n\t\tgeneratedClassHandler.classesISaw.clear();\\n\t}\\n\\n\tpublic void testGetCachingClassHandler() throws Excepti"
  },
  {
    "method_id": "M4532",
    "name": "testGetCachingClassHandler",
    "return_type": "void",
    "signature": "testGetCachingClassHandler()",
    "file_id": "F181",
    "start_line": 111,
    "text_preview": "cking.cache.clear();\\n\t\tgeneratedClassHandler.accepts = 0;\\n\t\tgeneratedClassHandler.classesISaw.clear();\\n\t}\\n\\n\tpublic void testGetCachingClassHandler() throws Exception {\\n\t\tWeavedClassCache cache = createCache();\\n\t\tGeneratedClassHandler newHandle = cache.getCachingClassHandler();\\n\t\tassertTrue(generatedClassHandler != newH"
  },
  {
    "method_id": "M4533",
    "name": "testCache",
    "return_type": "void",
    "signature": "testCache()",
    "file_id": "F181",
    "start_line": 118,
    "text_preview": "e(generatedClassHandler != newHandle);\\n\t\tassertTrue(newHandle instanceof GeneratedCachedClassHandler);\\n\t}\\n\\n\tpublic void testCache() throws Exception {\\n\t\treset();\\n\t\tWeavedClassCache cache = createCache();\\n\t\tCacheStatistics stats = cache.getStats();\\n\t\tCachedClassReference ref = cache.createCacheKey(FAKE_CLASS, FAKE_BYTES"
  },
  {
    "method_id": "M4534",
    "name": "testRemove",
    "return_type": "void",
    "signature": "testRemove()",
    "file_id": "F181",
    "start_line": 141,
    "text_preview": "FAKE_BYTES).getBytes()));\\n\\n\t\tassertEquals(4, stats.getHits());\\n\t\tassertEquals(2, stats.getMisses());\\n\\n\\n\t}\\n\\n\tpublic void testRemove() throws Exception {\\n\t\treset();\\n\t\tWeavedClassCache cache = createCache();\\n\t\tCachedClassReference ref = cache.createCacheKey(FAKE_CLASS, FAKE_BYTES);\\n\t\tassertNull(cache.get(ref, FAKE_BYTES))"
  },
  {
    "method_id": "M4535",
    "name": "ZippedFileCacheBackingTest",
    "return_type": "",
    "signature": "ZippedFileCacheBackingTest()",
    "file_id": "F182",
    "start_line": 30,
    "text_preview": "ass ZippedFileCacheBackingTest extends AsynchronousFileCacheBackingTestSupport {\\n\tprivate File\tzipTestFile;\\n\\n    public ZippedFileCacheBackingTest() {\\n        super();\\n    }\\n\\n    public void testReadIndex () throws Exception {\\n        IndexEntry[]    entries={\\n                createIgnoredEntry(\"ignored\"),\\n            "
  },
  {
    "method_id": "M4536",
    "name": "testReadIndex",
    "return_type": "void",
    "signature": "testReadIndex()",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4537",
    "name": "for",
    "return_type": "",
    "signature": "for(IndexEntry ie : entries)",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4538",
    "name": "if",
    "return_type": "",
    "signature": "if(ie.ignored)",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4539",
    "name": "for",
    "return_type": "",
    "signature": "for(IndexEntry entry : entries)",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4540",
    "name": "if",
    "return_type": "",
    "signature": "if(entry.ignored)",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4541",
    "name": "testReadWriteZipClassBytes",
    "return_type": "void",
    "signature": "testReadWriteZipClassBytes()",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4542",
    "name": "for",
    "return_type": "",
    "signature": "for(int    index=0; index < Byte.SIZE; index++)",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4543",
    "name": "testReadClassBytes",
    "return_type": "void",
    "signature": "testReadClassBytes()",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4544",
    "name": "for",
    "return_type": "",
    "signature": "for(IndexEntry ie : entries)",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4545",
    "name": "if",
    "return_type": "",
    "signature": "if(ie.ignored)",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4546",
    "name": "getZipFile",
    "return_type": "File",
    "signature": "getZipFile()",
    "file_id": "F182",
    "start_line": 52,
    "text_preview": ") {\\n                continue;\\n            }\\n\\n            entriesMap.put(ie.key, bytes);\\n        }\\n\\n        File\tzipFile=getZipFile();\\n        ZippedFileCacheBacking.writeZipClassBytes(zipFile, entriesMap);\\n\\n        File\t\t\t\t\t\t\tcacheDir=getCacheDir();\\n        AsynchronousFileCacheBacking    cache=createFileBacking(cacheD"
  },
  {
    "method_id": "M4547",
    "name": "if",
    "return_type": "",
    "signature": "if(zipTestFile == null)",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4548",
    "name": "cleanupCache",
    "return_type": "void",
    "signature": "cleanupCache()",
    "file_id": "F182",
    "start_line": 139,
    "text_preview": " File(cacheDir, ZippedFileCacheBacking.ZIP_FILE);\\n    \t}\\n\\n    \treturn zipTestFile;\\n    }\\n\\n    @Override\\n\tprotected void cleanupCache() {\\n\t\tif (zipTestFile != null) {\\n\t\t\tif (FileUtil.deleteContents(zipTestFile) > 0) {\\n\t\t\t\tSystem.out.println(\"Deleted \" + zipTestFile);\\n\t\t\t}\\n\t\t\tzipTestFile = null;\\n\t\t}\\n\\n\t\tsuper.cleanupCache"
  },
  {
    "method_id": "M4549",
    "name": "if",
    "return_type": "",
    "signature": "if(zipTestFile != null)",
    "file_id": "F182",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4550",
    "name": "createFileBacking",
    "return_type": "ZippedFileCacheBacking",
    "signature": "createFileBacking(File dir)",
    "file_id": "F182",
    "start_line": 56,
    "text_preview": "ssBytes(zipFile, entriesMap);\\n\\n        File\t\t\t\t\t\t\tcacheDir=getCacheDir();\\n        AsynchronousFileCacheBacking    cache=createFileBacking(cacheDir);\\n        Map<String, IndexEntry>\t\t\tindexMap=cache.getIndexMap();\\n        assertEquals(\"Mismatched index size\", entries.length, indexMap.size());\\n\\n        Map<String, byte[]"
  },
  {
    "method_id": "M4551",
    "name": "foo",
    "return_type": "String",
    "signature": "foo(Object a)",
    "file_id": "F183",
    "start_line": 20,
    "text_preview": " * @author colyer\\n * Part of the testdata for the org.aspectj.weaver.reflect tests\\n */\\npublic class C {\\n\\n\tpublic String foo(Object a) throws Exception {\\n\t\treturn null;\\n\t}\\n\\n\tprivate void bar() {}\\n\\n\tpublic int f;\\n\tprivate String s;\\n}\\n\\nclass D extends C implements java.io.Serializable {\\n\tpublic int getNumberOfThingies() {"
  },
  {
    "method_id": "M4552",
    "name": "bar",
    "return_type": "void",
    "signature": "bar()",
    "file_id": "F183",
    "start_line": 24,
    "text_preview": "er.reflect tests\\n */\\npublic class C {\\n\\n\tpublic String foo(Object a) throws Exception {\\n\t\treturn null;\\n\t}\\n\\n\tprivate void bar() {}\\n\\n\tpublic int f;\\n\tprivate String s;\\n}\\n\\nclass D extends C implements java.io.Serializable {\\n\tpublic int getNumberOfThingies() { return 0; }\\n\tprivate Object o;\\n}\\n"
  },
  {
    "method_id": "M4553",
    "name": "getNumberOfThingies",
    "return_type": "int",
    "signature": "getNumberOfThingies()",
    "file_id": "F183",
    "start_line": 31,
    "text_preview": "ate void bar() {}\\n\\n\tpublic int f;\\n\tprivate String s;\\n}\\n\\nclass D extends C implements java.io.Serializable {\\n\tpublic int getNumberOfThingies() { return 0; }\\n\tprivate Object o;\\n}\\n"
  },
  {
    "method_id": "M4554",
    "name": "a",
    "return_type": "void",
    "signature": "a(String s)",
    "file_id": "F184",
    "start_line": 15,
    "text_preview": "ent\\n * ******************************************************************/\\npackage test;\\n\\npublic class A {\\n\tpublic void a(String s) {}\\n\tpublic void b(@A1 String s) {}\\n\tpublic void c(@A1 @A2 String s) {}\\n\tpublic void d(@A1 String s,@A2 String t) {}\\n\\n\tpublic void e(A1AnnotatedType s) {}\\n\tpublic void f(A2AnnotatedType s) "
  },
  {
    "method_id": "M4555",
    "name": "b",
    "return_type": "void",
    "signature": "b(@A1 String s)",
    "file_id": "F184",
    "start_line": 16,
    "text_preview": "*********************************************/\\npackage test;\\n\\npublic class A {\\n\tpublic void a(String s) {}\\n\tpublic void b(@A1 String s) {}\\n\tpublic void c(@A1 @A2 String s) {}\\n\tpublic void d(@A1 String s,@A2 String t) {}\\n\\n\tpublic void e(A1AnnotatedType s) {}\\n\tpublic void f(A2AnnotatedType s) {}\\n\tpublic void g(@A2 A1Anno"
  },
  {
    "method_id": "M4556",
    "name": "c",
    "return_type": "void",
    "signature": "c(@A1 @A2 String s)",
    "file_id": "F184",
    "start_line": 17,
    "text_preview": "*************/\\npackage test;\\n\\npublic class A {\\n\tpublic void a(String s) {}\\n\tpublic void b(@A1 String s) {}\\n\tpublic void c(@A1 @A2 String s) {}\\n\tpublic void d(@A1 String s,@A2 String t) {}\\n\\n\tpublic void e(A1AnnotatedType s) {}\\n\tpublic void f(A2AnnotatedType s) {}\\n\tpublic void g(@A2 A1AnnotatedType s) {}\\n\tpublic void h(@"
  },
  {
    "method_id": "M4557",
    "name": "d",
    "return_type": "void",
    "signature": "d(@A1 String s,@A2 String t)",
    "file_id": "F184",
    "start_line": 18,
    "text_preview": " class A {\\n\tpublic void a(String s) {}\\n\tpublic void b(@A1 String s) {}\\n\tpublic void c(@A1 @A2 String s) {}\\n\tpublic void d(@A1 String s,@A2 String t) {}\\n\\n\tpublic void e(A1AnnotatedType s) {}\\n\tpublic void f(A2AnnotatedType s) {}\\n\tpublic void g(@A2 A1AnnotatedType s) {}\\n\tpublic void h(@A1 A1AnnotatedType s) {}\\n\tpublic voi"
  },
  {
    "method_id": "M4558",
    "name": "e",
    "return_type": "void",
    "signature": "e(A1AnnotatedType s)",
    "file_id": "F184",
    "start_line": 20,
    "text_preview": " void b(@A1 String s) {}\\n\tpublic void c(@A1 @A2 String s) {}\\n\tpublic void d(@A1 String s,@A2 String t) {}\\n\\n\tpublic void e(A1AnnotatedType s) {}\\n\tpublic void f(A2AnnotatedType s) {}\\n\tpublic void g(@A2 A1AnnotatedType s) {}\\n\tpublic void h(@A1 A1AnnotatedType s) {}\\n\tpublic void i(A1AnnotatedType s,@A2 String t) {}\\n\tpublic"
  },
  {
    "method_id": "M4559",
    "name": "f",
    "return_type": "void",
    "signature": "f(A2AnnotatedType s)",
    "file_id": "F184",
    "start_line": 21,
    "text_preview": " c(@A1 @A2 String s) {}\\n\tpublic void d(@A1 String s,@A2 String t) {}\\n\\n\tpublic void e(A1AnnotatedType s) {}\\n\tpublic void f(A2AnnotatedType s) {}\\n\tpublic void g(@A2 A1AnnotatedType s) {}\\n\tpublic void h(@A1 A1AnnotatedType s) {}\\n\tpublic void i(A1AnnotatedType s,@A2 String t) {}\\n\tpublic void j(@A1 @A2 String s) {}\\n\\n}\\n"
  },
  {
    "method_id": "M4560",
    "name": "g",
    "return_type": "void",
    "signature": "g(@A2 A1AnnotatedType s)",
    "file_id": "F184",
    "start_line": 22,
    "text_preview": "d(@A1 String s,@A2 String t) {}\\n\\n\tpublic void e(A1AnnotatedType s) {}\\n\tpublic void f(A2AnnotatedType s) {}\\n\tpublic void g(@A2 A1AnnotatedType s) {}\\n\tpublic void h(@A1 A1AnnotatedType s) {}\\n\tpublic void i(A1AnnotatedType s,@A2 String t) {}\\n\tpublic void j(@A1 @A2 String s) {}\\n\\n}\\n"
  },
  {
    "method_id": "M4561",
    "name": "h",
    "return_type": "void",
    "signature": "h(@A1 A1AnnotatedType s)",
    "file_id": "F184",
    "start_line": 23,
    "text_preview": "void e(A1AnnotatedType s) {}\\n\tpublic void f(A2AnnotatedType s) {}\\n\tpublic void g(@A2 A1AnnotatedType s) {}\\n\tpublic void h(@A1 A1AnnotatedType s) {}\\n\tpublic void i(A1AnnotatedType s,@A2 String t) {}\\n\tpublic void j(@A1 @A2 String s) {}\\n\\n}\\n"
  },
  {
    "method_id": "M4562",
    "name": "i",
    "return_type": "void",
    "signature": "i(A1AnnotatedType s,@A2 String t)",
    "file_id": "F184",
    "start_line": 24,
    "text_preview": " f(A2AnnotatedType s) {}\\n\tpublic void g(@A2 A1AnnotatedType s) {}\\n\tpublic void h(@A1 A1AnnotatedType s) {}\\n\tpublic void i(A1AnnotatedType s,@A2 String t) {}\\n\tpublic void j(@A1 @A2 String s) {}\\n\\n}\\n"
  },
  {
    "method_id": "M4563",
    "name": "j",
    "return_type": "void",
    "signature": "j(@A1 @A2 String s)",
    "file_id": "F184",
    "start_line": 25,
    "text_preview": "tatedType s) {}\\n\tpublic void h(@A1 A1AnnotatedType s) {}\\n\tpublic void i(A1AnnotatedType s,@A2 String t) {}\\n\tpublic void j(@A1 @A2 String s) {}\\n\\n}\\n"
  },
  {
    "method_id": "M4564",
    "name": "none",
    "return_type": "void",
    "signature": "none()",
    "file_id": "F190",
    "start_line": 15,
    "text_preview": "****************************************************************/\\npackage test;\\n\\npublic class AnnoValues {\\n\tpublic void none() {}\\n\t@A3 public void defaultMethod() {}\\n\t@A3(Color.GREEN) public void greenMethod() {}\\n\t@A3(Color.RED) public void redMethod() {}\\n\t@A3(Color.BLUE) public void blueMethod() {}\\n}\\n"
  },
  {
    "method_id": "M4565",
    "name": "defaultMethod",
    "return_type": "void",
    "signature": "defaultMethod()",
    "file_id": "F190",
    "start_line": 16,
    "text_preview": "*************************************/\\npackage test;\\n\\npublic class AnnoValues {\\n\tpublic void none() {}\\n\t@A3 public void defaultMethod() {}\\n\t@A3(Color.GREEN) public void greenMethod() {}\\n\t@A3(Color.RED) public void redMethod() {}\\n\t@A3(Color.BLUE) public void blueMethod() {}\\n}\\n"
  },
  {
    "method_id": "M4566",
    "name": "greenMethod",
    "return_type": "void",
    "signature": "greenMethod()",
    "file_id": "F190",
    "start_line": 17,
    "text_preview": "st;\\n\\npublic class AnnoValues {\\n\tpublic void none() {}\\n\t@A3 public void defaultMethod() {}\\n\t@A3(Color.GREEN) public void greenMethod() {}\\n\t@A3(Color.RED) public void redMethod() {}\\n\t@A3(Color.BLUE) public void blueMethod() {}\\n}\\n"
  },
  {
    "method_id": "M4567",
    "name": "redMethod",
    "return_type": "void",
    "signature": "redMethod()",
    "file_id": "F190",
    "start_line": 18,
    "text_preview": "one() {}\\n\t@A3 public void defaultMethod() {}\\n\t@A3(Color.GREEN) public void greenMethod() {}\\n\t@A3(Color.RED) public void redMethod() {}\\n\t@A3(Color.BLUE) public void blueMethod() {}\\n}\\n"
  },
  {
    "method_id": "M4568",
    "name": "blueMethod",
    "return_type": "void",
    "signature": "blueMethod()",
    "file_id": "F190",
    "start_line": 19,
    "text_preview": "\\n\t@A3(Color.GREEN) public void greenMethod() {}\\n\t@A3(Color.RED) public void redMethod() {}\\n\t@A3(Color.BLUE) public void blueMethod() {}\\n}\\n"
  },
  {
    "method_id": "M4569",
    "name": "m1",
    "return_type": "void",
    "signature": "m1()",
    "file_id": "F192",
    "start_line": 7,
    "text_preview": "ort p.SimpleAnnotation;\\n\\n@SimpleAnnotation(id=2)\\npublic class AnnotatedClass {\\n\\n  @SimpleAnnotation(id=3)\\n  public void m1() { }\\n\\n  @SimpleAnnotation(id=4)\\n  int i;\\n}\\n\\n"
  },
  {
    "method_id": "M4570",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] args)",
    "file_id": "F198",
    "start_line": 4,
    "text_preview": "new Error(\"around advice should have applied here\");\\n    }\\n}"
  },
  {
    "method_id": "M4571",
    "name": "method1",
    "return_type": "void",
    "signature": "method1()",
    "file_id": "F201",
    "start_line": 4,
    "text_preview": "ation3(id=2) \\n  public void method2() {\\n  }\\n}\\n"
  },
  {
    "method_id": "M4572",
    "name": "method2",
    "return_type": "void",
    "signature": "method2()",
    "file_id": "F201",
    "start_line": 8,
    "text_preview": "AnnotatedMethods {\\n\\n  @SimpleAnnotation3(id=1)\\n  public void method1() {\\n  }\\n\\n  @SimpleAnnotation3(id=2) \\n  public void method2() {\\n  }\\n}\\n"
  },
  {
    "method_id": "M4573",
    "name": "foo",
    "return_type": "void",
    "signature": "foo()",
    "file_id": "F209",
    "start_line": 3,
    "text_preview": "id run() {};\\n\t\t}.run();\\n\t\t\\n\t\t\\n\t}\\n\t\\n\tclass X {}\\n\t\\n\tstatic class Y {}\\n\t\\n}"
  },
  {
    "method_id": "M4574",
    "name": "Runnable",
    "return_type": "new",
    "signature": "Runnable()",
    "file_id": "F209",
    "start_line": 5,
    "text_preview": "run();\\n\t\t\\n\t\t\\n\t}\\n\t\\n\tclass X {}\\n\t\\n\tstatic class Y {}\\n\t\\n}"
  },
  {
    "method_id": "M4575",
    "name": "run",
    "return_type": "void",
    "signature": "run()",
    "file_id": "F209",
    "start_line": 6,
    "text_preview": "}\\n\t\\n\tstatic class Y {}\\n\t\\n}"
  },
  {
    "method_id": "M4576",
    "name": "m1",
    "return_type": "",
    "signature": "m1()",
    "file_id": "F210",
    "start_line": 5,
    "text_preview": ""
  },
  {
    "method_id": "M4577",
    "name": "m2",
    "return_type": "",
    "signature": "m2()",
    "file_id": "F210",
    "start_line": 6,
    "text_preview": ""
  },
  {
    "method_id": "M4578",
    "name": "m3",
    "return_type": "",
    "signature": "m3(String s)",
    "file_id": "F210",
    "start_line": 7,
    "text_preview": ".util.*;\\n\\npublic aspect AspectFromHell {\\n\\n  public void Foo.m1() {}\\n  public int Foo.m2() {return 2;}\\n  public void Foo.m3(String s) {}\\n  public Foo.new(String s) {super();}\\n  public int Foo.x;\\n  public List Foo.y;\\n\\n\\n  before(): execution(void Goo.m1()) {}\\n  after(): execution(void Goo.m2(String)) { System.err.println("
  },
  {
    "method_id": "M4579",
    "name": "new",
    "return_type": "",
    "signature": "new(String s)",
    "file_id": "F210",
    "start_line": 8,
    "text_preview": "tFromHell {\\n\\n  public void Foo.m1() {}\\n  public int Foo.m2() {return 2;}\\n  public void Foo.m3(String s) {}\\n  public Foo.new(String s) {super();}\\n  public int Foo.x;\\n  public List Foo.y;\\n\\n\\n  before(): execution(void Goo.m1()) {}\\n  after(): execution(void Goo.m2(String)) { System.err.println(thisJoinPoint);}\\n  void aroun"
  },
  {
    "method_id": "M4580",
    "name": "args",
    "return_type": "",
    "signature": "args(i)",
    "file_id": "F210",
    "start_line": 15,
    "text_preview": "xecution(void Goo.m2(String)) { System.err.println(thisJoinPoint);}\\n  void around(int i): execution(void Goo.m3(..)) && args(i) { }\\n\\n  class Goo {\\n    void m1() {}\\n    void m2(String s) {}\\n    void m3(int i) {}\\n  }\\n}\\n\\n  class Foo { }\\n"
  },
  {
    "method_id": "M4581",
    "name": "m1",
    "return_type": "void",
    "signature": "m1()",
    "file_id": "F210",
    "start_line": 5,
    "text_preview": ""
  },
  {
    "method_id": "M4582",
    "name": "m2",
    "return_type": "void",
    "signature": "m2(String s)",
    "file_id": "F210",
    "start_line": 6,
    "text_preview": ""
  },
  {
    "method_id": "M4583",
    "name": "m3",
    "return_type": "void",
    "signature": "m3(int i)",
    "file_id": "F210",
    "start_line": 7,
    "text_preview": ".util.*;\\n\\npublic aspect AspectFromHell {\\n\\n  public void Foo.m1() {}\\n  public int Foo.m2() {return 2;}\\n  public void Foo.m3(String s) {}\\n  public Foo.new(String s) {super();}\\n  public int Foo.x;\\n  public List Foo.y;\\n\\n\\n  before(): execution(void Goo.m1()) {}\\n  after(): execution(void Goo.m2(String)) { System.err.println("
  },
  {
    "method_id": "M4584",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[]argv)",
    "file_id": "F211",
    "start_line": 3,
    "text_preview": "void sayhello() { System.err.println(\"hello\");}\\n    }\\n  }\\n}\\n"
  },
  {
    "method_id": "M4585",
    "name": "sayhello",
    "return_type": "void",
    "signature": "sayhello()",
    "file_id": "F211",
    "start_line": 5,
    "text_preview": "\\n  }\\n}\\n"
  },
  {
    "method_id": "M4586",
    "name": "Runnable",
    "return_type": "new",
    "signature": "Runnable()",
    "file_id": "F212",
    "start_line": 3,
    "text_preview": "\");}\\n    };\\n  public static void main(String[]argv) {\\n  }\\n}\\n"
  },
  {
    "method_id": "M4587",
    "name": "run",
    "return_type": "void",
    "signature": "run()",
    "file_id": "F212",
    "start_line": 4,
    "text_preview": "d main(String[]argv) {\\n  }\\n}\\n"
  },
  {
    "method_id": "M4588",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[]argv)",
    "file_id": "F212",
    "start_line": 6,
    "text_preview": "\\n\\n    Runnable r = new Runnable() {\\n      public void run() { System.err.println(\"hello\");}\\n    };\\n  public static void main(String[]argv) {\\n  }\\n}\\n"
  },
  {
    "method_id": "M4589",
    "name": "getData",
    "return_type": "Vector<String>",
    "signature": "getData()",
    "file_id": "F217",
    "start_line": 5,
    "text_preview": "ctor<String> getData() { return null; }\\n\\n}\\n"
  },
  {
    "method_id": "M4590",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] argv)",
    "file_id": "F218",
    "start_line": 4,
    "text_preview": ""
  },
  {
    "method_id": "M4591",
    "name": "catch",
    "return_type": "",
    "signature": "catch(IOException e)",
    "file_id": "F218",
    "start_line": 11,
    "text_preview": "name = null;\\n\\n        try {\\n\t      System.out.print(\"Please enter your name> \");\\n\t      name = in.readLine();\\n        } catch(IOException e) { return; }\\n          System.out.println(\"Hello, \" + name);\\n      }\\n    }\\n"
  },
  {
    "method_id": "M4592",
    "name": "a",
    "return_type": "void",
    "signature": "a(List<String> List_String)",
    "file_id": "F222",
    "start_line": 5,
    "text_preview": ""
  },
  {
    "method_id": "M4593",
    "name": "b",
    "return_type": "void",
    "signature": "b(List<Double> List_Double)",
    "file_id": "F222",
    "start_line": 7,
    "text_preview": ""
  },
  {
    "method_id": "M4594",
    "name": "c",
    "return_type": "void",
    "signature": "c(List<? extends Number> q_extends_Number)",
    "file_id": "F222",
    "start_line": 9,
    "text_preview": "nericsSigs {\\n\\n  public void a(List<String> List_String) {}\\n\\n  public void b(List<Double> List_Double) {}\\n\\n  public void c(List<? extends Number> q_extends_Number) {}\\n\\n  public void d(List<? super Number> q_super_Number) {}\\n\\n  public void e(List<?> List_q) {}\\n\\n  public void f(Map<?,? super Number> Map_q_q_super_Number) "
  },
  {
    "method_id": "M4595",
    "name": "d",
    "return_type": "void",
    "signature": "d(List<? super Number> q_super_Number)",
    "file_id": "F222",
    "start_line": 11,
    "text_preview": " public void b(List<Double> List_Double) {}\\n\\n  public void c(List<? extends Number> q_extends_Number) {}\\n\\n  public void d(List<? super Number> q_super_Number) {}\\n\\n  public void e(List<?> List_q) {}\\n\\n  public void f(Map<?,? super Number> Map_q_q_super_Number) {}\\n\\n\\n\\n  <T extends Object & Comparable<? super T>> void r(Lis"
  },
  {
    "method_id": "M4596",
    "name": "e",
    "return_type": "void",
    "signature": "e(List<?> List_q)",
    "file_id": "F222",
    "start_line": 13,
    "text_preview": "d c(List<? extends Number> q_extends_Number) {}\\n\\n  public void d(List<? super Number> q_super_Number) {}\\n\\n  public void e(List<?> List_q) {}\\n\\n  public void f(Map<?,? super Number> Map_q_q_super_Number) {}\\n\\n\\n\\n  <T extends Object & Comparable<? super T>> void r(List<T> l) {}\\n\\n  <T extends Object & Comparable<? super T>> "
  },
  {
    "method_id": "M4597",
    "name": "f",
    "return_type": "void",
    "signature": "f(Map<?,? super Number> Map_q_q_super_Number)",
    "file_id": "F222",
    "start_line": 15,
    "text_preview": "_Number) {}\\n\\n  public void d(List<? super Number> q_super_Number) {}\\n\\n  public void e(List<?> List_q) {}\\n\\n  public void f(Map<?,? super Number> Map_q_q_super_Number) {}\\n\\n\\n\\n  <T extends Object & Comparable<? super T>> void r(List<T> l) {}\\n\\n  <T extends Object & Comparable<? super T>> T s(Collection<T> col) {return null;"
  },
  {
    "method_id": "M4598",
    "name": "r",
    "return_type": "void",
    "signature": "r(List<T> l)",
    "file_id": "F222",
    "start_line": 19,
    "text_preview": "{}\\n\\n  public void f(Map<?,? super Number> Map_q_q_super_Number) {}\\n\\n\\n\\n  <T extends Object & Comparable<? super T>> void r(List<T> l) {}\\n\\n  <T extends Object & Comparable<? super T>> T s(Collection<T> col) {return null;}\\n  \\n  static <T extends Comparable<? super Number>> T t(Collection<T> col) {return null;}\\n\\n  static <"
  },
  {
    "method_id": "M4599",
    "name": "s",
    "return_type": "T",
    "signature": "s(Collection<T> col)",
    "file_id": "F222",
    "start_line": 21,
    "text_preview": "{}\\n\\n\\n\\n  <T extends Object & Comparable<? super T>> void r(List<T> l) {}\\n\\n  <T extends Object & Comparable<? super T>> T s(Collection<T> col) {return null;}\\n  \\n  static <T extends Comparable<? super Number>> T t(Collection<T> col) {return null;}\\n\\n  static <T extends Comparable<T>> T u(Collection<T> col) {return null;}\\n\\n"
  },
  {
    "method_id": "M4600",
    "name": "t",
    "return_type": "T",
    "signature": "t(Collection<T> col)",
    "file_id": "F222",
    "start_line": 23,
    "text_preview": "ect & Comparable<? super T>> T s(Collection<T> col) {return null;}\\n  \\n  static <T extends Comparable<? super Number>> T t(Collection<T> col) {return null;}\\n\\n  static <T extends Comparable<T>> T u(Collection<T> col) {return null;}\\n\\n  <X> X v(Collection<X> x) {return null;}\\n\\n  public void w(List<List<List<List<List<? ext"
  },
  {
    "method_id": "M4601",
    "name": "u",
    "return_type": "T",
    "signature": "u(Collection<T> col)",
    "file_id": "F222",
    "start_line": 25,
    "text_preview": "atic <T extends Comparable<? super Number>> T t(Collection<T> col) {return null;}\\n\\n  static <T extends Comparable<T>> T u(Collection<T> col) {return null;}\\n\\n  <X> X v(Collection<X> x) {return null;}\\n\\n  public void w(List<List<List<List<List<? extends List>>>>> wtf) {}\\n \\n  static <T> void x(List <T> a,List<? extends T> "
  },
  {
    "method_id": "M4602",
    "name": "v",
    "return_type": "X",
    "signature": "v(Collection<X> x)",
    "file_id": "F222",
    "start_line": 27,
    "text_preview": " t(Collection<T> col) {return null;}\\n\\n  static <T extends Comparable<T>> T u(Collection<T> col) {return null;}\\n\\n  <X> X v(Collection<X> x) {return null;}\\n\\n  public void w(List<List<List<List<List<? extends List>>>>> wtf) {}\\n \\n  static <T> void x(List <T> a,List<? extends T> b) {}\\n\\n  <T extends Number> void y(Map<T,? su"
  },
  {
    "method_id": "M4603",
    "name": "w",
    "return_type": "void",
    "signature": "w(List<List<List<List<List<? extends List>>>>> wtf)",
    "file_id": "F222",
    "start_line": 29,
    "text_preview": " extends Comparable<T>> T u(Collection<T> col) {return null;}\\n\\n  <X> X v(Collection<X> x) {return null;}\\n\\n  public void w(List<List<List<List<List<? extends List>>>>> wtf) {}\\n \\n  static <T> void x(List <T> a,List<? extends T> b) {}\\n\\n  <T extends Number> void y(Map<T,? super Number> n) {}\\n\\n  static <T> void z(T[] ts,Col"
  },
  {
    "method_id": "M4604",
    "name": "x",
    "return_type": "void",
    "signature": "x(List <T> a,List<? extends T> b)",
    "file_id": "F222",
    "start_line": 31,
    "text_preview": "llection<X> x) {return null;}\\n\\n  public void w(List<List<List<List<List<? extends List>>>>> wtf) {}\\n \\n  static <T> void x(List <T> a,List<? extends T> b) {}\\n\\n  <T extends Number> void y(Map<T,? super Number> n) {}\\n\\n  static <T> void z(T[] ts,Collection<T> c) {}\\n}\\n"
  },
  {
    "method_id": "M4605",
    "name": "y",
    "return_type": "void",
    "signature": "y(Map<T,? super Number> n)",
    "file_id": "F222",
    "start_line": 33,
    "text_preview": "st<List<? extends List>>>>> wtf) {}\\n \\n  static <T> void x(List <T> a,List<? extends T> b) {}\\n\\n  <T extends Number> void y(Map<T,? super Number> n) {}\\n\\n  static <T> void z(T[] ts,Collection<T> c) {}\\n}\\n"
  },
  {
    "method_id": "M4606",
    "name": "z",
    "return_type": "void",
    "signature": "z(T[] ts,Collection<T> c)",
    "file_id": "F222",
    "start_line": 35,
    "text_preview": "> void x(List <T> a,List<? extends T> b) {}\\n\\n  <T extends Number> void y(Map<T,? super Number> n) {}\\n\\n  static <T> void z(T[] ts,Collection<T> c) {}\\n}\\n"
  },
  {
    "method_id": "M4607",
    "name": "p",
    "return_type": "",
    "signature": "p()",
    "file_id": "F228",
    "start_line": 2,
    "text_preview": "): p() {\\n    \\n  }\\n\\n  int SimpleAspect.i;\\n\\n  public void SimpleAspect.m() { }\\n\\n}\\n"
  },
  {
    "method_id": "M4608",
    "name": "m",
    "return_type": "",
    "signature": "m()",
    "file_id": "F228",
    "start_line": 10,
    "text_preview": "eAspect {\\n  pointcut p(): call(* *(..));\\n\\n  before(): p() {\\n    \\n  }\\n\\n  int SimpleAspect.i;\\n\\n  public void SimpleAspect.m() { }\\n\\n}\\n"
  },
  {
    "method_id": "M4609",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] argv)",
    "file_id": "F229",
    "start_line": 2,
    "text_preview": "c void main(String[] argv) {\\n    // Nothing unusual in this class\\n  }\\n}\\n"
  },
  {
    "method_id": "M4610",
    "name": "TreasureChest",
    "return_type": "",
    "signature": "TreasureChest()",
    "file_id": "F231",
    "start_line": 7,
    "text_preview": ""
  },
  {
    "method_id": "M4611",
    "name": "add",
    "return_type": "void",
    "signature": "add(T o)",
    "file_id": "F231",
    "start_line": 11,
    "text_preview": "hest<T> {\\n\\n  protected Set<T> contents;\\n\\n  public TreasureChest() {\\n    contents = new HashSet<T>();\\n  }\\n\\n  public void add(T o) {\\n    contents.add(o);\\n  }\\n}\\n\\npublic class SimpleGenericsProgram {\\n\\n  public static void main(String []argv) {\\n    TreasureChest<String> tc1 = new TreasureChest<String>();\\n    TreasureChest<I"
  },
  {
    "method_id": "M4612",
    "name": "main",
    "return_type": "void",
    "signature": "main(String []argv)",
    "file_id": "F231",
    "start_line": 18,
    "text_preview": ");\\n  }\\n\\n  public void add(T o) {\\n    contents.add(o);\\n  }\\n}\\n\\npublic class SimpleGenericsProgram {\\n\\n  public static void main(String []argv) {\\n    TreasureChest<String> tc1 = new TreasureChest<String>();\\n    TreasureChest<Integer> tc2 = new TreasureChest<Integer>();\\n\\n    tc1.add(\"dubloon\");\\n    tc2.add(new Integer(\"777\""
  },
  {
    "method_id": "M4613",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[]argv)",
    "file_id": "F232",
    "start_line": 5,
    "text_preview": "n(fruits.size()+\" fruits"
  },
  {
    "method_id": "M4614",
    "name": "setI",
    "return_type": "void",
    "signature": "setI(Integer i)",
    "file_id": "F234",
    "start_line": 4,
    "text_preview": "I(Integer i) { this.i=i;}\\n  public Integer getI() { return i;}\\n}\\n"
  },
  {
    "method_id": "M4615",
    "name": "getI",
    "return_type": "Integer",
    "signature": "getI()",
    "file_id": "F234",
    "start_line": 5,
    "text_preview": "I() { return i;}\\n}\\n"
  },
  {
    "method_id": "M4616",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] argv)",
    "file_id": "F235",
    "start_line": 3,
    "text_preview": " i<args.length;i++) {\\n      System.err.println(args[i]);\\n    }\\n  }\\n}\\n"
  },
  {
    "method_id": "M4617",
    "name": "callfoo",
    "return_type": "void",
    "signature": "callfoo(Object... args)",
    "file_id": "F235",
    "start_line": 4,
    "text_preview": "  System.err.println(args[i]);\\n    }\\n  }\\n}\\n"
  },
  {
    "method_id": "M4618",
    "name": "for",
    "return_type": "",
    "signature": "for(int i = 0 ; i<args.length;i++)",
    "file_id": "F235",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4619",
    "name": "foo",
    "return_type": "void",
    "signature": "foo(String abc,String... args)",
    "file_id": "F236",
    "start_line": 3,
    "text_preview": " args) { }\\n\\n  public void goo(String... args) { }\\n\\n  public void hoo() {}\\n\\n}\\n"
  },
  {
    "method_id": "M4620",
    "name": "goo",
    "return_type": "void",
    "signature": "goo(String... args)",
    "file_id": "F236",
    "start_line": 5,
    "text_preview": "\\n  public void hoo() {}\\n\\n}\\n"
  },
  {
    "method_id": "M4621",
    "name": "hoo",
    "return_type": "void",
    "signature": "hoo()",
    "file_id": "F236",
    "start_line": 7,
    "text_preview": " VarargsClass {\\n\\n  public void foo(String abc,String... args) { }\\n\\n  public void goo(String... args) { }\\n\\n  public void hoo() {}\\n\\n}\\n"
  },
  {
    "method_id": "M4622",
    "name": "ajc_before_0",
    "return_type": "void",
    "signature": "ajc_before_0()",
    "file_id": "F238",
    "start_line": 32,
    "text_preview": ".aspectj.runtime.internal.AroundClosure;\\nimport org.aspectj.lang.JoinPoint;\\n\\npublic class Aspect {\\n\\n\tpublic static void ajc_before_0() {\\n\t\tSystem.out.println(\"before_0\");\t\t\\n\t}\\n \tpublic static void ajc_before_0(String s) {\\n\t\tSystem.out.println(\"before_0: \" + s);\t\t\\n\t}\\n    public static boolean ajc_around_0(ArrayList s, A"
  },
  {
    "method_id": "M4623",
    "name": "ajc_before_0",
    "return_type": "void",
    "signature": "ajc_before_0(String s)",
    "file_id": "F238",
    "start_line": 32,
    "text_preview": ".aspectj.runtime.internal.AroundClosure;\\nimport org.aspectj.lang.JoinPoint;\\n\\npublic class Aspect {\\n\\n\tpublic static void ajc_before_0() {\\n\t\tSystem.out.println(\"before_0\");\t\t\\n\t}\\n \tpublic static void ajc_before_0(String s) {\\n\t\tSystem.out.println(\"before_0: \" + s);\t\t\\n\t}\\n    public static boolean ajc_around_0(ArrayList s, A"
  },
  {
    "method_id": "M4624",
    "name": "ajc_around_0",
    "return_type": "boolean",
    "signature": "ajc_around_0(ArrayList s, AroundClosure c)",
    "file_id": "F238",
    "start_line": 38,
    "text_preview": "\t}\\n \tpublic static void ajc_before_0(String s) {\\n\t\tSystem.out.println(\"before_0: \" + s);\t\t\\n\t}\\n    public static boolean ajc_around_0(ArrayList s, AroundClosure c) throws Throwable {\\n        System.out.println(\"doing around, got \" + s);\\n        Object ret = c.run(new Object[] {s}); // proceed(s)\\n        return ((Boolean"
  },
  {
    "method_id": "M4625",
    "name": "ajc_before_0",
    "return_type": "void",
    "signature": "ajc_before_0(java.util.ArrayList list)",
    "file_id": "F238",
    "start_line": 32,
    "text_preview": ".aspectj.runtime.internal.AroundClosure;\\nimport org.aspectj.lang.JoinPoint;\\n\\npublic class Aspect {\\n\\n\tpublic static void ajc_before_0() {\\n\t\tSystem.out.println(\"before_0\");\t\t\\n\t}\\n \tpublic static void ajc_before_0(String s) {\\n\t\tSystem.out.println(\"before_0: \" + s);\t\t\\n\t}\\n    public static boolean ajc_around_0(ArrayList s, A"
  },
  {
    "method_id": "M4626",
    "name": "ajc_before_method_execution",
    "return_type": "void",
    "signature": "ajc_before_method_execution()",
    "file_id": "F238",
    "start_line": 48,
    "text_preview": "atic void ajc_before_0(java.util.ArrayList list) {\\n\t\tSystem.out.println(\"before_0: \" + list);\t\t\\n\t}\\n\\n\tpublic static void ajc_before_method_execution() {\\n\\n\t}\t\\n\tpublic static void ajc_before_method_execution(Object o) {\\n\t\tSystem.out.println(\"before_method_execution: \" + o);\\n\t}\\n\\n    public static void ajc_after_method_exec"
  },
  {
    "method_id": "M4627",
    "name": "ajc_before_method_execution",
    "return_type": "void",
    "signature": "ajc_before_method_execution(Object o)",
    "file_id": "F238",
    "start_line": 48,
    "text_preview": "atic void ajc_before_0(java.util.ArrayList list) {\\n\t\tSystem.out.println(\"before_0: \" + list);\t\t\\n\t}\\n\\n\tpublic static void ajc_before_method_execution() {\\n\\n\t}\t\\n\tpublic static void ajc_before_method_execution(Object o) {\\n\t\tSystem.out.println(\"before_method_execution: \" + o);\\n\t}\\n\\n    public static void ajc_after_method_exec"
  },
  {
    "method_id": "M4628",
    "name": "ajc_after_method_execution",
    "return_type": "void",
    "signature": "ajc_after_method_execution()",
    "file_id": "F238",
    "start_line": 55,
    "text_preview": "c_before_method_execution(Object o) {\\n\t\tSystem.out.println(\"before_method_execution: \" + o);\\n\t}\\n\\n    public static void ajc_after_method_execution() {\\n        System.out.println(\"after_method_execution\");\\n    }    \\n    public static void ajc_after_method_execution(Object o) {\\n        System.out.println(\"after_method_ex"
  },
  {
    "method_id": "M4629",
    "name": "ajc_after_method_execution",
    "return_type": "void",
    "signature": "ajc_after_method_execution(Object o)",
    "file_id": "F238",
    "start_line": 55,
    "text_preview": "c_before_method_execution(Object o) {\\n\t\tSystem.out.println(\"before_method_execution: \" + o);\\n\t}\\n\\n    public static void ajc_after_method_execution() {\\n        System.out.println(\"after_method_execution\");\\n    }    \\n    public static void ajc_after_method_execution(Object o) {\\n        System.out.println(\"after_method_ex"
  },
  {
    "method_id": "M4630",
    "name": "ajc_afterReturning_method_execution",
    "return_type": "void",
    "signature": "ajc_afterReturning_method_execution()",
    "file_id": "F238",
    "start_line": 62,
    "text_preview": "hod_execution(Object o) {\\n        System.out.println(\"after_method_execution: \" + o);\\n    }\\n    \\n    public static void ajc_afterReturning_method_execution() {\\n        System.out.println(\"ajc_afterReturning_method_execution\");\\n    }           \t\\n\tpublic static void ajc_afterReturning_method_execution(Object o) {\\n\t\tSyste"
  },
  {
    "method_id": "M4631",
    "name": "ajc_afterReturning_method_execution",
    "return_type": "void",
    "signature": "ajc_afterReturning_method_execution(Object o)",
    "file_id": "F238",
    "start_line": 62,
    "text_preview": "hod_execution(Object o) {\\n        System.out.println(\"after_method_execution: \" + o);\\n    }\\n    \\n    public static void ajc_afterReturning_method_execution() {\\n        System.out.println(\"ajc_afterReturning_method_execution\");\\n    }           \t\\n\tpublic static void ajc_afterReturning_method_execution(Object o) {\\n\t\tSyste"
  },
  {
    "method_id": "M4632",
    "name": "ajc_afterThrowing_method_execution",
    "return_type": "void",
    "signature": "ajc_afterThrowing_method_execution()",
    "file_id": "F238",
    "start_line": 69,
    "text_preview": "_method_execution(Object o) {\\n\t\tSystem.out.println(\"afterReturning_method_execution: \" + o);\\n\t}\\n\\n    public static void ajc_afterThrowing_method_execution() {\\n        System.out.println(\"ajc_afterThrowing_method_execution\");\\n    }               \\n    public static void ajc_afterThrowing_method_execution(Object o) {\\n    "
  },
  {
    "method_id": "M4633",
    "name": "ajc_afterThrowing_method_execution",
    "return_type": "void",
    "signature": "ajc_afterThrowing_method_execution(Object o)",
    "file_id": "F238",
    "start_line": 69,
    "text_preview": "_method_execution(Object o) {\\n\t\tSystem.out.println(\"afterReturning_method_execution: \" + o);\\n\t}\\n\\n    public static void ajc_afterThrowing_method_execution() {\\n        System.out.println(\"ajc_afterThrowing_method_execution\");\\n    }               \\n    public static void ajc_afterThrowing_method_execution(Object o) {\\n    "
  },
  {
    "method_id": "M4634",
    "name": "ajc_around",
    "return_type": "Object",
    "signature": "ajc_around(AroundClosure closure)",
    "file_id": "F238",
    "start_line": 80,
    "text_preview": ") {\\n        System.out.println(\"afterThrowing_method_execution: \" + o);\\n    }    \\n\\n\\n\\n\\n        \\n    public static Object ajc_around(AroundClosure closure) throws Throwable {\\n        Object ret = closure.run(new Object[] {});\\n        return ret;\\n    }   \\n    \\n    public static Object ajc_around(AroundClosure closure, Joi"
  },
  {
    "method_id": "M4635",
    "name": "ajc_around",
    "return_type": "Object",
    "signature": "ajc_around(AroundClosure closure, JoinPoint tjp)",
    "file_id": "F238",
    "start_line": 80,
    "text_preview": ") {\\n        System.out.println(\"afterThrowing_method_execution: \" + o);\\n    }    \\n\\n\\n\\n\\n        \\n    public static Object ajc_around(AroundClosure closure) throws Throwable {\\n        Object ret = closure.run(new Object[] {});\\n        return ret;\\n    }   \\n    \\n    public static Object ajc_around(AroundClosure closure, Joi"
  },
  {
    "method_id": "M4636",
    "name": "ajc_before_method_call",
    "return_type": "void",
    "signature": "ajc_before_method_call()",
    "file_id": "F238",
    "start_line": 94,
    "text_preview": "t ret = closure.run(new Object[] {});\\n        return ret;\\n    }   \\n    \\n    // ---    \\n    \\n    \\n    public static void ajc_before_method_call() {\\n        System.out.println(\"before_method_call\");\\n    }    \\n    public static void ajc_before_method_call(Object o) {\\n        System.out.println(\"before_method_call: \" + o);"
  },
  {
    "method_id": "M4637",
    "name": "ajc_before_method_call",
    "return_type": "void",
    "signature": "ajc_before_method_call(Object o)",
    "file_id": "F238",
    "start_line": 94,
    "text_preview": "t ret = closure.run(new Object[] {});\\n        return ret;\\n    }   \\n    \\n    // ---    \\n    \\n    \\n    public static void ajc_before_method_call() {\\n        System.out.println(\"before_method_call\");\\n    }    \\n    public static void ajc_before_method_call(Object o) {\\n        System.out.println(\"before_method_call: \" + o);"
  },
  {
    "method_id": "M4638",
    "name": "ajc_after_method_call",
    "return_type": "void",
    "signature": "ajc_after_method_call()",
    "file_id": "F238",
    "start_line": 101,
    "text_preview": "e_method_call(Object o) {\\n        System.out.println(\"before_method_call: \" + o);\\n    }\\n        \\n    public static void ajc_after_method_call() {\\n        System.out.println(\"after_method_call\");\\n    }    \\n    public static void ajc_after_method_call(Object o) {\\n        System.out.println(\"after_method_call: \" + o);\\n   "
  },
  {
    "method_id": "M4639",
    "name": "ajc_after_method_call",
    "return_type": "void",
    "signature": "ajc_after_method_call(Object o)",
    "file_id": "F238",
    "start_line": 101,
    "text_preview": "e_method_call(Object o) {\\n        System.out.println(\"before_method_call: \" + o);\\n    }\\n        \\n    public static void ajc_after_method_call() {\\n        System.out.println(\"after_method_call\");\\n    }    \\n    public static void ajc_after_method_call(Object o) {\\n        System.out.println(\"after_method_call: \" + o);\\n   "
  },
  {
    "method_id": "M4640",
    "name": "ajc_afterReturning_method_call",
    "return_type": "void",
    "signature": "ajc_afterReturning_method_call()",
    "file_id": "F238",
    "start_line": 108,
    "text_preview": "er_method_call(Object o) {\\n        System.out.println(\"after_method_call: \" + o);\\n    }       \\n\t\\n    public static void ajc_afterReturning_method_call() {\\n        System.out.println(\"ajc_afterReturning_method_call\");\\n    }\\n\tpublic static void ajc_afterReturning_method_call(Object o) {\\n\t\tSystem.out.println(\"afterReturni"
  },
  {
    "method_id": "M4641",
    "name": "ajc_afterReturning_method_call",
    "return_type": "void",
    "signature": "ajc_afterReturning_method_call(Object o)",
    "file_id": "F238",
    "start_line": 108,
    "text_preview": "er_method_call(Object o) {\\n        System.out.println(\"after_method_call: \" + o);\\n    }       \\n\t\\n    public static void ajc_afterReturning_method_call() {\\n        System.out.println(\"ajc_afterReturning_method_call\");\\n    }\\n\tpublic static void ajc_afterReturning_method_call(Object o) {\\n\t\tSystem.out.println(\"afterReturni"
  },
  {
    "method_id": "M4642",
    "name": "ajc_afterThrowing_method_call",
    "return_type": "void",
    "signature": "ajc_afterThrowing_method_call()",
    "file_id": "F238",
    "start_line": 115,
    "text_preview": "Returning_method_call(Object o) {\\n\t\tSystem.out.println(\"afterReturning_method_call: \" + o);\\n\t}\\n\t\\n    public static void ajc_afterThrowing_method_call() {\\n        System.out.println(\"ajc_afterThrowing_method_call\");\\n    }\\n    public static void ajc_afterThrowing_method_call(Object o) {\\n        System.out.println(\"afterT"
  },
  {
    "method_id": "M4643",
    "name": "ajc_afterThrowing_method_call",
    "return_type": "void",
    "signature": "ajc_afterThrowing_method_call(Object o)",
    "file_id": "F238",
    "start_line": 115,
    "text_preview": "Returning_method_call(Object o) {\\n\t\tSystem.out.println(\"afterReturning_method_call: \" + o);\\n\t}\\n\t\\n    public static void ajc_afterThrowing_method_call() {\\n        System.out.println(\"ajc_afterThrowing_method_call\");\\n    }\\n    public static void ajc_afterThrowing_method_call(Object o) {\\n        System.out.println(\"afterT"
  },
  {
    "method_id": "M4644",
    "name": "ajc_around_method_call",
    "return_type": "Object",
    "signature": "ajc_around_method_call(AroundClosure closure)",
    "file_id": "F238",
    "start_line": 122,
    "text_preview": "call(Object o) {\\n        System.out.println(\"afterThrowing_method_call: \" + o);\\n    }    \\n    \\n    public static Object ajc_around_method_call(AroundClosure closure) throws Throwable {\\n        Object ret = null;\\n        for (int i=0; i<3; i++) {\\n            System.out.println(\"enter: \" + i);\\n            ret = closure.r"
  },
  {
    "method_id": "M4645",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0; i<3; i++)",
    "file_id": "F238",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4646",
    "name": "ajc_before_constructor_call",
    "return_type": "void",
    "signature": "ajc_before_constructor_call()",
    "file_id": "F238",
    "start_line": 133,
    "text_preview": "       ret = closure.run(new Object[] {});\\n        }\\n        return ret;\\n    }\\n    \\n    // ----\\n\\n    public static void ajc_before_constructor_call() {\\n        System.out.println(\"before_constructor_call\");\\n    }    \\n    public static void ajc_before_constructor_call(Object o) {\\n        System.out.println(\"before_const"
  },
  {
    "method_id": "M4647",
    "name": "ajc_before_constructor_call",
    "return_type": "void",
    "signature": "ajc_before_constructor_call(Object o)",
    "file_id": "F238",
    "start_line": 133,
    "text_preview": "       ret = closure.run(new Object[] {});\\n        }\\n        return ret;\\n    }\\n    \\n    // ----\\n\\n    public static void ajc_before_constructor_call() {\\n        System.out.println(\"before_constructor_call\");\\n    }    \\n    public static void ajc_before_constructor_call(Object o) {\\n        System.out.println(\"before_const"
  },
  {
    "method_id": "M4648",
    "name": "ajc_after_constructor_call",
    "return_type": "void",
    "signature": "ajc_after_constructor_call()",
    "file_id": "F238",
    "start_line": 140,
    "text_preview": "tor_call(Object o) {\\n        System.out.println(\"before_constructor_call: \" + o);\\n    }\\n        \\n    public static void ajc_after_constructor_call() {\\n        System.out.println(\"after_constructor_call\");\\n    }    \\n    public static void ajc_after_constructor_call(Object o) {\\n        System.out.println(\"after_construct"
  },
  {
    "method_id": "M4649",
    "name": "ajc_after_constructor_call",
    "return_type": "void",
    "signature": "ajc_after_constructor_call(Object o)",
    "file_id": "F238",
    "start_line": 140,
    "text_preview": "tor_call(Object o) {\\n        System.out.println(\"before_constructor_call: \" + o);\\n    }\\n        \\n    public static void ajc_after_constructor_call() {\\n        System.out.println(\"after_constructor_call\");\\n    }    \\n    public static void ajc_after_constructor_call(Object o) {\\n        System.out.println(\"after_construct"
  },
  {
    "method_id": "M4650",
    "name": "ajc_afterReturning_constructor_call",
    "return_type": "void",
    "signature": "ajc_afterReturning_constructor_call()",
    "file_id": "F238",
    "start_line": 147,
    "text_preview": "ctor_call(Object o) {\\n        System.out.println(\"after_constructor_call: \" + o);\\n    }       \\n\t\\n    public static void ajc_afterReturning_constructor_call() {\\n        System.out.println(\"ajc_afterReturning_constructor_call\");\\n    }\\n\tpublic static void ajc_afterReturning_constructor_call(Object o) {\\n\t\tSystem.out.printl"
  },
  {
    "method_id": "M4651",
    "name": "ajc_afterReturning_constructor_call",
    "return_type": "void",
    "signature": "ajc_afterReturning_constructor_call(Object o)",
    "file_id": "F238",
    "start_line": 147,
    "text_preview": "ctor_call(Object o) {\\n        System.out.println(\"after_constructor_call: \" + o);\\n    }       \\n\t\\n    public static void ajc_afterReturning_constructor_call() {\\n        System.out.println(\"ajc_afterReturning_constructor_call\");\\n    }\\n\tpublic static void ajc_afterReturning_constructor_call(Object o) {\\n\t\tSystem.out.printl"
  },
  {
    "method_id": "M4652",
    "name": "ajc_afterThrowing_constructor_call",
    "return_type": "void",
    "signature": "ajc_afterThrowing_constructor_call()",
    "file_id": "F238",
    "start_line": 154,
    "text_preview": "constructor_call(Object o) {\\n\t\tSystem.out.println(\"afterReturning_constructor_call: \" + o);\\n\t}\\n\t\\n    public static void ajc_afterThrowing_constructor_call() {\\n        System.out.println(\"ajc_afterThrowing_constructor_call\");\\n    }\\n    public static void ajc_afterThrowing_constructor_call(Object o) {\\n        System.out."
  },
  {
    "method_id": "M4653",
    "name": "ajc_afterThrowing_constructor_call",
    "return_type": "void",
    "signature": "ajc_afterThrowing_constructor_call(Object o)",
    "file_id": "F238",
    "start_line": 154,
    "text_preview": "constructor_call(Object o) {\\n\t\tSystem.out.println(\"afterReturning_constructor_call: \" + o);\\n\t}\\n\t\\n    public static void ajc_afterThrowing_constructor_call() {\\n        System.out.println(\"ajc_afterThrowing_constructor_call\");\\n    }\\n    public static void ajc_afterThrowing_constructor_call(Object o) {\\n        System.out."
  },
  {
    "method_id": "M4654",
    "name": "ajc_around_constructor_call",
    "return_type": "Object",
    "signature": "ajc_around_constructor_call(AroundClosure closure)",
    "file_id": "F238",
    "start_line": 161,
    "text_preview": "Object o) {\\n        System.out.println(\"afterThrowing_constructor_call: \" + o);\\n    }    \\n    \\n    public static Object ajc_around_constructor_call(AroundClosure closure) throws Throwable {\\n        Object ret = null;\\n        for (int i=0; i<3; i++) {\\n            System.out.println(\"enter: \" + i);\\n            ret = clos"
  },
  {
    "method_id": "M4655",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0; i<3; i++)",
    "file_id": "F238",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4656",
    "name": "ajc_before_constructor_execution",
    "return_type": "void",
    "signature": "ajc_before_constructor_execution()",
    "file_id": "F238",
    "start_line": 171,
    "text_preview": "        ret = closure.run(new Object[] {});\\n        }\\n        return ret;\\n    }    \\n    // ----\\n\\n    public static void ajc_before_constructor_execution() {\\n        System.out.println(\"before_constructor_execution\");\\n    }    \\n    public static void ajc_before_constructor_execution(Object o) {\\n        System.out.printl"
  },
  {
    "method_id": "M4657",
    "name": "ajc_before_constructor_execution",
    "return_type": "void",
    "signature": "ajc_before_constructor_execution(Object o)",
    "file_id": "F238",
    "start_line": 171,
    "text_preview": "        ret = closure.run(new Object[] {});\\n        }\\n        return ret;\\n    }    \\n    // ----\\n\\n    public static void ajc_before_constructor_execution() {\\n        System.out.println(\"before_constructor_execution\");\\n    }    \\n    public static void ajc_before_constructor_execution(Object o) {\\n        System.out.printl"
  },
  {
    "method_id": "M4658",
    "name": "ajc_after_constructor_execution",
    "return_type": "void",
    "signature": "ajc_after_constructor_execution()",
    "file_id": "F238",
    "start_line": 178,
    "text_preview": "ion(Object o) {\\n        System.out.println(\"before_constructor_execution: \" + o);\\n    }\\n        \\n    public static void ajc_after_constructor_execution() {\\n        System.out.println(\"after_constructor_execution\");\\n    }    \\n    public static void ajc_after_constructor_execution(Object o) {\\n        System.out.println(\""
  },
  {
    "method_id": "M4659",
    "name": "ajc_after_constructor_execution",
    "return_type": "void",
    "signature": "ajc_after_constructor_execution(Object o)",
    "file_id": "F238",
    "start_line": 178,
    "text_preview": "ion(Object o) {\\n        System.out.println(\"before_constructor_execution: \" + o);\\n    }\\n        \\n    public static void ajc_after_constructor_execution() {\\n        System.out.println(\"after_constructor_execution\");\\n    }    \\n    public static void ajc_after_constructor_execution(Object o) {\\n        System.out.println(\""
  },
  {
    "method_id": "M4660",
    "name": "ajc_afterReturning_constructor_execution",
    "return_type": "void",
    "signature": "ajc_afterReturning_constructor_execution()",
    "file_id": "F238",
    "start_line": 185,
    "text_preview": "tion(Object o) {\\n        System.out.println(\"after_constructor_execution: \" + o);\\n    }       \\n\t\\n    public static void ajc_afterReturning_constructor_execution() {\\n        System.out.println(\"ajc_afterReturning_constructor_execution\");\\n    }\\n\tpublic static void ajc_afterReturning_constructor_execution(Object o) {\\n\t\tSy"
  },
  {
    "method_id": "M4661",
    "name": "ajc_afterReturning_constructor_execution",
    "return_type": "void",
    "signature": "ajc_afterReturning_constructor_execution(Object o)",
    "file_id": "F238",
    "start_line": 185,
    "text_preview": "tion(Object o) {\\n        System.out.println(\"after_constructor_execution: \" + o);\\n    }       \\n\t\\n    public static void ajc_afterReturning_constructor_execution() {\\n        System.out.println(\"ajc_afterReturning_constructor_execution\");\\n    }\\n\tpublic static void ajc_afterReturning_constructor_execution(Object o) {\\n\t\tSy"
  },
  {
    "method_id": "M4662",
    "name": "ajc_afterThrowing_constructor_execution",
    "return_type": "void",
    "signature": "ajc_afterThrowing_constructor_execution()",
    "file_id": "F238",
    "start_line": 192,
    "text_preview": "r_execution(Object o) {\\n\t\tSystem.out.println(\"afterReturning_constructor_execution: \" + o);\\n\t}\\n\t\\n    public static void ajc_afterThrowing_constructor_execution() {\\n        System.out.println(\"ajc_afterThrowing_constructor_execution\");\\n    }\\n    public static void ajc_afterThrowing_constructor_execution(Object o) {\\n    "
  },
  {
    "method_id": "M4663",
    "name": "ajc_afterThrowing_constructor_execution",
    "return_type": "void",
    "signature": "ajc_afterThrowing_constructor_execution(Object o)",
    "file_id": "F238",
    "start_line": 192,
    "text_preview": "r_execution(Object o) {\\n\t\tSystem.out.println(\"afterReturning_constructor_execution: \" + o);\\n\t}\\n\t\\n    public static void ajc_afterThrowing_constructor_execution() {\\n        System.out.println(\"ajc_afterThrowing_constructor_execution\");\\n    }\\n    public static void ajc_afterThrowing_constructor_execution(Object o) {\\n    "
  },
  {
    "method_id": "M4664",
    "name": "ajc_around_constructor_execution",
    "return_type": "Object",
    "signature": "ajc_around_constructor_execution(AroundClosure closure)",
    "file_id": "F238",
    "start_line": 199,
    "text_preview": "t o) {\\n        System.out.println(\"afterThrowing_constructor_execution: \" + o);\\n    }    \\n    \\n    public static Object ajc_around_constructor_execution(AroundClosure closure) throws Throwable {\\n        Object ret = null;\\n        for (int i=0; i<3; i++) {\\n            System.out.println(\"enter: \" + i);\\n            ret ="
  },
  {
    "method_id": "M4665",
    "name": "for",
    "return_type": "",
    "signature": "for(int i=0; i<3; i++)",
    "file_id": "F238",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4666",
    "name": "ajc_before_field_get",
    "return_type": "void",
    "signature": "ajc_before_field_get()",
    "file_id": "F238",
    "start_line": 212,
    "text_preview": "ret = closure.run(new Object[] {});\\n        }\\n        return ret;\\n    }    \\n    \\n    \\n    // ---\\n\\n\t\\n\tpublic static void ajc_before_field_get() {\\n\t\tSystem.out.println(\"before_field_get\");\\n\t}   \\n    public static void ajc_before_field_get(Object o) {\\n        System.out.println(\"before_field_get: \" + o);\\n    }\\n    \\n    pu"
  },
  {
    "method_id": "M4667",
    "name": "ajc_before_field_get",
    "return_type": "void",
    "signature": "ajc_before_field_get(Object o)",
    "file_id": "F238",
    "start_line": 212,
    "text_preview": "ret = closure.run(new Object[] {});\\n        }\\n        return ret;\\n    }    \\n    \\n    \\n    // ---\\n\\n\t\\n\tpublic static void ajc_before_field_get() {\\n\t\tSystem.out.println(\"before_field_get\");\\n\t}   \\n    public static void ajc_before_field_get(Object o) {\\n        System.out.println(\"before_field_get: \" + o);\\n    }\\n    \\n    pu"
  },
  {
    "method_id": "M4668",
    "name": "ajc_after_field_get",
    "return_type": "void",
    "signature": "ajc_after_field_get()",
    "file_id": "F238",
    "start_line": 219,
    "text_preview": "jc_before_field_get(Object o) {\\n        System.out.println(\"before_field_get: \" + o);\\n    }\\n    \\n    public static void ajc_after_field_get() {\\n        System.out.println(\"after_field_get\");\\n    }    \\n    public static void ajc_after_field_get(Object o) {\\n        System.out.println(\"after_field_get: \" + o);\\n    }\\n    \\n"
  },
  {
    "method_id": "M4669",
    "name": "ajc_after_field_get",
    "return_type": "void",
    "signature": "ajc_after_field_get(Object o)",
    "file_id": "F238",
    "start_line": 219,
    "text_preview": "jc_before_field_get(Object o) {\\n        System.out.println(\"before_field_get: \" + o);\\n    }\\n    \\n    public static void ajc_after_field_get() {\\n        System.out.println(\"after_field_get\");\\n    }    \\n    public static void ajc_after_field_get(Object o) {\\n        System.out.println(\"after_field_get: \" + o);\\n    }\\n    \\n"
  },
  {
    "method_id": "M4670",
    "name": "ajc_afterReturning_field_get",
    "return_type": "void",
    "signature": "ajc_afterReturning_field_get()",
    "file_id": "F238",
    "start_line": 226,
    "text_preview": " ajc_after_field_get(Object o) {\\n        System.out.println(\"after_field_get: \" + o);\\n    }\\n    \\n    public static void ajc_afterReturning_field_get() {\\n        System.out.println(\"afterReturning_field_get\");\\n    }    \\n    public static void ajc_afterReturning_field_get(Object o) {\\n        System.out.println(\"afterRetu"
  },
  {
    "method_id": "M4671",
    "name": "ajc_afterReturning_field_get",
    "return_type": "void",
    "signature": "ajc_afterReturning_field_get(Object o)",
    "file_id": "F238",
    "start_line": 226,
    "text_preview": " ajc_after_field_get(Object o) {\\n        System.out.println(\"after_field_get: \" + o);\\n    }\\n    \\n    public static void ajc_afterReturning_field_get() {\\n        System.out.println(\"afterReturning_field_get\");\\n    }    \\n    public static void ajc_afterReturning_field_get(Object o) {\\n        System.out.println(\"afterRetu"
  },
  {
    "method_id": "M4672",
    "name": "ajc_afterThrowing_field_get",
    "return_type": "void",
    "signature": "ajc_afterThrowing_field_get()",
    "file_id": "F238",
    "start_line": 233,
    "text_preview": "rning_field_get(Object o) {\\n        System.out.println(\"afterReturning_field_get: \" + o);\\n    }\\n\\n    public static void ajc_afterThrowing_field_get() {\\n        System.out.println(\"afterThrowing_field_get\");\\n    }    \\n    public static void ajc_afterThrowing_field_get(Object o) {\\n        System.out.println(\"afterThrowin"
  },
  {
    "method_id": "M4673",
    "name": "ajc_afterThrowing_field_get",
    "return_type": "void",
    "signature": "ajc_afterThrowing_field_get(Object o)",
    "file_id": "F238",
    "start_line": 233,
    "text_preview": "rning_field_get(Object o) {\\n        System.out.println(\"afterReturning_field_get: \" + o);\\n    }\\n\\n    public static void ajc_afterThrowing_field_get() {\\n        System.out.println(\"afterThrowing_field_get\");\\n    }    \\n    public static void ajc_afterThrowing_field_get(Object o) {\\n        System.out.println(\"afterThrowin"
  },
  {
    "method_id": "M4674",
    "name": "ajc_afterThrowing_field_get",
    "return_type": "void",
    "signature": "ajc_afterThrowing_field_get(Throwable t)",
    "file_id": "F238",
    "start_line": 233,
    "text_preview": "rning_field_get(Object o) {\\n        System.out.println(\"afterReturning_field_get: \" + o);\\n    }\\n\\n    public static void ajc_afterThrowing_field_get() {\\n        System.out.println(\"afterThrowing_field_get\");\\n    }    \\n    public static void ajc_afterThrowing_field_get(Object o) {\\n        System.out.println(\"afterThrowin"
  },
  {
    "method_id": "M4675",
    "name": "ajc_around_field_get",
    "return_type": "Object",
    "signature": "ajc_around_field_get(AroundClosure closure)",
    "file_id": "F238",
    "start_line": 243,
    "text_preview": "wing_field_get(Throwable t) {\\n        System.out.println(\"afterThrowing_field_get: \" + t);\\n    }\\n\\n\tpublic static Object ajc_around_field_get(AroundClosure closure) throws Throwable {\\n\t\tObject ret = closure.run(new Object[] {});\\n\t\treturn ret;\\n\t}\\n\t\\n   \\n    // ---\\n\\n\t\\n\tpublic static void ajc_before_field_set() {\\n\t\tSystem.o"
  },
  {
    "method_id": "M4676",
    "name": "ajc_before_field_set",
    "return_type": "void",
    "signature": "ajc_before_field_set()",
    "file_id": "F238",
    "start_line": 252,
    "text_preview": "hrows Throwable {\\n\t\tObject ret = closure.run(new Object[] {});\\n\t\treturn ret;\\n\t}\\n\t\\n   \\n    // ---\\n\\n\t\\n\tpublic static void ajc_before_field_set() {\\n\t\tSystem.out.println(\"before_field_set\");\\n\t}   \\n    public static void ajc_before_field_set(Object o) {\\n        System.out.println(\"before_field_set: \" + o);\\n    }\\n    \\n    pu"
  },
  {
    "method_id": "M4677",
    "name": "ajc_before_field_set",
    "return_type": "void",
    "signature": "ajc_before_field_set(Object o)",
    "file_id": "F238",
    "start_line": 252,
    "text_preview": "hrows Throwable {\\n\t\tObject ret = closure.run(new Object[] {});\\n\t\treturn ret;\\n\t}\\n\t\\n   \\n    // ---\\n\\n\t\\n\tpublic static void ajc_before_field_set() {\\n\t\tSystem.out.println(\"before_field_set\");\\n\t}   \\n    public static void ajc_before_field_set(Object o) {\\n        System.out.println(\"before_field_set: \" + o);\\n    }\\n    \\n    pu"
  },
  {
    "method_id": "M4678",
    "name": "ajc_after_field_set",
    "return_type": "void",
    "signature": "ajc_after_field_set()",
    "file_id": "F238",
    "start_line": 259,
    "text_preview": "jc_before_field_set(Object o) {\\n        System.out.println(\"before_field_set: \" + o);\\n    }\\n    \\n    public static void ajc_after_field_set() {\\n        System.out.println(\"after_field_set\");\\n    }    \\n    public static void ajc_after_field_set(Object o) {\\n        System.out.println(\"after_field_set: \" + o);\\n    }\\n    \\n"
  },
  {
    "method_id": "M4679",
    "name": "ajc_after_field_set",
    "return_type": "void",
    "signature": "ajc_after_field_set(Object o)",
    "file_id": "F238",
    "start_line": 259,
    "text_preview": "jc_before_field_set(Object o) {\\n        System.out.println(\"before_field_set: \" + o);\\n    }\\n    \\n    public static void ajc_after_field_set() {\\n        System.out.println(\"after_field_set\");\\n    }    \\n    public static void ajc_after_field_set(Object o) {\\n        System.out.println(\"after_field_set: \" + o);\\n    }\\n    \\n"
  },
  {
    "method_id": "M4680",
    "name": "ajc_afterReturning_field_set",
    "return_type": "void",
    "signature": "ajc_afterReturning_field_set()",
    "file_id": "F238",
    "start_line": 266,
    "text_preview": " ajc_after_field_set(Object o) {\\n        System.out.println(\"after_field_set: \" + o);\\n    }\\n    \\n    public static void ajc_afterReturning_field_set() {\\n        System.out.println(\"afterReturning_field_set\");\\n    }    \\n    public static void ajc_afterReturning_field_set(Object o) {\\n        System.out.println(\"afterRetu"
  },
  {
    "method_id": "M4681",
    "name": "ajc_afterReturning_field_set",
    "return_type": "void",
    "signature": "ajc_afterReturning_field_set(Object o)",
    "file_id": "F238",
    "start_line": 266,
    "text_preview": " ajc_after_field_set(Object o) {\\n        System.out.println(\"after_field_set: \" + o);\\n    }\\n    \\n    public static void ajc_afterReturning_field_set() {\\n        System.out.println(\"afterReturning_field_set\");\\n    }    \\n    public static void ajc_afterReturning_field_set(Object o) {\\n        System.out.println(\"afterRetu"
  },
  {
    "method_id": "M4682",
    "name": "ajc_afterThrowing_field_set",
    "return_type": "void",
    "signature": "ajc_afterThrowing_field_set()",
    "file_id": "F238",
    "start_line": 273,
    "text_preview": "rning_field_set(Object o) {\\n        System.out.println(\"afterReturning_field_set: \" + o);\\n    }\\n\\n    public static void ajc_afterThrowing_field_set() {\\n        System.out.println(\"afterThrowing_field_set\");\\n    }    \\n    public static void ajc_afterThrowing_field_set(Object o) {\\n        System.out.println(\"afterThrowin"
  },
  {
    "method_id": "M4683",
    "name": "ajc_afterThrowing_field_set",
    "return_type": "void",
    "signature": "ajc_afterThrowing_field_set(Object o)",
    "file_id": "F238",
    "start_line": 273,
    "text_preview": "rning_field_set(Object o) {\\n        System.out.println(\"afterReturning_field_set: \" + o);\\n    }\\n\\n    public static void ajc_afterThrowing_field_set() {\\n        System.out.println(\"afterThrowing_field_set\");\\n    }    \\n    public static void ajc_afterThrowing_field_set(Object o) {\\n        System.out.println(\"afterThrowin"
  },
  {
    "method_id": "M4684",
    "name": "ajc_afterThrowing_field_set",
    "return_type": "void",
    "signature": "ajc_afterThrowing_field_set(Throwable t)",
    "file_id": "F238",
    "start_line": 273,
    "text_preview": "rning_field_set(Object o) {\\n        System.out.println(\"afterReturning_field_set: \" + o);\\n    }\\n\\n    public static void ajc_afterThrowing_field_set() {\\n        System.out.println(\"afterThrowing_field_set\");\\n    }    \\n    public static void ajc_afterThrowing_field_set(Object o) {\\n        System.out.println(\"afterThrowin"
  },
  {
    "method_id": "M4685",
    "name": "ajc_around_field_set",
    "return_type": "Object",
    "signature": "ajc_around_field_set(AroundClosure closure)",
    "file_id": "F238",
    "start_line": 283,
    "text_preview": "wing_field_set(Throwable t) {\\n        System.out.println(\"afterThrowing_field_set: \" + t);\\n    }\\n\\n\tpublic static Object ajc_around_field_set(AroundClosure closure) throws Throwable {\\n\t\tObject ret = closure.run(new Object[] {});\\n\t\treturn ret;\\n\t}\t\\n\t\\n\t// don't call this method for callee-side call join points\\n\tpublic stat"
  },
  {
    "method_id": "M4686",
    "name": "ajc_before",
    "return_type": "void",
    "signature": "ajc_before(JoinPoint.StaticPart tjp)",
    "file_id": "F238",
    "start_line": 289,
    "text_preview": "n(new Object[] {});\\n\t\treturn ret;\\n\t}\t\\n\t\\n\t// don't call this method for callee-side call join points\\n\tpublic static void ajc_before(JoinPoint.StaticPart tjp) {\\n\t\tSystem.out.println(\"before: \" + tjp);\\n\t\tif (tjp.getSourceLocation() == null) {\\n\t\t\tthrow new RuntimeException(\"didn't want null\");\\n\t\t}\\n\t\tSystem.out.println(\"   "
  },
  {
    "method_id": "M4687",
    "name": "ajc_before",
    "return_type": "void",
    "signature": "ajc_before(JoinPoint tjp)",
    "file_id": "F238",
    "start_line": 289,
    "text_preview": "n(new Object[] {});\\n\t\treturn ret;\\n\t}\t\\n\t\\n\t// don't call this method for callee-side call join points\\n\tpublic static void ajc_before(JoinPoint.StaticPart tjp) {\\n\t\tSystem.out.println(\"before: \" + tjp);\\n\t\tif (tjp.getSourceLocation() == null) {\\n\t\t\tthrow new RuntimeException(\"didn't want null\");\\n\t\t}\\n\t\tSystem.out.println(\"   "
  },
  {
    "method_id": "M4688",
    "name": "perObjectBind",
    "return_type": "",
    "signature": "perObjectBind(Object o)",
    "file_id": "F238",
    "start_line": 307,
    "text_preview": "ist(tjp.getArgs()));\\n\t}\\n\t\\n\t// per object stuff\\n\t\\n\tprivate static Map objects = new HashMap();\\n\t\\n\tpublic static void ajc$perObjectBind(Object o) {\\n\t\tif (objects.containsKey(o)) return;\\n\t\tobjects.put(o, new Aspect());\\n\t}\\n\t\\n\tpublic static boolean hasAspect(Object o) {\\n\t\treturn objects.containsKey(o);\\n\t}\\n\t\\n\tpublic static A"
  },
  {
    "method_id": "M4689",
    "name": "hasAspect",
    "return_type": "boolean",
    "signature": "hasAspect(Object o)",
    "file_id": "F238",
    "start_line": 312,
    "text_preview": "bjectBind(Object o) {\\n\t\tif (objects.containsKey(o)) return;\\n\t\tobjects.put(o, new Aspect());\\n\t}\\n\t\\n\tpublic static boolean hasAspect(Object o) {\\n\t\treturn objects.containsKey(o);\\n\t}\\n\t\\n\tpublic static Aspect aspectOf(Object o) {\\n\t\treturn (Aspect) objects.get(o);\\n\t}\t\\n\t\\n\t\\n\t// per cflow stuff\\n\t\\n\tpublic static void ajc$perCflowP"
  },
  {
    "method_id": "M4690",
    "name": "aspectOf",
    "return_type": "Aspect",
    "signature": "aspectOf(Object o)",
    "file_id": "F238",
    "start_line": 316,
    "text_preview": "spect());\\n\t}\\n\t\\n\tpublic static boolean hasAspect(Object o) {\\n\t\treturn objects.containsKey(o);\\n\t}\\n\t\\n\tpublic static Aspect aspectOf(Object o) {\\n\t\treturn (Aspect) objects.get(o);\\n\t}\t\\n\t\\n\t\\n\t// per cflow stuff\\n\t\\n\tpublic static void ajc$perCflowPush() {\\n\t\tajc$perCflowStack.pushInstance(new Aspect());\\n\t}\\n\t\\n\tpublic static boolea"
  },
  {
    "method_id": "M4691",
    "name": "perCflowPush",
    "return_type": "",
    "signature": "perCflowPush()",
    "file_id": "F238",
    "start_line": 323,
    "text_preview": "tic Aspect aspectOf(Object o) {\\n\t\treturn (Aspect) objects.get(o);\\n\t}\t\\n\t\\n\t\\n\t// per cflow stuff\\n\t\\n\tpublic static void ajc$perCflowPush() {\\n\t\tajc$perCflowStack.pushInstance(new Aspect());\\n\t}\\n\t\\n\tpublic static boolean hasAspect() {\\n\t\treturn ajc$perCflowStack.isValid();\\n\t}\\n\t\\n\tpublic static Aspect aspectOf() {\\n\t\tif (ajc$perSi"
  },
  {
    "method_id": "M4692",
    "name": "hasAspect",
    "return_type": "boolean",
    "signature": "hasAspect()",
    "file_id": "F238",
    "start_line": 312,
    "text_preview": "bjectBind(Object o) {\\n\t\tif (objects.containsKey(o)) return;\\n\t\tobjects.put(o, new Aspect());\\n\t}\\n\t\\n\tpublic static boolean hasAspect(Object o) {\\n\t\treturn objects.containsKey(o);\\n\t}\\n\t\\n\tpublic static Aspect aspectOf(Object o) {\\n\t\treturn (Aspect) objects.get(o);\\n\t}\t\\n\t\\n\t\\n\t// per cflow stuff\\n\t\\n\tpublic static void ajc$perCflowP"
  },
  {
    "method_id": "M4693",
    "name": "aspectOf",
    "return_type": "Aspect",
    "signature": "aspectOf()",
    "file_id": "F238",
    "start_line": 316,
    "text_preview": "spect());\\n\t}\\n\t\\n\tpublic static boolean hasAspect(Object o) {\\n\t\treturn objects.containsKey(o);\\n\t}\\n\t\\n\tpublic static Aspect aspectOf(Object o) {\\n\t\treturn (Aspect) objects.get(o);\\n\t}\t\\n\t\\n\t\\n\t// per cflow stuff\\n\t\\n\tpublic static void ajc$perCflowPush() {\\n\t\tajc$perCflowStack.pushInstance(new Aspect());\\n\t}\\n\t\\n\tpublic static boolea"
  },
  {
    "method_id": "M4694",
    "name": "ajc_before",
    "return_type": "void",
    "signature": "ajc_before()",
    "file_id": "F238",
    "start_line": 289,
    "text_preview": "n(new Object[] {});\\n\t\treturn ret;\\n\t}\t\\n\t\\n\t// don't call this method for callee-side call join points\\n\tpublic static void ajc_before(JoinPoint.StaticPart tjp) {\\n\t\tSystem.out.println(\"before: \" + tjp);\\n\t\tif (tjp.getSourceLocation() == null) {\\n\t\t\tthrow new RuntimeException(\"didn't want null\");\\n\t\t}\\n\t\tSystem.out.println(\"   "
  },
  {
    "method_id": "M4695",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] args)",
    "file_id": "F239",
    "start_line": 26,
    "text_preview": "tc)\\n *\\n * @version \t1.0\\n * @author\\n */\\npublic class DynamicHelloWorld implements Serializable {\\n\\n    public static void main(String[] args) {\\n    \ttry {\\n\t\t\tnew DynamicHelloWorld().doit(\"hello\", Collections.EMPTY_LIST);\\n\t\t} catch (UnsupportedOperationException t) {\\n\t\t\tSystem.out.println(\"expected and caught: \" + t);\\n\t\t\t"
  },
  {
    "method_id": "M4696",
    "name": "catch",
    "return_type": "",
    "signature": "catch(UnsupportedOperationException t)",
    "file_id": "F239",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4697",
    "name": "doit",
    "return_type": "String",
    "signature": "doit(String s, List l)",
    "file_id": "F239",
    "start_line": 28,
    "text_preview": "elloWorld implements Serializable {\\n\\n    public static void main(String[] args) {\\n    \ttry {\\n\t\t\tnew DynamicHelloWorld().doit(\"hello\", Collections.EMPTY_LIST);\\n\t\t} catch (UnsupportedOperationException t) {\\n\t\t\tSystem.out.println(\"expected and caught: \" + t);\\n\t\t\treturn;\\n\t\t}\\n\t\tthrow new RuntimeException(\"should have caught"
  },
  {
    "method_id": "M4698",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] args)",
    "file_id": "F240",
    "start_line": 20,
    "text_preview": "ava.io.PrintStream;\\n\\n/**\\n * @version \t1.0\\n * @author\\n */\\npublic abstract class FancyHelloWorld {\\n    public static void main(String[] args) {\\n    \tPrintStream out = System.out;\\n    \ttry {\\n    \t\tout.println(\"bye\");\\n    \t} catch (Exception e) {\\n    \t\tout.println(e);\\n    \t} finally {\\n    \t\tout.println(\"finally\");\\n    \t}\\n "
  },
  {
    "method_id": "M4699",
    "name": "catch",
    "return_type": "",
    "signature": "catch(Exception e)",
    "file_id": "F240",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4700",
    "name": "getName",
    "return_type": "String",
    "signature": "getName()",
    "file_id": "F240",
    "start_line": 31,
    "text_preview": "eption e) {\\n    \t\tout.println(e);\\n    \t} finally {\\n    \t\tout.println(\"finally\");\\n    \t}\\n    }\\n\\n    public static String getName() {\\n    \tint x = 0;\\n    \tx += \"name\".hashCode();\\n    \treturn \"name\" + x;\\n    }\\n}\\n"
  },
  {
    "method_id": "M4701",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] args)",
    "file_id": "F241",
    "start_line": 17,
    "text_preview": "org.aspectj.weaver.test;\\n\\npublic class FieldyHelloWorld {\\n\\n\tpublic static String str = \"Hello\";\\n\\n    public static void main(String[] args) {\\n        str += \" World\";\\n\\n        System.out.println(str);\\n    }\\n}\\n"
  },
  {
    "method_id": "M4702",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] args)",
    "file_id": "F242",
    "start_line": 19,
    "text_preview": "package org.aspectj.weaver.test;\\n\\n/**\\n * @version \t1.0\\n * @author\\n */\\npublic class HelloWorld {\\n\\n    public static void main(String[] args) {\\n        System.out\\n        .println(\"hello world\");\\n        //System.out.println(\"hello world\");\\n    }\\n}\\n"
  },
  {
    "method_id": "M4703",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] args)",
    "file_id": "F243",
    "start_line": 15,
    "text_preview": " initial implementation\\n */\\npackage org.aspectj.weaver.test;\\n\\npublic class MultiArgHelloWorld {\\n\\n    public static void main(String[] args) {\\n    \tfoo(\"Hello\", \"World\");\\n    }\\n\\n    static void foo(Object s, Object t) {\\n    \tSystem.out.println(s + \" \" + t);\\n    }\\n}\\n"
  },
  {
    "method_id": "M4704",
    "name": "foo",
    "return_type": "void",
    "signature": "foo(Object s, Object t)",
    "file_id": "F243",
    "start_line": 16,
    "text_preview": "\\npackage org.aspectj.weaver.test;\\n\\npublic class MultiArgHelloWorld {\\n\\n    public static void main(String[] args) {\\n    \tfoo(\"Hello\", \"World\");\\n    }\\n\\n    static void foo(Object s, Object t) {\\n    \tSystem.out.println(s + \" \" + t);\\n    }\\n}\\n"
  },
  {
    "method_id": "M4705",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] args)",
    "file_id": "F244",
    "start_line": 16,
    "text_preview": "org.aspectj.weaver.test;\\n\\nimport junit.framework.TestCase;\\n\\npublic class Test extends TestCase {\\n    public static void main(String[] args) {\\n        foo()\\n        .\\n        foo();\\n    }\\n    public static Test foo() {\\n        new Exception().printStackTrace();\\n        return new Test();\\n    }\\n    public void testNothin"
  },
  {
    "method_id": "M4706",
    "name": "foo",
    "return_type": "Test",
    "signature": "foo()",
    "file_id": "F244",
    "start_line": 17,
    "text_preview": "rt junit.framework.TestCase;\\n\\npublic class Test extends TestCase {\\n    public static void main(String[] args) {\\n        foo()\\n        .\\n        foo();\\n    }\\n    public static Test foo() {\\n        new Exception().printStackTrace();\\n        return new Test();\\n    }\\n    public void testNothingForAntJUnit() {}\\n}\\n"
  },
  {
    "method_id": "M4707",
    "name": "testNothingForAntJUnit",
    "return_type": "void",
    "signature": "testNothingForAntJUnit()",
    "file_id": "F244",
    "start_line": 25,
    "text_preview": " public static Test foo() {\\n        new Exception().printStackTrace();\\n        return new Test();\\n    }\\n    public void testNothingForAntJUnit() {}\\n}\\n"
  },
  {
    "method_id": "M4708",
    "name": "main",
    "return_type": "void",
    "signature": "main(String[] args)",
    "file_id": "F245",
    "start_line": 29,
    "text_preview": "ublic abstract class TestSwitchy {\\n\\n\\n    public int i = 3;\\n\\n    public static final int j = 4;\\n\\n\\n    public static void main(String[] args) {\\n        switch (args.length) {\\n            case 0: System.err.println(\"hi\");\\n            case 1: System.err.println(\"bye\"); break;\\n            case 2: System.err.println(\"two\");\\n"
  },
  {
    "method_id": "M4709",
    "name": "switch",
    "return_type": "",
    "signature": "switch(args.length)",
    "file_id": "F245",
    "start_line": null,
    "text_preview": ""
  },
  {
    "method_id": "M4710",
    "name": "nimbo",
    "return_type": "void",
    "signature": "nimbo()",
    "file_id": "F245",
    "start_line": 42,
    "text_preview": "lt: System.err.println(\"ning\");\\n        }\\n        System.err.println(\"done\");\\n    }\\n\\n\\n    abstract int goo();\\n\\n    void nimbo() {}\\n}\\n"
  }
]